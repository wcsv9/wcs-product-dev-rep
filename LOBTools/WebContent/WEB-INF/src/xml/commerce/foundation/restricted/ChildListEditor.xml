<?xml version="1.0" encoding="UTF-8"?>

<!--
 =================================================================
  Licensed Materials - Property of IBM

  WebSphere Commerce

  (C) Copyright IBM Corp. 2015, 2016 All Rights Reserved.

  US Government Users Restricted Rights - Use, duplication or
  disclosure restricted by GSA ADP Schedule Contract with
  IBM Corp.
 =================================================================
-->
<Definitions>
	<!---
		@keywords abstract 
		
		A child list editor is a widget that you can use to edit the child {@link cmc/foundation/ModelObject model objects} of a 
		particular object. You can use the child list editor to add new child objects to the list, 
		delete child objects from the list, or edit existing child objects in the list. 
		
		The class needs to provide the {@link cmc/foundation/ObjectDefinition#objectType object types} of the child objects to be displayed, as well
		as the name of the class to use for viewing the child list. 
		
		This is an abstract class and instances of this type should not be created, nor should this class be extended. 
		Instead, use either {@link cmc/foundation/ChildListEditor}	or {@link cmc/foundation/PropertyChildListEditor} as needed. 
	-->
	<FocusableComponent classDefinition="true" definitionName="cmc/foundation/BaseChildListEditor" focusable="false" visible="true">
		<dependency localName="UtilitiesButton" moduleName="cmc/foundation/UtilitiesButton"/>
		<dependency localName="ViewUtil" moduleName="cmc/foundation/ViewUtil"/>
		<dependency localName="StringUtil" moduleName="cmc/foundation/StringUtil"/>
		<dependency localName="SequenceDownButton" moduleName="cmc/foundation/SequenceDownButton"/>
		<dependency localName="MoveAction" moduleName="cmc/foundation/MoveAction"/>
		<dependency localName="EventHandler" moduleName="cmc/foundation/EventHandler"/>
		<dependency localName="SequenceUpButton" moduleName="cmc/foundation/SequenceUpButton"/>
		<dependency localName="ChildClientActionButton" moduleName="cmc/foundation/ChildClientActionButton"/>
		<dependency localName="DndManager" moduleName="cmc/foundation/DndManager"/>
		<dependency localName="DefinitionUtil" moduleName="cmc/foundation/DefinitionUtil"/>
		<dependency localName="EventTimer" moduleName="cmc/shell/EventTimer"/>
		<dependency localName="EventUtil" moduleName="cmc/foundation/EventUtil"/>
		<dependency localName="ActionUtil" moduleName="cmc/foundation/ActionUtil"/>
		<dependency localName="Logger" moduleName="cmc/shell/Logger"/>
		<dependency localName="DeleteChildButton" moduleName="cmc/foundation/DeleteChildButton"/>
		<dependency localName="CopyAction" moduleName="cmc/foundation/CopyAction"/>
		<dependency localName="ChildSearchWidget" moduleName="cmc/foundation/ChildSearchWidget"/>
		<dependency localName="SequenceSortComparator" moduleName="cmc/foundation/SequenceSortComparator"/>
		<dependency localName="AddToCollectionAction" moduleName="cmc/foundation/AddToCollectionAction"/>
		<dependency localName="EditColumnButton" moduleName="cmc/foundation/EditColumnButton"/>
		<dependency localName="NewChildButton" moduleName="cmc/foundation/NewChildButton"/>
		<dependency localName="ChildListBackgroundMenu" moduleName="cmc/foundation/ChildListBackgroundMenu"/>
		<dependency localName="AddReferenceAction" moduleName="cmc/foundation/AddReferenceAction"/>
		<dependency localName="ModelUtil" moduleName="cmc/foundation/ModelUtil"/>
		<dependency localName="ChildListMenu" moduleName="cmc/foundation/ChildListMenu"/>
		<!---
			A comma separated list of {@link cmc/foundation/ObjectDefinition#objectType object types} to be displayed in this child object list.
			This is a required attribute.
		-->
		<variable name="objectTypes" type="string"/>
		<!---
			True if this child list editor should only have a single child.  It will delete its children
			when a new child is added and will only accept one child.
		-->
		<variable name="singleChild" type="boolean" value="false"/>
		<!---
			@keywords private
			Model instance.
		-->
		<variable name="model"/>
		<!---
			@keywords private
			Model object instance.
		-->
		<variable name="o"/>
		<!---
			@keywords private
			Array of object selectors supported by this list view.
		-->
		<variable name="objectSelectors"/>
		<!---
			The name of the class to use for viewing this list. 
			This is often a class that extends {@link cmc/foundation/ObjectGrid}.
			@type string
		-->
		<variable name="listClass" type="module" value="${null}"/>
		<!---
			The name of the definition to use for viewing this list. 
			This is often a definition that extends {@link cmc/foundation/ObjectGrid}.
			Only specify this attribute if you are not providing a value
			for <code>listClass</code>.
			@type string
		-->
		<variable name="listDefinition" type="module" value="${null}"/>
		<!---
			@keywords private
			The closest ancestor view that defines an "availableHeight" attribute. This
			is used to calculate the list view's available height.
		-->
		<variable name="availableHeightView" value="${ViewUtil.Singleton.getAvailableHeightView(this)}"/>
		<!---
			@keywords private
			The fraction of available height allocated for this editor. When one or more editors share the same available
			space, this is used to determine the fraction of space allocated for each individual one.
		-->
		<variable name="fractionOfAvailableHeight" type="number" value="1"/>
		<!---
			@keywords private
			The closest ancestor view that defines an "availableWidth" attribute. This
			is used to calculate the list view's available width.
		-->
		<variable name="availableWidthView" value="${ViewUtil.Singleton.getAvailableWidthView(this)}"/>
		<!---
			@keywords private
			Array of custom services available for the objects in this child list editor.
		-->
		<variable name="customServices" value="${[]}"/>
		<!---
			@keywords private
			Array of client actions available for the objects in this child list editor.
		-->
		<variable name="clientActions"/>
		<!---
			@keywords private
			Indicates that this child list editor is embedded in a properties view.
		-->
		<variable name="embedded" type="boolean" value="true"/>
		<!---
			@keywords private
			Indicates that the delete action is enabled.
		-->
		<variable name="deleteEnabled" type="boolean" value="false"/>
		<!---
			@keywords private
			Indicates that the sequence up action is enabled.
		-->
		<variable name="sequenceUpEnabled" type="boolean" value="false"/>
		<!---
			@keywords private
			Indicates that the sequence down action is enabled.
		-->
		<variable name="sequenceDownEnabled" type="boolean" value="false"/>
		<!---
			@keywords private
			Indicates that the Edit Column action is enabled.
		-->
		<variable name="editColumnEnabled" type="boolean" value="false"/>
		
		<!---
			@keywords private
			Indicate Edit Column action is not available
		-->
		<variable name="hideEditColumnAction" type="boolean" value="false"/>
		<!---
			@keywords private
			Indicates that the delete action is not available.
		-->
		<variable name="hideDeleteAction" type="boolean" value="false"/>
		<!---
			@keywords private
			Indicates that the add action is enabled.
		-->
		<variable name="addEnabled" type="boolean" value="true"/>
		<!---
			@keywords private
			Instance of search widget {@link cmc/foundation/ChildSearchWidget}
		-->
		<variable name="searchWidget"/>
		<!---
			@keywords private
			Instance of utility button {@link cmc/foundation/UtilitiesButton}
		-->
		<variable name="utilitiesButton"/>
		<!---
			@keywords private
			Instance of new button {@link cmc/foundation/NewChildButton}
		-->
		<variable name="newButton"/>
		<!---
			@keywords private
			Instance of sequencer up button {@link cmc/foundation/SequenceUpButton}
		-->
		<variable name="sequenceUpButton"/>
		<!---
			@keywords private
			Instance of sequencer down button {@link cmc/foundation/SequenceDownButton}
		-->
		<variable name="sequenceDownButton"/>
		<!---
			Resource name of the new button.
		-->
		<variable name="newButtonResource" type="string" value="grid_createNewIconForSingleAction"/>
		<!---
			Tooltip text of the new button. Specify this attribute if the default text needs to be overridden.
		-->
		<variable name="newButtonHelpText" type="string" value="${null}"/>
		<!---
			@keywords private
			Child list status message.
		-->
		<variable name="statusMessage" type="string" value=""/>
		<!---
			@keywords private
			Indicates that the status message should be displayed as an error.
		-->
		<variable name="hasError" type="boolean" value="false"/>
		<!--- @keywords private
		
			  Indicates if reference object is moveable
		-->
		<variable name="referenceMoveable" type="boolean" value="false"/>
		<!---
			@keywords private
			Indicates that pop-up dialog will be presented to the user for the copy action.
		-->
		<variable name="promptForCopy" type="boolean" value="false"/>
		<!---
			@keywords private
			Indicates whether find and replace is available for the grid contained within this child list editor. The default is <code>false</code>.
		-->
		<variable name="findable" type="boolean" value="false"/>
		<!---
			@keywords private
			An ancestor view that will be updated with the currently selected object.
		-->
		<variable name="selectedObjectView" value="${null}"/>
		<!---
			@keywords private
			The name of the attribute of the selectedObjectVIew that will be updated with the currently selected object.
		-->
		<variable name="selectedObjectName" type="string" value="${null}"/>
		<!---
			@keywords private
			Array of embedded client action buttons.
		-->
		<variable name="childClientActionButtons"/>
		<!---
			When a value for sequencePropertyName is specified, the sequence of the grid is controlled by the property with this name. The property must be a number. 
		-->		
		<variable name="sequencePropertyName" type="string" value="${null}"/>
		<!---
			When a value for {@link cmc/foundation/BaseChildListEditor#sequencePropertyName sequencePropertyName} is specified, the value of this property will be used to help resolve the property value.
		-->	
		<variable name="sequencePropertyPath" type="string" value="${null}"/>	
		<!---
			When a value for {@link cmc/foundation/BaseChildListEditor#sequencePropertyName sequencePropertyName} is specified, this property will be used to increment the value of the sequence property when new objects are added to the list.
		-->		
		<variable name="sequenceIncrement" type="number" value="1"/>
		<!---
			@keywords private
			A reference to the sorter for the grid. This is will be defined when {@link cmc/foundation/BaseChildListEditor#sequencePropertyName sequencePropertyName} is not null.
		-->
		<variable name="sequencedGridSorter" value="${null}"/>
		<!---
			@keywords private
			Comma separated client action types. Client actions associated with the current object that have a matching action type will be displayed in the toolbar of the child list editor.
		-->
		<variable name="clientActionTypes" type="string" value=""/>
		<!---
			@keywords private
			Array of client actions that will be added to the child list editor toolbar for selected row objects.
		-->
		<variable name="childObjectClientActions"/>
		<!---
			@keywords private
			Array of client actions that will be added to the child list editor toolbar for objects referenced through selected row objects.
		-->
		<variable name="referencedObjectClientActions"/>
		<!---
			@keywords private
			Array of client actions that will be added to the child list editor toolbar for the current parent object.
		-->
		<variable name="parentObjectClientActions"/>
		<!---
			@keywords private
			Indicates that the New button will always be displayed.
		-->
		<variable name="alwaysShowNewButton" type="boolean" value="false"/>
		<!---
			@keywords private
			This attribute indicates that the editor will provide the ability to create a new referenced primary object directly
			from the child list editor toolbar. The attribute is only applicable to child list editors that manage reference objects.
			The default is false.
		-->
		<variable name="allowCreateReferencedPrimary" type="boolean" value="false"/>
		<!---
			@keywords private
			Set this attribute to <code>true</code> to indicate that the framework should allow the business user to duplicate
			the objects that are displayed in this list. The default is <code>false</code>.
		-->
		<variable name="allowDuplicate" type="boolean" value="false"/>
		<!--- 
		    @keywords private
		    Instance of new handler class that is called
		    when the create new referenced object button is clicked. 
			When the allowCreateReferencedPrimary option is true, this handler
			will be used to override the default primary object create method.
			This class must extend the {@link cmc/foundation/NewReferencedObjectHandler} class and
			implement a method called "createNewObject".
		-->
		<variable name="newReferencedPrimaryObjectHandler" type="string" value="${null}"/>
		<!--- 
		    @keywords private
			The class name for the dialog that is launched when the new button is clicked. 
			This dialog class must extend the {@link cmc/foundation/Dialog} class and implement a method called "openNewActionDialog" that accepts 
			arguments that are the parent {@link cmc/foundation/ModelObject object} and the child list editor {@link cmc/foundation/BaseChildListEditor}. 
			@type string
		-->
		<variable name="newActionDialogClass" type="module" value="${null}"/>
						
		<!--- @keywords private -->
		
		
		<!--- @keywords private -->
		<method args="args, parent" name="constructor">
			<![CDATA[
			this.checkEnabledDel = new EventHandler.Class(this, "checkEnabled");
			this.updateActionsDel = new EventHandler.Class(this, "updateActions");
			this.releaseModelObjectDel = new EventHandler.Class(this, "releaseModelObject");
			this.listSelectDel = new EventHandler.Class(this, "listSelect");
			this.createdPrimaryObjectDel = new EventHandler.Class(this, "createdPrimaryObject");
			this.updateMessageDel = new EventHandler.Class(this, "updateMessage");
			this.customServices = [];
			this.clientActions = [];
			this.childObjectClientActions = [];
			this.referencedObjectClientActions = [];
			this.parentObjectClientActions = [];
			this.childClientActionButtons = [];
			this.objectSelectors = [];
			this.o = null;
			]]>
		</method>
		
		<!--- @keywords private -->
		<method name="init">
			<![CDATA[
			if (this.listClass == null) {
				this.listClass = this.listDefinition;
			}
			if (this.availableHeightView != null) {
				this.updateAvailableHeightDel = new EventHandler.Class(this, "updateAvailableHeight");
				this.updateAvailableHeightDel.connect(this.availableHeightView, "onavailableHeight");
				this.updateAvailableHeightDel.connect(this.actionArea, "onheight");
				this.updateAvailableHeight();
			}
			if (this.availableWidthView != null) {
				this.updateAvailableWidthDel = new EventHandler.Class(this, "updateAvailableWidth");
				this.updateAvailableWidthDel.connect(this.availableWidthView, "onavailableWidth");
				this.updateAvailableWidth();
			}
			if (this.listClass.Class) {
				new this.listClass.Class(this, {
					name: "list",
					placement: "content",
					rowMenuClass: ChildListMenu,
					menuClass: ChildListBackgroundMenu,
					fitExistingRows: this.embedded,
					listBorderSize: this.embedded ? 1 : 0,
					filterLeftPadding: this.embedded ? 0 : 3,
					findable: this.findable,
					selectedObjectName: this.selectedObjectName,
					selectedObjectView: this.selectedObjectView,
					sortingOff: this.sequencePropertyName != null
				});
			}
			else {
				DefinitionUtil.createDefinitionInstance(this.listClass, this, {
					name: "list",
					placement: "content",
					rowMenuClass: ChildListMenu,
					menuClass: ChildListBackgroundMenu,
					fitExistingRows: this.embedded,
					listBorderSize: this.embedded ? 1 : 0,
					filterLeftPadding: this.embedded ? 0 : 3,
					findable: this.findable,
					selectedObjectName: this.selectedObjectName,
					selectedObjectView: this.selectedObjectView,
					sortingOff: this.sequencePropertyName != null
				});
			}
			if (this.sequencePropertyName != null) {
				if (!this.sequencedGridSorter) {
					this.sequencedGridSorter = new SequenceSortComparator.Class(this);
				}
				this.sequencedGridSorter.setVariable("sequencePropertyName", this.sequencePropertyName);
				this.sequencedGridSorter.setVariable("sequencePropertyPath", this.sequencePropertyPath);
			}
			if (this.o) {
				this.o.bindViewToChildren(this.list, null, this.objectTypes, this.sequencedGridSorter);
			}
			if (this.list.filters && this.list.filters.length > 0) {
				if (this.embedded) {
					this.list.setVariable("padding", 5);
				}
			}
			else {
				this.list.setVariable("padding", 0);
			}
			this.checkEnabled();
			this.listSelectDel.connect(this.list, "onselect");
			if (this.embedded) {
				this.createActions();
				this.updateActions();
			}
			this.updateMessage();
			this.inherited(arguments);
			]]>
		</method>

		<!--- @keywords private -->
		<method name="destroy">
			<![CDATA[
			if (this.o) {
				this.o.releaseViewFromChildren(this.list);
			}
			this.listSelectDel.disconnectAll();
			delete this.listSelectDel;
			delete this.createdPrimaryObjectDel;
			this.checkEnabledDel.disconnectAll();
			delete this.checkEnabledDel;
			this.updateActionsDel.disconnectAll();
			delete this.updateActionsDel;
			if (this.updateAvailableHeightDel) {
				this.updateAvailableHeightDel.disconnectAll();
				delete this.updateAvailableHeightDel;
			}
			if (this.updateAvailableWidthDel) {
				this.updateAvailableWidthDel.disconnectAll();
				delete this.updateAvailableWidthDel;
			}
			this.releaseModelObjectDel.disconnectAll();
			delete this.releaseModelObjectDel;
			this.updateMessageDel.disconnectAll();
			delete this.updateMessageDel;
			this.inherited(arguments);
			]]>
		</method>
				
		<!---
			@keywords private
			This method sets the model object for this tree node to the specified object.
			@param cmc/foundation/ModelObject newObject: the new object
		-->
		<method args="newObject" name="setModelObject">
			<![CDATA[
			if (Logger.Singleton.enabled) {
				Logger.Singleton.entering("com.ibm.commerce.lobtools.foundation.view", "cmc/foundation/BaseChildListEditor", "setModelObject(newObject)", [newObject]);
			}
			if (this.o !== newObject) {
				this.releaseModelObjectDel.disconnectAll();
				if (this.o) {
					this.objectSelectors = [];
					if (this.list) {
						this.o.releaseViewFromChildren(this.list);
					}
				}
				this.o = newObject;
				if (this.o) {
					this.releaseModelObjectDel.connect(this.o, "beingDestroyed");
					if (this.list) {
						this.o.bindViewToChildren(this.list, null, this.objectTypes, this.sequencedGridSorter);
					}
					this.objectSelectors = this.model.getObjectSelectors(this.o, this.objectTypes);
					this.promptForCopy = false;
					var actionTypes = StringUtil.Singleton.splitAndTrim(this.clientActionTypes, ",");
					for (var i = 0; i < this.objectSelectors.length; i++) {
						var oDef = this.objectSelectors[i].objectDefinition;
						if (oDef.organizational || oDef.primary || oDef.parentReference || oDef.collectionReference) {
							this.promptForCopy = true;
						}
					}
					if (this.promptForCopy) {
						this.promptForCopy = !this.o.objectDefinition.organizational;
					}
				}
				if (this.list) {
					this.checkEnabled();
				}
				EventUtil.trigger(this, "ono", this.o);
				this.updateMessage();
			}
			if (this.embedded) {
				this.createActions();
				this.updateActions();
			}
			if (Logger.Singleton.enabled) {
				Logger.Singleton.exiting("com.ibm.commerce.lobtools.foundation.view", "cmc/foundation/BaseChildListEditor", "setModelObject(newObject)");
			}
			]]>
		</method>
		
		<!---
			@keywords private
			This method releases the {@link cmc/foundation/ModelObject model object} from this child list editor.
		-->
		<method args="e" name="releaseModelObject">
			<![CDATA[
			if (typeof(e) == "undefined") e = null;
			this.setVariable("o", null);
			]]>
		</method>

		<!---
			@keywords private
			This method checks the current enablement of the available actions.
		-->
		<method args="e" name="checkEnabled">
			<![CDATA[
			if (typeof(e) == "undefined") e = null;
			this.checkEnabledDel.disconnectAll();
			this.customServices = [];
			this.clientActions = [];
			this.childObjectClientActions = [];
			this.referencedObjectClientActions = [];
			this.parentObjectClientActions = [];
			if (this.o) {
				var actionTypes = StringUtil.Singleton.splitAndTrim(this.clientActionTypes, ",");
				for (var i = 0; i < this.objectSelectors.length; i++) {
					var oDef = this.objectSelectors[i].objectDefinition;
					for (var j = 0; j < oDef.customServices.length; j++) {
						if (this.customServices.indexOf(oDef.customServices[j]) < 0) {
							this.customServices.push(oDef.customServices[j]);
						}
					}
					for (var j = 0; j < oDef.clientActions.length; j++) {
						var clientAction = oDef.clientActions[j];
						if (((this.embedded && clientAction.availableFromEmbeddedListView) || (!this.embedded && clientAction.availableFromMainListView)) && this.clientActions.indexOf(clientAction) < 0) {
							this.clientActions.push(clientAction);
						}
						if (this.embedded && clientAction.childListEditorIcon != null && clientAction.childListEditorIcon != "" && this.childObjectClientActions.indexOf(clientAction) < 0) {
							this.childObjectClientActions.push(clientAction);
						}
					}
					if (oDef.reference) {
						var referencedDefinitions = oDef.getReferencedDefinitions(this.checkEnabledDel);
						if (referencedDefinitions != null) {
							for (var k = 0; k < referencedDefinitions.length; k++) {
								var referencedDef = referencedDefinitions[k];
								if (referencedDef != null) {
									for (var j = 0; j < referencedDef.customServices.length; j++) {
										if (this.customServices.indexOf(referencedDef.customServices[j]) < 0) {
											this.customServices.push(referencedDef.customServices[j]);
										}
									}
									for (var j = 0; j < referencedDef.clientActions.length; j++) {
										var clientAction = referencedDef.clientActions[j];
										if (((this.embedded && referencedDef.clientActions[j].availableFromEmbeddedListView) || (!this.embedded && referencedDef.clientActions[j].availableFromMainListView)) && this.clientActions.indexOf(referencedDef.clientActions[j]) < 0) {
											this.clientActions.push(referencedDef.clientActions[j]);
										}
										if (this.embedded && clientAction.childListEditorIcon != null && clientAction.childListEditorIcon != "" && this.referencedObjectClientActions.indexOf(clientAction) < 0) {
											if (clientAction.actionType == "" || actionTypes.indexOf(this.clientActions.actionType) != -1) {
												this.referencedObjectClientActions.push(clientAction);
											}
										}
									}
								}
							}
						}
					}
					if (this.embedded) {
						if (actionTypes.length > 0) {
							for (var i = 0; i < this.o.objectDefinition.clientActions.length; i++) {
								if (actionTypes.indexOf(this.o.objectDefinition.clientActions[i].actionType) != -1) {
									this.parentObjectClientActions.push(this.o.objectDefinition.clientActions[i]);
								}
							}
						}
					}
				}
			}
			var actionEnabled = this.o != null && this.isDeleteEnabled(this.checkEnabledDel);
			if (actionEnabled != this.deleteEnabled) {
				this.setVariable("deleteEnabled", actionEnabled);
			}
			actionEnabled = this.sequencePropertyName != null && this.o != null && this.isSequenceUpEnabled(this.checkEnabledDel);
			if (actionEnabled != this.sequenceUpEnabled) {
				this.setVariable("sequenceUpEnabled", actionEnabled);
			}
			actionEnabled = this.sequencePropertyName != null && this.o != null && this.isSequenceDownEnabled(this.checkEnabledDel);
			if (actionEnabled != this.sequenceDownEnabled) {
				this.setVariable("sequenceDownEnabled", actionEnabled);
			}
			actionEnabled = this.isEditColumnEnabled(this.checkEnabledDel);
			if (actionEnabled != this.editColumnEnabled) {
				this.setVariable("editColumnEnabled", actionEnabled);
			}
			actionEnabled = false;
			if (this.o != null && (!this.singleChild || this.isDeleteAllEnabled(this.checkEnabledDel))) {
				for (var i = 0; i < this.objectSelectors.length; i++) {
					var def = this.objectSelectors[i].objectDefinition;
					if (def.isCreatable(this.o, null, this.checkEnabledDel)) {
						if (def.parentReference) {
							var referencedDefinitions = def.getReferencedDefinitions(this.checkEnabledDel);
							if (referencedDefinitions != null) {
								for (var k = 0; k < referencedDefinitions.length; k++) {
									var referencedDef = referencedDefinitions[k];
									if (referencedDef != null && referencedDef.isCreatable(this.o, null, this.checkEnabledDel)) {
										actionEnabled = true;
									}
								}
							}
						}
						else {
							actionEnabled = true;
						}
						if (actionEnabled) {
							break;
						}
					}
				}
			}
			if (actionEnabled != this.addEnabled) {
				this.setVariable("addEnabled", actionEnabled);
			}
			]]>
		</method>

		<!---
			@keywords private
			This method creates the toolbar actions for this list.
		-->
		<method name="createActions">
			<![CDATA[
			if (this.actionArea) {
				if (!this._actionsCreated) {
					this.searchWidget = new ChildSearchWidget.Class(this.actionArea, {
						editor: this,
						searchDefinitions: null,
						y: 1
					});
					this.newButton = new NewChildButton.Class(this.actionArea, {
						editor: this,
						actionDefinitions: null,
						buttonResourceForSingleAction: this.newButtonResource,
						buttonHelpText: this.newButtonHelpText,
						y: 5
					});
					new DeleteChildButton.Class(this.actionArea, {
						editor: this,
						y: 5
					});
					if (this.sequencePropertyName != null) {
						this.sequenceUpButton = new SequenceUpButton.Class(this.actionArea, {
							editor: this,
							y: 5
						});
						this.sequenceDownButton = new SequenceDownButton.Class(this.actionArea, {
							editor: this,
							y: 5
						});
					}
					if (!this.singleChild) {
						new EditColumnButton.Class(this.actionArea, {
							editor: this,
							y: 5
						});
					}
					this.utilitiesButton = new UtilitiesButton.Class(this.actionArea, {
						editor: this,
						objectDefinition: null,
						y: 5
					});
					this._actionsCreated = true;
					this.actionArea.setVariable("visible", true);
				}
				var totalClientActionButtons = this.childObjectClientActions.length + this.referencedObjectClientActions.length + this.parentObjectClientActions.length;
				while (this.childClientActionButtons.length < totalClientActionButtons) {
					this.childClientActionButtons.push(new ChildClientActionButton.Class(this.actionArea, {
						editor: this,
						enabled: false
					}));
				}
			}
			]]>
		</method>
		
		<!---
			@keywords private
		-->
		<method name="updateChildClientActionButtons">
			<![CDATA[
			var buttonIndex = 0;
			for (var i = 0; i < this.childObjectClientActions.length; i++) {
				var clientAction = this.childObjectClientActions[i];
				var button = this.childClientActionButtons[buttonIndex];
				button.setVariable("clientAction", clientAction);
				button.setVariable("parentObjectAction", false);
				button.setVariable("referencedObjectAction", false);
				button.updateButton();
				buttonIndex++;
			}
			for (var i = 0; i < this.referencedObjectClientActions.length; i++) {
				var clientAction = this.referencedObjectClientActions[i];
				var button = this.childClientActionButtons[buttonIndex];
				button.setVariable("clientAction", clientAction);
				button.setVariable("parentObjectAction", false);
				button.setVariable("referencedObjectAction", true);
				button.updateButton();
				buttonIndex++;
			}
			for (var i = 0; i < this.parentObjectClientActions.length; i++) {
				var clientAction = this.parentObjectClientActions[i];
				var button = this.childClientActionButtons[buttonIndex];
				button.setVariable("clientAction", clientAction);
				button.setVariable("parentObjectAction", true);
				button.setVariable("referencedObjectAction", false);
				button.updateButton();
				buttonIndex++;
			}
			while (buttonIndex < this.childClientActionButtons.length) {
				var button = this.childClientActionButtons[buttonIndex];
				button.setVariable("clientAction", null);
				button.updateButton();
				buttonIndex++;
			}
			]]>
		</method>
		
		<!---
			@keywords private
			This method will update the toolbar actions with the new object object definition.
		-->
		<method args="e" name="updateActions">
			<![CDATA[
			if (typeof(e) == "undefined") e = null;
			this.updateActionsDel.disconnectAll();
			if (this.objectSelectors && this.objectSelectors.length > 0 && this.actionArea) {
				var primaryCreate = false;
				var createActionDefinitions = [];
				var referenceDefinitions = [];
				var searchDefinitions = [];
				var searchTypes = {};
				for (var i = 0; i < this.objectSelectors.length; i++) {
					var actionDefinitions = [];
					var objectSelector = this.objectSelectors[i];
					var def = objectSelector.objectDefinition;
					if (def.primary) {
						if (def.isCreatable(null, null, this.updateActionsDel)) {
							actionDefinitions.push({
								primaryDefinition: null,
								childDefinitions: [null]
							});
						}
					}
					else if (def.getReferencedDefinitions(this.updateActionsDel) == null || def.newHandler != null) {
						if (def.isCreatable(this.o, null, this.updateActionsDel)) {
							actionDefinitions.push({
								primaryDefinition: null,
								childDefinitions: [null]
							});
						}
					}
					else {
						if (def.isCreatable(this.o, null, this.updateActionsDel)) {
							if (def.parentReference || def.collectionReference || this.allowCreateReferencedPrimary) {
								var defs = def.getReferencedDefinitions(this.updateActionsDel);
								for (var j = 0; j < defs.length; j++) {
									if (defs[j] != null && defs[j].isCreatable(null, null, this.updateActionsDel)) {
										actionDefinitions.push({
											primaryDefinition: defs[j],
											childDefinitions: [null]
										});
									}
								}
							}
							if (!def.parentReference) {
								referenceDefinitions.push(def);
								var defs = def.getReferencedDefinitions(this.updateActionsDel);
								for (var j = 0; j < defs.length; j++) {
									var referencedDef = defs[j];
									if (referencedDef != null) {
										var searchDef = referencedDef.getSearchDefinition(this.updateActionsDel);
										if (searchDef != null && !searchTypes[searchDef.searchType]) {
											searchTypes[searchDef.searchType] = true;
											searchDefinitions.push(searchDef);
										}
										if (referencedDef.createService != null) {
											var creatableChildDefs = referencedDef.getAllowImplicitParentCreateChildDefinitions();
											var addableRefDefs = referencedDef.getAllowImplicitParentCreateReferenceDefinitions();
											if ((creatableChildDefs.length > 0 || addableRefDefs.length > 0) && referencedDef.isCreatable(this.o, null, this.updateActionsDel)) {
												var testObject = ModelUtil.Singleton.createTestObject(referencedDef);
												var childDefinitions = [];
												for (var k = 0; k < creatableChildDefs.length; k++) {
													if (creatableChildDefs[k].isCreatable(testObject, null, this.updateActionsDel)) {
														childDefinitions.push(creatableChildDefs[k]);
													}
												}
												if (childDefinitions.length > 0) {
													actionDefinitions.push({
														primaryDefinition: referencedDef,
														childDefinitions: childDefinitions
													});
												}
												for (var k = 0; k < addableRefDefs.length; k++) {
													referenceDefinitions.push(addableRefDefs[k]);
													var defs = addableRefDefs[k].getReferencedDefinitions(this.updateActionsDel);
													if (defs != null) {
														for (var l = 0; l < defs.length; l++) {
															searchDef = defs[l] != null && defs[l].getSearchDefinition(this.updateActionsDel);
															if (searchDef != null && !searchTypes[searchDef.searchType]) {
																searchTypes[searchDef.searchType] = true;
																searchDefinitions.push(searchDef);
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
					for (var j = 0; j < actionDefinitions.length; j++) {
						var primaryDef = actionDefinitions[j].primaryDefinition;
						var childDefinitions = actionDefinitions[j].childDefinitions;
						for (var k = 0; k < childDefinitions.length; k++) {
							var childDef = childDefinitions[k];
							var actionDef = null;
							if (childDef != null) {
								actionDef = childDef;
							}
							else if (primaryDef != null) {
								actionDef = primaryDef;
								primaryCreate = true;
							}
							else {
								actionDef = def;
							}
							var actionDisplayName = actionDef.displayName;
							this.updateActionsDel.connect(actionDef, "ondisplayName");
							var actionIcon = actionDef.icon;
							createActionDefinitions.push({
								displayName: actionDisplayName,
								icon: actionIcon,
								objectSelector: objectSelector,
								primaryDefinition: primaryDef,
								childDefinition: childDef
							});
						}
					}
				}
				var doUpdateSearchDefinitions = false;
				for (var i = 0; i < searchDefinitions.length; i++) {
					if (!searchDefinitions[i].showInUtilitiesView && this.o && !this.o.isContextReadOnly()) {
						searchDefinitions[i].showInUtilitiesView = true;
						doUpdateSearchDefinitions = true;
					}
				}
				if (doUpdateSearchDefinitions && this.model.oEditor.utilities) {
					this.model.oEditor.utilities.updateSearchDefinitions();
				}
				if (!this.alwaysShowNewButton && referenceDefinitions.length > 0 && searchDefinitions.length > 0 && (createActionDefinitions.length == 0 || primaryCreate || this.newActionDialogClass != null)) {
					this.searchWidget.setVariable("searchDefinitions", searchDefinitions);
				}
				else {
					this.searchWidget.setVariable("searchDefinitions", null);
				}
				if (referenceDefinitions.length > 0) {
					this.utilitiesButton.setVariable("objectDefinition", referenceDefinitions[0].getReferencedDefinitions()[0]);
				}
				else {
					this.utilitiesButton.setVariable("objectDefinition", null);
				}
				var newButtonDefinitions = [];
				if (this.newActionDialogClass != null && createActionDefinitions.length > 0) {
					newButtonDefinitions.push({
						displayName: createActionDefinitions[0].displayName
					});
				}
				else {
					for (var i = 0; i < createActionDefinitions.length; i++) {
						newButtonDefinitions.push(createActionDefinitions[i]);
					}
				}
				if (newButtonDefinitions.length > 0 || this.alwaysShowNewButton) {
					if (!primaryCreate && this.newActionDialogClass == null) {
						for (var i = 0; i < searchDefinitions.length; i++) {
							newButtonDefinitions.push({
								displayName: searchDefinitions[i].objectTypeDisplayName != null ? searchDefinitions[i].objectTypeDisplayName : searchDefinitions[i].displayName,
								icon: searchDefinitions[i].icon,
								searchDefinition: searchDefinitions[i]
							});
						}
					}
					this.newButton.setVariable("actionDefinitions", newButtonDefinitions);
				}
				else {
					this.newButton.setVariable("actionDefinitions", null);
				}
				this.updateActionsDel.connect(this.list, "onselect");
				this.updateChildClientActionButtons();
			}
			]]>
		</method>

		<!---
			@keywords private
			Update the message.
		-->
		<method args="e" name="updateMessage">
			<![CDATA[
			if (typeof(e) == "undefined") e = null;
			if (this.list) {
				this.updateMessageDel.disconnectAll();
				this.hasError = false;
				var newMessage = "";
				if (this.o && this.list.oList) {
					if (this.list.oList.statusObject != null) {
						this.hasError = this.list.oList.statusObject.hasError;
						newMessage = this.list.oList.statusObject.message;
					}
					this.updateMessageDel.connect(this.list.oList, "onstatusObject");
				}
				if (newMessage != this.statusMessage) {
					this.setVariable("statusMessage", newMessage);
				}
			}
			]]>
		</method>

		<!---
			@keywords private
			This method gets the currently selected object in the list.
		-->
		<method name="getSelectedObject">
			<![CDATA[
			return this.list.getSelectedObject();
			]]>
		</method>

		<!---
			@keywords private
			This method is called when the selection changes in the list.
		-->
		<method args="e" name="listSelect">
			<![CDATA[
			if (typeof(e) == "undefined") e = null;
			EventUtil.trigger(this, "onselect");
			]]>
		</method>
		
		<!---
			@keywords private
			Create a new child object for the specified object definition.  In case of a non-primary object,
			if the objectOpenGroup is set to true and has a properties class, the new object properties view
			will be set in focus.  Otherwise, the object will be selected in the grid in edit mode.
			@param Object actionDef: The action definition for the created object
		-->
		<method args="actionDef" name="createChild">
			<![CDATA[
			if (this.singleChild) {
				this.doDeleteAll();
			}
			var creatableDef = null;
			if (actionDef.objectSelector.objectDefinition.reference && actionDef.childDefinition == null && actionDef.primaryDefinition != null) {
				creatableDef = actionDef.primaryDefinition;
			}
			else {
				creatableDef = actionDef.objectSelector.objectDefinition;
			}
			var nextSeq = this.getNextSequence();
			if (creatableDef.newHandler != null) {
				creatableDef.newHandler.createNewObject(creatableDef, this.o);
			}
			else if (actionDef.childDefinition != null) {
				var newPO = this.model.createNewObject(actionDef.primaryDefinition);
				var newCO = this.model.createNewObject(actionDef.childDefinition, newPO);
				var newRO = this.model.createNewObject(creatableDef, this.o);
				newRO.addChild(newPO);
				if (this.sequencePropertyName != null) {
					newRO.setPropertyValue(this.sequencePropertyName, this.sequencePropertyPath, nextSeq);
				}
				if (this.o.lockCount == 0) {
					this.o.updateChildObjects(true);
					this.list.showObjectInView(newRO, true);
				}
			}
			else if (creatableDef.primary) {
				if (this.allowCreateReferencedPrimary && this.newReferencedPrimaryObjectHandler != null) {
					this.newReferencedPrimaryObjectHandler.createNewObject(creatableDef, this.o, this.createdPrimaryObjectDel);
				}
				else {
					creatableDef.doCreate({
						createCallbackDel: this.createdPrimaryObjectDel
					});
				}
			}
			else {
				var newO = this.o.model.createNewObject(creatableDef, this.o, true);
				for (var i = 0; i < actionDef.objectSelector.selectors.length; i++) {
					newO.setPropertyValue(actionDef.objectSelector.selectors[i].propertyName, null, actionDef.objectSelector.selectors[i].propertyValue);
				}
				if (this.sequencePropertyName != null) {
					newO.setPropertyValue(this.sequencePropertyName, this.sequencePropertyPath, nextSeq);
				}
				if (this.o.lockCount == 0) {
					this.o.updateChildObjects(true);
					this.list.showObjectInView(newO, true);
				}
			}
			]]>
		</method>

		<!---
			@keywords private
			Adds a reference child for the given new primary object.
			@param cmc/foundation/ModelObject newObject: the new object
		-->
		<method args="newObject" name="createdPrimaryObject">
			<![CDATA[
			var roDef = null;
			for (var i = 0; i < this.objectSelectors.length; i++) {
				var def = this.objectSelectors[i].objectDefinition;
				if (def.reference && def.isReferencedDefinition(newObject.objectDefinition)) {
					roDef = def;
					if (def.parentReference || def.collectionReference) {
						break;
					}
				}
			}
			if (roDef != null) {
				var newRO = this.model.createNewObject(roDef, this.o);
				newRO.addChild(newObject);
				if (this.sequencePropertyName != null) {
					newRO.setPropertyValue(this.sequencePropertyName, this.sequencePropertyPath, this.getNextSequence());
				}
				newObject = newRO;
			}
			if (this.o.lockCount == 0) {
				this.list.showObjectInView(newObject);
			}
			]]>
		</method>

		<!---
			@keywords private
			Get the available custom services.
		-->
		<method name="getCustomServices">
			<![CDATA[
			return this.customServices;
			]]>
		</method>

		<!---
			@keywords private
			Get the available client actions.
		-->
		<method name="getClientActions">
			<![CDATA[
			return this.clientActions;
			]]>
		</method>
		
		<!--- 
			@keywords private
			Check if Edit Column is enabled for the selected objects.
		-->
		<method args="delegate" name="isEditColumnEnabled">
			<![CDATA[
			var editColumnEnabled = false;
			if (this.list && this.list.isEditColumnEnabled) {
				editColumnEnabled = this.list.isEditColumnEnabled(delegate);
			}
			return editColumnEnabled;
			]]>
		</method>
		<!---
			@keywords private
			Check if delete is enabled for the given objects.
			@param Array objects: An array of cmc/foundation/ModelObject objects
			@param cmc/foundation/EventHandler delegate: An optional parameter with a delegate that will be registered with the
			readonly properties of the objects in question.
		-->
		<method args="objects, delegate" name="isDeleteObjectsEnabled">
			<![CDATA[
			var deleteEnabled = objects.length > 0;
			if (deleteEnabled) {
				var deleteCollectionReferencedObjectEnabled = true;
				var deleteCollectionReferenceEnabled = true;
				for (var i = 0; i < objects.length; i++) {
					var oDef = objects[i].objectDefinition;
					if (oDef.parentReference) {
						if (!objects[i].getReferencedObject().isDeletable(delegate)) {
							deleteEnabled = false;
							break;
						}
					}
					else if (oDef.collectionReference) {
						if (!objects[i].getReferencedObject().isDeletable(delegate)) {
							deleteCollectionReferencedObjectEnabled = false;
						}
						if (!objects[i].isDeletable(delegate)) {
							deleteCollectionReferenceEnabled = false;
						}
						if (!deleteCollectionReferencedObjectEnabled && !deleteCollectionReferenceEnabled) {
							deleteEnabled = false;
							break;
						}
					}
					else {
						if (!objects[i].isDeletable(delegate)) {
							deleteEnabled = false;
							break;
						}
					}
				}
			}
			return deleteEnabled;
			]]>
		</method>

		<!---
			@keywords private
			Check if delete is enabled.
			@param cmc/foundation/EventHandler delegate: An optional parameter, a delegate registered to changes that can effect the deletable state
		-->
		<method args="delegate" name="isDeleteEnabled">
			<![CDATA[
			if (typeof(delegate) == "undefined") delegate = null;
			if (delegate) {
				delegate.connect(this, "onselect");
			}
			return this.isDeleteObjectsEnabled(this.list.getSelectedObjects(), delegate);
			]]>
		</method>

		<!---
			@keywords private
			Check if delete all is enabled.
			@param cmc/foundation/EventHandler delegate: An optional parameter with a delegate that will be registered with the
			readonly properties of the objects in question.
		-->
		<method args="delegate" name="isDeleteAllEnabled">
			<![CDATA[
			if (typeof(delegate) == "undefined") delegate = null;
			var objects = this.list.oList.getMatchingModelObjects();
			if (delegate) {
				delegate.connect(this.list.oList, "onfilteredObjects");
			}
			return objects.length == 0 || this.isDeleteObjectsEnabled(objects, delegate);
			]]>
		</method>

		<!---
			@keywords private
			Invoke delete for the given cmc/foundation/ModelObjects.
			@param Array objects: An array of cmc/foundation/ModelObject objects
		-->
		<method args="objects" name="doDeleteObjects">
			<![CDATA[
			var objs = [];
			for (var i = 0; i < objects.length; i++) {
				objs[i] = objects[i];
			}
			var deleteObjects = [];
			var isCollectionReferenceObjects = true;
			for (var i = 0; i < objs.length; i++) {
				var o = objs[i];
				var oDef = o.objectDefinition;
				if (oDef.openGroupTop) {
					deleteObjects.push(o);
				}
				else if (oDef.parentReference || oDef.collectionReference) {
					deleteObjects.push(o.getReferencedObject());
				}
				else {
					o.deleteObject();
				}
				if (isCollectionReferenceObjects && !oDef.collectionReference) {
					isCollectionReferenceObjects = false;
				}
			}
			if (isCollectionReferenceObjects) {
				var deleteCollectionReferencedObjectEnabled = true;
				var deleteCollectionReferenceEnabled = true;
				for (var i = 0; i < objs.length; i++) {
					var o = objs[i];
					if (!o.getReferencedObject().isDeletable()) {
						deleteCollectionReferencedObjectEnabled = false;
						break;
					}
					if (!o.isDeletable()) {
						deleteCollectionReferenceEnabled = false;
						break;
					}
				}
				if (deleteObjects.length == 1) {
					if (deleteCollectionReferencedObjectEnabled && deleteCollectionReferenceEnabled) {
						require(["cmc/foundation/CollectionReferenceObjectDeleteConfirmationDialog"], function(CollectionReferenceObjectDeleteConfirmationDialog) {
							CollectionReferenceObjectDeleteConfirmationDialog.Singleton.openCollectionReferenceObjectDeleteConfirmationDialog(objs[0]);
						});
					}
					else if (deleteCollectionReferencedObjectEnabled) {
						deleteObjects[0].deleteObject(true);
					}
					else if (deleteCollectionReferenceEnabled) {
						require(["cmc/foundation/CollectionReferenceObjectRemoveConfirmationDialog"], function(CollectionReferenceObjectRemoveConfirmationDialog) {
							CollectionReferenceObjectRemoveConfirmationDialog.Singleton.openCollectionReferenceObjectRemoveConfirmationDialog(objs[0]);
						});
					}
				}
				else if (deleteObjects.length > 0) {
					if (deleteCollectionReferencedObjectEnabled && deleteCollectionReferenceEnabled) {
						require(["cmc/foundation/MultipleCollectionReferenceObjectDeleteConfirmationDialog"], function(MultipleCollectionReferenceObjectDeleteConfirmationDialog) {
							MultipleCollectionReferenceObjectDeleteConfirmationDialog.Singleton.openMultipleCollectionReferenceObjectDeleteConfirmationDialog(objs);
						});
					}
					else if (deleteCollectionReferencedObjectEnabled) {
						require(["cmc/foundation/MultipleDeleteConfirmationDialog"], function(MultipleDeleteConfirmationDialog) {
							MultipleDeleteConfirmationDialog.Singleton.openMultipleDeleteConfirmationDialog(deleteObjects);
						});
					}
					else if (deleteCollectionReferenceEnabled) {
						require(["cmc/foundation/MultipleCollectionReferenceObjectRemoveConfirmationDialog"], function(MultipleCollectionReferenceObjectRemoveConfirmationDialog) {
							MultipleCollectionReferenceObjectRemoveConfirmationDialog.Singleton.openMultipleCollectionReferenceObjectRemoveConfirmationDialog(objs);
						});
					}
				}
			}
			else {
				if (deleteObjects.length == 1) {
					deleteObjects[0].deleteObject(true);
				}
				else if (deleteObjects.length > 0) {
					require(["cmc/foundation/MultipleDeleteConfirmationDialog"], function(MultipleDeleteConfirmationDialog) {
						MultipleDeleteConfirmationDialog.Singleton.openMultipleDeleteConfirmationDialog(deleteObjects);
					});
				}
			}
			]]>
		</method>

		<!---
			@keywords private
			Invoke delete.
		-->
		<method name="doDelete">
			<![CDATA[
			this.doDeleteObjects(this.list.getSelectedObjects());
			]]>
		</method>

		<!---
			@keywords private
			Invoke delete for all child objects.
		-->
		<method name="doDeleteAll">
			<![CDATA[
			this.doDeleteObjects(this.list.oList.getMatchingModelObjects());
			]]>
		</method>
		
		<!---
			@keywords private
			This method launches the edit column dialog.
		-->
		<method name="doEditColumn">
			<![CDATA[
			var caller = this;
			require(["cmc/foundation/EditColumnDialog"], function(EditColumnDialog) {
				EditColumnDialog.Singleton.openEditColumnDialog(caller.list);
			});
			]]>
		</method>

		<!---
			@keywords private
			Check if drop is enabled.
			@param array sources: array of drag sources
		-->
		<method args="sources" name="isDropEnabled">
			<![CDATA[
			var dropEnabled = false;
			if (sources.length > 0 && sources[0].dragParent != this.list) {
				var objects = [];
				for (var i = 0; i < sources.length; i++) {
					objects.push(ModelUtil.Singleton.findObjectForView(sources[i]));
				}
				dropEnabled = this.getAddActions(objects).length > 0;
			}
			return dropEnabled;
			]]>
		</method>

		<!---
			@keywords private
			Add the dragged objects into this list.
			@param array sources: array of drag sources
		-->
		<method args="sources" name="droppedInTarget">
			<![CDATA[
			var objects = [];
			for (var i = 0; i < sources.length; i++) {
				objects.push(ModelUtil.Singleton.findObjectForView(sources[i]));
			}
			this.addObjects(objects);
			]]>
		</method>

		<!---
			@keywords private
			Check if all of the objects currently in the clipboard can be used as source objects to
			add new objects to this list.
			@return boolean: true if the objects can be pasted
		-->
		<method name="isPasteEnabled">
			<![CDATA[
			var pasteEnabled = false;
			var objects = this.model.clipboardObjects;
			pasteEnabled = this.getAddActions(objects).length > 0;
			return pasteEnabled;
			]]>
		</method>

		<!---
			@keywords private
			Paste the objects in the clipboard into this list.
		-->
		<method name="doPaste">
			<![CDATA[
			var pasteObjects = this.model.clipboardObjects;
			this.addObjects(pasteObjects);
			]]>
		</method>
		
		<!---
			@keywords private
			Check if the sequence up button is enabled. 
			@param cmc/foundation/EventHandler delegate: An optional parameter, a delegate registered to changes that can effect the sequence state
		-->
		<method args="delegate" name="isSequenceUpEnabled">
			<![CDATA[
			if (typeof(delegate) == "undefined") delegate = null;
			var seqUpEnabled = false;
			if (delegate) {
				delegate.connect(this, "onselect");
			}
			var selectedObjects = this.list.getSelectedObjects();
			if (this.sequencePropertyName != null && selectedObjects.length == 1) {
				var index = this.list.oList.filteredObjects.indexOf(selectedObjects[0]);
				if (index != 0 && !selectedObjects[0].getPropertyReadOnly(this.sequencePropertyName, this.sequencePropertyPath) && !this.list.oList.filteredObjects[index - 1].getPropertyReadOnly(this.sequencePropertyName, this.sequencePropertyPath)) {
					seqUpEnabled = true;
				}
			}
			return seqUpEnabled;
			]]>
		</method>
		<!---
			@keywords private
			Invoke sequenceUp.
		-->
		<method name="doSequenceUp">
			<![CDATA[
			var selectedObject = this.list.getSelectedObjects()[0];
			var index = this.list.oList.filteredObjects.indexOf(selectedObject);
			var previousRowO = this.list.oList.filteredObjects[index - 1];
			var oldVal = selectedObject.getPropertyValue(this.sequencePropertyName, this.sequencePropertyPath);
			var newVal = previousRowO.getPropertyValue(this.sequencePropertyName, this.sequencePropertyPath);
			selectedObject.setPropertyValue(this.sequencePropertyName, this.sequencePropertyPath, newVal);
			previousRowO.setPropertyValue(this.sequencePropertyName, this.sequencePropertyPath, oldVal);
			this.list.oList.filteredObjects[index] = previousRowO;
			this.list.oList.filteredObjects[index - 1] = selectedObject;
			this.updateSequence();
			this.list.oList.setVariable("filteredObjects", this.list.oList.filteredObjects);
			this.list.showObjectInView(selectedObject, false);
			this.checkEnabled();
			]]>
		</method>
		
		<!---
			@keywords private
			Check if the sequence down button is enabled.
			@param cmc/foundation/EventHandler delegate: An optional parameter, a delegate registered to changes that can effect the sequence state
		-->
		<method args="delegate" name="isSequenceDownEnabled">
			<![CDATA[
			if (typeof(delegate) == "undefined") delegate = null;
			var seqDownEnabled = false;
			if (delegate) {
				delegate.connect(this, "onselect");
			}
			var selectedObjects = this.list.getSelectedObjects();
			if (this.sequencePropertyName != null && selectedObjects.length == 1) {
				var index = this.list.oList.filteredObjects.indexOf(selectedObjects[0]);
				if (index != this.list.oList.filteredObjects.length - 1 && !selectedObjects[0].getPropertyReadOnly(this.sequencePropertyName, this.sequencePropertyPath) && !this.list.oList.filteredObjects[index + 1].getPropertyReadOnly(this.sequencePropertyName, this.sequencePropertyPath)) {
					seqDownEnabled = true;
				}
			}
			return seqDownEnabled;
			]]>
		</method>
		
		<!---
			@keywords private
			Invoke sequence down.
		-->
		<method name="doSequenceDown">
			<![CDATA[
			var selectedObject = this.list.getSelectedObjects()[0];
			var index = this.list.oList.filteredObjects.indexOf(selectedObject);
			var nextRowO = this.list.oList.filteredObjects[index + 1];
			var oldVal = selectedObject.getPropertyValue(this.sequencePropertyName, this.sequencePropertyPath);
			var newVal = nextRowO.getPropertyValue(this.sequencePropertyName, this.sequencePropertyPath);
			selectedObject.setPropertyValue(this.sequencePropertyName, this.sequencePropertyPath, newVal);
			nextRowO.setPropertyValue(this.sequencePropertyName, this.sequencePropertyPath, oldVal);
			this.list.oList.filteredObjects[index] = nextRowO;
			this.list.oList.filteredObjects[index + 1] = selectedObject;
			this.updateSequence();
			this.list.oList.setVariable("filteredObjects", this.list.oList.filteredObjects);
			this.list.showObjectInView(selectedObject, false);
			this.checkEnabled();
			]]>
		</method>
		
		<!---
			@keywords private
			Get the list of add actions that are available for the specified list of source objects.
			@param array objects: array of cmc/foundation/ModelObject instances to check
			@return array: array of object definitions
		-->
		<method args="objects" name="getAddActions">
			<![CDATA[
			var actions = [];
			if (!this.singleChild || (objects.length == 1 && this.isDeleteAllEnabled())) {
				if (ActionUtil.Singleton.isMoveActionEnabled(objects, this.o, this.objectSelectors, this.referenceMoveable)) {
					actions.push(MoveAction.Singleton);
				}
				if (ActionUtil.Singleton.isCopyActionEnabled(objects, this.o, this.objectSelectors)) {
					actions.push(CopyAction.Singleton);
				}
				if (ActionUtil.Singleton.isAddToCollectionActionEnabled(objects, this.o, this.objectSelectors)) {
					actions.push(AddToCollectionAction.Singleton);
				}
				actions = actions.concat(this.getAddReferenceActions(objects));
				if (actions.length == 0) {
					var pass = true;
					if (objects.length > 0) {
						for (var i = 0; i < objects.length; i++) {
							if (this.getAddReferenceActions([objects[i]]).length != 1) {
								pass = false;
								break;
							}
						}
						if (pass) {
							actions.push(AddReferenceAction.Singleton);
						}
					}
				}
			}
			return actions;
			]]>
		</method>

		<!---
			@keywords private
			Get the list of add reference actions that are available for the
			specified list of source objects.
			@param array objects: array of cmc/foundation/ModelObject instances to check
			@param del callback handler
			@return array: array of acceptable add actions allowed
		-->
		<method args="objects, del" name="getAddReferenceActions">
			<![CDATA[
			var actions = [];
			for (var i = 0; i < this.objectSelectors.length; i++) {
				var oDef = this.objectSelectors[i].objectDefinition;
				if (!oDef.parentReference && !oDef.collectionReference && oDef.getReferencedDefinitions(del) != null) {
					if (ActionUtil.Singleton.isAddReferenceActionEnabled(objects, this.o, this.objectSelectors, oDef)) {
						actions.push({
							displayName: oDef.displayName,
							targetDefinition: oDef,
							primaryDefinition: null,
							childDefinition: null
						});
					}
					else {
						var targetDef = oDef;
						var referencedDefinitions = oDef.getReferencedDefinitions(del);
						for (var k = 0; k < referencedDefinitions.length; k++) {
							var referencedDef = referencedDefinitions[k];
							if (referencedDef != null) {
								var referenceDefs = referencedDef.getAllowImplicitParentCreateReferenceDefinitions();
								var childDefs = referencedDef.getAllowImplicitParentCreateChildDefinitions();
								var testObjects = null;
								if ((referenceDefs.length > 0 || childDefs.length > 0) && referencedDef.isCreatable(this.o)) {
									testObjects = [];
									testObjects.push(ModelUtil.Singleton.createTestObject(referencedDef));
									if (ActionUtil.Singleton.isAddReferenceActionEnabled(testObjects, this.o, null, targetDef)) {
										for (var j = 0; j < referenceDefs.length; j++) {
											var referenceDef = referenceDefs[j];
											if (ActionUtil.Singleton.isAddReferenceActionEnabled(objects, testObjects[0], null, referenceDef)) {
												actions.push({
													displayName: referenceDef.displayName,
													targetDefinition: targetDef,
													primaryDefinition: referencedDef,
													childDefinition: referenceDef,
													sequencePropertyName: this.sequencePropertyName,
													sequencePropertyPath: this.sequencePropertyPath,
													nextSeq: this.getNextSequence()
												});
											}
										}
										for (var j = 0; j < childDefs.length; j++) {
											var childDef = childDefs[j];
											if (childDef.isCreatable(testObjects[0]) && this.isCopyCompatible(childDef, objects)) {
												actions.push({
													displayName: childDef.displayName,
													targetDefinition: targetDef,
													primaryDefinition: referencedDef,
													childDefinition: childDef,
													sequencePropertyName: this.sequencePropertyName,
													sequencePropertyPath: this.sequencePropertyPath,
													nextSeq: this.getNextSequence()
												});
											}
										}
									}
								}
							}
						}
					}
				}
			}
			return actions;
			]]>
		</method>
		
		<!---
			@keywords private
			Checks if the given object definition is copy compatible with the given source objects
			@param cmc/foundation/ObjectDefinition oDef: the object definition
			@param array objects: source objects
		-->
		<method args="oDef, objects" name="isCopyCompatible">
			<![CDATA[
			var actionEnabled = false;
			if (objects.length > 0) {
				actionEnabled = true;
				for (var i = 0; i < objects.length; i++) {
					var sourceDef = objects[i].getReferencedObject().objectDefinition;
					if (oDef != sourceDef && !sourceDef.isCompatibleType(oDef.objectType)) {
						actionEnabled = false;
						break;
					}
				}
			}
			return actionEnabled;
			]]>
		</method>

		<!---
			@keywords private
			Perform the add action for the specified list of objects.
		-->
		<method args="action, objects" name="doAddAction">
			<![CDATA[
			if (EventTimer.Singleton.enabled) EventTimer.Singleton.start("cmc/foundation/BaseChildListEditor " + (action.displayName ? action.displayName : "doAddAction") + ": " + this.o.objectDisplayName + " #objects=" + objects.length);
			if (this.singleChild) {
				this.doDeleteAll();
			}
			var nextSeq = this.getNextSequence();
			if (action == MoveAction.Singleton) {
				ActionUtil.Singleton.triggerMove(objects, this.o, this.objectSelectors, this.sequencePropertyName, this.sequencePropertyPath, nextSeq, this.sequenceIncrement);
			}
			else if (action == CopyAction.Singleton) {
				ActionUtil.Singleton.triggerCopy(objects, this.o, this.objectSelectors, this.sequencePropertyName, this.sequencePropertyPath, nextSeq, this.sequenceIncrement);
			}
			else if (action == AddToCollectionAction.Singleton) {
				ActionUtil.Singleton.triggerAddToCollection(objects, this.o);
			}
			else if (action == AddReferenceAction.Singleton) {
				for (var i = 0; i < objects.length; i++) {
					ActionUtil.Singleton.triggerAddReference(this.getAddReferenceActions([objects[i]])[0], [objects[i]], this.o, this.sequencePropertyName, this.sequencePropertyPath, nextSeq, this.sequenceIncrement);
					nextSeq = this.getNextSequence();
				}
			}
			else {
				ActionUtil.Singleton.triggerAddReference(action, objects, this.o, this.sequencePropertyName, this.sequencePropertyPath, nextSeq, this.sequenceIncrement);
			}
			if (this.sequencePropertyName != null && this.sequencedGridSorter != null) {
				this.list.oList.doSort(this.sequencedGridSorter, true);
			}
			if (EventTimer.Singleton.enabled) EventTimer.Singleton.end();
			]]>
		</method>

		<!---
			@keywords private
			Add the specified source objects to the list. If there are multiple ways that the objects may be
			added to the list, then a pop-up dialog will be presented to the user with the list of options.
			@param array objects: array of source objects
		-->
		<method args="objects" name="addObjects">
			<![CDATA[
			var actions = this.getAddActions(objects);
			if (actions.length > 0) {
				if (actions.length > 1 || (this.promptForCopy && actions.length == 1 && actions[0] == CopyAction.Singleton)) {
					if (actions.length > 4) {
						var caller = this;
						require(["cmc/foundation/AddActionPopUp"], function(AddActionPopUp) {
							AddActionPopUp.Singleton.open(caller, actions, objects);
						});
					}
					else {
						var caller = this;
						require(["cmc/foundation/AddActionDialog"], function(AddActionDialog) {
							AddActionDialog.Singleton.openAddActionDialog(caller, actions, objects);
						});
					}
				}
				else {
					this.doAddAction(actions[0], objects);
				}
			}
			]]>
		</method>
		
		<!---
			@keywords private
			This item computes the next sequence in the list by looking at the last sequence value in the current list and adding {@link cmc/foundation/BaseChildListEditor#sequenceIncrement} to it. This method does not have a notion of paging, so it is possible that the returned value will not be unique and/or might move the item to the next page.
			@return string The sequence value of the next item in the list.
		-->
		<method name="getNextSequence">
			<![CDATA[
			var nextSeq = 1;
			if (this.sequencePropertyName != null && this.list.oList.filteredObjects.length > 0) {
				this.updateSequence();
				var numItems = this.list.oList.filteredObjects.length;
				nextSeq = parseInt(this.list.oList.filteredObjects[numItems - 1].getPropertyValue(this.sequencePropertyName, this.sequencePropertyPath)) + this.sequenceIncrement;
			}
			return nextSeq.toString();
			]]>
		</method>
		
		<!---
			@keywords private
			Ensure that all the items in the list have a unique sequence value.
		-->
		<method name="updateSequence">
			<![CDATA[
			if (this.sequencePropertyName != null && this.list.oList.filteredObjects.length >= 2) {
				for (var i = 1; i < this.list.oList.filteredObjects.length; i++) {
					var firstObjectValue = parseInt(this.list.oList.filteredObjects[i - 1].getPropertyValue(this.sequencePropertyName, this.sequencePropertyPath));
					if (isNaN(firstObjectValue)) {
						firstObjectValue = 1;
					}
					var secondObject = this.list.oList.filteredObjects[i];
					var secondObjectValue = parseInt(secondObject.getPropertyValue(this.sequencePropertyName, this.sequencePropertyPath));
					if (isNaN(secondObjectValue) || secondObjectValue <= firstObjectValue) {
						var newValue = firstObjectValue + this.sequenceIncrement;
						secondObject.setPropertyValue(this.sequencePropertyName, this.sequencePropertyPath, newValue.toString());
					}
				}
			}
			]]>
		</method>
				
		<!---
			@keywords private
			Update the available height.
		-->
		<method args="e" name="updateAvailableHeight">
			<![CDATA[
			if (typeof(e) == "undefined") e = null;
			var newHeight = this.availableHeightView.availableHeight * this.fractionOfAvailableHeight - this.content.y;
			if (this.embedded) {
				newHeight -= 2;
			}
			if (this.content.availableHeight != newHeight) {
				this.content.setVariable("availableHeight", newHeight);
			}
			]]>
		</method>
		
		<!---
			@keywords private
			Update the available width.
		-->
		<method args="e" name="updateAvailableWidth">
			<![CDATA[
			if (typeof(e) == "undefined") e = null;
			var newWidth = this.availableWidthView.availableWidth;
			if (this.embedded) {
				newWidth -= this.x + 2;
			}
			if (this.content.availableWidth != newWidth) {
				this.content.setVariable("availableWidth", newWidth);
			}
			]]>
		</method>

		<AxisLayout axis="y" spacing="5"/>

		<Component name="actionArea" visible="false">
			<AxisLayout axis="x" spacing="3"/>
		</Component>
		<TextComponent multiline="true" name="message" text="${this.classroot.statusMessage}" visible="${this.classroot.embedded &amp;&amp; this.classroot.statusMessage != ''}" width="${this.parent.content.width}"/>		
		<Component name="content"/>
		
		<DropTarget dragAndDropManager="${DndManager.Singleton}" targetKey="${'element'}">
			<handler args="sources" name="ondroppedintarget">
				<![CDATA[
				this.classroot.droppedInTarget(sources);
				]]>
			</handler>
			<method args="currentDragSource" name="isEnabled">
				<![CDATA[
				return this.classroot.isDropEnabled(currentDragSource);
				]]>
			</method>
		</DropTarget>
		<!--- @keywords private -->
		<method args="o" name="set_o">
			<![CDATA[
			this.setModelObject(o);
			]]>
		</method>
	</FocusableComponent>
	
	<!---
		A child list editor is a widget that you can use to edit the child {@link cmc/foundation/ModelObject model objects} of a particular object. 
		You can use the child list editor to create new child objects in the list, delete child objects from the 
		list, or edit existing child objects in the list. This class requires the 
		{@link cmc/foundation/ObjectDefinition#objectType} value of the child objects to be displayed, as well as the name of the 
		class to use for viewing the child list.
		
		Classes should extend cmc/foundation/ChildListEditor, as follows:
	
			@START_CODE
				<class name="sampleChildListEditor" extends="cmc/foundation/ChildListEditor" 
					listClass="sampleGrid"
					objectTypes="SampleChildObject,SampleChildFolder"/>
			@END_CODE
			
		A child list editor can also be declared as a definition:
			@START_CODE
				<ChildListEditor definitionName="sampleChildListEditor" 
					listDefinitionName="sampleGrid"
					objectTypes="SampleChildObject,SampleChildFolder"/>
			@END_CODE
		
		Classes and definitions that extend cmc/foundation/ChildListEditor are often provided as the {@link cmc/foundation/NavigationListDefinition#listClass} for a 
		{@link cmc/foundation/NavigationListDefinition}.
	-->
	<BaseChildListEditor classDefinition="true" definitionName="cmc/foundation/ChildListEditor" referenceMoveable="true">
		<dependency localName="ModelUtil" moduleName="cmc/foundation/ModelUtil"/>
		<dependency localName="EventHandler" moduleName="cmc/foundation/EventHandler"/>
		<!---
			@keywords private
			The nearest ancestor view that defines a model object.
		-->
		<variable name="oView" value="${ModelUtil.Singleton.findObjectView(this.parent)}"/>
		<!---
			@keywords private
			This attribute is an object path to use when looking up the {@link cmc/foundation/ModelObject} that this class binds to. 
			If this value is not provided, the class will bind to {@link cmc/foundation/BaseChildListEditor#o}. 
			Otherwise it will bind to the object returned when this attribute is resolved relative to 
			{@link cmc/foundation/BaseChildListEditor#o}.
						
			The default value for this attribute is null. 
		-->
		<variable name="objectPath" type="string" value="${null}"/>
		
		<!--- @keywords private -->
		<handler name="oninit">
			<![CDATA[
			this.model = ModelUtil.Singleton.findModelForView(this);
			this.updateModelObjectDel = new EventHandler.Class(this, "updateModelObject");
			this.updateModelObject();
			]]>
		</handler>
		
		<!--- @keywords private -->
		<method name="destroy">
			<![CDATA[
			this.updateModelObjectDel.disconnectAll();
			delete this.updateModelObjectDel;
			this.inherited(arguments);
			]]>
		</method>

		<!---
			@keywords private
			Update the model object.
		-->
		<method args="e" name="updateModelObject">
			<![CDATA[
			if (typeof(e) == "undefined") e = null;
			this.updateModelObjectDel.disconnectAll();
			this.updateModelObjectDel.connect(this.oView, "ono");
			var newObject = this.oView.o;
			if (newObject != null && this.objectPath) {
				newObject = newObject.getObject(this.objectPath, false, null, this.updateModelObjectDel);
			}
			this.setVariable("o", newObject);
			]]>
		</method>
		
	</BaseChildListEditor>
	
	<!---
		@keywords final
		This class defines a child list editor for use within a properties view. It behaves like 
		{@link cmc/foundation/ChildListEditor} but it can be declared as a child of {@link cmc/foundation/PropertyGroup}. 
		The widget will include its own toolbar that allows the business user to add new objects to the list.
		@see cmc/foundation/ChildListEditor. 
	-->
	<PropertiesComponent classDefinition="true" definitionName="cmc/foundation/PropertyChildListEditor">
		<dependency localName="ObjectPropertiesUtil" moduleName="cmc/foundation/ObjectPropertiesUtil"/>
		<dependency localName="CallbackUtil" moduleName="cmc/foundation/CallbackUtil"/>
		<dependency localName="BaseChildListEditor" moduleName="cmc/foundation/BaseChildListEditor"/>
		<dependency localName="ModelUtil" moduleName="cmc/foundation/ModelUtil"/>
		<!---
			Comma separated list of object types to be displayed in this child object list.
			This is a required attribute.
		-->
		<variable name="objectTypes" type="string"/>
		<!---
			True if this child list editor should only have a single child.  It will delete its children
			when a new child is added and will only accept one child.
		-->
		<variable name="singleChild" type="boolean" value="false"/>
		<!---
			The class name for the list view. This must be a class that extends cmc/foundation/ObjectGrid. 
			@type string
		-->
		<variable name="listClass" type="module" value="${null}"/>
		<!---
			The definition name for the list view. This must be a definition that extends cmc/foundation/ObjectGrid.
			Only specify this attribute if you are not providing a value
			for <code>listClass</code>.
			@type string
		-->
		<variable name="listDefinition" type="module" value="${null}"/>
		<!---
			Resource name of the create new object button.
		-->
		<variable name="newButtonResource" type="string" value="grid_createNewIconForSingleAction"/>
		<!---
			Tooltip text of the new button. Specify this attribute if the default text needs to be overridden.
		-->
		<variable name="newButtonHelpText" type="string" value="${null}"/>
		<!---
			Set this to <code>true</code> to hide the Edit Column action. The default is <code>false</code>.
		-->
		<variable name="hideEditColumnAction" type="boolean" value="false"/>
		<!---
			Set this to <code>true</code> to hide the Delete action. The default is <code>false</code>.
		-->
		<variable name="hideDeleteAction" type="boolean" value="false"/>
		<!---
			The fraction of the available vertical space that will be allocated to this editor. This can be used to prevent the editor from
			consuming all of the visible space in a properties view. When multiple editors share the same properties view,
			they can each be assigned a fraction of the available height so that they are all visible at the same time. For example,
			to ensure that an editor only takes up half the available vertical space, set this attribute to "0.5".
		-->
		<variable name="fractionOfAvailableHeight" type="number" value="1"/>
		<!---
			The name of the currently selected object. This name must match one of the names declared
			in the containing {@link cmc/foundation/ObjectProperties properties view} with the componentObjectNames
			attribute. Other {@link cmc/foundation/PropertiesComponent properties components} can be configured to
			use this selected object as their component object by specifying the same name with the
			componentObjectName attribute.
		-->
		<variable name="selectedObjectName" type="string" value="${null}"/>
		<!---
			Indicates whether find and replace is available for the grid contained within this child list editor. The default is <code>false</code>.
		-->
		<variable name="findable" type="boolean" value="false"/>
		
		<!---
			Defines a property to use to sequence the objects in the list. When this value is provided, the list will be sequenced by the value of this property, and 
			the columns will not be sortable.
		-->
		<variable name="sequencePropertyName" type="string" value="${null}"/>
		<!---
			This property is used in conjunction with {@link cmc/foundation/PropertyChildListEditor#sequencePropertyName} to resolve the value of the sequence property.
		-->
		<variable name="sequencePropertyPath" type="string" value="${null}"/>
		<!---
			When a value for {@link cmc/foundation/BaseChildListEditor#sequencePropertyName sequencePropertyName} is specified, this property will be used to increment the value of the sequence property when new objects are added to the list.
		-->		
		<variable name="sequenceIncrement" type="number" value="1"/>			
		<!---
			The types of client action.
		-->
		<variable name="clientActionTypes" type="string" value=""/>
		<!---
			Indicates that the New button will always be displayed.
		-->
		<variable name="alwaysShowNewButton" type="boolean" value="false"/>
		<!---
			This attribute indicates that the editor will provide the ability to create a new referenced primary object directly
			from the child list editor toolbar. The attribute is only applicable to child list editors that manage reference objects.
			The default is false
		-->
		<variable name="allowCreateReferencedPrimary" type="boolean" value="false"/>
		<!---
			@keywords private
			Set this attribute to <code>true</code> to indicate that the framework should allow the business user to duplicate
			the objects that are displayed in this list. The default is <code>false</code>.
		-->
		<variable name="allowDuplicate" type="boolean" value="false"/>
		<!--- 
		    @keywords private
		    Instance of new handler class that is called
		    when the create new referenced object button is clicked. 
			When the allowCreateReferencedPrimary option is true, this handler
			will be used to override the default primary object create method.
			This class must extend the {@link cmc/foundation/NewReferencedObjectHandler} class and
			implement a method called "createNewObject".
		-->
		<variable name="newReferencedPrimaryObjectHandler" value="${null}"/>
		<!--- 
			The class name for the dialog that is launched when the new button is clicked. 
			This dialog class must extend the {@link cmc/foundation/Dialog} class and implement a method called "openNewActionDialog" that accepts 
			arguments that are the parent {@link cmc/foundation/ModelObject object} and the child list editor {@link cmc/foundation/BaseChildListEditor}. 
			@type string
		-->
		<variable name="newActionDialogClass" type="module" value="${null}"/>
		
		<!---
			@keywords private
			Property child list editors should determine their enablement on its own by looking at its 
			child object definitions to find out if they can be creatable. Overwrites the 
			{@link cmc/foundation/PropertiesComponent#updateEnablement} method to do nothing.
		-->
		<method args="e" name="updateEnablement">
			<![CDATA[
			if (typeof(e) == "undefined") e = null;

			]]>
		</method>
		
		<!---
			@keywords private
			This method creates the editor for the given property component
			@param cmc/foundation/PropertiesComponent parentComponent The parent properties component from which to create the editor
		-->
		<method args="parentComponent" name="createEditor">
			<![CDATA[
			var objectView = null;
			var objectName = null;
			if (this.selectedObjectName != null) {
				objectName = "o_" + this.selectedObjectName;
				objectView = ModelUtil.Singleton.findObjectView(this.parent, objectName);
			}
			new BaseChildListEditor.Class(parentComponent, {
				name: "editor",
				model: parentComponent.model,
				x: parentComponent.promptWidth + parentComponent.xspacing,
				o: parentComponent.o,
				objectTypes: this.objectTypes,
				listClass: this.listClass,
				listDefinition: this.listDefinition,
				embedded: true,
				singleChild: this.singleChild,
				newButtonResource: this.newButtonResource,
				newButtonHelpText: this.newButtonHelpText,
				hideEditColumnAction: this.hideEditColumnAction,
				hideDeleteAction: this.hideDeleteAction,
				fractionOfAvailableHeight: this.fractionOfAvailableHeight,
				selectedObjectView: objectView,
				selectedObjectName: objectName,
				findable: this.findable,
				sequencePropertyName: this.sequencePropertyName,
				sequencePropertyPath: this.sequencePropertyPath,
				sequenceIncrement: this.sequenceIncrement,
				clientActionTypes: this.clientActionTypes,
				alwaysShowNewButton: this.alwaysShowNewButton,
				allowCreateReferencedPrimary: this.allowCreateReferencedPrimary,
				allowDuplicate: this.allowDuplicate,
				newReferencedPrimaryObjectHandler: this.newReferencedPrimaryObjectHandler,
				newActionDialogClass: this.newActionDialogClass
			});
			]]>
		</method>
	
		<!---
			@keywords private
			This method returns the error message to be displayed from the first cell that contains an error
			@param cmc/foundation/EventHandler del This method will register the specified delegate to be called if the returned error changes.
			
			@return string The error message to be displayed.
		-->
		<method args="del" name="getFirstError">
			<![CDATA[
			var error = null;
			if (this.editor && this.editor.o) {
				error = this.inherited(arguments);
				if (error == null) {
					error = this.editor.list.getFirstError(del);
				}
			}
			return error;
			]]>
		</method>
		
		<!---
			@keywords private
			<p>This method determines if the error message associated with the specified object, property and
			validator type belongs to this child list editor.
			<p>The method first checks if the object matches this properties component's {@link cmc/foundation/PropertiesComponent#o model object}
			and whether the given validatorType is one of the {@link cmc/foundation/PropertiesComponent#validatorTypes validator types}
			supported by the properties component. If "errorObject" and "validatorType" match this properties component, then
			this method sets the focus to the editor and returns true.
			<p>The method then checks if an ancestor of the error object is one of the objects in the child list editor. If such
			an object is found, then the method delegates setting focus to the error to the {@link cmc/foundation/ObjectGrid object grid} and returns
			true.
			<p>Otherwise the method returns false.
			
			@param cmc/foundation/PropertiesComponent component The properties component to which focus is to be set
			@param object args a map containing the arguments for this method:
				objectPropertiesView - The object properties view that contains this properties component,
				errorObject - The cmc/foundation/ModelObject on which the error was reported, 
				errorProperty - The cmc/foundation/ModelProperty on which the error was reported,
				validatorType - The type of the validator that generated the error  
			@returns boolean true if focus is set to the editor that contains the error, false otherwise
		-->
		<method args="component, args" name="handleSetFocusToError">
			<![CDATA[
			var errorFound = this.inherited(arguments);
			if (!errorFound && args.errorObject != null && component.o != null && args.errorObject != component.o) {
				var objectSelectors = component.editor ? component.editor.objectSelectors : component.o.model.getObjectSelectors(component.o, this.objectTypes);
				var o = args.errorObject;
				while (o != null && o != component.o) {
					if (o.parentObject == component.o && ModelUtil.Singleton.matchesObjectSelectors(o, objectSelectors)) {
						errorFound = true;
						if (component.editor) {
							ObjectPropertiesUtil.Singleton.showComponent(args.objectPropertiesView, component);
							component.editor.list.setFocusToError(o, args.errorObject, args.errorProperty, args.validatorType);
						}
						else if (component.createViewsDel) {
							var callbackArgs = CallbackUtil.Singleton.getCallbackArguments(component.createViewsDel);
							if (callbackArgs) {
								callbackArgs.setFocusToErrorArgs = args;
							}
						}
						break;
					}
					o = o.parentObject;
				}
			}
			return errorFound;
			]]>
		</method>
	</PropertiesComponent>

	
	<!---
		@keywords private
		This class defines the create new child button.
	-->
	<ActionListButton buttonResource="grid_createNewIcon" buttonResourceForSingleAction="grid_createNewIconForSingleAction" classDefinition="true" defaultActionDefinition="${this.actionDefinitions == null ? null : this.actionDefinitions[0]}" definitionName="cmc/foundation/NewChildButton" displaySelectedIndicator="true" dropdownResource="dropdownToolbarIcon_New" enabled="${this.editor.addEnabled}" visible="${this.actionDefinitions == null ? false : true}">
		<dependency localName="foundationResources" moduleName="cmc/foundation/FoundationResources"/>
		<dependency localName="EventHandler" moduleName="cmc/foundation/EventHandler"/>
		<dependency localName="DefinitionUtil" moduleName="cmc/foundation/DefinitionUtil"/>
		<dependency localName="RootComponent" moduleName="cmc/RootComponent"/>
		<!---
			Child list editor.
		-->
		<variable name="editor"/>

		<!---
			Tooltip text for this button.
		-->
		<variable name="buttonHelpText" type="string" value="${null}"/>

		<Tooltip name="tooltip"/>
	
		<!---
			Create the new child object.
			@param Object definition: the action definition for the object to create
		-->
		<method args="definition" name="doAction">
			<![CDATA[
			if (definition == null) {
				definition = this.actionDefinitions[0];
			}
			if (this.editor.newActionDialogClass != null) {
				if (!this.editor._newDialog) {
					if (this.editor.newActionDialogClass.Class) {
						this.editor._newDialog = new this.editor.newActionDialogClass.Class(RootComponent.Singleton);
					}
					else {
						this.editor._newDialog = DefinitionUtil.createDefinitionInstance(this.editor.newActionDialogClass, RootComponent.Singleton);
					}
				}
				this.editor._newDialog.openNewActionDialog(this.editor.o, this.editor);
			}
			else if (definition.searchDefinition) {
				var caller = this;
				require(["cmc/foundation/NewChildSearchDialog"], function(NewChildSearchDialog) {
					NewChildSearchDialog.Singleton.openNewChildSearchDialog(caller, definition.searchDefinition);
				});
			}
			else {
				this.editor.createChild(definition);
			}
			]]>
		</method>
		
		<!--- @keywords private -->
		<method name="init">
			<![CDATA[
			this.inherited(arguments);
			this.updateTooltipDel = new EventHandler.Class(this, "updateTooltip");
			this.updateTooltip();
			]]>
		</method>
		
		<!--- @keywords private -->
		<method args="e" name="updateTooltip">
			<![CDATA[
			if (typeof(e) == "undefined") e = null;
			this.updateTooltipDel.disconnectAll();
			this.updateTooltipDel.connect(this, "ondefaultActionDefinition");
			if (this.buttonHelpText != null) {
				this.tooltip.setVariable("text", this.buttonHelpText);
			}
			else {
				if (this.defaultActionDefinition != null && typeof (this.defaultActionDefinition.displayName) != "undefined") {
					this.updateTooltipDel.connect(foundationResources.Singleton.childListEditorNewObject, "onstring");
					this.tooltip.setVariable("text", foundationResources.Singleton.replaceValues("childListEditorNewObject", [this.defaultActionDefinition.displayName]));
				}
				else {
					this.updateTooltipDel.connect(foundationResources.Singleton.childListEditorNew, "onstring");
					this.tooltip.setVariable("text", foundationResources.Singleton.childListEditorNew.string);
				}
			}
			]]>
		</method>
	</ActionListButton>
	
	<!---
		@keywords private
		This class defines the delete child button.
	-->
	<BaseButton classDefinition="true" definitionName="cmc/foundation/DeleteChildButton" doesenter="true" enabled="${this.editor.deleteEnabled}" focusable="true" imageSet="grid_deleteIcon" visible="${!this.editor.hideDeleteAction}">
		<dependency localName="foundationResources" moduleName="cmc/foundation/FoundationResources"/>
		<dependency localName="FocusIndicator" moduleName="cmc/foundation/FocusIndicator"/>
		<!---
			Child list editor.
		-->
		<variable name="editor"/>

		<Tooltip text="${foundationResources.Singleton.childListEditorDelete.string}"/>
		
		<handler name="onclick">
			<![CDATA[
			this.editor.doDelete();
			]]>
		</handler>		
		<!--- @keywords private -->
		<handler name="onfocus">
			<![CDATA[
			if (!this.indicator) {
				new FocusIndicator.Class(this, {
					name: "indicator",
					focusableView: this,
					indicatorView: this
				});
			}
			]]>
		</handler>
	</BaseButton>
	
	<!---
		@keywords private
		This class defines the embedded child client action button.
	-->
	<Component classDefinition="true" definitionName="cmc/foundation/ChildClientActionButton">
		<dependency localName="EventHandler" moduleName="cmc/foundation/EventHandler"/>
		<!--- @keywords private -->
		<variable name="editor"/>
		<!--- @keywords private -->
		<variable name="clientAction"/>
		<!--- @keywords private -->
		<variable name="text" type="string" value=""/>
		<!--- @keywords private -->
		<variable name="parentObjectAction" type="boolean" value="false"/>
		<!--- @keywords private -->
		<variable name="referencedObjectAction" type="boolean" value="false"/>

		<!--- @keywords private -->
		<method name="init">
			<![CDATA[
			this.inherited(arguments);
			this.updateButtonDel = new EventHandler.Class(this, "updateButton");
			this.updateButton();
			]]>
		</method>

		<!--- @keywords private -->
		<method args="e" name="updateButton">
			<![CDATA[
			if (typeof(e) == "undefined") e = null;
			this.updateButtonDel.disconnectAll();
			if (this.clientAction != null) {
				var actionEnabled = false;
				var selectedObjects = this.editor.list.getSelectedObjects();
				if (this.parentObjectAction) {
					actionEnabled = this.clientAction.isEnabled(this.editor.o);
					this.clientAction.registerEnablementDelegate(this.editor.o, this.updateButtonDel);
				}
				else {
					if (selectedObjects.length > 0 && (this.clientAction.allowMultipleSelection || selectedObjects.length == 1)) {
						actionEnabled = true;
						for (var i = 0; i < selectedObjects.length; i++) {
							var o = this.referencedObject ? selectedObjects[i].getReferencedObject() : selectedObjects[i];
							if (!o.objectDefinition || !o.objectDefinition.isClientActionDefined(this.clientAction)) {
								actionEnabled = false;
								break;
							}
							this.clientAction.registerEnablementDelegate(o, this.updateButtonDel);
							if (!this.clientAction.isEnabled(o)) {
								actionEnabled = false;
								break;
							}
						}
					}
				}
				this.updateButtonDel.connect(this.clientAction, "ondisplayName");
				this.setVariable("text", this.clientAction.displayName);
				if (this.clientAction.childListEditorIcon != null && this.clientAction.childListEditorIcon != "") {
					this.textButton.setVariable("visible", false);
					this.textButton.setVariable("enabled", false);
					this.resourceButton.setVariable("buttonResource", this.clientAction.childListEditorIcon);
					this.resourceButton.setVariable("imageComponents", 1);
					this.resourceButton._callShow();
					this.resourceButton.setVariable("visible", true);
					this.resourceButton.setVariable("enabled", actionEnabled);
				}
				else {
					this.resourceButton.setVariable("visible", false);
					this.resourceButton.setVariable("enabled", false);
					this.textButton.setVariable("visible", true);
					this.textButton.setVariable("enabled", actionEnabled);
				}
				this.setVariable("visible", true);
			}
			else {
				this.setVariable("visible", false);
				this.resourceButton.setVariable("enabled", false);
				this.textButton.setVariable("enabled", false);
			}
			]]>
		</method>
				
		<!--- @keywords private -->
		<method name="handleClick">
			<![CDATA[
			var objects = [];
			if (this.parentObjectAction) {
				objects.push(this.editor.o);
			}
			else {
				var selectedObjects = this.editor.list.getSelectedObjects();
				for (var i = 0; i < selectedObjects.length; i++) {
					objects.push(this.referencedObjectAction ? selectedObjects[i].getReferencedObject() : selectedObjects[i]);
				}
			}
			this.clientAction.performAction(objects);
			]]>
		</method>

		<ToolBarButton name="resourceButton" visible="false" y="5">
			<Tooltip name="tooltip" text="${this.classroot.text}"/>
			<handler name="onclick">
				<![CDATA[
				this.parent.handleClick();
				]]>
			</handler>
		</ToolBarButton>
		<Button name="textButton" text="${this.classroot.text}" visible="false" y="2">
			<handler name="onclick">
				<![CDATA[
				this.parent.handleClick();
				]]>
			</handler>
		</Button>
	</Component>

	<!---
		@keywords private
		This class defines the Edit Column button.
	-->
	<BaseButton classDefinition="true" definitionName="cmc/foundation/EditColumnButton" doesenter="true" enabled="${this.editor.editColumnEnabled}" focusable="true" imageSet="editColumnEmbedButtonIcon" visible="${!this.editor.hideEditColumnAction}">
		<dependency localName="foundationResources" moduleName="cmc/foundation/FoundationResources"/>
		<dependency localName="FocusIndicator" moduleName="cmc/foundation/FocusIndicator"/>
		<!---
			Child list editor.
		-->
		<variable name="editor"/>

		<Tooltip text="${foundationResources.Singleton.childListEditorEditColumn.string}"/>
		
		<handler name="onclick">
			<![CDATA[
			this.editor.doEditColumn();
			]]>
		</handler>
		<!--- @keywords private -->
		<handler name="onfocus">
			<![CDATA[
			if (!this.indicator) {
				new FocusIndicator.Class(this, {
					name: "indicator",
					focusableView: this,
					indicatorView: this
				});
			}
			]]>
		</handler>
	</BaseButton>
	
	<!---
		@keywords private
		This class defines the utilities view launch button.
	-->
	<BaseButton classDefinition="true" definitionName="cmc/foundation/UtilitiesButton" doesenter="true" enabled="${this.editor.addEnabled}" focusable="true" imageSet="grid_utilitiesIcon" visible="${this.objectDefinition == null ? false : true}">
		<dependency localName="foundationResources" moduleName="cmc/foundation/FoundationResources"/>
		<dependency localName="FocusIndicator" moduleName="cmc/foundation/FocusIndicator"/>
		<!---
			Editor view associated with this button.
		-->
		<variable name="editor"/>
		<!---
			Object definition.
		-->
		<variable name="objectDefinition" value="${null}"/>
		
		<Tooltip extendedText="${foundationResources.Singleton.refEditorShowUtilitiesExtendedHelp.string}" linkURL="tasks/ttfutilitiespane.htm" text="${foundationResources.Singleton.refEditorShowUtilities.string}"/>

		<handler name="onclick">
			<![CDATA[
			var oEditor = this.objectDefinition.model.oEditor;
			var objectDefinition = this.objectDefinition;
			require(["cmc/foundation/UtilitiesSplitView"], function(UtilitiesSplitView) {
				if (!oEditor.utilities) {
					new UtilitiesSplitView.Class(oEditor.content.workAreaUtilitiesSplit, {
						name: "utilitiesSplit",
						oEditor: oEditor
					});
				}
				var utilities = oEditor.utilities;
				utilities.setContext(objectDefinition);
				utilities.open();
			});
			]]>
		</handler>
		<!--- @keywords private -->
		<handler name="onfocus">
			<![CDATA[
			if (!this.indicator) {
				new FocusIndicator.Class(this, {
					name: "indicator",
					focusableView: this,
					indicatorView: this
				});
			}
			]]>
		</handler>
	</BaseButton>
	
	<!---
		@keywords private
		This class defines the sequence up button.
	-->
	<BaseButton classDefinition="true" definitionName="cmc/foundation/SequenceUpButton" doesenter="true" enabled="${this.editor.sequenceUpEnabled}" focusable="true" imageSet="grid_sequenceUpButton" visible="${this.editor.sequencePropertyName != null}">
		<dependency localName="foundationResources" moduleName="cmc/foundation/FoundationResources"/>
		<dependency localName="FocusIndicator" moduleName="cmc/foundation/FocusIndicator"/>
		<dependency localName="FocusUtil" moduleName="cmc/foundation/FocusUtil"/>
		<!---
			Child list editor associated with this button.
		-->
		<variable name="editor"/>
		
		<Tooltip extendedText="${foundationResources.Singleton.childListEditorSeqUpExtendedHelp.string}" text="${foundationResources.Singleton.childListEditorSeqUp.string}"/>

		<handler name="onclick">
			<![CDATA[
			this.editor.doSequenceUp();
			FocusUtil.setFocus(this);
			]]>
		</handler>
		
		<!--- @keywords private -->
		<handler name="onfocus">
			<![CDATA[
			if (!this.indicator) {
				new FocusIndicator.Class(this, {
					name: "indicator",
					focusableView: this,
					indicatorView: this
				});
			}
			]]>
		</handler>
	</BaseButton>
	
	<!---
		@keywords private
		This class defines the sequence down button.
	-->
	<BaseButton classDefinition="true" definitionName="cmc/foundation/SequenceDownButton" doesenter="true" enabled="${this.editor.sequenceDownEnabled}" focusable="true" imageSet="grid_sequenceDownButton" visible="${this.editor.sequencePropertyName != null}">
		<dependency localName="foundationResources" moduleName="cmc/foundation/FoundationResources"/>
		<dependency localName="FocusIndicator" moduleName="cmc/foundation/FocusIndicator"/>
		<dependency localName="FocusUtil" moduleName="cmc/foundation/FocusUtil"/>
		<!---
			Child list editor.
		-->
		<variable name="editor"/>
		
		<Tooltip extendedText="${foundationResources.Singleton.childListEditorSeqDownExtendedHelp.string}" text="${foundationResources.Singleton.childListEditorSeqDown.string}"/>

		<handler name="onclick">
			<![CDATA[
			this.editor.doSequenceDown();
			FocusUtil.setFocus(this);
			]]>
		</handler>
		<!--- @keywords private -->
		<handler name="onfocus">
			<![CDATA[
			if (!this.indicator) {
				new FocusIndicator.Class(this, {
					name: "indicator",
					focusableView: this,
					indicatorView: this
				});
			}
			]]>
		</handler>
	</BaseButton>
	

	<!---
		@keywords private
		Child search widget. This widget is used to search for a primary object that will be referenced
		by the parent child list.
	-->
	<Component classDefinition="true" definitionName="cmc/foundation/ChildSearchWidget" visible="${this.searchDefinitions == null ? false : true}">
		<dependency localName="foundationResources" moduleName="cmc/foundation/FoundationResources"/>
		<dependency localName="StringUtil" moduleName="cmc/foundation/StringUtil"/>
		<dependency localName="FocusIndicator" moduleName="cmc/foundation/FocusIndicator"/>
		<dependency localName="EventHandler" moduleName="cmc/foundation/EventHandler"/>
		<dependency localName="EventTimer" moduleName="cmc/shell/EventTimer"/>
		<dependency localName="MessageLogger" moduleName="cmc/shell/MessageLogger"/>
		<!---
			Child list editor.
		-->
		<variable name="editor"/>
		<!---
			Array of search definitions.
		-->
		<variable name="searchDefinitions" value="${null}"/>
		<!---
			Current definition.
		-->
		<variable name="currentDefinition" value="${null}"/>
		<!---
			Current search results object.
		-->
		<variable name="searchResults" value="${null}"/>
		<!--- 
			The request identifier for the curent search results. 
		-->
		<variable name="serviceRequestId" type="string" value=""/>
		<!--- 
			The search text for the curent search results. 
		-->
		<variable name="serviceSearchText" type="string" value=""/>
		
		<!--- @keywords private -->
		<method name="init">
			<![CDATA[
			this.searchCompleteDel = new EventHandler.Class(this, "searchComplete");
			this.inherited(arguments);
			]]>
		</method>
		
		<!--- @keywords private -->
		<method name="destroy">
			<![CDATA[
			this.searchCompleteDel.disconnectAll();
			delete this.searchCompleteDel;
			this.inherited(arguments);
			]]>
		</method>
		
		<!---
			@keywords private
			Sets currentDefinition and defaultActionDefinition.
		-->
		<handler name="onsearchDefinitions">
			<![CDATA[
			this.resetSearchField();
			if (this.searchDefinitions != null) {
				this.currentDefinition = this.searchDefinitions[0];
			}
			else {
				this.currentDefinition = null;
			}
			this.searchButton.setVariable("defaultActionDefinition", this.currentDefinition);
			]]>
		</handler>

		<!---
			Launch the search.
		-->
		<method name="doSearch">
			<![CDATA[
			if (EventTimer.Singleton.enabled) EventTimer.Singleton.start("cmc/foundation/ChildSearchWidget doSearch: " + this.searchTextArea.searchText.getText());
			if (StringUtil.Singleton.trim(this.searchTextArea.searchText.getText()) == "") {
				this.serviceRequestId = "-1";
				var params = {};
				params.requestIdentifier = "-1";
				params.searchResultObjects = [];
				params.statusMessage = foundationResources.Singleton.searchResultsNoCriteriaMsg.string;
				this.searchComplete(params);
			}
			else {
				var s = this.editor.model.findSearchResults(this.currentDefinition.searchType);
				this.searchResults = s;
				this.searchCompleteDel.disconnectAll();
				this.searchCompleteDel.connect(s, "onsearchComplete");
				s.doSearch({
					searchText: this.searchTextArea.searchText.getText()
				});
				this.serviceRequestId = s.searchDefinition.searchService.requestIdentifier;
				this.serviceSearchText = this.searchTextArea.searchText.getText();
			}
			if (EventTimer.Singleton.enabled) EventTimer.Singleton.end();
			]]>
		</method>
		
		<!---
			Handle search complete.
			@param object args: the arguments containing the search service requestIdentifier and the search result objects
		-->
		<method args="args" name="searchComplete">
			<![CDATA[
			if (args && args.requestIdentifier == this.serviceRequestId) {
				this.searchCompleteDel.disconnectAll();
				var errorMessage = null;
				if (args && args.searchResultObjects) {
					var objects = args.searchResultObjects;
					if (objects.length == 0) {
						errorMessage = args.statusMessage;
					}
					else {
						var doUtilitiesOpen = false;
						if (objects.length == 1 || (!this.editor.singleChild && objects.length <= this.serviceSearchText.split(",").length)) {
							var actions = this.editor.getAddReferenceActions(objects);
							if (actions.length == 1) {
								this.editor.doAddAction(actions[0], objects);
								var statusMessage = args.statusMessage;
								MessageLogger.Singleton.logStatus(statusMessage);
							}
							else {
								doUtilitiesOpen = true;
							}
						}
						else {
							doUtilitiesOpen = true;
						}
						if (doUtilitiesOpen) {
							var oEditor = this.editor.o.model.oEditor;
							var currentDefinition = this.currentDefinition;
							require(["cmc/foundation/UtilitiesSplitView"], function(UtilitiesSplitView) {
								if (!oEditor.utilities) {
									new UtilitiesSplitView.Class(oEditor.content.workAreaUtilitiesSplit, {
										name: "utilitiesSplit",
										oEditor: oEditor
									});
								}
								var utilities = oEditor.utilities;
								utilities.setContext(currentDefinition);
								utilities.open();
							});
						}
					}
				}
				else if (args && args.statusMessage) {
					errorMessage = args.statusMessage;
				}
				if (errorMessage != null) {
					MessageLogger.Singleton.logException(null, errorMessage);
				}
			}
			]]>
		</method>
		
		<!--- @keywords private -->
		<handler eventSource="this.editor" name="ono">
			<![CDATA[
			this.resetSearchField();
			]]>
		</handler>
		
		<!---
			Clear the text from the search field, and unregister the delegate listening for results of searches
			that were already in progress.
		-->
		<method name="resetSearchField">
			<![CDATA[
			this.searchCompleteDel.disconnectAll();
			this.searchTextArea.searchText.setVariable('text', "");
			]]>
		</method>

		<AxisLayout axis="x" spacing="10"/>
		
		<BorderedView name="searchTextArea" borderSize="1" borderColor="${this.classroot.editor.addEnabled ? '#959595' : '#b1b1b1'}" paddingLeftSize="8" paddingRightSize="8">
			<InputTextComponent name="searchText" width="133" height="28">
				<variable name="enabled" type="boolean" value="${this.classroot.editor.addEnabled}"/>
				<handler args="kc" name="onkeydown">
					<![CDATA[
					if (kc == 13) {
						this.classroot.doSearch();
					}
					]]>
				</handler>
			</InputTextComponent>
			<!---
				@keywords private
				Handle onfocus event. 
			-->
			<handler eventSource="this.searchText" name="onfocus">
				<![CDATA[
				if (!this.indicator) {
					new FocusIndicator.Class(this, {
						name: "indicator",
						focusableView: this.searchText,
						indicatorView: this,
						offset: 1
					});
				}
				]]>
			</handler>
		</BorderedView>

		<ActionListButton actionDefinitions="${this.parent.searchDefinitions}" defaultActionDefinition="${this.classroot.currentDefinition}" displaySelectedIndicator="true" enabled="${this.classroot.editor.addEnabled &amp;&amp; this.classroot.searchTextArea.searchText.text != ''}" name="searchButton">
			<variable name="buttonText" value="${foundationResources.Singleton.childListEditorFindAndAdd.string}"/>
			<variable name="dropdownResource" value="searchDropdownResource"/>
			<variable name="dropdownOffset" value="8"/>
			
			<Tooltip extendedText="${foundationResources.Singleton.childListEditorFindAndAddExtendedHelp.string}" linkURL="tasks/ttfsearch.htm" text="${foundationResources.Singleton.childListEditorFindAndAdd.string}"/>
			
			<method args="definition" name="doAction">
				<![CDATA[
				if (definition) {
					this.classroot.currentDefinition = definition;
				}
				if (typeof (definition) == "undefined" || definition == null) {
					this.classroot.doSearch();
				}
				]]>
			</method>
		</ActionListButton>
	</Component>

	<!--- @keywords private -->
	<Node definitionName="cmc/foundation/MoveAction" singletonDefinition="true">
		<dependency localName="foundationResources" moduleName="cmc/foundation/FoundationResources"/>
		<variable name="displayName" type="string" value="${foundationResources.Singleton.addActionPopUpMove.string}"/>
	</Node>

	<!--- @keywords private -->
	<Node definitionName="cmc/foundation/CopyAction" singletonDefinition="true">
		<dependency localName="foundationResources" moduleName="cmc/foundation/FoundationResources"/>
		<variable name="displayName" type="string" value="${foundationResources.Singleton.addActionPopUpCopy.string}"/>
	</Node>

	<!--- @keywords private -->
	<Node definitionName="cmc/foundation/AddToCollectionAction" singletonDefinition="true">
		<dependency localName="foundationResources" moduleName="cmc/foundation/FoundationResources"/>
		<variable name="displayName" type="string" value="${foundationResources.Singleton.addActionPopUpAdd.string}"/>
	</Node>

	<!--- @keywords private -->
	<Node definitionName="cmc/foundation/AddReferenceAction" singletonDefinition="true"/>

	<!---
		@keywords private
		Add action dialog. This dialog presents the user with a list of possible "add" actions.
	-->
	<BaseList definitionName="cmc/foundation/AddActionPopUp" singletonDefinition="true" visible="false" x="${-1000}" y="${-1000}">
		<dependency localName="MouseUtil" moduleName="cmc/foundation/MouseUtil"/>
		<dependency localName="ViewUtil" moduleName="cmc/foundation/ViewUtil"/>
		<dependency localName="EventHandler" moduleName="cmc/foundation/EventHandler"/>
		<dependency localName="FocusUtil" moduleName="cmc/foundation/FocusUtil"/>
		<dependency localName="ListItem" moduleName="cmc/foundation/ListItem"/>
		<dependency localName="Logger" moduleName="cmc/shell/Logger"/>
		<dependency localName="RootComponent" moduleName="cmc/RootComponent"/>
		<dependency localName="ModalUtil" moduleName="cmc/foundation/ModalUtil"/>
		<!---
			Reference to the child list editor being added.
		-->
		<variable name="editor" value="${null}"/>
		<!---
			Array of source objects. This is a required attribute.
		-->
		<variable name="objects" value="${[]}"/>
		<!---
			Array of list items.
		-->
		<variable name="items" value="${[]}"/>
		<!---
			Array of list items available for reuse.
		-->
		<variable name="availableItems" value="${[]}"/>

		<!---
			The view to which focus will be restored when the popup is closed.
		-->
		<variable name="restoreFocusView" value="${null}"/>
		<!---
			Business Object Editor associated with the objects being added.
		 -->
		<variable name="oEditor" value="${null}"/>		

		<!--- @keywords private -->
		<method name="init">
			<![CDATA[
			this.inherited(arguments);
			this.checkMouseDel = new EventHandler.Class(this, "checkMouse");
			]]>
		</method>

		<!--- @keywords private -->		
		<method name="destroy">
			<![CDATA[
			this.checkMouseDel.disconnectAll();
			delete this.checkMouseDel;
			this.inherited(arguments);
			]]>
		</method>	
						
		<!---
			Handle key down event.
			@param number k: key code
		-->
		<handler args="k" name="onkeydown">
			<![CDATA[
			if (k == 27) {
				this.close();
			}
			]]>
		</handler>
		
		<!---
			Handle selection.
			@param listitem item: list item
		-->
		<handler args="item" name="onselect">
			<![CDATA[
			if (Logger.Singleton.perfTraceEnabled) {
				Logger.Singleton.perfTrace("cmc/foundation/AddActionPopUp", "onselect", "Start " + item.value.displayName);
			}
			var action = item.value;
			this.editor.doAddAction(action, this.objects);
			this.close();
			if (Logger.Singleton.perfTraceEnabled) {
				Logger.Singleton.perfTrace("cmc/foundation/AddActionPopUp", "onselect", "End " + action.displayName);
			}
			]]>
		</handler>
		
		<!---
			Open the pop up.
			@param cmc/foundation/Component editor: parent editor
			@param array actions: array of actions
			@param array objects: array of source objects
		-->
		<method args="editor, actions, objects" name="open">
			<![CDATA[
			if (this.visible) {
				this.close();
			}
			this.editor = editor;
			this.setVariable("restoreFocusView", FocusUtil.getFocus());
			this.oEditor = objects[0].model.oEditor;
			this.objects = objects;
			for (var i = 0; i < actions.length; i++) {
				var action = actions[i];
				if (this.availableItems.length > 0) {
					var item = this.availableItems.shift();
					item.setVariable("value", action);
					item.setVariable("displayName", action.displayName);
					item.setVariable("visible", true);
					this.items.push(item);
				}
				else {
					var item = new ListItem.Class(this, {
						value: action,
						displayName: action.displayName,
						icon: null
					});
					this.items.push(item);
				}
			}
			this.checkWidth();
			if (ViewUtil.Singleton.getLastKeyStroke() > ViewUtil.Singleton.getLastMouseMove()) {
				var targetX = RootComponent.Singleton.getMouse("x");
				var targetY = RootComponent.Singleton.getMouse("y");
			}
			else {
				var targetX = editor.getVariableRelative("x", RootComponent.Singleton) + this.width / 3;
				var targetY = editor.getVariableRelative("y", RootComponent.Singleton) + 90;
			}
			if (targetX + this.width > RootComponent.Singleton.width) {
				targetX = RootComponent.Singleton.width - this.width;
			}
			if (targetY + this.height > RootComponent.Singleton.height) {
				targetY = RootComponent.Singleton.height - this.height;
			}
			this.setVariable("x", targetX);
			this.setVariable("y", targetY);
			this.bringToFront();
			this.setVariable("visible", true);
			ModalUtil.makeModal(this);
			FocusUtil.setFocus(this);
			this.checkMouseDel.connect(MouseUtil, "onmousedown");
			]]>
		</method>

		<!---
			Check the width of the popup to ensure that all items are visible.
		-->
		<method name="checkWidth">
			<![CDATA[
			var newWidth = 90;
			for (var i = 0; i < this.items.length; i++) {
				var item = this.items[i];
				var itemWidth = item.title.width;
				if (itemWidth > newWidth) {
					newWidth = itemWidth;
				}
			}
			this.setVariable('width', newWidth + 10);
			]]>
		</method>

		<!---
			Close the pop up.
		-->		
		<method name="close">
			<![CDATA[
			this.editor = null;
			this.objects = null;
			this.checkMouseDel.disconnectAll();
			this.setVariable("x", -1000);
			this.setVariable("y", -1000);
			this.setVariable("visible", false);
			this.setHilite(null);
			this.clearSelection();
			ModalUtil.release(this);
			while (this.items.length > 0) {
				var item = this.items.pop();
				item.setVariable("visible", false);
				item.setVariable("value", null);
				this.availableItems.unshift(item);
			}
			if (ViewUtil.Singleton.containsView(this, FocusUtil.getFocus())) {
				if (this.restoreFocusView != null && this.restoreFocusView.visible && ViewUtil.Singleton.getInvisibleAncestor(this.restoreFocusView) == null) {
					FocusUtil.setFocus(this.restoreFocusView, false);
				}
				else {
					this.oEditor.restoreFocus();
				}
			}
			this.restoreFocusView = null;
			this.oEditor = null;
			]]>
		</method>
		
		<!---
			Check the mouse down. If it happened outside this view, then close the pop-up.
		-->
		<method args="e" name="checkMouse">
			<![CDATA[
			if (typeof(e) == "undefined") e = null;
			if (!this.containsPt(this.getMouse("x"), this.getMouse("y"))) {
				this.close();
			}
			]]>
		</method>
		
	</BaseList>
		
	<!---
		@keywords private
		Add action dialog. This dialog presents the user with a list of possible "add" actions.
	-->
	<Dialog definitionName="cmc/foundation/AddActionDialog" singletonDefinition="true">
		<dependency localName="foundationResources" moduleName="cmc/foundation/FoundationResources"/>
		<dependency localName="AddToCollectionAction" moduleName="cmc/foundation/AddToCollectionAction"/>
		<dependency localName="MoveAction" moduleName="cmc/foundation/MoveAction"/>
		<dependency localName="FocusUtil" moduleName="cmc/foundation/FocusUtil"/>
		<dependency localName="Logger" moduleName="cmc/shell/Logger"/>
		<dependency localName="CopyAction" moduleName="cmc/foundation/CopyAction"/>
		<dependency localName="AddReferenceButton" moduleName="cmc/foundation/AddReferenceButton"/>
		<!---
			Reference to the editor to which the objects are being added.
		-->
		<variable name="editor" value="${null}"/>
		<!---
			Array of source objects. This is a required attribute.
		-->
		<variable name="objects" value="${null}"/>
		<!---
			Array of add reference buttons.
		-->
		<variable name="addReferenceButtons" value="${[]}"/>
		<!---
			Array of buttons available for reuse.
		-->
		<variable name="availableButtons" value="${[]}"/>

		<!---
			Open the add action dialog.
			@param cmc/foundation/Component editor: parent editor
			@param array actions: array of actions
			@param array objects: array of source objects
		-->
		<method args="editor, actions, objects" name="openAddActionDialog">
			<![CDATA[
			this.openWindow();
			this.editor = editor;
			this.objects = objects;
			var showMoveBtn = false;
			var showCopyBtn = false;
			var showAddToCollectionBtn = false;
			var showAddReferenceBtns = false;
			for (var i = 0; i < actions.length; i++) {
				var action = actions[i];
				if (action == MoveAction.Singleton) {
					showMoveBtn = true;
				}
				else if (action == CopyAction.Singleton) {
					showCopyBtn = true;
				}
				else if (action == AddToCollectionAction.Singleton) {
					showAddToCollectionBtn = true;
				}
				else {
					var addReferenceButton = null;
					if (this.availableButtons.length > 0) {
						addReferenceButton = this.availableButtons.shift();
						addReferenceButton.setVariable("text", action.displayName);
						addReferenceButton.setVariable("action", action);
						addReferenceButton.setVariable("visible", true);
					}
					else {
						addReferenceButton = new AddReferenceButton.Class(this.viewButtons.addReferenceBtns, {
							text: action.displayName,
							action: action,
							visible: true,
							addReferenceDialog: this
						});
					}
					this.addReferenceButtons.push(addReferenceButton);
					showAddReferenceBtns = true;
				}
			}
			if (this.viewButtons.moveBtn.visible != showMoveBtn) {
				this.viewButtons.moveBtn.setVariable("visible", showMoveBtn);
			}
			if (this.viewButtons.copyBtn.visible != showCopyBtn) {
				this.viewButtons.copyBtn.setVariable("visible", showCopyBtn);
			}
			if (this.viewButtons.addToCollectionBtn.visible != showAddToCollectionBtn) {
				this.viewButtons.addToCollectionBtn.setVariable("visible", showAddToCollectionBtn);
			}
			if (this.viewButtons.addReferenceBtns.visible != showAddReferenceBtns) {
				this.viewButtons.addReferenceBtns.setVariable("visible", showAddReferenceBtns);
			}
			var questionText = "";
			if (actions.length == 1 && showCopyBtn) {
				if (this.objects.length > 1) {
					questionText = foundationResources.Singleton.addActionDialogCopyMultipleObjectsText.string;
				}
				else {
					questionText = foundationResources.Singleton.addActionDialogCopySingleObjectText.string;
				}
			}
			else {
				if (this.objects.length > 1) {
					questionText = foundationResources.Singleton.addActionDialogMultipleObjectsText.string;
				}
				else {
					questionText = foundationResources.Singleton.addActionDialogSingleObjectText.string;
				}
			}
			this.questionArea.setVariable("text", questionText);
			]]>
		</method>
		
		<!---
			Set the focus to Copy button
		-->
		<method args="e" name="setInitialFocus">
			<![CDATA[
			if (typeof(e) == "undefined") e = null;
			var firstButton = this.getFirstVisibleButton();
			FocusUtil.setFocus(firstButton);
			]]>
		</method>
		
		<!---
			Get the first visible button
		-->
		<method name="getFirstVisibleButton">
			<![CDATA[
			var firstButton = null;
			var buttonCount = this.viewButtons.childComponents.length;
			for (var i = 0; i < buttonCount; i++) {
				if (this.viewButtons.childComponents[i].visible) {
					firstButton = this.viewButtons.childComponents[i];
					break;
				}
			}
			return firstButton;
			]]>
		</method>
		
		<!---
			Close add action dialog.
		-->
		<method name="closeWindow">
			<![CDATA[
			while (this.addReferenceButtons.length > 0) {
				var addReferenceButton = this.addReferenceButtons.pop();
				addReferenceButton.setVariable("visible", false);
				addReferenceButton.setVariable("text", "");
				addReferenceButton.setVariable("action", "");
				this.availableButtons.unshift(addReferenceButton);
			}
			this.objects = null;
			this.editor = null;
			this.inherited(arguments);
			]]>
		</method>

		<!---
			This method is called when the user selects the action. Perform the action for the specified list of objects.
		-->
		<method args="action" name="handleAddAction">
			<![CDATA[
			if (Logger.Singleton.perfTraceEnabled) {
				Logger.Singleton.perfTrace("cmc/foundation/AddActionDialog", "handleAddAction", "Start " + action.displayName);
			}
			this.editor.doAddAction(action, this.objects);
			if (Logger.Singleton.perfTraceEnabled) {
				Logger.Singleton.perfTrace("cmc/foundation/AddActionDialog", "handleAddAction", "End " + action.displayName);
			}
			]]>
		</method>

		<AxisLayout axis="x" spacing="10"/>
		<Component imageSet="dialogQuestionIcon" name="infoIcon"/>		
		<TextComponent multiline="true" name="questionArea" width="400"/>
		
		<Component name="viewButtons" placement="footer">
			<AxisLayout axis="x" spacing="10"/>
			<Button name="cancelBtn" text="${foundationResources.Singleton.addActionDialogCancel.string}" visible="true" primary="false">
				<handler name="onclick">
					<![CDATA[
					this.parent.parent.closeWindow();
					]]>
				</handler>
			</Button>
			<Button name="moveBtn" text="${MoveAction.Singleton.displayName}">
				<handler name="onclick">
					<![CDATA[
					this.parent.parent.handleAddAction(MoveAction.Singleton);
					this.parent.parent.closeWindow();
					]]>
				</handler>
			</Button>
			<Button name="copyBtn" text="${CopyAction.Singleton.displayName}">
				<handler name="onclick">
					<![CDATA[
					this.parent.parent.handleAddAction(CopyAction.Singleton);
					this.parent.parent.closeWindow();
					]]>
				</handler>
			</Button>
			<Button name="addToCollectionBtn" text="${AddToCollectionAction.Singleton.displayName}">
				<handler name="onclick">
					<![CDATA[
					this.parent.parent.handleAddAction(AddToCollectionAction.Singleton);
					this.parent.parent.closeWindow();
					]]>
				</handler>
			</Button>
			<Component name="addReferenceBtns"/>
		</Component>
	</Dialog>
	
	<!---
		@keywords private
		This class defines the add reference button.
	-->
	<Button classDefinition="true" definitionName="cmc/foundation/AddReferenceButton">
		<!---
			The add reference dialog.
		-->
		<variable name="addReferenceDialog" value="${null}"/>
		<!---
			The add reference action.
		-->
		<variable name="action" value="${null}"/>
		
		<handler name="onclick">
			<![CDATA[
			this.addReferenceDialog.handleAddAction(this.action);
			this.addReferenceDialog.closeWindow();
			]]>
		</handler>
	</Button>

	<!---
		@keywords private

		Child Object Checkbox Dialog.
	-->
	<Dialog definitionName="cmc/foundation/NewChildSearchDialog" singletonDefinition="true" title="${foundationResources.Singleton.childListEditorFindAndAdd.string}">
		<dependency localName="foundationResources" moduleName="cmc/foundation/FoundationResources"/>
		<!---
			Reference to the new child button from which this dialog was launched.
		-->
		<variable name="newChildButton"/>

		<!---
			Handle OK.
		-->
		<method name="onOk">
			<![CDATA[
			this.newChildButton.editor.searchWidget.searchTextArea.searchText.setVariable("text", this.contentView.searchText.getText());
			this.newChildButton.editor.searchWidget.doSearch();
			this.closeWindow();
			]]>
		</method>

		<!---
			Handle Cancel.
		-->
		<method name="onCancel">
			<![CDATA[
			this.closeWindow();
			]]>
		</method>

		<!---
			Open the new child search dialog.
			@param cmc/foundation/NewChildButton newChildButton New child button widget.
			@param cmc/foundation/SearchDefinition searchDefinition Search definition.
		-->
		<method args="newChildButton, searchDefinition" name="openNewChildSearchDialog">
			<![CDATA[
			this.openWindow();
			this.contentView.searchText.setVariable("text", "");
			this.newChildButton = newChildButton;
			this.newChildButton.editor.searchWidget.setVariable("currentDefinition", searchDefinition);
			]]>
		</method>

		<Component height="55" name="contentView" width="250">
			<TextComponent text="${foundationResources.Singleton.childListEditorSearchKeywordPrompt.string}"/>
			<InputText name="searchText" width="230"/>
			<AxisLayout axis="y" spacing="2"/>
		</Component>

		<Component name="buttonSection" placement="footer">
			<Button name="cancelButton" text="${foundationResources.Singleton.simpleDialogCancel.string}" primary="false">
				<handler name="onclick">
					<![CDATA[
					this.parent.parent.onCancel();
					]]>
				</handler>
			</Button>
			<Button isdefault="true" name="okButton" text="${foundationResources.Singleton.simpleDialogOK.string}">
				<handler name="onclick">
					<![CDATA[
					this.parent.parent.onOk();
					]]>
				</handler>
			</Button>			
			<AxisLayout axis="x" spacing="10"/>
		</Component>
	</Dialog>

</Definitions>