<?xml version="1.0" encoding="UTF-8"?>

<!--
 =================================================================
  Licensed Materials - Property of IBM

  WebSphere Commerce

  (C) Copyright IBM Corp. 2015, 2017 All Rights Reserved.

  US Government Users Restricted Rights - Use, duplication or
  disclosure restricted by GSA ADP Schedule Contract with
  IBM Corp.
 =================================================================
-->
<Definitions>
	<!---
		A model object is the representation of a business object. Every business object that is loaded by the Management Center framework is an instance of cmc/foundation/ModelObject.
		A business object is an object that is authored by a business user. The characteristics of these objects are defined in the object definition.
		<p>
		For example,<br/>
		A product is a business object. The characteristics of products are defined in a cmc/foundation/ObjectDefinition instance. In this case, the object definition is
		{@link cmc/catalog/ProductPrimaryObjectDefinition}. When a new product is created by the business user, the Management Center framework creates a new instance of
		cmc/foundation/ModelObject that represents this new product. The Management Center creates an association between this cmc/foundation/ModelObject and the object definition
		cmc/catalog/ProductPrimaryObjectDefinition.
		<P>
		The model object will contain all of the data of this specific instance.  For example:
		<ul>
			<li>A number of {@link cmc/foundation/ModelProperty model properties}
			<li>Child objects, such as product description, and product price
			<li>References to other objects, such as merchandising associations
		</ul>
		
		The Management Center creates instances of cmc/foundation/ModelObject when:
		
		<ul>
			<li>The business user requests to create a new business object
			<li>The business user requests to load objects from the server
		</ul>
	-->
	<Node classDefinition="true" definitionName="cmc/foundation/ModelObject">
		<dependency localName="ServiceTransactionUtil" moduleName="cmc/foundation/ServiceTransactionUtil"/>
		<dependency localName="XMLUtil" moduleName="cmc/foundation/XMLUtil"/>
		<dependency localName="CallbackUtil" moduleName="cmc/foundation/CallbackUtil"/>
		<dependency localName="StringUtil" moduleName="cmc/foundation/StringUtil"/>
		<dependency localName="EventHandler" moduleName="cmc/foundation/EventHandler"/>
		<dependency localName="Timer" moduleName="cmc/foundation/Timer"/>
		<dependency localName="EventUtil" moduleName="cmc/foundation/EventUtil"/>
		<dependency localName="Logger" moduleName="cmc/shell/Logger"/>
		<dependency localName="MessageLogger" moduleName="cmc/shell/MessageLogger"/>
		<dependency localName="foundationResources" moduleName="cmc/foundation/FoundationResources"/>
		<dependency localName="ModelUtil" moduleName="cmc/foundation/ModelUtil"/>
		<dependency localName="ContextUtil" moduleName="cmc/foundation/ContextUtil"/>
		<dependency localName="ModelObjectList" moduleName="cmc/foundation/ModelObjectList"/>
		<!---
			@keywords private
			Reference to the parent model that manages this model object
			@see cmc/foundation/Model
		-->
		<variable name="model" value="${null}"/>
		
		<!---
			Reference to definition of this model object.
			@see cmc/foundation/ObjectDefinition
			@type cmc/foundation/ObjectDefinition
		-->
		<variable name="objectDefinition" value="${null}"/>
		
		<!---
			The type of this object. This is a read-only attribute. It is populated with the value from this
			object's {@link cmc/foundation/ObjectDefinition objectDefinition}.
		 -->
		<variable name="objectType" type="string" value=""/>
		
		<!---
			@keywords private
			Unique identifier of this model object among objects with the same
			object type or under the same parent object.
		-->
		<variable name="objectId" type="string" value=""/>
		
		<!---
			@keywords private
			The current template type of this model object.
		-->
		<variable name="templateType" type="string" value=""/>
		
		<!---
			@keywords private
			Unique identifier of the version of this model object.
		-->
		<variable name="objectVersionId" type="string" value=""/>
		
		<!---
			@keywords private
			Object key used in object maps. It must be unique in the scope where
			an object map is used. For example, all the child objects under the
			same parent object must have unique keys. If some child objects are
			also available globally in the model, they must have unique keys in
			the model.
		-->
		<variable name="objectKey" type="string" value=""/>
		
		<!---
			@keywords private
			Object display name.
		-->
		<variable name="objectDisplayName" value="${null}"/>

		<!---
			@keywords private
			Object display name in lower case
		-->
		<variable name="lowerCaseDisplayName" value="${null}"/>
		
		<!---
			@keywords private
			Object long display name, this is defined by the <code>longObjectDisplayNameProperty</code>
			in the object's {@link cmc/foundation/ObjectDefinition}
		-->		
		<variable name="objectLongDisplayName" value="${null}"/>
		
		<!---
			@keywords private
			Object's Read Only State, if explicitly set
		-->
		<variable name="objectReadOnly" value="${null}"/>
		
		<!---
			@keywords private
			Object's Deletable State, if explicitly set
		-->
		<variable name="objectDeletable" value="${null}"/>
		
		<!---
			@keywords private
			Open group's Read Only State. This flag is set to "true" if the group doesn't have any
			editable properties and doesn't contain any objects that are read only.
		-->
		<variable name="openGroupReadOnly" type="boolean" value="false"/>
		
		<!---
			@keywords private
			Open group's Partially Editable State. This flag is set to true if the object has some but not all
			editable properties.
		-->	
		<variable name="openGroupPartiallyEditable" type="boolean" value="false"/>
		

		<!--- Object's Read Only State, either explicitly set or inherited.-->
		<variable name="readOnly" type="boolean" value="false"/>
		
		<!---
			@keywords private
			Array of model object lists that are tied to this object's children.
		-->
		<variable name="childModelObjectLists" value="${[]}"/>
		
		<!---
			@keywords private
			Array of objects that describe the binding between this object
			and a model object list that contains a list of objects that
			reference this object. The binding objects contain the following properties:
			- list: the model object list instance
			- paths: an array of arrays of reference object definitions
			- intermediateObjects: an array of intermediate objects
		-->
		<variable name="referenceListBindings" value="${[]}"/>
		
		<!---
			@keywords private
			Indicate that user has access rights to the store
		 -->
		<variable name="hasAccessRight" type="boolean" value="true"/>
		
		<!---
			@keywords private
			An array of the get children services currently loading.
		-->
		<variable name="getChildrenServicesLoading" value="${[]}"/>
		
		<!---
			@keywords private
			An array of the get children services currently loaded.
		-->
		<variable name="getChildrenServicesLoaded" value="${[]}"/>
		
		<!---
			@keywords private
			An array of the get children services that failed the last time the load was requested.
		-->
		<variable name="getChildrenServicesFailed" value="${[]}"/>
		
		<!---
			@keywords private
			Indicates that the object's references are not up to date.
		-->
		<variable name="referencesStale" type="boolean" value="true"/>
		
		<!---
			@keywords private
			Indicates that the object's references are not up to date.
		-->
		<variable name="referencesLoaded" type="boolean" value="false"/>
		
		<!---
			@keywords private
			Indicates that the object's refresh service is currently loading.
		-->
		<variable name="refreshing" type="boolean" value="false"/>
		
		<!---
			Indicates that the object is waiting to be deleted. It will be deleted when the parent is saved.
		-->
		<variable name="pendingDelete" type="boolean" value="false"/>
		
		<!---
			@keywords private
			Indicates that the object is waiting to have its child object lists updated.
		-->
		<variable name="childObjectListsStale" type="boolean" value="false"/>
		
		<!---
			@keywords private
			Indicates that the object is waiting to have its reference lists updated.
		-->
		<variable name="referenceListsStale" type="boolean" value="false"/>
		
		<!---
			Parent object. Primary objects do not have a parent.
			@type cmc/foundation/ModelObject
		-->
		<variable name="parentObject" value="${null}"/>
		
		<!---
			@keywords private
			A map of this object's references. A key in this map must be an <code>objectKey</code>,
			and the value referred to by this key must be an model object that owns
			the same <code>objectKey</code>.
		-->
		<variable name="referenceMap" value="${{}}"/>
		
		<!---
			@keywords private
			An array of all of the model objects that reference this object.
		-->
		<variable name="references" value="${[]}"/>
		
		<!--- "true" if this is a new object that has never been saved. -->
		<variable name="newObject" type="boolean" value="false"/>
		
		<!--- "true" if the new object was created implicitly. -->
		<variable name="implicitNewObject" type="boolean" value="false"/>

		<!--- "true" if this object is a test object. -->
		<variable name="testObject" type="boolean" value="false"/>
				
		<!--- "true" if this object is new or being edited. -->
		<variable name="open" type="boolean"/>
		
		<!--- "true" if this object is opened in Compare View. -->
		<variable name="isOpenInCompareView" type="boolean" value="false"/>
		
		<!---
			@keywords private
			A map of this object's children. The key of this map is a {@link cmc/foundation/ModelObject#objectKey},
			and the value referred to by this key must be a model object instance that owns this
			<code>objectKey</code>.
		-->
		<variable name="childObjectMap" value="${{}}"/>
		<!---
			@keywords private
			An array of child object keys that are ordered based on when they were assigned. The most recently assigned
			child object keys will be at the end of the list.
		-->
		<variable name="orderedChildObjectKeys" value="${[]}"/>
		
		<!---
			@keywords private
			An array of this object's children. Each element in this array has to be a model object.
			This list is not always synchronized to <code>childObjectMap</code>. If the most current
			list of child objects need to be retrieved, use {@link cmc/foundation/ModelObject#childObjectMap}.
		-->
		<variable name="childObjects" value="${[]}"/>
		
		<!---
			@keywords private
			A map of this object's properties.
		-->
		<variable name="propertyMap" value="${{}}"/>
		
		<!---
			The top object for the open group to which this object belongs.
			@type cmc/foundation/ModelObject
		-->
		<variable name="openGroupObject" value="${null}"/>
		
		<!--- "true" if the object has validation errors. This attribute is only set for the open group object. -->
		<variable name="errorInOpenGroup" type="boolean" value="false"/>
		
		<!---
			The first object error found in the open group.
			@type String
		-->
		<variable name="openGroupError" value="${null}"/>
		
		<!---
			@keywords private
			An array of client validation errors. Client validation errors are stored as objects that contain two properties:
			"message" and "validator".
		-->
		<variable name="clientErrors" value="${[]}"/>

		<!---
			@keywords private
			An array of server validation errors. Server validation errors are stored as strings.
		-->
		<variable name="serverErrors" value="${[]}"/>
		
		<!---
			"true" if the open group has at least one unsaved change. False otherwise. This attribute
			is guaranteed to be set only when this object is its open group object.
		 -->
		<variable name="openGroupDirty" type="boolean" value="false"/>
		
		<!---
			@keywords private
			The service transaction object associated with this object. A transaction
			object will be created for service requests that are persisting the current
			state of this model object. If this value is null, it indicates that there
			is no active transaction request.
		-->
		<variable name="transaction" value="${null}"/>
		
		<!---
			@keywords private
			The array of pending transaction objects associated with this object. Only
			one transaction service request is active at a time.
		-->
		<variable name="pendingTransactions" value="${[]}"/>
		
		<!---
			@keywords private
			Indicates that there is an active transaction that is creating this object.
		-->
		<variable name="creating" type="boolean" value="false"/>
		
		<!---
			@keywords private
			Indicates that there is an active transaction that is deleting this object.
		-->
		<variable name="deleting" type="boolean" value="false"/>
		
		<!---
			@keywords private
			A non-zero value indicates that this object is locked. Updates will not be trigged until the
			object is unlocked.
		-->
		<variable name="lockCount" type="number" value="0"/>
		
		<!---
			@keywords private
			A non-zero value keeps track of the number of references are made to this object.
		-->
		<variable name="referenceCount" type="number" value="0"/>
		
		<!---
			@keywords private
			A non-zero value indicates that this object has child in open state.
		-->
		<variable name="openChildCount" type="number" value="0"/>
		
		<!---
			@keywords private
			"true" if this object is an open group object and its init() method is completed.
			False otherwise.
		 -->
		<variable name="openGroupInitiated" type="boolean" value="false"/>
		
		<!---
			@keywords private
			The state of the views that are bound to this model object.
		-->
		<variable name="viewState" type="string" value=""/>

		<!---
			@keywords private
			An instance of {@link cmc/foundation/DisplayNameStyle} that the framework will use to display the display name of this
			business object. If this value is null, then the default display name style will
			be used.
		-->
		<variable name="displayNameStyle" value="${null}"/>
		
		<!---
			@keywords private
			Array of status objects indicating the state of loading get children services. Each entry in the array is
			an object with the following properties:
			service - the cmc/foundation/GetChildrenService instance associated with this status object
			message - the status message that will be displayed to the user
			messageForTree - the status message that will be displayed to the user (on browse object tree)
			hasError - indicates that the status message is an error
			startIndex - the start index of the current page
			totalRecords - recordSetTotal returned from service.
			currPageNum - the current page number.
			lastPageNum - the last page number.
			deleteCount - number of records deleted.
			serviceObjectList - the list of objects returned from the service.
		-->
		<variable name="loadChildrenStatusObjects" type="string" value="${[]}"/>
		
		<!---
			@keywords private
			Array of status objects indicating the state of loading get references services. Each entry in the array is
			an object with the following properties:
			service - the cmc/foundation/GetReferencesService instance associated with this status object
			message - the status message that will be displayed to the user
			hasError - indicates that the status message is an error
		-->
		<variable name="loadReferencesStatusObjects" type="string" value="${[]}"/>
		
		<!---
			@keywords private
			Raw data property map. This is an internal data structure that stores property values of this model object when
			it is first loaded. This data will not be refreshed until the model object is reloaded. It is read only and should
			never be updated by other classes. It is used for lazy initialization of property values.
		-->
		<variable name="rawDataPropertyMap" value="${{}}"/>
		
		<!---
			@keywords private
			Indicates that validation messages have been reported to the message logger. Messages are only logged
			in the message logger if the object is open.
		-->
		<variable name="messagesLogged" type="boolean" value="false"/>
		
		<!---
			An array of the views this object is shown with
			@keywords private
		-->
		<variable name="objectViews" value="${[]}"/>
		
		<!---
			"true" if we should force the parsed data
			@keywords private
		-->
		<variable name="forceParseData" type="boolean" value="false"/>
		
		<!---
			Map for tracking whether a request for loading children for a given languageId have been sent.
			Key is languageId and value is an array of cmc/foundation/GetChildrenService instances for which the languageId
			has been requested.
			@keywords private
		-->
		<variable name="loadChildrenLanguageMap" value="${{}}"/>

		<!---
			An array of XML objects whose parsing is deferred by the framework because their parent
			objects have not been parsed as of yet.
			@keywords private
		-->
		<variable name="deferredElements" value="${[]}"/>		
		
		<!---
			@keywords private
			Unique identifier of the store that this model object belongs to.
		-->
		<variable name="objectStoreId" type="string" value=""/>
		
		<!---
			@keywords private
			Object's Modifiable State in change control metadata, if explicitely set
		-->
		<variable name="changeControlModifiable" value="${null}"/>
		
		<!--- This event is triggered if the object is being destroyed. -->
		
		
		<!--- @keywords private
		
			  The file reference object, for internal use. This is an ActionScript object that is available as of swf8.
			  This attribute has a default value of null. If the object definition for this object has
			  {@link cmc/foundation/ObjectDefinition#isFileObject} set to "true", then file upload widgets such as {@link cmc/foundation/PropertyFileUploader}
			  will create the FileReference object for the model object to support the file upload.
		-->
		<variable name="fileref" value="${null}"/>
		
		<!---  Object is being saved. This event will be triggered before any change is actually saved -->
		
		
		<!--- @keywords private
		
			  Indicates that this model object is moveable
		-->
		<variable name="moveable" type="boolean" value="true"/>
		
		<!--- @keywords private
		
			  Indicates that this model object has been explicitly opened and viewed in its properties view.
		-->
		<variable name="viewed" type="boolean" value="false"/>
		
		<!--- @keywords private
		
			  The number of milliseconds since the last time this model object has been explicitly opened and
			  viewed in its properties view.
		-->
		<variable name="lastViewedTime" type="number" value="0"/>
		<!--- @keywords private
			The number of calls to be made to the method updateChildObjectLists.
		-->
		<variable name="updateChildObjectListsCallbackCount" type="number" value="0"/>
		<!--- @keywords private
			The number of calls to be made to the method updateReferencesLists.
		-->
		<variable name="updateReferencesListsCallbackCount" type="number" value="0"/>
		<!---
			@keywords private
			Indicates that a deferred callback has been added for the update log messages callback.
		-->
		<variable name="updateLogMessagesCallbackAdded" type="boolean" value="false"/>
		
		<!--- @keywords private
			  The number of milliseconds since the last time this model object has been changed.
		-->
		<variable name="changeToDirtyTime" type="number" value="0"/>
		
		<!---
			@keywords private
			Indicates that this object has releasable children. This attribute is set to true when
			an object is opened before all of the children services are loaded.
		-->
		<variable name="hasReleasableChildren" type="boolean" value="false"/>
		<!---
			@keywords private
			The initialization identifier associated with the model this object was created with.  This is
			only set for objects that are put into the object map.
		-->
		<variable name="modelInitializationIdentifier" type="number" value="0"/>
		<!---
			@keywords private
			Array of unparsed object elements.
		-->
		<variable name="unparsedObjects" value="${null}"/>
		<!---
			@keywords private
			The default language child object for this object.
		-->
		<variable name="defaultLanguageObject" value="${null}"/>
		<!---
			@keywords private
			The parent primary object for this object. This will be set for non-primary objects.
		-->
		<variable name="parentPrimaryObject" value="${null}"/>	
		<!---
			@keywords private
			The post save transaction object associated with this object. One post save transaction
			object will be created for each create and update request for the open group object.
			If this value is null, it indicates that there is no active post save transaction request.
		-->
		<variable name="postSaveTransaction" value="${null}"/>	
		<!---
			@keywords private
			This flag is set to true when a call to the {@link cmc/foundation/PostSaveService#post save service} fails. When true, the {@link cmc/foundation/PostSaveService#post save service}
			needs to be called the next time the object is saved even if no changes have been made to the object.
		-->
		<variable name="postSaveFailed" value="false"/>	
		<!---
			@keywords private
			This attribute is used to cache the referenced object of this object.
		-->
		<variable name="referencedObject" value="${null}"/>

		<!---
			@keywords private
			This attribute contains an instance of the context class that is used within the scope of this object.
		-->
		<variable name="localContext"/>

		<!---  @keywords private -->
		<method name="init">
			<![CDATA[
			this.inherited(arguments);
			this.updateChildObjectListsDel = new EventHandler.Class(this, "updateChildObjectLists");
			this.updateReferencesListsDel = new EventHandler.Class(this, "updateReferencesLists");
			this.updateFilteredChildObjectsDel = new EventHandler.Class(this, "updateFilteredChildObjects");
			this.updateReadOnlyDel = new EventHandler.Class(this, "updateReadOnly");
			this.updateDisplayNameDel = new EventHandler.Class(this, "updateDisplayName");
			this.updateLongDisplayNameDel = new EventHandler.Class(this, "updateLongDisplayName");
			this.updateTemplateTypeDel = new EventHandler.Class(this, "updateTemplateType");
			this.onLanguageChangeDel = new EventHandler.Class(this, "checkLanguageSensitiveObject");
			this.checkOpenGroupReadOnlyDel = new EventHandler.Class(this, "checkOpenGroupReadOnly");
			this.updateLogMessagesCallbackDel = new EventHandler.Class(this, "updateLogMessagesCallback");
			this.setDefaultPropertyValuesDel = new EventHandler.Class(this, "setDefaultPropertyValues");
			this.updateDisplayNameStyleDel = new EventHandler.Class(this, "updateDisplayNameStyle");
			this.checkLoadedChildrenDel = new EventHandler.Class(this, "checkLoadedChildren");
			this.loadLanguageSensitiveChildrenDel = new EventHandler.Class(this, "loadLanguageSensitiveChildren");
			]]>
		</method>
		
		<!---
			@keywords private
			@param Object args An object whose properties will be copied to this model object.
		-->
		<method args="args" name="initializeObject">
			<![CDATA[
			this.referenceCount = 0;
			for (var key in args) {
				this[key] = args[key];
			}
			this.parent = this.model;
			if (this.model.oEditor.localContext != null && typeof (this.localContext) == "undefined") {
				this.localContext = this.model.oEditor.localContext;
			}
			this.setVariable("open", false);
			if (typeof (this.objectReadOnly) == "undefined") {
				this.objectReadOnly = null;
			}
			this.initOpenGroupObject();
			if (this.newObject) {
				var storeConfig = (this.localContext ? this.localContext.storeConfig : null);
				if (this.objectDefinition.initializeObjectStoreId && (storeConfig != null)) {
					var prop = this.propertyMap.objectStoreId;
					if (prop) {
						prop.setVariable("value", storeConfig.storeId);
					}
					else {
						var rawData = this.rawDataPropertyMap.objectStoreId;
						if (!rawData) {
							rawData = {};
							this.rawDataPropertyMap.objectStoreId = rawData;
						}
						rawData.propertyValue = storeConfig.storeId;
						rawData.propertyReadOnly = false;
						rawData.trimmed = false;
					}
					this.parseObjectStoreId();
				}
				this.setDefaultPropertyValues();
				var e = this.objectDefinition.getTemplate();
				if (e) {
					this.parseDataElement(e);
				}
				if (this.openGroupObject != null && !this.implicitNewObject) {
					this.openGroupObject.setVariable("open", true);
					this.openGroupObject.checkUnsavedChanges(true);
				}
				else if (this.objectDefinition.organizational) {
					this.newObject = false;
				}
			}
			else {
				this.setDefaultPropertyValues();
				var e = this.objectDefinition.getTemplate();
				if (e) {
					this.parseProperties(e);
				}
			}
			this.updateDisplayName();
			this.updateLongDisplayName();
			this.updateTemplateType();
			this.updateDisplayNameStyle();
			if (this == this.openGroupObject) {
				this.openGroupInitiated = true;
			}
			this.checkOpenGroupReadOnly();
			this.updateRefreshTimer();
			if (this.objectDefinition.languageSensitive && this.implicitNewObject) {
				ContextUtil.Singleton.findContextValue(this, "inputLanguageIds", this.onLanguageChangeDel);
			}
			if (!this.testObject) {
				if (this.objectDefinition.organizational) {
					this.model.organizationalObjectMap[this.objectKey] = this;
				}
				this.assignToOrganizationalObjects();
			}
			if (Logger.Singleton.enabled) {
				Logger.Singleton.log("com.ibm.commerce.lobtools.foundation.model", "FINER", "cmc/foundation/ModelObject", "initializeObject", "objectType: " + this.objectType + "objectId: " + this.objectId);
			}
			]]>
		</method>
		
		<method name="assignToOrganizationalObjects">
			<![CDATA[
			if (!this.assignToOrganizationalObjectsDel) {
				this.assignToOrganizationalObjectsDel = new EventHandler.Class(this, "assignToOrganizationalObjects");
			}
			else {
				this.assignToOrganizationalObjectsDel.disconnectAll();
			}
			for (var i in this.model.organizationalObjectMap) {
				var orgDef = this.model.organizationalObjectMap[i].objectDefinition;
				var defs = orgDef.getOrganizedObjectDefinitions(this.assignToOrganizationalObjectsDel);
				if (defs != null && defs.indexOf(this.objectDefinition) != -1) {
					var add = true;
					if (!this.newObject) {
						var services = orgDef.getChildrenServices;
						if (services && services.length > 0) {
							for (var j = 0; j < services.length; j++) {
								if (services[j].matchesObjectDefinitions(orgDef, [this.objectDefinition]), true) {
									add = false;
									break;
								}
							}
						}
					}
					if (add) {
						this.model.organizationalObjectMap[i].addChild(this);
					}
				}
			}
			]]>
		</method>
		
		<!---
			@keywords private
			This method sets up the refresh timer if this object has an enabled refresh condition.
		-->
		<method args="e" name="updateRefreshTimer">
			<![CDATA[
			if (typeof(e) == "undefined") e = null;
			if (this.objectDefinition.refreshCondition) {
				if (this.updateRefreshTimerDel) {
					this.updateRefreshTimerDel.disconnectAll();
				}
				else {
					this.updateRefreshTimerDel = new EventHandler.Class(this, "updateRefreshTimer");
					this.refreshTimeoutDel = new EventHandler.Class(this, "refreshTimeout");
				}
				this.objectDefinition.refreshCondition.registerDelegate(this, this.updateRefreshTimerDel);
				if (this.objectDefinition.refreshCondition.isEnabled(this)) {
					Timer.resetTimer(this.refreshTimeoutDel, 1000 * this.objectDefinition.refreshInterval);
				}
				else {
					Timer.removeTimer(this.refreshTimeoutDel);
				}
			}
			]]>
		</method>	
		
		<!---
			@keywords private
		-->
		<method args="e" name="refreshTimeout">
			<![CDATA[
			if (typeof(e) == "undefined") e = null;
			if (this.objectDefinition.refreshService != null && !this.refreshing) {
				this.refreshing = true;
				this.objectDefinition.refreshService.doRequest(this);
			}
			Timer.resetTimer(this.refreshTimeoutDel, 1000 * this.objectDefinition.refreshInterval);
			]]>
		</method>
		
		<!---
			@keywords private
			This method updates the template type for the given template type property.
		-->
		<method args="e" name="updateTemplateType">
			<![CDATA[
			if (typeof(e) == "undefined") e = null;
			this.updateTemplateTypeDel.disconnectAll();
			if (this.objectDefinition.templateTypeProperty) {
				var templateTypeProperty = this.getProperty(this.objectDefinition.templateTypeProperty);
				this.updateTemplateTypeDel.connect(templateTypeProperty, "onvalue");
				if (this.templateType != templateTypeProperty.value) {
					if (this.templateType) {
						var objectTemplate = this.objectDefinition.objectTemplates[this.templateType];
						if (objectTemplate && objectTemplate.deleteObjectTypes != "") {
							var deleteObjectTypes = StringUtil.Singleton.splitAndTrim(objectTemplate.deleteObjectTypes, ",");
							for (var i = 0; i < deleteObjectTypes.length; i++) {
								var objectsToDelete = this.getObjects(deleteObjectTypes[i]);
								for (var j = 0; j < objectsToDelete.length; j++) {
									objectsToDelete[j].deleteObject();
								}
							}
						}
					}
					this.templateType = templateTypeProperty.value;
					if (templateTypeProperty.dirty) {
						var objectTemplate = this.objectDefinition.objectTemplates[this.templateType];
						if (objectTemplate) {
							this.parseDataElement(objectTemplate.getTemplate(), false, true);
						}
					}
				}
			}
			]]>
		</method>			
		
		<!---
			@keywords private
			@return "true" if this object is currently being viewed. False otherwise.
		-->
		<method name="isViewed">
			<![CDATA[
			return this.objectViews.length > 0;
			]]>
		</method>
		
		<!---
			@keywords private
			Registers a view that is currently being used to display this model object.
			@param cmc/foundation/Component objectView a view that displays this object
		-->
		<method args="objectView" name="registerObjectView">
			<![CDATA[
			if (this.objectDefinition != null) {
				var i = this.objectViews.indexOf(objectView);
				if (i < 0) {
					this.objectViews.push(objectView);
				}
				this.checkParsedData();
				if (this.objectDefinition.reference) {
					var ref = this.getReferencedObject();
					if (ref && ref != this) {
						ref.registerObjectView(objectView);
					}
				}
			}
			]]>
		</method>
		
		<!---
			@keywords private
			Removes an object view that displays this model object, if the given
			object view is already registered to this model object.
			@param cmc/foundation/Component objectView the view to be removed.
			@see cmc/foundation/ModelObject#registerObjectView
		-->
		<method args="objectView" name="unregisterObjectView">
			<![CDATA[
			if (this.objectDefinition != null) {
				var i = this.objectViews.indexOf(objectView);
				if (i >= 0) {
					this.objectViews.splice(i, 1);
				}
				if (this.objectDefinition.reference) {
					var ref = this.getReferencedObject();
					if (ref && ref != this) {
						ref.unregisterObjectView(objectView);
					}
				}
			}
			]]>
		</method>

		<!---
			@keywords private
			Checks if the data element associated with this model object is set. If it is set,
			the element will be parsed.
		-->
		<method name="checkParsedData">
			<![CDATA[
			if (this.unparsedObjects != null) {
				this.parseDataElement();
			}
			]]>
		</method>

		<!---
			Destroy this object. This method will send the "beingDestroyed" event on this object.
			@keywords private
		-->
		<method name="destroy">
			<![CDATA[
			if (Logger.Singleton.enabled) {
				Logger.Singleton.entering("com.ibm.commerce.lobtools.foundation.model", "cmc/foundation/ModelObject", "destroy");
			}
			this.release();
			Logger.Singleton.log("com.ibm.commerce.lobtools.foundation.model", "SEVERE", "cmc/foundation/ModelObject", "destroy", "Unexpected cmc/foundation/ModelObject destroy from " + arguments.caller.name);
			delete this.updateReadOnlyDel;
			delete this.updateDisplayNameDel;
			delete this.updateLongDisplayNameDel;
			delete this.updateChildObjectListsDel;
			delete this.updateReferencesListsDel;
			delete this.updateFilteredChildObjectsDel;
			delete this.updateTemplateTypeDel;
			delete this.onLanguageChangeDel;
			delete this.updateAccessRightDel;
			delete this.checkOpenGroupReadOnlyDel;
			delete this.updateLogMessagesCallbackDel;
			delete this.setDefaultPropertyValuesDel;
			delete this.updateDisplayNameStyleDel;
			delete this.checkLoadedChildrenDel;
			delete this.updateRefreshTimerDel;
			delete this.refreshTimeoutDel;
			delete this.loadLanguageSensitiveChildrenDel;
			if (this.assignToOrganizationalObjectsDel) {
				delete this.assignToOrganizationalObjectsDel;
			}
			if (this.initOpenGroupObjectDel) {
				delete this.initOpenGroupObjectDel;
			}
			if (typeof (this.checkErrorsCallbackDel) != "undefined") {
				delete this.checkErrorsCallbackDel;
				this.checkErrorsCallbackCount = 0;
			}
			this.inherited(arguments);
			if (Logger.Singleton.enabled) {
				Logger.Singleton.exiting("com.ibm.commerce.lobtools.foundation.model", "cmc/foundation/ModelObject", "destroy");
			}
			]]>
		</method>
		
		<!---
			Releases this object. This method will send the "beingDestroyed" event on this object.
			@event beingDestroyed
			@keywords private
		-->
		<method name="release">
			<![CDATA[
			if (Logger.Singleton.enabled) {
				Logger.Singleton.entering("com.ibm.commerce.lobtools.foundation.model", "cmc/foundation/ModelObject", "release");
			}
			this.releasing = true;
			EventUtil.trigger(this, "beingDestroyed", this);
			if (this.newObject && this.objectDefinition.reference) {
				var referencedObject = this.getReferencedObject();
				if (!referencedObject.releasing && referencedObject.open && referencedObject.newObject && !referencedObject.viewed) {
					var deleteReferencedObject = true;
					for (var refKey in referencedObject.referenceMap) {
						var ref = referencedObject.referenceMap[refKey];
						if (!ref.objectDefinition.organizational && ref != this) {
							deleteReferencedObject = false;
							break;
						}
					}
					if (deleteReferencedObject) {
						this.removeChild(referencedObject);
						referencedObject.deleteObject(false);
					}
				}
			}
			if (this.parseUnparsedObjectsDel) {
				this.parseUnparsedObjectsDel.disconnectAll();
			}
			this.updateFilteredChildObjectsDel.disconnectAll();
			this.checkLoadedChildrenDel.disconnectAll();
			for (var key in this.referenceMap) {
				var o = this.referenceMap[key];
				if (o.getReferencedObject() == this) {
					var referenceOpenGroupObject = o.openGroupObject;
					var dirty = o.hasUnsavedChanges();
					ModelUtil.Singleton.releaseModelObject(o);
					if (dirty && referenceOpenGroupObject != null && referenceOpenGroupObject != this) {
						referenceOpenGroupObject.checkUnsavedChanges();
					}
				}
				else {
					o.removeChild(this);
				}
			}
			for (var i = 0; i < this.orderedChildObjectKeys.length; i++) {
				var key = this.orderedChildObjectKeys[i];
				var o = this.childObjectMap[key];
				if (typeof (o) != "undefined") {
					if (o.parentObject == this) {
						o.parentObject = null;
						ModelUtil.Singleton.releaseModelObject(o);
					}
					else {
						o.removeReference(this);
					}
				}
			}
			this.discardPendingTransactions();
			if (this.open) {
				this.setVariable("open", false);
			}
			if (this.updateLogMessagesCallbackAdded) {
				CallbackUtil.Singleton.cancelCallback(this.updateLogMessagesCallbackDel);
				this.updateLogMessagesCallbackAdded = false;
			}
			this.clearLogMessages();
			if (this.objectDefinition.primary || this.objectDefinition.organizational) {
				if (this.model.objectMap[this.objectKey] == this) {
					delete this.model.objectMap[this.objectKey];
				}
			}
			if (this.objectDefinition.organizational) {
				if (this.model.organizationalObjectMap[this.objectKey] == this) {
					delete this.model.organizationalObjectMap[this.objectKey];
				}
			}
			if (this.parentObject) {
				this.parentObject.removeChild(this);
			}
			if (this.updateChildObjectListsCallbackCount > 0) {
				CallbackUtil.Singleton.cancelCallback(this.updateChildObjectListsDel);
			}
			if (this.updateReferencesListsCallbackCount > 0) {
				CallbackUtil.Singleton.cancelCallback(this.updateReferencesListsDel);
			}
			if (typeof (this.checkErrorsCallbackDel) != "undefined" && this.checkErrorsCallbackCount > 0) {
				CallbackUtil.Singleton.cancelCallback(this.checkErrorsCallbackDel);
				this.checkErrorsCallbackCount = 0;
			}
			var releaseProperties = [];
			for (var key in this.propertyMap) {
				releaseProperties.push(this.propertyMap[key]);
			}
			for (var i = 0; i < releaseProperties.length; i++) {
				ModelUtil.Singleton.releaseModelProperty(releaseProperties[i]);
			}
			while (this.childModelObjectLists.length > 0) {
				this.releaseViewFromChildren(this.childModelObjectLists[0].v);
			}
			while (this.referenceListBindings.length > 0) {
				this.releaseViewFromReferences(this.referenceListBindings[0].list.v);
			}
			this.updateReadOnlyDel.disconnectAll();
			this.updateDisplayNameDel.disconnectAll();
			this.updateLongDisplayNameDel.disconnectAll();
			this.updateTemplateTypeDel.disconnectAll();
			this.onLanguageChangeDel.disconnectAll();
			if (this.updateAccessRightDel) {
				this.updateAccessRightDel.disconnectAll();
			}
			this.checkOpenGroupReadOnlyDel.disconnectAll();
			this.setDefaultPropertyValuesDel.disconnectAll();
			this.updateDisplayNameStyleDel.disconnectAll();
			if (this.updateRefreshTimerDel) {
				this.updateRefreshTimerDel.disconnectAll();
				Timer.removeTimer(this.refreshTimeoutDel);
			}
			this.loadLanguageSensitiveChildrenDel.disconnectAll();
			if (this.openGroupObject && this.openGroupObject.messagesLogged) {
				MessageLogger.Singleton.clearModelObjectMessages(this);
			}
			if (this.assignToOrganizationalObjectsDel) {
				this.assignToOrganizationalObjectsDel.disconnectAll();
			}
			if (this.initOpenGroupObjectDel) {
				this.initOpenGroupObjectDel.disconnectAll();
			}
			this.model = null;
			this.objectDefinition = null;
			this.objectType = "";
			this.objectId = "";
			this.objectVersionId = "";
			this.objectKey = "";
			this.objectDisplayName = null;
			this.lowerCaseDisplayname = null;
			this.objectLongDisplayName = null;
			this.displayNameStyle = null;
			this.objectReadOnly = null;
			this.objectDeletable = null;
			this.readOnly = false;
			this.openGroupReadOnly = false;
			this.childModelObjectLists = [];
			this.referenceListBindings = [];
			this.getChildrenServicesLoading = [];
			this.getChildrenServicesLoaded = [];
			this.getChildrenServicesFailed = [];
			this.referencesStale = true;
			this.referencesLoaded = false;
			this.pendingDelete = false;
			this.childObjectListsStale = false;
			this.referenceListsStale = false;
			this.parentObject = null;
			this.referenceMap = {};
			this.references = [];
			this.newObject = false;
			this.implicitNewObject = false;
			this.open = false;
			this.isOpenInCompareView = false;
			this.childObjectMap = {};
			this.orderedChildObjectKeys = [];
			this.childObjects = [];
			this.propertyMap = {};
			this.templateObject = null;
			this.openGroupObject = null;
			this.errorInOpenGroup = false;
			this.openGroupError = null;
			this.clientErrors = [];
			this.serverErrors = [];
			this.openGroupDirty = false;
			this.changeToDirtyTime = 0;
			this.transaction = null;
			this.pendingTransactions = [];
			this.creating = false;
			this.deleting = false;
			this.lockCount = 0;
			this.referenceCount = 0;
			this.openChildCount = 0;
			this.openGroupInitiated = false;
			this.viewState = "";
			this.loadChildrenStatusObjects = [];
			this.loadReferencesStatusObjects = [];
			this.rawDataPropertyMap = {};
			this.messagesLogged = false;
			this.loadChildrenLanguageMap = {};
			this.objectViews = [];
			this.forceParseData = false;
			this.deferredElements = [];
			this.templateType = "";
			this.objectStoreId = "";
			this.changeControlModifiable = null;
			this.fileref = null;
			this.testObject = false;
			this.viewed = false;
			this.lastViewedTime = 0;
			this.moveable = true;
			this.refreshing = false;
			this.hasAccessRight = true;
			this.openGroupPartiallyEditable = false;
			this.updateChildObjectListsCallbackCount = 0;
			this.updateReferencesListsCallbackCount = 0;
			this.hasReleasableChildren = false;
			this.modelInitializationIdentifier = 0;
			this.unparsedObjects = null;
			this.defaultLanguageObject = null;
			this.parentPrimaryObject = null;
			this.postSaveFailed = false;
			this.postSaveTransaction = null;
			this.releasing = false;
			this.referencedObject = null;
			this.localContext = undefined;
			if (Logger.Singleton.enabled) {
				Logger.Singleton.exiting("com.ibm.commerce.lobtools.foundation.model", "cmc/foundation/ModelObject", "release");
			}
			]]>
		</method>
		
		<!---
			@keywords private
			
			Validates this object and optionally the properties in this object.
			@param validateProperties "true" if the properties of this object should be validated. False otherwise.
		-->
		<method args="validateProperties" name="validate">
			<![CDATA[
			if (typeof(validateProperties) == "undefined") validateProperties = true;
			if (!this.testObject && this.openGroupObject != null && !this.openGroupObject.refreshing && !cmcConfig.noValidation) {
				if (!this.objectDefinition.primary || (this.isGetChildrenServicesLoaded(this.objectDefinition.getOpenGroupObjectDefinitions()) && this.referencesLoaded)) {
					var validators = this.objectDefinition.validators;
					for (var i = 0; i < validators.length; i++) {
						validators[i].validate(this);
					}
				}
				if (validateProperties && this.objectDefinition.propertyDefinitions) {
					for (var key in this.objectDefinition.propertyDefinitions) {
						var pDef = this.objectDefinition.getPropertyDefinition(this, key);
						if (pDef && pDef.validators.length > 0) {
							var prop = this.propertyMap[pDef.propertyName];
							if (prop) {
								prop.validate(false);
							}
							else if (!pDef.checkPropertyValue(this, this.getPropertyValue(pDef.propertyName))) {
								this.getProperty(pDef.propertyName).validate(false);
							}
						}
					}
				}
			}
			]]>
		</method>

		<!---
			@keywords private
			Returns "true" if this object is the top object of an open group.
			@return boolean "true" if this object is the open group object.
		 -->
		<method name="isOpenGroupObject">
			<![CDATA[
			return this == this.openGroupObject;
			]]>
		</method>
				
		<!---
			@keywords private
			Add this object's validation errors to the message logger. This method will be called recursively for
			all the object's in the open group.
		-->
		<method name="addLogMessages">
			<![CDATA[
			if (!this.messagesLogged) {
				this.messagesLogged = true;
				this.validate(true);
				this.addPropertyLogMessages();
				var isVersionObject = this.getIsVersionObject();
				for (var key in this.childObjectMap) {
					var o = this.childObjectMap[key];
					if (o.parentObject == this && o.openGroupObject == this.openGroupObject && (isVersionObject || !o.getIsVersionObject())) {
						o.addLogMessages();
					}
				}
				for (var key in this.referenceMap) {
					var o = this.referenceMap[key];
					var oDef = o.objectDefinition;
					if ((oDef.parentReference || oDef.collectionReference) && o.openGroupObject == this.openGroupObject && (isVersionObject || !o.getIsVersionObject())) {
						o.addPropertyLogMessages();
					}
				}
			}
			]]>
		</method>
		
		<!---
			@keywords private
			Adds this object's property validation errors to the message logger.
		-->
		<method name="addPropertyLogMessages">
			<![CDATA[
			for (var i = 0; i < this.serverErrors.length; i++) {
				MessageLogger.Singleton.logValidationError(this.serverErrors[i], this, null, null);
			}
			for (var i = 0; i < this.clientErrors.length; i++) {
				var error = this.clientErrors[i];
				MessageLogger.Singleton.logValidationError(error.message, this, null, error.validator);
			}
			for (var key in this.propertyMap) {
				var property = this.propertyMap[key];
				if (property.serverErrors.length > 0) {
					for (var i = 0; i < property.serverErrors.length; i++) {
						MessageLogger.Singleton.logValidationError(property.serverErrors[i], this, property, null);
					}
				}
				else {
					for (var i = 0; i < property.clientErrors.length; i++) {
						var error = property.clientErrors[i];
						MessageLogger.Singleton.logValidationError(error.message, this, property, error.validator);
					}
				}
			}
			]]>
		</method>
		
		<!---
			@keywords private
			Clears this object's messages from the message logger.
		-->		
		<method name="clearLogMessages">
			<![CDATA[
			if (this.messagesLogged) {
				this.messagesLogged = false;
				this.clearServiceErrors();
				MessageLogger.Singleton.clearModelObjectMessages(this);
				var isVersionObject = this.getIsVersionObject();
				for (var key in this.childObjectMap) {
					var o = this.childObjectMap[key];
					if (o.parentObject == this && o.openGroupObject == this.openGroupObject && (isVersionObject || !o.getIsVersionObject())) {
						o.clearLogMessages();
					}
				}
				for (var key in this.referenceMap) {
					var o = this.referenceMap[key];
					var oDef = o.objectDefinition;
					if ((oDef.parentReference || oDef.collectionReference) && o.openGroupObject == this.openGroupObject && (isVersionObject || !o.getIsVersionObject())) {
						o.clearServiceErrors();
						MessageLogger.Singleton.clearModelObjectMessages(o);
					}
				}
			}
			]]>
		</method>
		
		<!---
			@keywords private
			Add a deferred callback to update the log messages.
		 -->
		<method name="updateLogMessages">
			<![CDATA[
			if (!this.updateLogMessagesCallbackAdded) {
				this.updateLogMessagesCallbackAdded = true;
				CallbackUtil.Singleton.addDeferredCallback(this.updateLogMessagesCallbackDel, null, CallbackUtil.Singleton.PRIORITY_FOREGROUND);
			}
			]]>
		</method>
		
		<!---
			@keywords private
			Updates the message logger. If the object is open, then validation errors associated with this object are added to
			the message logger. If the object is closed, then validation errors removed from the model object and service
			errors are cleared.
		 -->
		<method args="e" name="updateLogMessagesCallback">
			<![CDATA[
			if (typeof(e) == "undefined") e = null;
			this.updateLogMessagesCallbackAdded = false;
			this.clearLogMessages();
			if (this.openGroupObject != null && this.openGroupObject.open && !this.refreshing) {
				this.addLogMessages();
			}
			]]>
		</method>
		
		<!---
			Registers a validation error for the specified validator. Each
			validator can register only one error message. A "null" value for the
			validator indicates that the message has been reported by a service.
			There is no limit to the number of service errors.
			
			@param cmc/foundation/Validator validator validator that generates the given error message
			@param string errorMsg the error message of the validation error to be registered
			@event onvalidationErrors if the error is added and the event onvalidationErrors exists
		-->
		<method args="validator, errorMsg" name="addValidationError">
			<![CDATA[
			var update = false;
			var error = null;
			if (validator != null) {
				for (var i = 0; i < this.clientErrors.length; i++) {
					if (this.clientErrors[i].validator == validator) {
						error = this.clientErrors[i];
						if (error.message != errorMsg) {
							error.message = errorMsg;
							update = true;
						}
						break;
					}
				}
				if (error == null) {
					error = {
						message: errorMsg,
						validator: validator
					};
					this.clientErrors.push(error);
					update = true;
				}
			}
			else {
				this.serverErrors.push(errorMsg);
				update = true;
			}
			if (update) {
				if (this.openGroupObject) {
					this.checkErrors();
					if (this.openGroupObject.messagesLogged) {
						MessageLogger.Singleton.logValidationError(errorMsg, this, null, validator);
					}
				}
				EventUtil.trigger(this, "onvalidationErrors");
			}
			]]>
		</method>
		
		<!---
			Returns an array of the validation errors in this object.
			@return String[] an array of all validation errors in this node. An empty array if
				no validation errors.
		-->
		<method name="getValidationErrors">
			<![CDATA[
			var errors = [];
			for (var i = 0; i < this.serverErrors.length; i++) {
				errors.push(this.serverErrors[i]);
			}
			for (var i = 0; i < this.clientErrors.length; i++) {
				var error = this.clientErrors[i];
				errors.push(error.message);
			}
			return errors;
			]]>
		</method>
		
		<!---
			Finds all the validation errors that are created by the validators with the given validator type
			in this model object.
			@param String[] a list of validator types. Each validator type is a string. See {@link cmc/foundation/Validator#validatorType}
				for description of validator types.
			@return String[] A list of validation errors that are created by the validators with the given validator types. Empty
				array if none is found. Each validation error describes what this error is, and is NL-enabled.
		 -->
		<method args="validatorTypes" name="getValidationErrorsByValidatorTypes">
			<![CDATA[
			if (typeof (validatorTypes) == "undefined" || validatorTypes == null) {
				return [];
			}
			var result = [];
			for (var i = 0; i < this.clientErrors.length; ++i) {
				var error = this.clientErrors[i];
				var validator = error.validator;
				if (validator.validatorType) {
					for (var j = 0; j < validatorTypes.length; ++j) {
						if (validator.validatorType == validatorTypes[j]) {
							result.push(error.message);
						}
					}
				}
			}
			return result;
			]]>
		</method>
		
		<!---
			@keywords private
			Returns "true" if this object has any validation error.
			@param boolean ignoreServiceErrors if "true", ignore errors reported by service requests
			@return boolean "true" if there are validation errors
		-->
		<method args="ignoreServiceErrors" name="hasValidationError">
			<![CDATA[
			var hasError = false;
			if (ignoreServiceErrors) {
				hasError = this.clientErrors.length > 0;
			}
			else {
				hasError = this.clientErrors.length > 0 || this.serverErrors.length > 0;
			}
			return hasError;
			]]>
		</method>
		
		<!---
			Removes the validator error for the specified validator. The errors associated
			with the given validator in this object and in the message console will be
			cleared for the open group object of this object. The event onvalidationErrors
			will be sent out if this event exists.
			
			@param cmc/foundation/Validator validator The validator used to identify the validation errors to be removed.
			@event onvalidationError
		-->
		<method args="validator" name="clearValidationError">
			<![CDATA[
			var update = false;
			if (validator != null) {
				for (var i = 0; i < this.clientErrors.length; i++) {
					if (this.clientErrors[i].validator == validator) {
						update = true;
						this.clientErrors.splice(i, 1);
						i--;
					}
				}
			}
			else {
				if (this.serverErrors.length > 0) {
					this.serverErrors = [];
					update = true;
				}
			}
			if (update) {
				this.checkErrors();
				if (this.openGroupObject && this.openGroupObject.messagesLogged) {
					MessageLogger.Singleton.clearValidationError(this, null, validator);
				}
				EventUtil.trigger(this, "onvalidationErrors");
			}
			]]>
		</method>
		
		<!---
			@keywords private
			Clear service errors for this object.
		-->
		<method name="clearServiceErrors">
			<![CDATA[
			this.clearValidationError(null);
			for (var key in this.propertyMap) {
				var property = this.propertyMap[key];
				property.clearValidationError(null);
			}
			]]>
		</method>
	
		<!---
			@keywords private
			Check to see whether there are server errors for this object.
			@return boolean "true" if the object has server errors
		-->
		<method name="hasServiceErrors">
			<![CDATA[
			var propertyErrors = false;
			for (var key in this.propertyMap) {
				var property = this.propertyMap[key];
				if (property.serverErrors.length > 0 || property.clientErrors.length > 0) {
					propertyErrors = true;
					break;
				}
			}
			return propertyErrors || this.serverErrors.length > 0;
			]]>
		</method>
	
		<!---
			@keywords private
			Sets the top object for the open group to which this object belongs.
		-->
		<method name="initOpenGroupObject">
			<![CDATA[
			if (!this.initOpenGroupObjectDel) {
				this.initOpenGroupObjectDel = new EventHandler.Class(this, "initOpenGroupObject");
			}
			else {
				this.initOpenGroupObjectDel.disconnectAll();
			}
			if (this.openGroupObject == null) {
				var o = this;
				do {
					var oDef = o.objectDefinition;
					if (oDef.openGroupTop) {
						this.openGroupObject = o;
						for (var key in this.childObjectMap) {
							var childObject = this.childObjectMap[key];
							childObject.initOpenGroupObject();
						}
						this.checkOpenGroupPartiallyEditable();
						this.updateLogMessages();
						break;
					}
					if (oDef.getReferencedDefinitions(this.initOpenGroupObjectDel) != null && (oDef.parentReference || oDef.collectionReference)) {
						var i = 0;
						var referencedObject = null;
						while (!referencedObject && i < o.objectDefinition.getReferencedDefinitions(this.initOpenGroupObjectDel).length) {
							if (o.objectDefinition.getReferencedDefinitions()[i] != null) {
								referencedObject = o.getObject(o.objectDefinition.getReferencedDefinitions()[i].objectType);
							}
							i++;
						}
						o = referencedObject;
					}
					else {
						o = o.parentObject;
					}
				}
				while (o);
				this.updateAccessRight();
				this.updateReadOnly();
			}
			]]>
		</method>
		
		<!---
			@keywords private
			Bind the specified view to the children of this model object.
			@param cmc/foundation/Component v the view to be bound
			@param cmc/foundation/Filter filter an optional filter. If the given view doesn't have object list, this filter will be used to create a new
				object list.
			@param string objectTypes optional comma separated list of object types. These types are used to determine which objects should be bound.
			@param object sortComparator the sort comparator. This comparator is used to sort the objects in the newly created object list, if
				the given view doesn't have a object list yet.
		-->
		<method args="v, filter, objectTypes, sortComparator" name="bindViewToChildren">
			<![CDATA[
			if (typeof(filter) == "undefined") filter = null;
			if (typeof(objectTypes) == "undefined") objectTypes = null;
			if (typeof(sortComparator) == "undefined") sortComparator = null;
			if (Logger.Singleton.enabled) {
				Logger.Singleton.entering("com.ibm.commerce.lobtools.foundation.model", "cmc/foundation/ModelObject", "bindViewToChildren(v, filter, objectTypes)", [v, filter, objectTypes]);
			}
			var baseFilter = null;
			if (filter != null) {
				baseFilter = filter;
			}
			var objectSelectors = null;
			var objectDefinitions = null;
			if (objectTypes) {
				objectSelectors = this.model.getObjectSelectors(this, objectTypes);
			}
			this.referenceCount++;
			if (Logger.Singleton.enabled) {
				Logger.Singleton.log("com.ibm.commerce.lobtools.foundation.model", "FINER", "cmc/foundation/ModelObject", "bindViewToChildren(v, filter, objectTypes)", "Increment reference count for: Object key=" + this.objectKey + ", new reference count=" + this.referenceCount);
			}
			var list = v.oList;
			if (list) {
				list.setVariable("baseFilter", baseFilter);
				list.setVariable("objectSelectors", objectSelectors);
				list.setVariable("modelObjects", this.childObjects);
				list.setVariable("sortComparator", sortComparator);
			}
			else {
				list = new ModelObjectList.Class(v, {
					v: v,
					baseFilter: baseFilter,
					objectSelectors: objectSelectors,
					modelObjects: this.childObjects,
					sortComparator: sortComparator,
					pageController: this
				});
			}
			v.setVariable("parentO", this);
			this.childModelObjectLists.push(list);
			this.updateChildObjectListStatus(list);
			list.loadChildren();
			EventUtil.trigger(list, "onreset");
			if (Logger.Singleton.enabled) {
				Logger.Singleton.exiting("com.ibm.commerce.lobtools.foundation.model", "cmc/foundation/ModelObject", "bindViewToChildren(v, filter, objectTypes)");
			}
			]]>
		</method>

		<!---
			@keywords private
			Bind the specified view to the references to this model object.
			param view v: the view to be bound
			@param cmc/foundation/Filter filter an optional filter. If the given view doesn't have object list, this filter will be used to create a new
				object list.
			@param string referenceObjectPaths comma separated list of reference object paths
		-->
		<method args="v, filter, referenceObjectPaths" name="bindViewToReferences">
			<![CDATA[
			if (Logger.Singleton.enabled) {
				Logger.Singleton.entering("com.ibm.commerce.lobtools.foundation.model", "cmc/foundation/ModelObject", "bindViewToReferences(v, filter, referenceObjectPaths)", [v, filter, referenceObjectPaths]);
			}
			if (typeof (filter) == "undefined") {
				filter = null;
			}
			var baseFilter = null;
			if (filter != null) {
				baseFilter = filter;
			}
			var paths = null;
			if (referenceObjectPaths) {
				paths = [];
				var refObjPaths = StringUtil.Singleton.splitAndTrim(referenceObjectPaths, ",");
				for (var i = 0; i < refObjPaths.length; i++) {
					var path = [];
					var types = refObjPaths[i].split("/");
					for (var j = 0; j < types.length; j++) {
						path.unshift(types[j]);
					}
					paths.push(path);
				}
			}
			this.referenceCount++;
			if (Logger.Singleton.enabled) {
				Logger.Singleton.log("com.ibm.commerce.lobtools.foundation.model", "FINER", "cmc/foundation/ModelObject", "bindViewToReferences(v, filter, referenceObjectPaths)", "Increment reference count for: Object key=" + this.objectKey + ", new reference count=" + this.referenceCount);
			}
			var list = v.oList;
			if (list) {
				list.setVariable("baseFilter", baseFilter);
			}
			else {
				list = new ModelObjectList.Class(v, {
					v: v,
					baseFilter: baseFilter
				});
			}
			var binding = {
				list: list,
				paths: paths,
				intermediateObjects: [],
				updateIntermediateReferencesDel: new EventHandler.Class(this, "updateIntermediateReferences"),
				releaseIntermediateObjectDel: new EventHandler.Class(this, "releaseIntermediateObject")
			};
			this.referenceListBindings.push(binding);
			this.updateReferenceListBinding(binding);
			this.loadReferences();
			EventUtil.trigger(list, "onreset");
			if (Logger.Singleton.enabled) {
				Logger.Singleton.exiting("com.ibm.commerce.lobtools.foundation.model", "cmc/foundation/ModelObject", "bindViewToReferences(v, filter, referenceObjectPaths)");
			}
			]]>
		</method>
		
		<!---
			@keywords private
			
			Releases the specified view from list of child objects.
			@param cmc/foundation/Component v the view to be released.
		-->
		<method args="v" name="releaseViewFromChildren">
			<![CDATA[
			if (Logger.Singleton.enabled) {
				Logger.Singleton.entering("com.ibm.commerce.lobtools.foundation.model", "cmc/foundation/ModelObject", "releaseViewFromChildren(v)", [v]);
			}
			var lists = this.childModelObjectLists;
			for (var i = 0; i < lists.length; i++) {
				if (lists[i].v == v) {
					v.setVariable("parentO", null);
					lists[i].setVariable("modelObjects", []);
					lists[i].setVariable("statusObject", null);
					lists.splice(i, 1);
					this.referenceCount--;
					if (Logger.Singleton.enabled) {
						Logger.Singleton.log("com.ibm.commerce.lobtools.foundation.model", "FINER", "cmc/foundation/ModelObject", "releaseViewFromChildren(v)", "Decrement reference count for: Object key=" + this.objectKey + ", new reference count=" + this.referenceCount);
					}
					break;
				}
			}
			if (Logger.Singleton.enabled) {
				Logger.Singleton.exiting("com.ibm.commerce.lobtools.foundation.model", "cmc/foundation/ModelObject", "releaseViewFromChildren(v)");
			}
			]]>
		</method>
		
		<!---
			@keywords private
			Releases the specified view from list of references.
			@param cmc/foundation/Component v the view to be released
		-->
		<method args="v" name="releaseViewFromReferences">
			<![CDATA[
			if (Logger.Singleton.enabled) {
				Logger.Singleton.entering("com.ibm.commerce.lobtools.foundation.model", "cmc/foundation/ModelObject", "releaseViewFromReferences(v)", [v]);
			}
			var bindings = this.referenceListBindings;
			for (var i = 0; i < bindings.length; i++) {
				var binding = bindings[i];
				if (binding.list.v == v) {
					binding.list.setVariable("modelObjects", []);
					this.releaseIntermediateObjects(binding);
					for (var prop in binding) {
						delete binding[prop];
					}
					bindings.splice(i, 1);
					this.referenceCount--;
					if (Logger.Singleton.enabled) {
						Logger.Singleton.log("com.ibm.commerce.lobtools.foundation.model", "FINER", "cmc/foundation/ModelObject", "releaseViewFromReferences(v)", "Decrement reference count for: Object key=" + this.objectKey + ", new reference count=" + this.referenceCount);
					}
					break;
				}
			}
			if (Logger.Singleton.enabled) {
				Logger.Singleton.exiting("com.ibm.commerce.lobtools.foundation.model", "cmc/foundation/ModelObject", "releaseViewFromReferences(v)");
			}
			]]>
		</method>

		<!---
			@keywords private
			Gets the data language Ids for unloaded languages for the current language context
			@param cmc/foundation/GetChildrenService service the get children service that will be called for the languages
			@param boolean all Optional parameter when "true" forces all the languages to load
			@return String a comma delimited string of data language ids
		-->
		<method args="service, all" name="getDataLanguageIds">
			<![CDATA[
			var dataLanguageIds = "";
			var context = ContextUtil.Singleton.findContext(this);
			if (context != null && context.storeConfig != null) {
				var languagesContext = all ? context.getContextValue("storeLanguageIds") : context.getContextValue("inputLanguageIds");
				var dataLanguages = context.storeConfig.getLanguagesById((languagesContext != null) ? languagesContext.value : "");
				var missingPages = false;
				if (all) {
					for (var k = 0; k < this.loadChildrenStatusObjects.length; k++) {
						var statusObject = this.loadChildrenStatusObjects[k];
						if (statusObject.service == service) {
							if (statusObject.lastPageNum != 1) {
								missingPages = true;
							}
							break;
						}
					}
				}
				for (var i = 0; i < dataLanguages.length; i++) {
					var language = dataLanguages[i];
					var services = this.loadChildrenLanguageMap[language.languageId];
					if (missingPages || typeof (services) == "undefined" || services.indexOf(service) == -1) {
						if (dataLanguageIds.length > 0) {
							dataLanguageIds += ",";
						}
						dataLanguageIds += language.languageId;
					}
				}
			}
			return dataLanguageIds;
			]]>
		</method>
		
		<!---
			@keywords private
			Mark the specified data language IDs as requested for the specified service.
			@param cmc/foundation/GetChildrenService service for which the language has been requested
			@param string languageIds Comma separated list of language IDs
		-->
		<method args="service, languageIds" name="setRequestedDataLanguageIds">
			<![CDATA[
			var ids = languageIds.split(",");
			for (var i = 0; i < ids.length; i++) {
				var services = this.loadChildrenLanguageMap[ids[i]];
				if (typeof (services) == "undefined") {
					services = [];
					this.loadChildrenLanguageMap[ids[i]] = services;
				}
				if (services.indexOf(service) == -1) {
					services.push(service);
				}
			}
			]]>
		</method>
		
		<!---
			@keywords private
			Clear the requested data language IDs for the specified service.
			@param cmc/foundation/GetChildrenService service for which the data language ids should be cleared
		-->
		<method args="service" name="clearRequestedDataLanguageIds">
			<![CDATA[
			for (var id in this.loadChildrenLanguageMap) {
				var services = this.loadChildrenLanguageMap[id];
				for (var i = 0; i < services.length; i++) {
					if (services[i] == service) {
						services.splice(i, 1);
						break;
					}
				}
			}
			]]>
		</method>
		
		<!---
			@keywords private
			Checks the given get children service to see if its stale
			@param cmc/foundation/GetChildrenService service the get children service to check
			@return boolean "true" if the children service is stale
		-->
		<method args="service" name="isGetChildrenServiceStale">
			<![CDATA[
			for (var i = 0; i < this.getChildrenServicesLoaded.length; i++) {
				if (this.getChildrenServicesLoaded[i] == service) {
					return false;
				}
			}
			for (var i = 0; i < this.getChildrenServicesLoading.length; i++) {
				if (this.getChildrenServicesLoading[i] == service) {
					return false;
				}
			}
			return true;
			]]>
		</method>	
		
		<!---
			@keywords private
			Sets the the get children services for this object as loaded
		-->
		<method name="setGetChildrenServicesLoaded">
			<![CDATA[
			var services = this.objectDefinition ? this.objectDefinition.getChildrenServices : null;
			if (services && services.length > 0) {
				for (var i = 0; i < services.length; i++) {
					this.spliceGetChildrenServiceLoaded(services[i]);
					this.clearRequestedDataLanguageIds(services[i]);
					var loaded = true;
					var objectDefinitions = services[i].getObjectDefinitions(this.objectDefinition);
					if (objectDefinitions.length > 0) {
						loaded = false;
						for (var j = 0; j < objectDefinitions.length; j++) {
							if (!objectDefinitions[j].deferLoad) {
								loaded = true;
								break;
							}
						}
						for (var j = 0; !loaded && j < this.childModelObjectLists.length; j++) {
							var objectSelectors = this.childModelObjectLists[j].objectSelectors;
							if (objectSelectors != null && objectSelectors.length > 0) {
								for (var k = 0; k < objectSelectors.length; k++) {
									if (objectDefinitions.indexOf(objectSelectors[k].objectDefinition) != -1) {
										loaded = true;
										break;
									}
								}
							}
						}
					}
					if (loaded) {
						this.getChildrenServicesLoaded.push(services[i]);
						var storeLanguageIdsContext = ContextUtil.Singleton.findContextValue(this, "storeLanguageIds");
						this.setRequestedDataLanguageIds(services[i], storeLanguageIdsContext != null ? storeLanguageIdsContext.value : "");
					}
				}
			}
			]]>
		</method>
		
		<!---
			@keywords private
			Sets the corresponding children services for the given object definition as stale
			@param cmc/foundation/ObjectDefinition oDef The object definition
			@param boolean reload trigger the reload
		-->
		<method args="oDef, reload" name="setGetChildrenServicesStale">
			<![CDATA[
			if (typeof(reload) == "undefined") reload = true;
			var services = this.objectDefinition ? this.objectDefinition.getChildrenServices : null;
			if (services.length == 0 && !this.objectDefinition.primary && !this.objectDefinition.organizational) {
				this.parentObject.setGetChildrenServicesStale(this.objectDefinition);
			}
			else {
				if (services && services.length > 0) {
					for (var i = 0; i < services.length; i++) {
						if (oDef == null || services[i].matchesObjectDefinition(this.objectDefinition, oDef)) {
							this.spliceGetChildrenServiceLoaded(services[i]);
							this.clearRequestedDataLanguageIds(services[i]);
						}
					}
				}
				if (reload && this.modelInitializationIdentifier == this.model.initializationIdentifier) {
					var doLoadChildren = (oDef == null && this.childModelObjectLists.length > 0);
					for (var i = 0; !doLoadChildren && i < this.childModelObjectLists.length; i++) {
						var objectSelectors = this.childModelObjectLists[i].objectSelectors;
						if (objectSelectors == null || objectSelectors.length == 0) {
							doLoadChildren = true;
						}
						else {
							for (var j = 0; j < objectSelectors.length; j++) {
								if (objectSelectors[j].objectDefinition == oDef) {
									doLoadChildren = true;
									break;
								}
							}
						}
					}
					if (doLoadChildren) {
						if (oDef != null) {
							this.loadChildren([oDef]);
						}
						else {
							this.loadChildren();
						}
					}
				}
			}
			]]>
		</method>
				
		<!---
			@keywords private
			Loads this object's children.
			@param [cmc/foundation/ObjectDefinition] oDefs optional array of object definitions to load
			@param boolean getAll Optional parameter when "true" forces all the languages and children to load 
			@param boolean refresh Optional parameter when "true" only loads get children services marked for refresh, object definitions are ignored
			@param boolean strictMatch: if "true" services with no object types specified will not match the object definitions
			@param integer pageNum: the page number to be loaded.
		-->
		<method args="oDefs, getAll, refresh, strictMatch, pageNum" name="loadChildren">
			<![CDATA[
			if (typeof(oDefs) == "undefined") oDefs = null;
			if (typeof(getAll) == "undefined") getAll = false;
			if (typeof(refresh) == "undefined") refresh = false;
			if (typeof(strictMatch) == "undefined") strictMatch = false;
			if (typeof(pageNum) == "undefined") pageNum = null;
			if (Logger.Singleton.enabled) {
				Logger.Singleton.entering("com.ibm.commerce.lobtools.foundation.model", "cmc/foundation/ModelObject", "loadChildren");
			}
			if (refresh) {
				this.loadChildrenLanguageMap = {};
			}
			var serviceRequests = [];
			if (!this.newObject || (this.implicitNewObject && this.parentPrimaryObject != null && !this.parentPrimaryObject.newObject)) {
				var services = this.objectDefinition ? this.objectDefinition.getChildrenServices : null;
				if (services && services.length > 0) {
					if (refresh) {
						var reload = !this.objectDefinition.organizational || this.childModelObjectLists.length > 0;
						for (var i = 0; i < this.getChildrenServicesLoaded.length; i++) {
							if (reload) {
								serviceRequests.push(this.getChildrenServicesLoaded[i]);
							}
						}
						for (var i = 0; i < this.getChildrenServicesFailed.length; i++) {
							if (reload) {
								serviceRequests.push(this.getChildrenServicesFailed[i]);
							}
						}
						this.getChildrenServicesLoaded = [];
						this.getChildrenServicesFailed = [];
					}
					else {
						for (var i = 0; i < services.length; i++) {
							if (services[i].matchesObjectDefinitions(this.objectDefinition, oDefs, strictMatch)) {
								if (this.isGetChildrenServiceStale(services[i])) {
									this.spliceGetChildrenServiceFailed(services[i]);
									serviceRequests.push(services[i]);
								}
								else if (services[i].isLanguageSensitive(this.objectDefinition) && this.getDataLanguageIds(services[i], getAll).length > 0) {
									this.spliceGetChildrenServiceLoaded(services[i]);
									serviceRequests.push(services[i]);
								}
								else if (getAll) {
									this.spliceGetChildrenServiceLoaded(services[i]);
									serviceRequests.push(services[i]);
								}
							}
						}
					}
					if (serviceRequests.length > 0) {
						var checkLoadedChildrenRequired = false;
						for (var i = 0; i < serviceRequests.length; i++) {
							var submitRequest = true;
							var startIndex = 0;
							for (var j = 0; j < this.loadChildrenStatusObjects.length; j++) {
								if (this.loadChildrenStatusObjects[j].service == serviceRequests[i]) {
									var statusObject = this.loadChildrenStatusObjects[j];
									if (pageNum != null) {
										var maxRecordSetTotal = statusObject.service.getMaxRecordSetTotal();
										if (statusObject.currPageNum > 0 && statusObject.currPageNum < pageNum) {
											var maxItems = statusObject.service.getMaxItems();
											startIndex = statusObject.startIndex + (maxRecordSetTotal * (pageNum - statusObject.currPageNum)) - Math.ceil(statusObject.deleteCount / maxItems) * maxItems;
										}
										else {
											startIndex = maxRecordSetTotal * (pageNum - 1);
										}
										if (startIndex >= statusObject.totalRecords) {
											submitRequest = false;
										}
									}
									statusObject.deleteCount = 0;
									statusObject.currPageNum = 0;
									statusObject.lastPageNum = 0;
									statusObject.startIndex = 0;
									if (statusObject.serviceObjectList != null) {
										statusObject.serviceObjectList = null;
										checkLoadedChildrenRequired = true;
									}
									break;
								}
							}
							if (submitRequest) {
								this.getChildrenServicesLoading.push(serviceRequests[i]);
								var dataLanguageIds = this.getDataLanguageIds(serviceRequests[i], getAll);
								this.setRequestedDataLanguageIds(serviceRequests[i], dataLanguageIds);
								serviceRequests[i].doRequest(this, {
									dataLanguageIds: dataLanguageIds
								}, {
									startIndex: startIndex,
									getAll: getAll
								});
							}
						}
						if (checkLoadedChildrenRequired) {
							this.checkLoadedChildren();
						}
					}
				}
			}
			if (serviceRequests.length == 0 && this.onGetChildrenServiceCompleted) {
				EventUtil.trigger(this, "onGetChildrenServiceCompleted");
			}
			if (Logger.Singleton.enabled) {
				Logger.Singleton.exiting("com.ibm.commerce.lobtools.foundation.model", "cmc/foundation/ModelObject", "loadChildren");
			}
			]]>
		</method>
		
		<!---
			@keywords private
		-->		
		<method args="oDefs, all" name="isGetChildrenServicesLoaded">
			<![CDATA[
			if (typeof(all) == "undefined") all = false;
			if (this.newObject) {
				return true;
			}
			var services = this.objectDefinition ? this.objectDefinition.getChildrenServices : null;
			if (services && services.length > 0) {
				for (var i = 0; i < services.length; i++) {
					if (services[i].matchesObjectDefinitions(this.objectDefinition, oDefs)) {
						var found = false;
						for (var j = 0; j < this.getChildrenServicesLoaded.length; j++) {
							if (this.getChildrenServicesLoaded[j] == services[i]) {
								if (!services[i].isLanguageSensitive(this.objectDefinition) || this.getDataLanguageIds(services[i], all).length == 0) {
									found = true;
									if (all) {
										for (var k = 0; k < this.loadChildrenStatusObjects.length; k++) {
											var statusObject = this.loadChildrenStatusObjects[k];
											if (statusObject.service == services[i]) {
												if (statusObject.lastPageNum != 1) {
													found = false;
												}
												break;
											}
										}
									}
								}
								break;
							}
						}
						if (!found) {
							return false;
						}
					}
				}
			}
			return true;
			]]>
		</method>
		
		<!---
			@keywords private
		-->
		<method name="isGetChildrenServicesLoading">
			<![CDATA[
			return this.getChildrenServicesLoading.length > 0;
			]]>
		</method>

		<!---
			@keywords private
		-->		
		<method args="service" name="spliceGetChildrenServiceLoading">
			<![CDATA[
			for (var i = 0; i < this.getChildrenServicesLoading.length; i++) {
				if (this.getChildrenServicesLoading[i] == service) {
					this.getChildrenServicesLoading.splice(i, 1);
					break;
				}
			}
			]]>
		</method>
		
		<!---
			@keywords private
		-->		
		<method args="service" name="spliceGetChildrenServiceLoaded">
			<![CDATA[
			for (var i = 0; i < this.getChildrenServicesLoaded.length; i++) {
				if (this.getChildrenServicesLoaded[i] == service) {
					this.getChildrenServicesLoaded.splice(i, 1);
					break;
				}
			}
			]]>
		</method>
		
		<!---
			@keywords private
		-->		
		<method args="service" name="spliceGetChildrenServiceFailed">
			<![CDATA[
			for (var i = 0; i < this.getChildrenServicesFailed.length; i++) {
				if (this.getChildrenServicesFailed[i] == service) {
					this.getChildrenServicesFailed.splice(i, 1);
					break;
				}
			}
			]]>
		</method>
		
		<!---
			@keywords private
			Sets up childrens populated by the serice that gets children. This method is
			called by the get children service when its request has been completed.
			@param cmc/foundation/GetChildrenService service: the service that gets children of this object
			@param number startIndex: the index of the first object of the current page
			@param number totalObjects: the total number of child objects available - if the results are paged this will be greater than the number loaded
			@param boolean recordSetComplete: to indicate whether all record sets loaded	
		-->
		<method args="service, startIndex, totalRecords, recordSetComplete" name="childrenServiceRequestCompleted">
			<![CDATA[
			if (Logger.Singleton.enabled) {
				Logger.Singleton.entering("com.ibm.commerce.lobtools.foundation.model", "cmc/foundation/ModelObject", "childrenServiceRequestCompleted(service, startIndex, totalRecords, recordSetComplete)", [service, startIndex, totalRecords, recordSetComplete]);
			}
			if (isNaN(totalRecords)) {
				totalRecords = 0;
			}
			if (isNaN(startIndex) || (startIndex > 0 && totalRecords == 0)) {
				startIndex = -1;
			}
			var maxRecordSetTotal = service.getMaxRecordSetTotal();
			var currPageNum = Math.ceil((startIndex + maxRecordSetTotal) / maxRecordSetTotal);
			var lastPageNum = currPageNum;
			if (startIndex == 0 && recordSetComplete) {
				lastPageNum = 1;
			}
			else if (startIndex + maxRecordSetTotal < totalRecords) {
				lastPageNum += Math.ceil((totalRecords - startIndex - maxRecordSetTotal) / maxRecordSetTotal);
			}
			var currPageNum = Math.ceil(startIndex / maxRecordSetTotal) + 1;
			var statusObject;
			for (var i = 0; i < this.loadChildrenStatusObjects.length; i++) {
				statusObject = this.loadChildrenStatusObjects[i];
				if (statusObject.service == service) {
					statusObject.hasError = false;
					statusObject.message = null;
					statusObject.messageForTree = null;
					statusObject.startIndex = startIndex;
					statusObject.totalRecords = totalRecords;
					statusObject.currPageNum = currPageNum;
					statusObject.lastPageNum = lastPageNum;
					break;
				}
			}
			this.spliceGetChildrenServiceLoading(service);
			var found = false;
			for (var i = 0; i < this.getChildrenServicesLoading.length; i++) {
				if (this.getChildrenServicesLoading[i] == service) {
					found = true;
					break;
				}
			}
			if (!found) {
				this.getChildrenServicesLoaded.push(service);
				this.childObjectListsStale = true;
				this.updateChildObjects(true);
				if (this.isGetChildrenServicesLoaded(this.objectDefinition.getOpenGroupObjectDefinitions()) && !this.childObjectListsStale) {
					this.validate(false);
					this.checkErrors();
				}
				EventUtil.trigger(this, "onGetChildrenServiceCompleted", service);
			}
			if (Logger.Singleton.enabled) {
				Logger.Singleton.exiting("com.ibm.commerce.lobtools.foundation.model", "cmc/foundation/ModelObject", "childrenServiceRequestCompleted(service, startIndex, totalRecords, recordSetComplete)");
			}
			]]>
		</method>
		
		<!---
			@keywords private
			
			Called by the get children service when its request has been completed
			@param cmc/foundation/GetReferencesService service the service that gets children.
			@param string message status message to be displayed to the user
		-->
		<method args="service, message" name="childrenServiceRequestError">
			<![CDATA[
			if (typeof(message) == "undefined") message = null;
			if (Logger.Singleton.enabled) {
				Logger.Singleton.entering("com.ibm.commerce.lobtools.foundation.model", "cmc/foundation/ModelObject", "childrenServiceRequestError(service)", [service]);
			}
			var serviceFound = false;
			for (var i = 0; i < this.loadChildrenStatusObjects.length; i++) {
				var statusObject = this.loadChildrenStatusObjects[i];
				if (statusObject.service == service) {
					if (statusObject.serviceObjectList != null) {
						statusObject.serviceObjectList = null;
						this.checkLoadedChildren();
					}
					serviceFound = true;
					if (message) {
						statusObject.message = message;
						statusObject.messageForTree = null;
						statusObject.hasError = true;
						statusObject.startIndex = 0;
						statusObject.totalRecords = 0;
						statusObject.deleteCount = 0;
						statusObject.currPageNum = -1;
						statusObject.lastPageNum = -1;
					}
					else {
						this.loadChildrenStatusObjects.splice(i, 1);
					}
					break;
				}
			}
			if (!serviceFound && message) {
				this.loadChildrenStatusObjects.push({
					service: service,
					serviceObjectList: null,
					message: message,
					messageForTree: null,
					hasError: true,
					startIndex: 0,
					totalRecords: 0,
					deleteCount: 0,
					currPageNum: -1,
					lastPageNum: -1
				});
			}
			this.spliceGetChildrenServiceLoading(service);
			var found = false;
			for (var i = 0; i < this.getChildrenServicesFailed.length; i++) {
				if (this.getChildrenServicesFailed[i] == service) {
					found = true;
					break;
				}
			}
			if (!found) {
				this.getChildrenServicesFailed.push(service);
			}
			if (service.isLanguageSensitive(this.objectDefinition)) {
				this.loadChildrenLanguageMap = {};
			}
			EventUtil.trigger(this, "onGetChildrenServiceError", service);
			if (message) {
				this.childObjectListsStale = true;
				this.updateChildObjects(true);
			}
			if (Logger.Singleton.enabled) {
				Logger.Singleton.exiting("com.ibm.commerce.lobtools.foundation.model", "cmc/foundation/ModelObject", "childrenServiceRequestError(service)");
			}
			]]>
		</method>
		
		<!---
			@keywords private
			Load this object's references.
		-->
		<method name="loadReferences">
			<![CDATA[
			if (Logger.Singleton.enabled) {
				Logger.Singleton.entering("com.ibm.commerce.lobtools.foundation.model", "cmc/foundation/ModelObject", "loadReferences", [this.referencesStale, this.newObject]);
			}
			if (this.referencesStale && !this.newObject) {
				this.referencesLoaded = false;
				this.referencesStale = false;
				this._getReferenceServiceRequests = [];
				var services = this.objectDefinition ? this.objectDefinition.getReferencesServices : null;
				if (services && services.length > 0) {
					for (var i = 0; i < services.length; i++) {
						this._getReferenceServiceRequests.push(services[i]);
					}
					for (var i = 0; i < services.length; i++) {
						services[i].doRequest(this);
					}
				}
				else {
					this.setVariable("referencesLoaded", true);
				}
			}
			else if (this.newObject) {
				this.setVariable("referencesLoaded", true);
			}
			if (Logger.Singleton.enabled) {
				Logger.Singleton.exiting("com.ibm.commerce.lobtools.foundation.model", "cmc/foundation/ModelObject", "loadReferences", [this.referencesLoaded]);
			}
			]]>
		</method>
		
		<!---
			@keywords private
			Call-back method that is called by the get reference service when its request has been completed.
			@keywords private the service that gets references.
		-->
		<method args="service" name="referenceServiceRequestCompleted">
			<![CDATA[
			if (Logger.Singleton.enabled) {
				Logger.Singleton.entering("com.ibm.commerce.lobtools.foundation.model", "cmc/foundation/ModelObject", "referenceServiceRequestCompleted(service)", [service]);
			}
			for (var i = 0; i < this._getReferenceServiceRequests.length; i++) {
				if (this._getReferenceServiceRequests[i] == service) {
					this._getReferenceServiceRequests.splice(i, 1);
					break;
				}
			}
			if (this._getReferenceServiceRequests.length == 0) {
				this.setVariable("referencesLoaded", true);
				this.validate(false);
				this.checkErrors();
			}
			if (Logger.Singleton.enabled) {
				Logger.Singleton.exiting("com.ibm.commerce.lobtools.foundation.model", "cmc/foundation/ModelObject", "referenceServiceRequestCompleted(service)");
			}
			]]>
		</method>
		
		
		<!---
			@keywords private
			Call-back method that is called by the get reference service when its request has returned with errors.
			@param cmc/foundation/GetReferencesService service the service that gets references.
			@param string message status message to be displayed to the user
		-->
		<method args="service, message" name="referenceServiceRequestError">
			<![CDATA[
			if (typeof(message) == "undefined") message = null;
			if (Logger.Singleton.enabled) {
				Logger.Singleton.entering("com.ibm.commerce.lobtools.foundation.model", "cmc/foundation/ModelObject", "referenceServiceRequestError(service)", [service]);
			}
			var serviceFound = false;
			for (var i = 0; i < this.loadReferencesStatusObjects.length; i++) {
				if (this.loadReferencesStatusObjects[i].service == service) {
					serviceFound = true;
					if (message) {
						this.loadReferencesStatusObjects[i].message = message;
						this.loadReferencesStatusObjects[i].hasError = true;
					}
					else {
						this.loadReferencesStatusObjects.splice(i, 1);
					}
					break;
				}
			}
			if (!serviceFound && message) {
				this.loadReferencesStatusObjects.push({
					service: service,
					message: message,
					hasError: true
				});
			}
			for (var i = 0; i < this._getReferenceServiceRequests.length; i++) {
				if (this._getReferenceServiceRequests[i] == service) {
					this._getReferenceServiceRequests.splice(i, 1);
					break;
				}
			}
			if (message) {
				this.referenceListsStale = true;
				this.updateReferences();
			}
			if (this._getReferenceServiceRequests.length == 0) {
				this.setVariable("referencesLoaded", true);
			}
			if (Logger.Singleton.enabled) {
				Logger.Singleton.exiting("com.ibm.commerce.lobtools.foundation.model", "cmc/foundation/ModelObject", "referenceServiceRequestError(service)");
			}
			]]>
		</method>
		
		<!---
			@keywords private
			Parses the specified data element attributes for this object, and sets the objectReadOnly attribute
			if the element has its readonly attribute set and sets the moveable attribute.
			@param XML e the data element to be parsed.
		-->
		<method args="e" name="parseAttributes">
			<![CDATA[
			var attrReadOnly = e.getAttribute("readonly");
			if (typeof (attrReadOnly) != "undefined") {
				if (this.objectReadOnly != attrReadOnly) {
					this.setVariable("objectReadOnly", attrReadOnly);
				}
			}
			var attrMoveable = e.getAttribute("moveable");
			if (typeof (attrMoveable) != "undefined") {
				var newMoveable = attrMoveable != "false";
				if (this.moveable != newMoveable) {
					this.setVariable("moveable", newMoveable);
				}
			}
			var attrDeletable = e.getAttribute("deletable");
			if (typeof (attrDeletable) != "undefined") {
				if (this.objectDeletable != attrDeletable) {
					this.setVariable("objectDeletable", attrDeletable);
				}
			}
			]]>
		</method>
		
		<!---
			@keywords private
			Parses the specified data element and add any properties and child objects found from parsing to this object.
			@param XML e the data element to be parsed.
			@param boolean lazyParse if "true" pass lazy parsing to child objects
			@param boolean createAsNew: If "true" created the parsed objects as new objects
		-->
		<method args="e, lazyParse, createAsNew" name="parseDataElement">
			<![CDATA[
			if (typeof(e) == "undefined") e = null;
			if (typeof(lazyParse) == "undefined") lazyParse = false;
			if (typeof(createAsNew) == "undefined") createAsNew = false;
			if (e) {
				this.parseProperties(e);
			}
			if (this.unparsedObjects != null && (!lazyParse || ModelUtil.Singleton.isParseRequired(this))) {
				this.parseObjects(lazyParse, null, createAsNew);
				this.updateChildObjects();
			}
			if (e) {
				this.parseAttributes(e);
			}
			]]>
		</method>
		
		<!---
			Parse any unparse child objects.
		-->
		<method name="parseUnparsedObjects">
			<![CDATA[
			this.parseObjects(true, null, false);
			]]>
		</method>
		
		<!---
			Parse any unparsed child objects.

			@param boolean lazyParse: if true do lazy parsing
			@param string type: the object type to be parsed
			@param boolean createAsNew: If true created the parsed objects as new objects
		-->
		<method args="lazyParse, type, createAsNew" name="parseObjects">
			<![CDATA[
			if (typeof(createAsNew) == "undefined") createAsNew = false;
			if (Logger.Singleton.enabled) {
				Logger.Singleton.entering("com.ibm.commerce.lobtools.foundation.model", "cmc/foundation/ModelObject", "parseObjects(lazyParse, type)");
			}
			if (this.parseUnparsedObjectsDel) {
				this.parseUnparsedObjectsDel.disconnectAll();
			}
			if (this.unparsedObjects != null) {
				var elements = this.unparsedObjects;
				if (!type) {
					this.unparsedObjects = null;
				}
				for (var i = 0; i < elements.length; i++) {
					var e = elements[i];
					if (e.nodeName == "object") {
						if (!createAsNew) {
							createAsNew = e.getAttribute("new") == "true";
						}
						if (type) {
							var doParse = false;
							var objectType = e.getAttribute("objectType");
							if (objectType == type) {
								doParse = true;
							}
							else {
								var od = this.model.getObjectDefinition(this, objectType, true);
								if (od && od.matchesType(type)) {
									doParse = true;
								}
							}
							if (doParse) {
								elements.splice(i, 1);
								i--;
								this.model.parseObject(e, this, lazyParse, createAsNew);
							}
						}
						else {
							if (!this.parseUnparsedObjectsDel) {
								this.parseUnparsedObjectsDel = new EventHandler.Class(this, "parseUnparsedObjects");
							}
							var parsedO = this.model.parseObject(e, this, lazyParse, createAsNew, undefined, undefined, this.parseUnparsedObjectsDel);
							if (parsedO == null) {
								if (this.unparsedObjects == null) {
									this.unparsedObjects = [];
								}
								this.unparsedObjects.push(e);
							}
						}
					}
					else if (!type && e.nodeName == "reference") {
						var o = this.model.parseObject(XMLUtil.getFirstElement(e, "object"), null, false, false, this.objectVersionId, this.localContext);
						if (o == null) {
							Logger.Singleton.log("com.ibm.commerce.lobtools.foundation.model", "SEVERE", "cmc/foundation/ModelObject", "parseObjects", "Error parsing reference " + e);
						}
						else {
							o.addChild(this);
						}
					}
				}
			}
			if (Logger.Singleton.enabled) {
				Logger.Singleton.exiting("com.ibm.commerce.lobtools.foundation.model", "cmc/foundation/ModelObject", "parseObjects(lazyParse, type)");
			}
			]]>
		</method>
		
		<!---
			@keywords private
			Parses the specified data element and create property objects for any child elements found.
			Child elements that are named "object" are ignored.
			@param XML e the data element to be parsed.
		-->
		<method args="e" name="parseProperties">
			<![CDATA[
			if (typeof(e) == "undefined") e = null;
			if (Logger.Singleton.enabled) {
				Logger.Singleton.entering("com.ibm.commerce.lobtools.foundation.model", "cmc/foundation/ModelObject", "parseProperties(e)", [e]);
			}
			if (this.unparsedObjects == null) {
				this.unparsedObjects = [];
			}
			var unparsedProperties = [];
			var nodes = e.childNodes;
			for (var i = 0; i < nodes.length; i++) {
				var node = nodes[i];
				if (node.nodeType == 1) {
					var propertyName = node.nodeName;
					if (propertyName == "object" || propertyName == "reference" || propertyName == "parent") {
						this.unparsedObjects.push(node);
					}
					else {
						unparsedProperties.push(node);
					}
				}
			}
			var propChanged = false;
			var objectKeyChanged = false;
			for (var i = 0; i < unparsedProperties.length; i++) {
				var node = unparsedProperties[i];
				var propertyName = node.nodeName;
				var propertyValue = XMLUtil.getNodeValue(node);
				var attrReadOnly = node.getAttribute("readonly");
				if (typeof (attrReadOnly) == "undefined") {
					attrReadOnly = null;
				}
				if (node.getAttribute("dirty") == "true") {
					this.setPropertyValue(propertyName, null, propertyValue);
				}
				else if (this.propertyMap[propertyName]) {
					var property = this.propertyMap[propertyName];
					if ((!property.dirty || property.transaction != null) && property.value != propertyValue) {
						this._parsing = true;
						property.setVariable("value", propertyValue);
						this._parsing = false;
					}
					property.setVariable("propertyReadOnly", attrReadOnly);
				}
				else if (propertyValue != "" || attrReadOnly != null || typeof (this.objectDefinition.defaultPropertyValues[propertyName]) != "undefined") {
					var rawData = this.rawDataPropertyMap[propertyName];
					if (!rawData) {
						rawData = {};
						this.rawDataPropertyMap[propertyName] = rawData;
					}
					propChanged = propChanged || rawData.propertyValue != propertyValue;
					rawData.propertyValue = propertyValue;
					rawData.propertyReadOnly = attrReadOnly;
					rawData.trimmed = false;
				}
				else if (this.rawDataPropertyMap[propertyName]) {
					delete this.rawDataPropertyMap[propertyName];
				}
				if (propertyName == this.objectDefinition.idProperty) {
					objectKeyChanged = true;
				}
			}
			if (objectKeyChanged) {
				this.updateObjectId(true);
			}
			if (propChanged) {
				EventUtil.trigger(this, "propertyChanged");
			}
			this.parseObjectStoreId();
			this.parseChangeControlModifiableProperty();
			if (Logger.Singleton.enabled) {
				Logger.Singleton.exiting("com.ibm.commerce.lobtools.foundation.model", "cmc/foundation/ModelObject", "parseProperties(e)");
			}
			]]>
		</method>	

		<!---
			@keywords private
			Update display name style based on the {@link cmc/foundation/DisplayNameStyle}
			configuration.
		-->
		<method args="e" name="updateDisplayNameStyle">
			<![CDATA[
			if (typeof(e) == "undefined") e = null;
			if (Logger.Singleton.enabled) {
				Logger.Singleton.entering("com.ibm.commerce.lobtools.foundation.model", "cmc/foundation/ModelObject", "updateDisplayNameStyle(e)", [e]);
			}
			this.updateDisplayNameStyleDel.disconnectAll();
			var newDisplayNameStyle = null;
			var o = this.getReferencedObject();
			if (o != null) {
				for (var i = 0; i < o.objectDefinition.displayNameStyles.length; i++) {
					var style = o.objectDefinition.displayNameStyles[i];
					style.registerDelegate(o, this.updateDisplayNameStyleDel);
					if (style.isEnabled(o)) {
						newDisplayNameStyle = style;
						break;
					}
				}
			}
			if (newDisplayNameStyle != this.displayNameStyle) {
				this.setVariable("displayNameStyle", newDisplayNameStyle);
			}
			if (Logger.Singleton.enabled) {
				Logger.Singleton.exiting("com.ibm.commerce.lobtools.foundation.model", "cmc/foundation/ModelObject", "updateDisplayNameStyle(e)");
			}
			]]>
		</method>		
		<!---
			@keywords private
			This method parses the value of the object store identifier.
		-->
		<method name="parseObjectStoreId">
			<![CDATA[
			if (Logger.Singleton.enabled) {
				Logger.Singleton.entering("com.ibm.commerce.lobtools.foundation.model", "cmc/foundation/ModelObject", "parseObjectStoreId", [this.objectKey]);
			}
			var storeId = this.getPropertyValue("objectStoreId");
			if (storeId != this.objectStoreId && StringUtil.Singleton.isInteger(storeId)) {
				this.setVariable("objectStoreId", storeId);
			}
			if (Logger.Singleton.enabled) {
				Logger.Singleton.exiting("com.ibm.commerce.lobtools.foundation.model", "cmc/foundation/ModelObject", "parseObjectStoreId", [this.objectReadOnly, this.readOnly, this.objectStoreId]);
			}
			]]>
		</method>
		
		<!---
			@keywords private
			This method to parse the value of the change control modifiable property.
		-->
		<method name="parseChangeControlModifiableProperty">
			<![CDATA[
			if (Logger.Singleton.enabled) {
				Logger.Singleton.entering("com.ibm.commerce.lobtools.foundation.model", "cmc/foundation/ModelObject", "parseChangeControlModifiableProperty", [this.objectKey]);
			}
			var modifiable = this.getPropertyValue("changeControlModifiable");
			if (modifiable != "" && modifiable != this.changeControlModifiable) {
				this.setVariable("changeControlModifiable", modifiable);
				this.checkOpenGroupPartiallyEditable();
			}
			if (Logger.Singleton.enabled) {
				Logger.Singleton.exiting("com.ibm.commerce.lobtools.foundation.model", "cmc/foundation/ModelObject", "parseChangeControlModifiableProperty", [this.readOnly, this.changeControlModifiable]);
			}
			]]>
		</method>
		
		<!---
			@keywords private
			Initializes this model object from its template.
			@param cmc/foundation/ModelObject templateObject The source object to be used to create the current object
			@param boolean changeDisplayNameProperty "true" or undefined if the property used for display name should be changed.
		-->
		<method args="templateObject, changeDisplayNameProperty" name="initFromTemplate">
			<![CDATA[
			if (Logger.Singleton.enabled) {
				Logger.Singleton.entering("com.ibm.commerce.lobtools.foundation.model", "cmc/foundation/ModelObject", "initFromTemplate(templateObject, changeDisplayNameProperty)", [templateObject, changeDisplayNameProperty]);
			}
			if (templateObject.objectDefinition.hasChildDefinitions()) {
				for (var i = 0; i < this.orderedChildObjectKeys.length; i++) {
					var key = this.orderedChildObjectKeys[i];
					var o = this.childObjectMap[key];
					if (typeof (o) != "undefined") {
						if (templateObject.objectDefinition.getChildDefinition(o.objectType) && !o.objectDefinition.primary && !o.pendingDelete) {
							o.deleteObject();
						}
					}
				}
			}
			templateObject.checkParsedData();
			var propertyValues = templateObject.getPropertyValues();
			for (var propertyName in propertyValues) {
				var newPropertyName = null;
				if (propertyName == templateObject.objectDefinition.displayNameProperty && this.objectDefinition.displayNameProperty) {
					newPropertyName = this.objectDefinition.displayNameProperty;
				}
				else {
					newPropertyName = propertyName;
				}
				var copyProperty = true;
				var pDef = templateObject.objectDefinition.getPropertyDefinition(templateObject, propertyName);
				if (propertyName == templateObject.objectDefinition.idProperty && !templateObject.objectDefinition.languageSensitive) {
					copyProperty = pDef && !pDef.copyProtected;
				}
				else if (newPropertyName == this.objectDefinition.displayNameProperty && templateObject.objectDefinition.displayNameProperty && propertyName != templateObject.objectDefinition.displayNameProperty) {
					copyProperty = false;
				}
				else if (propertyName == "objectStoreId" && this.objectType != templateObject.objectType) {
					copyProperty = false;
					var context = ContextUtil.Singleton.findContext(this);
					var storeConfig = context != null ? context.storeConfig : null;
					if (storeConfig != null) {
						var propertyValue = storeConfig.storeId;
						var property = this.propertyMap[propertyName];
						if (property) {
							property.setVariable("value", propertyValue);
						}
						else {
							var rawData = this.rawDataPropertyMap[propertyName];
							if (!rawData) {
								rawData = {};
								this.rawDataPropertyMap[propertyName] = rawData;
							}
							rawData.propertyValue = propertyValue;
							rawData.propertyReadOnly = false;
							rawData.trimmed = false;
						}
					}
				}
				else if (propertyName == "changeControlModifiable" || propertyName == "changeControlWorkspaceName" || propertyName == "changeControlWorkspaceTaskGroup" || propertyName == "changeControlWorkspaceTask" || propertyName == "basedOnVersionNumber" || propertyName == "basedOnVersionName" || propertyName == "objectVersionId" || propertyName == "objectVersionNumber") {
					copyProperty = false;
				}
				else {
					copyProperty = !pDef || (pDef && !pDef.copyProtected);
				}
				var defaultPropertyValue = null;
				if (!copyProperty && typeof (this.objectDefinition.defaultPropertyValues[newPropertyName]) != "undefined") {
					defaultPropertyValue = this.objectDefinition.defaultPropertyValues[newPropertyName];
				}
				if (copyProperty || defaultPropertyValue != null) {
					var propertyValue = null;
					var changeProperty = false;
					if (copyProperty) {
						if (newPropertyName == this.objectDefinition.displayNameProperty && changeDisplayNameProperty) {
							propertyValue = foundationResources.Singleton.replaceValues("templateCopyOf", [propertyValues[propertyName]]);
						}
						else {
							propertyValue = propertyValues[propertyName];
						}
						if (newPropertyName == this.objectDefinition.templateTypeProperty && propertyName != templateObject.objectDefinition.templateTypeProperty) {
							changeProperty = true;
						}
					}
					else {
						propertyValue = defaultPropertyValue;
					}
					var property = this.propertyMap[newPropertyName];
					if (property) {
						if (changeProperty) {
							property.change(propertyValue);
						}
						else {
							property.setVariable("value", propertyValue);
						}
					}
					else {
						var newRawData = {};
						newRawData.propertyValue = propertyValue;
						newRawData.propertyReadOnly = false;
						newRawData.trimmed = false;
						this.rawDataPropertyMap[newPropertyName] = newRawData;
					}
				}
			}
			var templateObjectIsVersionObject = templateObject.getIsVersionObject();
			for (var i = 0; i < templateObject.orderedChildObjectKeys.length; i++) {
				var key = templateObject.orderedChildObjectKeys[i];
				var o = templateObject.childObjectMap[key];
				if (typeof (o) != "undefined") {
					if (o.objectDefinition.primary) {
						this.addChild(o, false);
					}
					else if (!o.pendingDelete && !o.objectDefinition.parentReference && !o.objectDefinition.collectionReference && !o.objectDefinition.copyProtected && (templateObjectIsVersionObject || !o.getIsVersionObject())) {
						var newObject = null;
						var objectDef = this.model.getObjectDefinition(this, o.objectDefinition.objectType);
						if (!objectDef) {
							var types = o.objectDefinition.getCompatibleObjectTypes();
							for (var j = 0; j < types.length; j++) {
								objectDef = this.model.getObjectDefinition(this, types[j], true);
								if (objectDef) {
									break;
								}
							}
						}
						if (objectDef) {
							var propertyDef = objectDef.getPropertyDefinition(this, objectDef.idProperty);
							if (objectDef.languageSensitive || (propertyDef && !propertyDef.copyProtected)) {
								newObject = this.model.createObject(this, objectDef, o.objectId, true);
							}
							else {
								newObject = this.model.createNewObject(objectDef, this, false);
							}
							newObject.initFromTemplate(o, false);
						}
					}
				}
			}
			this.updateChildObjects();
			if (Logger.Singleton.enabled) {
				Logger.Singleton.exiting("com.ibm.commerce.lobtools.foundation.model", "cmc/foundation/ModelObject", "initFromTemplate(templateObject, changeDisplayNameProperty)");
			}
			]]>
		</method>
		
		<!---
			@keywords private
			Revert this object to a new object. Server managed properties such as the ID property will
			be removed and the newObject attribute will be reset to true.
		-->
		<method name="revertToNewObject">
			<![CDATA[
			var oDef = this.objectDefinition;
			if (!this.objectDefinition.languageSensitive) {
				var propertyName = this.objectDefinition.idProperty;
				var prop = this.propertyMap[propertyName];
				if (prop) {
					if (prop.value != "") {
						prop.setVariable("value", "");
					}
				}
				else {
					delete this.rawDataPropertyMap[propertyName];
				}
			}
			for (var propertyName in this.objectDefinition.propertyDefinitions) {
				var pDef = this.objectDefinition.getPropertyDefinition(this, propertyName);
				if (pDef && pDef.serverManaged) {
					var prop = this.propertyMap[propertyName];
					if (prop) {
						if (prop.value != "") {
							prop.setVariable("value", "");
						}
					}
					else {
						delete this.rawDataPropertyMap[propertyName];
					}
				}
			}
			this.transaction.o.setVariable("newObject", true);
			]]>
		</method>
		
		<!---
			@keywords private
			Returns a saveable parent primary object.
		-->
		<method name="getSaveableParentPrimaryObject">
			<![CDATA[
			var saveableParentPrimaryObject = null;
			if (this.objectDefinition.saveParentPrimaryObject && this.viewed) {
				var po = this.getParentPrimaryObject();
				if (po && this.openGroupObject != po.openGroupObject && po.openGroupObject.openGroupDirty) {
					saveableParentPrimaryObject = po;
				}
			}
			return saveableParentPrimaryObject;
			]]>
		</method>
		
		<!---
			@keywords private
			Saves the object including its children. If the saved object is an open group object and contains validation
			error, a confirmation box will be prompt, unless the argument prompt is set to false. Before any value is
			actually saved, the event beingSaved will be sent out.
			
			@param boolean prompt False if no dialog window should be popped up when a validation error is present while this
				model object is an open group object. Otherwise, a dialog window will be shown.
			@param boolean saveRelatedObjects true if the save should ensure that related objects are saved
			@event beingSaved
		-->
		<method args="prompt, saveRelatedObjects" name="saveObject">
			<![CDATA[
			if (typeof(prompt) == "undefined") prompt = true;
			if (typeof(saveRelatedObjects) == "undefined") saveRelatedObjects = true;
			if (Logger.Singleton.enabled) {
				Logger.Singleton.entering("com.ibm.commerce.lobtools.foundation.model", "cmc/foundation/ModelObject", "saveObject");
			}
			if (!this.saveObjectLock) {
				this.saveObjectLock = true;
				var doSaveObject = true;
				if (this.isOpenGroupObject()) {
					EventUtil.trigger(this, "beingSaved", this);
				}
				if (prompt && this.isOpenGroupObject() && this.hasErrors(true)) {
					var caller = this;
					require(["cmc/foundation/SaveWithErrorConfirmationDialog"], function(SaveWithErrorConfirmationDialog) {
						SaveWithErrorConfirmationDialog.Singleton.openSaveWithErrorConfirmationDialog(caller);
					});
					doSaveObject = false;
				}
				if (doSaveObject) {
					if (saveRelatedObjects) {
						var unsavedOpenAncestors = this.getUnsavedOpenAncestors();
						for (var i = 0; i < unsavedOpenAncestors.length; i++) {
							unsavedOpenAncestors[i].saveObject(false, true);
						}
						var saveableParentPrimaryObject = this.getSaveableParentPrimaryObject();
						if (saveableParentPrimaryObject != null) {
							saveableParentPrimaryObject.saveObject(false, true);
						}
					}
					if (this.objectDefinition.saveHandler != null) {
						this.objectDefinition.saveHandler.save(this);
					}
					else {
						if (!this.pendingDelete) {
							for (var key in this.childObjectMap) {
								var o = this.childObjectMap[key];
								if (!o.getIsVersionObject() && o.objectDefinition.reference && !o.objectDefinition.parentReference && !o.objectDefinition.collectionReference) {
									var referencedObject = o.getReferencedObject();
									if (referencedObject != null && (referencedObject.newObject || (!referencedObject.viewed && referencedObject.isOpenGroupObject() && referencedObject.openGroupDirty))) {
										referencedObject.saveObject(false, false);
									}
								}
							}
						}
						var saveChildren = !this.objectDefinition.parentReference && !this.objectDefinition.collectionReference;
						if (this.newObject && !this.creating) {
							if (this.objectDefinition.createService != null) {
								this.objectDefinition.createService.doRequest(this);
							}
						}
						else if (this.pendingDelete) {
							if (this.objectDefinition.deleteService != null) {
								this.objectDefinition.deleteService.doRequest(this);
							}
							saveChildren = false;
						}
						else {
							if (this.objectDefinition.saveService != null) {
								this.objectDefinition.saveService.doRequest(this);
							}
						}
						if (saveChildren) {
							var saveObjects = [];
							for (var key in this.referenceMap) {
								var o = this.referenceMap[key];
								var oDef = o.objectDefinition;
								if (!o.getIsVersionObject() && (oDef.parentReference || oDef.collectionReference)) {
									if (o.pendingDelete) {
										saveObjects.push(o);
									}
									else {
										saveObjects.unshift(o);
									}
								}
							}
							for (var i = 0; i < saveObjects.length; i++) {
								var o = saveObjects[i];
								var oDef = o.objectDefinition;
								o.saveObject(false, saveRelatedObjects && oDef.collectionReference);
							}
							saveObjects = [];
							for (var key in this.childObjectMap) {
								var o = this.childObjectMap[key];
								if (o.getIsVersionObject()) {
									continue;
								}
								if (o.parentObject == this && o.openGroupObject == this.openGroupObject) {
									saveObjects.push(o);
								}
								else if (o.objectDefinition.parentReference || o.objectDefinition.collectionReference) {
									var referencedObject = o.getReferencedObject();
									if (saveRelatedObjects && !referencedObject.viewed && referencedObject.isOpenGroupObject() && referencedObject.openGroupDirty) {
										referencedObject.saveObject(false, false);
									}
								}
								else if (!o.viewed && o.parentObject == this && o.isOpenGroupObject() && o.openGroupDirty) {
									saveObjects.push(o);
								}
							}
							if (saveObjects.length > 0) {
								ModelUtil.Singleton.sortObjectsBySaveOrder(saveObjects);
								for (var i = 0; i < saveObjects.length; i++) {
									saveObjects[i].saveObject(false, false);
								}
							}
						}
					}
					if (!this.pendingDelete) {
						if (this.objectDefinition.postSaveService != null) {
							this.objectDefinition.postSaveService.doRequest(this);
						}
					}
					if (!this.viewed && this.open) {
						this.closeObject(false);
					}
					if (this.isOpenGroupObject()) {
						this.checkUnsavedChanges();
					}
				}
				this.saveObjectLock = false;
			}
			if (Logger.Singleton.enabled) {
				Logger.Singleton.exiting("com.ibm.commerce.lobtools.foundation.model", "cmc/foundation/ModelObject", "saveObject");
			}
			]]>
		</method>
		
		<!---
			@keywords private
			True if the current object is deleting or whether its referenced object is deleting.
			@param cmc/foundation/EventHandler del The
		-->
		<method args="del" name="isDeleting">
			<![CDATA[
			if (typeof(del) == "undefined") del = null;
			var isDeletingBool = false;
			if (this.objectDefinition != null) {
				if (del) {
					del.connect(this, "ondeleting");
				}
				if (this.deleting) {
					isDeletingBool = true;
				}
				if (!isDeletingBool && this.objectDefinition.reference) {
					var referencedObject = this.getReferencedObject();
					if (referencedObject != null && referencedObject.isDeleting(del)) {
						isDeletingBool = true;
					}
				}
			}
			return isDeletingBool;
			]]>
		</method>

		<!---
			@keywords private
			Deletes this object including its children.
			@param boolean prompt Prompt the user to confirm the delete action. The default is false.
			@param boolean immediate Whether the delete service request for child objects should be sent immediately or not. The default is false.
		-->
		<method args="prompt, immediate" name="deleteObject">
			<![CDATA[
			if (typeof(prompt) == "undefined") prompt = false;
			if (typeof(immediate) == "undefined") immediate = false;
			if (Logger.Singleton.enabled) {
				Logger.Singleton.entering("com.ibm.commerce.lobtools.foundation.model", "cmc/foundation/ModelObject", "deleteObject(prompt, immediate)", [prompt, immediate]);
			}
			var openGroupObject = this.openGroupObject;
			if (this.newObject && !this.creating) {
				if (prompt && openGroupObject != null && openGroupObject == this) {
					var caller = this;
					require(["cmc/foundation/DeleteConfirmationDialog"], function(DeleteConfirmationDialog) {
						DeleteConfirmationDialog.Singleton.openDeleteConfirmationDialog(caller);
					});
				}
				else {
					ModelUtil.Singleton.releaseModelObject(this);
					if (openGroupObject != null && openGroupObject != this) {
						openGroupObject.checkUnsavedChanges();
					}
				}
			}
			else if (this.objectDefinition.deleteService && (immediate || openGroupObject == this)) {
				if (prompt && openGroupObject != null && openGroupObject == this) {
					var caller = this;
					require(["cmc/foundation/DeleteConfirmationDialog"], function(DeleteConfirmationDialog) {
						DeleteConfirmationDialog.Singleton.openDeleteConfirmationDialog(caller);
					});
				}
				else {
					this.objectDefinition.deleteService.doRequest(this);
				}
			}
			else if (this.parentObject != null) {
				this.pendingDelete = true;
				this.parentObject.childObjectListsStale = true;
				this.parentObject.updateChildObjects();
				if (this.openGroupObject != null) {
					if (this.openGroupObject.messagesLogged) {
						MessageLogger.Singleton.clearModelObjectMessages(this);
					}
					this.openGroupObject.setVariable("open", true);
					this.openGroupObject.setVariable("openGroupDirty", true);
				}
				for (var key in this.childObjectMap) {
					var o = this.childObjectMap[key];
					if (o.parentObject == null && !o.getIsVersionObject()) {
						o.referenceListsStale = true;
						o.updateReferences();
					}
				}
			}
			if (Logger.Singleton.enabled) {
				Logger.Singleton.exiting("com.ibm.commerce.lobtools.foundation.model", "cmc/foundation/ModelObject", "deleteObject(prompt, immediate)");
			}
			]]>
		</method>

		<!---
			@keywords private
			Restore this object if it is pending delete.
		-->
		<method name="undeleteObject">
			<![CDATA[
			if (this.pendingDelete && this.parentObject != null) {
				this.pendingDelete = false;
				this.parentObject.childObjectListsStale = true;
				this.parentObject.updateChildObjects();
				if (this.openGroupObject != null) {
					if (this.openGroupObject.messagesLogged) {
						this.addPropertyLogMessages();
					}
					this.openGroupObject.checkUnsavedChanges();
					if (!this.openGroupObject.viewed && !this.openGroupObject.openGroupDirty && this.openGroupObject.open) {
						this.openGroupObject.closeObject(false);
					}
				}
				for (var key in this.childObjectMap) {
					var o = this.childObjectMap[key];
					if (o.parentObject == null) {
						o.referenceListsStale = true;
						o.updateReferences();
					}
				}
			}
			]]>
		</method>

		<!---
			@keywords private
			Gets the reference object that matches the specified object definition and referenced
			object. This may include pending delete reference objects. If no such object exists, then null is returned.
			@param cmc/foundation/ObjectDefinition refDef the reference object definition
			@param cmc/foundation/ModelObject o referenced object
		-->
		<method args="refDef, o" name="getMatchingReferenceObject">
			<![CDATA[
			var ro = null;
			for (var key in this.childObjectMap) {
				var childObject = this.childObjectMap[key];
				if (childObject.objectDefinition == refDef && childObject.getReferencedObject() == o) {
					ro = childObject;
					break;
				}
			}
			return ro;
			]]>
		</method>

		<!---
			@keywords private
			Returns "true" if this object has any unsaved changes. The children and references of this object will be searched too.
			@return boolean "true" if the object has unsaved changes
		-->
		<method name="hasUnsavedChanges">
			<![CDATA[
			if (Logger.Singleton.enabled) {
				Logger.Singleton.entering("com.ibm.commerce.lobtools.foundation.model", "cmc/foundation/ModelObject", "hasUnsavedChanges");
			}
			var unsavedChanges = (this.pendingDelete && !this.deleting) || (this.newObject && !this.implicitNewObject && !this.creating) || this.hasUnsavedPropertyChanges();
			if (!unsavedChanges) {
				unsavedChanges = (this.postSaveFailed && this.postSaveTransaction == null);
			}
			if (!unsavedChanges) {
				for (var key in this.childObjectMap) {
					var o = this.childObjectMap[key];
					if (o.parentObject == this && o.openGroupObject == this.openGroupObject && !o.getIsVersionObject() && o.hasUnsavedChanges()) {
						unsavedChanges = true;
						break;
					}
				}
			}
			if (!unsavedChanges) {
				for (var key in this.referenceMap) {
					var o = this.referenceMap[key];
					var oDef = o.objectDefinition;
					if (((oDef.parentReference || oDef.collectionReference) && o.openGroupObject == this.openGroupObject) && !o.getIsVersionObject() && ((o.newObject && !o.creating) || (o.pendingDelete && !o.deleting) || o.hasUnsavedPropertyChanges())) {
						unsavedChanges = true;
						break;
					}
				}
			}
			if (Logger.Singleton.enabled) {
				Logger.Singleton.exiting("com.ibm.commerce.lobtools.foundation.model", "cmc/foundation/ModelObject", "hasUnsavedChanges", unsavedChanges);
			}
			return unsavedChanges;
			]]>
		</method>

		<!---
			@keywords private
			Returns "true" if this object has any unsaved property changes.
			@return boolean "true" if the object has unsaved property changes
		-->
		<method name="hasUnsavedPropertyChanges">
			<![CDATA[
			var unsavedChanges = false;
			if (!this.pendingDelete) {
				for (var key in this.propertyMap) {
					var prop = this.propertyMap[key];
					if (prop.dirty && prop.transaction == null) {
						unsavedChanges = true;
						break;
					}
				}
			}
			return unsavedChanges;
			]]>
		</method>

		<!---
			@keywords private
			Checks if there are unsaved changes in the open group and updates the "openGroupDirty" attribute.			
			@param boolean dirty: pass in true if the caller knows that we have unsaved changes. Don't
				pass in this argument if the caller has committed or rolled back a change and is checking to see if
				there are still other unsaved changes
		-->
		<method args="dirty" name="checkUnsavedChanges">
			<![CDATA[
			if (typeof(dirty) == "undefined") dirty = false;
			if (this.openGroupObject != null) {
				var newOpenGroupDirty = dirty ? dirty : this.openGroupObject.hasUnsavedChanges();
				if (newOpenGroupDirty != this.openGroupObject.openGroupDirty) {
					this.openGroupObject.setVariable("openGroupDirty", newOpenGroupDirty);
				}
			}
			]]>
		</method>		
		
		<!--- 
			@keywords private
			Returns a boolean value indicating if this openGroup object is dirty or not. 
			If the flag of checkDescendants is set to true, then this method looks at the model's 
			open objects which are descendants of this object to see if any one of them
			is dirty. 
			@param boolean checkDescendants: set to true if the caller wants to include the 
			model's open objects that are descendants of this object in the check for dirty property. 
		-->
		<method args="checkDescendants" name="isOpenGroupDirty">
			<![CDATA[
			if (typeof(checkDescendants) == "undefined") checkDescendants = false;
			var newOpenGroupDirty = false;
			if (this.openGroupObject != null) {
				newOpenGroupDirty = this.openGroupObject.openGroupDirty;
				if (!newOpenGroupDirty && checkDescendants) {
					var currentOpenObjects = this.model.openObjects;
					for (var i = 0; i < currentOpenObjects.length; i++) {
						var o = currentOpenObjects[i];
						if (o.openGroupDirty && this.openGroupObject.isDescendant(o)) {
							newOpenGroupDirty = true;
							break;
						}
					}
				}
			}
			return newOpenGroupDirty;
			]]>
		</method>
		
		<!---
			@keywords private
			Returns "true" if this object has any validation errors.
			@param boolean ignoreServiceErrors if "true", ignore errors reported by service requests
			@return boolean "true" if the object has validation errors.
		-->
		<method args="ignoreServiceErrors" name="hasErrors">
			<![CDATA[
			if (typeof(ignoreServiceErrors) == "undefined") ignoreServiceErrors = false;
			var hasErrors = this.hasValidationError(ignoreServiceErrors) || this.hasPropertyErrors(ignoreServiceErrors);
			var isVersionObject = this.getIsVersionObject();
			if (!hasErrors) {
				for (var key in this.childObjectMap) {
					var o = this.childObjectMap[key];
					if (!o.pendingDelete && o.parentObject == this && o.openGroupObject == this.openGroupObject && (isVersionObject || !o.getIsVersionObject()) && o.hasErrors(ignoreServiceErrors)) {
						hasErrors = true;
						break;
					}
				}
			}
			if (!hasErrors) {
				for (var key in this.referenceMap) {
					var o = this.referenceMap[key];
					var oDef = o.objectDefinition;
					if (!o.pendingDelete && (oDef.parentReference || oDef.collectionReference) && o.openGroupObject == this.openGroupObject && (isVersionObject || !o.getIsVersionObject()) && (o.hasValidationError(ignoreServiceErrors) || o.hasPropertyErrors(ignoreServiceErrors))) {
						hasErrors = true;
						break;
					}
				}
			}
			return hasErrors;
			]]>
		</method>
		
		<!---
			@keywords private
			Returns "true" if this object has any property errors.
			@param boolean ignoreServiceErrors if "true", ignore errors reported by service requests
			@return boolean "true" if the object has property errors.
		-->
		<method args="ignoreServiceErrors" name="hasPropertyErrors">
			<![CDATA[
			var hasErrors = false;
			for (var key in this.propertyMap) {
				if (this.propertyMap[key].hasValidationError(ignoreServiceErrors)) {
					hasErrors = true;
					break;
				}
			}
			return hasErrors;
			]]>
		</method>
		
		<!---
			@keywords private
			Returns the first error found in this model object. This method will recursively search through
			all the objects in the open group until an error is found.
			@return object the first error object found in this model object
		 -->
		<method name="getError">
			<![CDATA[
			var error = this.getObjectError();
			var isVersionObject = this.getIsVersionObject();
			if (error == null) {
				for (var key in this.childObjectMap) {
					var o = this.childObjectMap[key];
					if (!o.pendingDelete && o.parentObject == this && o.openGroupObject == this.openGroupObject && (isVersionObject || !o.getIsVersionObject())) {
						error = o.getError();
						if (error != null) {
							break;
						}
					}
				}
			}
			if (error == null) {
				for (var key in this.referenceMap) {
					var o = this.referenceMap[key];
					var oDef = o.objectDefinition;
					if (!o.pendingDelete && (oDef.parentReference || oDef.collectionReference) && o.openGroupObject == this.openGroupObject && (isVersionObject || !o.getIsVersionObject())) {
						error = o.getObjectError();
						if (error != null) {
							break;
						}
					}
				}
			}
			return error;
			]]>
		</method>
		
		<!---
			@keywords private
			Returns the first error found in this model object. If object-level error is found,
			the model object's properties will be searched for errors.
			@return string the message of the first error object found in this model object or in the properties of this model object
		-->
		<method name="getObjectError">
			<![CDATA[
			var error = null;
			if (this.serverErrors.length > 0) {
				error = this.serverErrors[0];
			}
			else if (this.clientErrors.length > 0) {
				error = this.clientErrors[0].message;
			}
			if (error == null) {
				error = this.getPropertyError();
			}
			if (error != null) {
				var context = ContextUtil.Singleton.findContext(this);
				var storeConfig = context != null ? context.storeConfig : null;
				if (this.objectDefinition.languageSensitive && storeConfig != null) {
					var langId = this.getPropertyValue("languageId");
					if (langId) {
						var langObject = storeConfig.getLanguageById(langId);
						if (langObject) {
							error = error + " (" + langObject.languageDescription + ")";
						}
					}
				}
			}
			return error;
			]]>
		</method>

		<!---
			@keywords private
			To register a language sensitive object to a delegate so that when input language selection is changed,
			it will be removed if it's language specific input is no longer necessary.
		-->
		<method args="e" name="checkLanguageSensitiveObject">
			<![CDATA[
			if (typeof(e) == "undefined") e = null;
			if (!this.hasUnsavedChanges() && this.implicitNewObject) {
				var objLang = this.getPropertyValue("languageId");
				var inputLanguageIdsContext = ContextUtil.Singleton.findContextValue(this, "inputLanguageIds");
				var inputLangs = inputLanguageIdsContext != null ? inputLanguageIdsContext.value.split(",") : [];
				var isInputLang = false;
				for (var i = 0; i < inputLangs.length; i++) {
					if (inputLangs[i] == objLang) {
						isInputLang = true;
						break;
					}
				}
				if (!isInputLang) {
					this.onLanguageChangeDel.disconnectAll();
					this.deleteObject();
				}
			}
			]]>
		</method>	
		<!---
			@keywords private
			Gets the validation error first found in a property of this model object. All the properties
			in this model object will be searched until an error is found in a property or until all
			properties are tried. No child object will be searched.
			@return Object the first error object found in a property of this model object
		-->
		<method name="getPropertyError">
			<![CDATA[
			for (var key in this.propertyMap) {
				var errors = this.propertyMap[key].getValidationErrors();
				if (errors.length > 0) {
					return errors[0];
				}
			}
			return null;
			]]>
		</method>
		
		<!---
			@keywords private
			Add a deferred callback to check errors.
		 -->
		<method name="checkErrors">
			<![CDATA[
			if (this.openGroupObject != null && !this.openGroupObject.isGetChildrenServicesLoading()) {
				if (typeof (this.openGroupObject.checkErrorsCallbackDel) == "undefined") {
					this.openGroupObject.checkErrorsCallbackDel = new EventHandler.Class(this.openGroupObject, "checkErrorsCallback");
					this.openGroupObject.checkErrorsCallbackCount = 0;
				}
				if (this.openGroupObject.checkErrorsCallbackCount > 0) {
					CallbackUtil.Singleton.cancelCallback(this.openGroupObject.checkErrorsCallbackDel);
					this.openGroupObject.checkErrorsCallbackCount--;
				}
				this.openGroupObject.checkErrorsCallbackCount++;
				CallbackUtil.Singleton.addDeferredCallback(this.openGroupObject.checkErrorsCallbackDel);
			}
			]]>
		</method>
		<!---
			@keywords private
			Checks if there are any errors in the open group and updates the "errorInOpenGroup" and "openGroupError" attributes.
		-->	
		<method args="e" name="checkErrorsCallback">
			<![CDATA[
			if (typeof(e) == "undefined") e = null;
			var newErrorInOpenGroup = this.hasErrors();
			if (newErrorInOpenGroup != this.errorInOpenGroup) {
				this.setVariable("errorInOpenGroup", newErrorInOpenGroup);
			}
			var newOpenGroupError = this.getError();
			if (newOpenGroupError != this.openGroupError) {
				this.setVariable("openGroupError", newOpenGroupError);
			}
			]]>
		</method>

		<!---
			@keywords private
			Returns "true" if this object has any transactions
			@return boolean "true" if the object has any transactions
		-->
		<method name="hasTransaction">
			<![CDATA[
			if (Logger.Singleton.enabled) {
				Logger.Singleton.entering("com.ibm.commerce.lobtools.foundation.model", "cmc/foundation/ModelObject", "hasTransaction");
			}
			var hasTransactionBool = (this.transaction != null);
			var isVersionObject = this.getIsVersionObject();
			if (!hasTransactionBool) {
				for (var key in this.childObjectMap) {
					var o = this.childObjectMap[key];
					if (o.parentObject == this && o.openGroupObject == this.openGroupObject && (isVersionObject || !o.getIsVersionObject()) && o.hasTransaction()) {
						hasTransactionBool = true;
						break;
					}
				}
			}
			if (!hasTransactionBool) {
				for (var key in this.referenceMap) {
					var o = this.referenceMap[key];
					var oDef = o.objectDefinition;
					if ((oDef.parentReference || oDef.collectionReference) && o.openGroupObject == this.openGroupObject && o.transaction != null && (isVersionObject || !o.getIsVersionObject())) {
						hasTransactionBool = true;
						break;
					}
				}
			}
			if (Logger.Singleton.enabled) {
				Logger.Singleton.exiting("com.ibm.commerce.lobtools.foundation.model", "cmc/foundation/ModelObject", "hasTransaction", hasTransactionBool);
			}
			return hasTransactionBool;
			]]>
		</method>
		
		<!---
			@keywords private
			Adds the specified object to the list of child objects.
			@param cmc/foundation/ModelObject o the new object to be added
			@param boolean update trigger the update of child objects if "true". The default is "true".
		-->
		<method args="o, update" name="addChild">
			<![CDATA[
			if (typeof(update) == "undefined") update = true;
			if (Logger.Singleton.enabled) {
				Logger.Singleton.entering("com.ibm.commerce.lobtools.foundation.model", "cmc/foundation/ModelObject", "addChild(o, update)", [o, update]);
			}
			var key = o.objectKey;
			if (this.childObjectMap[key] != o) {
				if (typeof (this.childObjectMap[key]) == "undefined" && this.orderedChildObjectKeys.indexOf(key) == -1) {
					this.orderedChildObjectKeys.push(key);
				}
				this.childObjectMap[key] = o;
				if (o.objectDefinition.primary || o.objectDefinition.organizational) {
					o.addReference(this);
					o.updateReferenceObjectIds();
					if (this.objectDefinition.reference) {
						this.updateDisplayName();
						this.updateDisplayNameStyle();
					}
					if (this.objectDefinition.parentReference || this.objectDefinition.collectionReference) {
						this.updateAccessRight();
						this.updateReadOnly();
					}
				}
				else {
					o.parentObject = this;
					if (this.objectDefinition.primary) {
						o.parentPrimaryObject = this;
					}
					else {
						o.parentPrimaryObject = this.parentPrimaryObject;
					}
					if (!o.objectDefinition.openGroupTop) {
						o.initOpenGroupObject();
					}
					else {
						o.updateAccessRight();
						o.updateReadOnly();
					}
					if (o.newObject && o.openGroupObject != null && !o.implicitNewObject) {
						o.openGroupObject.setVariable("open", true);
						o.openGroupObject.setVariable("openGroupDirty", true);
					}
					if (o.open) {
						var po = o.getParentPrimaryObject();
						po.openChildCount++;
						if (Logger.Singleton.enabled) {
							Logger.Singleton.log("com.ibm.commerce.lobtools.foundation.model", "FINER", "cmc/foundation/ModelObject", "addChild(o, update)", "Child object: Object key=" + o.objectKey + ". Increment open child count for: Object key=" + po.objectKey + ", new open child count=" + po.openChildCount);
						}
					}
					if (o.objectDefinition.parentReleaseProtected) {
						this.referenceCount++;
						if (Logger.Singleton.enabled) {
							Logger.Singleton.log("com.ibm.commerce.lobtools.foundation.model", "FINER", "cmc/foundation/ModelObject", "addChild(o, update)", "Child object: Object key=" + o.objectKey + ". Increment reference count for: Object key=" + this.objectKey + ", new reference count=" + this.referenceCount);
						}
					}
				}
				this.childObjectListsStale = true;
				if (update) {
					this.updateChildObjects();
				}
			}
			if (Logger.Singleton.enabled) {
				Logger.Singleton.exiting("com.ibm.commerce.lobtools.foundation.model", "cmc/foundation/ModelObject", "addChild(o, update)");
			}
			]]>
		</method>
		
		<!---
			@keywords private
			Removes the specified object from the list of child objects.
			@param cmc/foundation/ModelObject o the object to remove
			@param boolean update trigger update of the child objects if "true". The default is ""true"".
		-->
		<method args="o, update" name="removeChild">
			<![CDATA[
			if (typeof(update) == "undefined") update = true;
			if (Logger.Singleton.enabled) {
				Logger.Singleton.entering("com.ibm.commerce.lobtools.foundation.model", "cmc/foundation/ModelObject", "removeChild(o, update)", [o, update]);
			}
			var key = o.objectKey;
			delete this.childObjectMap[key];
			if (o.objectDefinition.primary || o.objectDefinition.organizational) {
				o.removeReference(this);
			}
			else {
				if (o.open) {
					var po = o.getParentPrimaryObject();
					po.openChildCount--;
					if (Logger.Singleton.enabled) {
						Logger.Singleton.log("com.ibm.commerce.lobtools.foundation.model", "FINER", "cmc/foundation/ModelObject", "removeChild(o, update)", "Child object: Object key=" + o.objectKey + ". Decrement open child count for: Object key=" + po.objectKey + ", new open child count=" + po.openChildCount);
					}
				}
				o.parentObject = null;
				if (o.objectDefinition.parentReleaseProtected) {
					this.referenceCount--;
					if (Logger.Singleton.enabled) {
						Logger.Singleton.log("com.ibm.commerce.lobtools.foundation.model", "FINER", "cmc/foundation/ModelObject", "removeChild(o, update)", "Child object: Object key=" + o.objectKey + ". Decrement reference count for: Object key=" + this.objectKey + ", new reference count=" + this.referenceCount);
					}
				}
				if (this.defaultLanguageObject == o) {
					this.defaultLanguageObject = null;
				}
			}
			this.childObjectListsStale = true;
			if (update) {
				this.updateChildObjects();
			}
			if (Logger.Singleton.enabled) {
				Logger.Singleton.exiting("com.ibm.commerce.lobtools.foundation.model", "cmc/foundation/ModelObject", "removeChild(o, update)");
			}
			]]>
		</method>
		
		<!---
			@keywords private
			Updates the list of child objects to reflect changes.
			Views that are bound to the list of child objects will
			be updated.
			@param boolean immediate "true" to update the child objects immediately without a deferred callback
		-->
		<method args="immediate" name="updateChildObjects">
			<![CDATA[
			if (typeof(immediate) == "undefined") immediate = false;
			if (Logger.Singleton.enabled) {
				Logger.Singleton.entering("com.ibm.commerce.lobtools.foundation.model", "cmc/foundation/ModelObject", "updateChildObjects");
			}
			if (this.childObjectListsStale && this.lockCount == 0) {
				if (this.updateChildObjectListsCallbackCount > 0) {
					CallbackUtil.Singleton.cancelCallback(this.updateChildObjectListsDel);
					this.updateChildObjectListsCallbackCount--;
				}
				this.updateChildObjectListsCallbackCount++;
				if (immediate) {
					this.updateChildObjectLists();
				}
				else {
					CallbackUtil.Singleton.addDeferredCallback(this.updateChildObjectListsDel);
				}
			}
			if (Logger.Singleton.enabled) {
				Logger.Singleton.exiting("com.ibm.commerce.lobtools.foundation.model", "cmc/foundation/ModelObject", "updateChildObjects");
			}
			]]>
		</method>
		
		<!---
			@keywords private
			Force the update of the list of child objects. This is called when the filter condition changes for
			one of the child objects.
		-->
		<method args="e" name="updateFilteredChildObjects">
			<![CDATA[
			if (typeof(e) == "undefined") e = null;
			this.childObjectListsStale = true;
			this.updateChildObjects();
			]]>
		</method>
		
		<!---
			@keywords private
			Updates the list of child objects to reflect changes.
			Views that are bound to the list of child objects will
			be updated.
			@event onchildObjects
		-->
		<method args="e" name="updateChildObjectLists">
			<![CDATA[
			if (typeof(e) == "undefined") e = null;
			if (Logger.Singleton.enabled) {
				Logger.Singleton.entering("com.ibm.commerce.lobtools.foundation.model", "cmc/foundation/ModelObject", "updateChildObjectLists");
			}
			this.updateChildObjectListsCallbackCount--;
			if (this.childObjectListsStale) {
				this.childObjects = [];
				var filter = null;
				if (this.objectDefinition.organizational && this.objectDefinition.filters.length > 0) {
					filter = this.objectDefinition.filters[0];
					this.updateFilteredChildObjectsDel.disconnectAll();
				}
				for (var i = 0; i < this.orderedChildObjectKeys.length; i++) {
					var key = this.orderedChildObjectKeys[i];
					var o = this.childObjectMap[key];
					if (typeof (o) == "undefined") {
						this.orderedChildObjectKeys.splice(i, 1);
						i--;
					}
					else if (!o.pendingDelete && (o.objectVersionId == null || o.objectVersionId == "")) {
						if (filter != null) {
							filter.registerDelegate(o, this.updateFilteredChildObjectsDel);
							if (filter.matchesFilter(o)) {
								this.childObjects.push(o);
							}
						}
						else {
							this.childObjects.push(o);
						}
					}
				}
				if (this.childModelObjectLists) {
					var lists = this.childModelObjectLists;
					for (var i = 0; i < lists.length; i++) {
						lists[i].setVariable("modelObjects", this.childObjects);
						this.updateChildObjectListStatus(lists[i]);
					}
				}
				if (this.objectDefinition.getReferencedDefinitions() != null) {
					this.updateDisplayName();
					this.updateDisplayNameStyle();
				}
				this.childObjectListsStale = false;
				EventUtil.trigger(this, "onchildObjects", this.childObjects);
				this.validate(false);
				this.checkErrors();
				this.checkOpenGroupReadOnly();
			}
			if (Logger.Singleton.enabled) {
				Logger.Singleton.exiting("com.ibm.commerce.lobtools.foundation.model", "cmc/foundation/ModelObject", "updateChildObjectLists");
			}
			]]>
		</method>

		<!---
			@keywords private
			Updates the status of the specified model object list.
			@param cmc/foundation/ModelObjectList list
		-->
		<method args="list" name="updateChildObjectListStatus">
			<![CDATA[
			var totalRecords = 0;
			var currPageNum = 0;
			var lastPageNum = 0;
			var hasError = false;
			for (var i = 0; i < this.loadChildrenStatusObjects.length; i++) {
				var statusObject = this.loadChildrenStatusObjects[i];
				if (statusObject.service.matchesObjectDefinitions(this.objectDefinition, list.getChildObjectDefinitions())) {
					if (statusObject.hasError) {
						list.setVariable("statusObject", statusObject);
						hasError = true;
						break;
					}
					currPageNum = Math.max(currPageNum, statusObject.currPageNum);
					lastPageNum = Math.max(lastPageNum, statusObject.lastPageNum);
					totalRecords += statusObject.totalRecords;
				}
			}
			if (!hasError) {
				if (lastPageNum > 1) {
					list.setVariable("statusObject", {
						message: foundationResources.Singleton.replaceValues("serviceOverLimitMsg", [currPageNum, totalRecords]),
						messageForTree: foundationResources.Singleton.replaceValues("serviceOverLimitMsgForTree", [currPageNum, totalRecords]),
						hasError: false,
						currPageNum: currPageNum,
						lastPageNum: lastPageNum,
						pageController: this
					});
				}
				else {
					list.setVariable("statusObject", null);
				}
			}
			]]>
		</method>
				
		<!---
			@keywords private
			Finds the parent object of a given model object.
			@param object the model object whose parent is to be found.
			@return the paretn object of the given object.
		 -->
		<method args="object" name="findParentObject">
			<![CDATA[
			var o = object;
			var found = false;
			while (!found) {
				if (o.parentObject != null) {
					o = o.parentObject;
					found = true;
				}
				else {
					found = true;
					var isVersionObject = this.getIsVersionObject();
					for (var key in this.referenceMap) {
						var ref = this.referenceMap[key];
						if (typeof (ref) != "undefined" && !ref.pendingDelete && ref.objectDefinition.parentReference && (isVersionObject || !ref.getIsVersionObject())) {
							o = ref;
							found = false;
						}
					}
				}
			}
			return o;
			]]>
		</method>		
		
		<!---
			@keywords private
			Updates the object ID of this model object.
		-->
		<method args="parsing" name="updateObjectId">
			<![CDATA[
			if (typeof(parsing) == "undefined") parsing = false;
			if (Logger.Singleton.enabled) {
				Logger.Singleton.entering("com.ibm.commerce.lobtools.foundation.model", "cmc/foundation/ModelObject", "updateObjectId");
			}
			if (this.modelInitializationIdentifier != 0 && this.modelInitializationIdentifier != this.model.initializationIdentifier) {
				return;
			}
			var newObjectId = this.getPropertyValue(this.objectDefinition.idProperty);
			if (!newObjectId) {
				newObjectId = this.objectId;
			}
			var newObjectKey = this.model.getObjectKey(this.objectDefinition, newObjectId, this.objectVersionId, this.localContext);
			if (this.objectId != newObjectId || this.objectKey != newObjectKey) {
				var oldObjectKey = this.objectKey;
				this.setVariable("objectId", newObjectId);
				if (this.objectDefinition.primary || this.objectDefinition.organizational) {
					delete this.model.objectMap[oldObjectKey];
					this.model.objectMap[newObjectKey] = this;
				}
				if (!this.newObject && parsing && this.parentObject != null && this.parentObject.childObjectMap[newObjectKey] != undefined && this.parentObject.childObjectMap[newObjectKey] != this) {
					ModelUtil.Singleton.releaseModelObject(this.parentObject.childObjectMap[newObjectKey]);
				}
				if (this.parentObject) {
					var keyIndex = this.parentObject.orderedChildObjectKeys.indexOf(oldObjectKey);
					delete this.parentObject.childObjectMap[oldObjectKey];
					var dupCount = 0;
					var k = newObjectKey;
					while (this.parentObject.childObjectMap[k] != undefined && this.parentObject.childObjectMap[k] != this) {
						k = newObjectKey + "DUP_" + dupCount;
						dupCount++;
					}
					this.parentObject.childObjectMap[k] = this;
					if (k != oldObjectKey) {
						if (this.parentObject.orderedChildObjectKeys.indexOf(k) == -1) {
							this.parentObject.orderedChildObjectKeys[keyIndex] = k;
						}
						else {
							this.parentObject.orderedChildObjectKeys.splice(keyIndex, 1);
						}
					}
					newObjectKey = k;
				}
				this.setVariable("objectKey", newObjectKey);
				for (var key in this.referenceMap) {
					var o = this.referenceMap[key];
					var keyIndex = o.orderedChildObjectKeys.indexOf(oldObjectKey);
					delete o.childObjectMap[oldObjectKey];
					o.childObjectMap[newObjectKey] = this;
					if (newObjectKey != oldObjectKey) {
						if (o.orderedChildObjectKeys.indexOf(newObjectKey) == -1) {
							o.orderedChildObjectKeys[keyIndex] = newObjectKey;
						}
						else {
							o.orderedChildObjectKeys.splice(keyIndex, 1);
						}
					}
				}
				this.updateReferenceObjectIds();
			}
			if (Logger.Singleton.enabled) {
				Logger.Singleton.exiting("com.ibm.commerce.lobtools.foundation.model", "cmc/foundation/ModelObject", "updateObjectId");
			}
			]]>
		</method>
		
		<!---
			@keywords private
			Update all the reference objects' IDs that have derived ids
		-->
		<method name="updateReferenceObjectIds">
			<![CDATA[
			if (Logger.Singleton.enabled) {
				Logger.Singleton.entering("com.ibm.commerce.lobtools.foundation.model", "cmc/foundation/ModelObject", "updateReferenceObjectIds");
			}
			for (var key in this.referenceMap) {
				var o = this.referenceMap[key];
				if (!o.pendingDelete && o.objectDefinition.reference && o.objectDefinition.derivedId) {
					var propertyName = o.objectDefinition.idProperty;
					if (o.getPropertyValue(propertyName) != this.objectId) {
						var property = o.propertyMap[propertyName];
						if (property) {
							property.setVariable("value", this.objectId);
						}
						else {
							var rawData = o.rawDataPropertyMap[propertyName];
							if (!rawData) {
								rawData = {};
								o.rawDataPropertyMap[propertyName] = rawData;
								rawData.propertyReadOnly = false;
								rawData.trimmed = false;
							}
							rawData.propertyValue = this.objectId;
							o.updateObjectId();
						}
					}
				}
			}
			if (Logger.Singleton.enabled) {
				Logger.Singleton.exiting("com.ibm.commerce.lobtools.foundation.model", "cmc/foundation/ModelObject", "updateReferenceObjectIds");
			}
			]]>
		</method>

		<!---
			@keywords private
			Updates the long display name.  The long display name property is defined in the object definition.
		-->
		<method args="e" name="updateLongDisplayName">
			<![CDATA[
			if (typeof(e) == "undefined") e = null;
			this.updateLongDisplayNameDel.disconnectAll();
			var longDisplayName = null;
			if (this.objectDefinition.getReferencedDefinitions(this.updateLongDisplayNameDel) != null) {
				var o = this.getReferencedObject();
				if (o != null) {
					longDisplayName = o.objectLongDisplayName;
					this.updateLongDisplayNameDel.connect(o, "onobjectLongDisplayName");
				}
			}
			else if (this.objectDefinition.longDisplayNameProperty) {
				var prop = this.getProperty(this.objectDefinition.longDisplayNameProperty, this.objectDefinition.longDisplayNameObjectPath);
				if (prop) {
					longDisplayName = prop.value;
					this.updateLongDisplayNameDel.connect(prop, "onvalue");
				}
				else if (this.objectDefinition.longDisplayNameObjectPath) {
					this.updateLongDisplayNameDel.connect(this, "onchildObjects");
				}
				if (longDisplayName == null || longDisplayName == "") {
					if (this.newObject && typeof (this.objectDefinition.newDisplayName) != "undefined") {
						longDisplayName = this.objectDefinition.newDisplayName;
						this.updateLongDisplayNameDel.connect(this.objectDefinition, "onnewDisplayName");
						this.updateLongDisplayNameDel.connect(this, "onnewObject");
					}
					else if (typeof (this.objectDefinition.displayName) == "undefined") {
						longDisplayName = this.objectType + "_" + this.objectId;
					}
					else {
						longDisplayName = this.objectDefinition.displayName;
						this.updateLongDisplayNameDel.connect(this.objectDefinition, "ondisplayName");
					}
				}
			}
			else {
				longDisplayName = this.objectDisplayName;
				this.updateLongDisplayNameDel.connect(this, "onobjectDisplayName");
			}
			if (longDisplayName != this.objectLongDisplayName) {
				this.setVariable("objectLongDisplayName", longDisplayName);
			}
			]]>
		</method>

		
		<!---
			@keywords private
			Updates the display name. If this object has reference definition, the display name will be retrieved from the
			reference definition. Otherwise, the display name property in the object definition will be attempted. If null
			or empty string is found, a new display name will be generated.
		-->
		<method args="e" name="updateDisplayName">
			<![CDATA[
			if (typeof(e) == "undefined") e = null;
			this.updateDisplayNameDel.disconnectAll();
			var displayName = null;
			if (this.objectDefinition.getReferencedDefinitions(this.updateDisplayNameDel) != null) {
				var o = this.getReferencedObject();
				if (o != null) {
					displayName = o.objectDisplayName;
					this.updateDisplayNameDel.connect(o, "onobjectDisplayName");
				}
			}
			else if (this.objectDefinition.displayNameProperty) {
				var prop = this.getProperty(this.objectDefinition.displayNameProperty, this.objectDefinition.displayNameObjectPath);
				if (prop) {
					displayName = prop.value;
					this.updateDisplayNameDel.connect(prop, "onvalue");
				}
				else if (this.objectDefinition.displayNameObjectPath) {
					this.updateDisplayNameDel.connect(this, "onchildObjects");
				}
			}
			if (displayName == null || displayName == "") {
				if (this.newObject && typeof (this.objectDefinition.newDisplayName) != "undefined") {
					displayName = this.objectDefinition.newDisplayName;
					this.updateDisplayNameDel.connect(this.objectDefinition, "onnewDisplayName");
					this.updateDisplayNameDel.connect(this, "onnewObject");
				}
				else if (typeof (this.objectDefinition.displayName) == "undefined") {
					displayName = this.objectType + "_" + this.objectId;
					this.updateDisplayNameDel.connect(this.objectDefinition, "ondisplayName");
				}
				else {
					displayName = this.objectDefinition.displayName;
					this.updateDisplayNameDel.connect(this.objectDefinition, "ondisplayName");
				}
			}
			if (this.objectDefinition.primary && this.objectVersionId != "" && this.objectVersionId != null && displayName != null && displayName != "") {
				var prop = this.getProperty("objectVersionNumber");
				var objectVersionNumber = prop.value;
				this.updateDisplayNameDel.connect(prop, "onvalue");
				if (objectVersionNumber != null && objectVersionNumber != "") {
					displayName = foundationResources.Singleton.replaceValues("versionedObjectDisplayText", [displayName, objectVersionNumber]);
					this.updateDisplayNameDel.connect(foundationResources.Singleton.versionedObjectDisplayText, "onstring");
				}
			}
			if (this.objectDefinition.primary && this.isContextReadOnly() && displayName != null && displayName != "") {
				var workSpace = ContextUtil.Singleton.findContextValue(this, "workspaceName");
				if (workSpace != null) {
					this.updateDisplayNameDel.connect(workSpace, "onvalue");
					if (workSpace.value != null && workSpace.value != "") {
						displayName = foundationResources.Singleton.replaceValues("workspaceObjectDisplayText", [displayName, workSpace.value]);
						this.updateDisplayNameDel.connect(foundationResources.Singleton.workspaceObjectDisplayText, "onstring");
					}
					else {
						displayName = foundationResources.Singleton.replaceValues("approvedContentObjectDisplayText", [displayName]);
						this.updateDisplayNameDel.connect(foundationResources.Singleton.approvedContentObjectDisplayText, "onstring");
					}
				}
			}
			if (displayName != this.objectDisplayName) {
				this.lowerCaseDisplayName = displayName.toLowerCase();
				this.setVariable("objectDisplayName", displayName);
			}
			]]>
		</method>
		
		<!---
			@keywords private
			Returns the icon for this cmc/foundation/ModelObject instance
		-->
		<method name="getIcon">
			<![CDATA[
			var icon;
			if (this.objectDefinition.icon) {
				icon = this.objectDefinition.icon;
			}
			else if (this.getReferencedObject() && this.getReferencedObject().objectDefinition["icon"]) {
				icon = this.getReferencedObject().objectDefinition.icon;
			}
			return icon;
			]]>
		</method>

		<!---
			@keywords private
			Returns the formula icon for this cmc/foundation/ModelObject instance.
		-->
		<method name="getFormulaIcon">
			<![CDATA[
			var formulaIcon;
			if (this.objectDefinition.formulaIcon) {
				formulaIcon = this.objectDefinition.formulaIcon;
			}
			else if (this.getReferencedObject() && this.getReferencedObject().objectDefinition["formulaIcon"]) {
				formulaIcon = this.getReferencedObject().objectDefinition.formulaIcon;
			}
			return formulaIcon;
			]]>
		</method>

		<!---
			@keywords private
			Returns the type display name of the business object
			@param cmc/foundation/EventHandler del optional, if passed to this method it will register the delegate to the "ondisplayName" event of the resolved object definition.
		-->
		<method args="del" name="getTypeDisplayName">
			<![CDATA[
			var oDef = (this.objectDefinition.displayName) ? this.objectDefinition : this.getReferencedObject().objectDefinition;
			if (del) {
				del.connect(oDef, "ondisplayName");
			}
			return oDef.displayName;
			]]>
		</method>
		
		<!---
			@keywords private
			Finds a property based on given property name and object path.  Returns null if there is no object
			along the object path.
			@param String propertyName the name of the property to be found.
			@param String objectPath the path that points to the parent object of the property to be found
			@return a property whose name is the given propertyName, and whose parent object has the given objectPath
		 -->
		<method args="propertyName, objectPath" name="getProperty">
			<![CDATA[
			if (typeof(objectPath) == "undefined") objectPath = null;
			var property = null;
			var o = this;
			if (objectPath && objectPath != "") {
				o = this.getObject(objectPath, false);
			}
			if (o) {
				property = o.propertyMap[propertyName];
				if (typeof (property) == "undefined") {
					property = ModelUtil.Singleton.createModelProperty(o, propertyName);
				}
			}
			return property;
			]]>
		</method>
		
		<!---
			@keywords private
			Gets a map that contains all of the property values associated with this model object.
			@param Object map the map object to populate with the property values
			@param boolean getDirty only get the dirty properties
			@param boolean getSend only get the sendable properties
			@param string keyPrefix a prefix that will be applied to the property names before setting them
				in the map
			@param boolean trim trim the trimmable property values
			@param boolean omitEmptyProperties omit all empty properties
			@return Object a map whose keys are property names, and values are the current property values
		-->
		<method args="map, getDirty, getSend, keyPrefix, trim, omitEmptyProperties" name="getPropertyValues">
			<![CDATA[
			if (typeof(map) == "undefined") map = null;
			if (typeof(getDirty) == "undefined") getDirty = false;
			if (typeof(getSend) == "undefined") getSend = false;
			if (typeof(keyPrefix) == "undefined") keyPrefix = null;
			if (typeof(trim) == "undefined") trim = false;
			var propertyValues = map ? map : {};
			if (!getDirty) {
				for (var propertyName in this.rawDataPropertyMap) {
					var rawData = this.rawDataPropertyMap[propertyName];
					var pDef = this.objectDefinition.getPropertyDefinition(this, propertyName);
					var isEnabled = true;
					if (!pDef && this.objectDefinition.propertyDefinitions[propertyName]) {
						isEnabled = false;
					}
					if (isEnabled && (!getSend || !pDef || pDef.send)) {
						if (trim && !rawData.trimmed && pDef && pDef.trim) {
							rawData.propertyValue = StringUtil.Singleton.trim(rawData.propertyValue);
							rawData.trimmed = true;
						}
						var key = propertyName;
						if (keyPrefix) {
							key = keyPrefix + key;
						}
						if (!omitEmptyProperties || rawData.propertyValue != "") { 
							propertyValues[key] = rawData.propertyValue;
						}
					}
				}
			}
			for (var propertyName in this.propertyMap) {
				var prop = this.propertyMap[propertyName];
				var pDef = prop.propertyDefinition;
				if (prop.enabled && (!getSend || !pDef || pDef.send)) {
					if (!getDirty || prop.dirty) {
						if (trim && !prop.trimmed && pDef && pDef.trim) {
							prop.trim();
						}
						var key = propertyName;
						if (keyPrefix) {
							key = keyPrefix + key;
						}
						if (!omitEmptyProperties || prop.value != "") {
							propertyValues[key] = prop.value;
						}
					}
				}
			}
			return propertyValues;
			]]>
		</method>
		
		<!---
			@keywords private
			Gets an array of properties objects that match the specified property name and
			object path.
			@param string propertyName the property name
			@param string objectPath the object path of the property's parent object
			@return array an array of cmc/foundation/ModelProperty objects
		-->
		<method args="propertyName, objectPath" name="getProperties">
			<![CDATA[
			if (Logger.Singleton.enabled) {
				Logger.Singleton.entering("com.ibm.commerce.lobtools.foundation.model", "cmc/foundation/ModelObject", "getProperties(propertyName, objectPath)", [propertyName, objectPath]);
			}
			var properties = [];
			var objects = this.getObjects(objectPath);
			for (var i = 0; i < objects.length; i++) {
				var o = objects[i];
				var prop = o.propertyMap[propertyName];
				if (typeof (prop) == "undefined") {
					prop = ModelUtil.Singleton.createModelProperty(o, propertyName);
				}
				properties.push(prop);
			}
			if (Logger.Singleton.enabled) {
				Logger.Singleton.exiting("com.ibm.commerce.lobtools.foundation.model", "cmc/foundation/ModelObject", "getProperties(propertyName, objectPath)", properties);
			}
			return properties;
			]]>
		</method>

		<!---
			@keywords private
			Discards any unsaved changes for this object.
		-->		
		<method name="discardChanges">
			<![CDATA[
			if (Logger.Singleton.enabled) {
				Logger.Singleton.entering("com.ibm.commerce.lobtools.foundation.model", "cmc/foundation/ModelObject", "discardChanges");
			}
			if (this.newObject) {
				ModelUtil.Singleton.releaseModelObject(this);
			}
			else {
				for (var key in this.propertyMap) {
					this.propertyMap[key].restore();
				}
				var updateChildObjects = false;
				for (var key in this.childObjectMap) {
					var o = this.childObjectMap[key];
					if (o.parentObject == this && o.openGroupObject == this.openGroupObject && !o.getIsVersionObject()) {
						if (o.pendingDelete) {
							if (this.openGroupObject.messagesLogged) {
								this.addPropertyLogMessages();
							}
							o.pendingDelete = false;
							updateChildObjects = true;
						}
						o.discardChanges();
					}
				}
				if (updateChildObjects) {
					this.childObjectListsStale = true;
					this.updateChildObjects();
				}
				var updateReferences = false;
				for (var key in this.referenceMap) {
					var o = this.referenceMap[key];
					var oDef = o.objectDefinition;
					if ((oDef.parentReference || oDef.collectionReference) && o.openGroupObject == this.openGroupObject && !o.getIsVersionObject()) {
						if (o.newObject) {
							ModelUtil.Singleton.releaseModelObject(o);
						}
						else {
							for (var key in o.propertyMap) {
								o.propertyMap[key].restore();
							}
							if (o.pendingDelete) {
								if (this.openGroupObject.messagesLogged) {
									this.addPropertyLogMessages();
								}
								o.pendingDelete = false;
								updateReferences = true;
								if (o.parentObject != null) {
									o.parentObject.childObjectListsStale = true;
									o.parentObject.updateChildObjects();
								}
							}
						}
					}
				}
				if (this.isOpenGroupObject()) {
					this.openGroupObject.setVariable("openGroupDirty", false);
				}
				if (updateReferences) {
					this.referenceListsStale = true;
					this.updateReferences();
				}
			}
			if (Logger.Singleton.enabled) {
				Logger.Singleton.exiting("com.ibm.commerce.lobtools.foundation.model", "cmc/foundation/ModelObject", "discardChanges");
			}
			]]>
		</method>
		
		<!---
			Gets the value of a property with the given property name and object path to its parent object.
			@param String propertyName the name of the proprety whose value is to be found
			@param String objectPath the path of the property's parent object
			@param boolean trim trim the property value before returning it
			@return Object The value of the found property. If the property is not {@link cmc/foundation/ModelProperty#enabled enabled}, an empty string is returned.
		 -->
		<method args="propertyName, objectPath, trim" name="getPropertyValue">
			<![CDATA[
			if (typeof(objectPath) == "undefined") objectPath = null;
			if (typeof(trim) == "undefined") trim = false;
			var value = null;
			var o = this;
			if (objectPath && objectPath != "") {
				o = this.getObject(objectPath, false);
			}
			if (o) {
				if (o.propertyMap[propertyName]) {
					var prop = o.propertyMap[propertyName];
					if (trim && !prop.trimmed && prop.propertyDefinition && prop.propertyDefinition.trim) {
						prop.trim();
					}
					value = (prop.enabled) ? prop.value : "";
				}
				else if (o.rawDataPropertyMap[propertyName]) {
					var rawData = o.rawDataPropertyMap[propertyName];
					var pDef = o.objectDefinition.getPropertyDefinition(o, propertyName);
					if (trim && !rawData.trimmed && pDef && pDef.trim) {
						rawData.propertyValue = StringUtil.Singleton.trim(rawData.propertyValue);
						rawData.trimmed = true;
					}
					var isEnabled = true;
					if (!pDef && o.objectDefinition.propertyDefinitions[propertyName]) {
						isEnabled = false;
					}
					value = (isEnabled) ? rawData.propertyValue : "";
				}
				else {
					value = "";
				}
			}
			return value;
			]]>
		</method>

		<!---
			Sets the value of the property that matches the given property name and path to its parent object.
			@param String propertyName the name of the property whose value is to be set
			@param String objectPath the path to the property's parent object
			@param String value the value to be set to the property
		 -->
		<method args="propertyName, objectPath, value" name="setPropertyValue">
			<![CDATA[
			var property = this.getProperty(propertyName, objectPath);
			property.change(value);
			]]>
		</method>
		
		<!---
			@keywords private
			For all properties defined in this object's definition, apply the default values
			to this object if they have been specified by {@link cmc/foundation/PropertyValue#isDefault}.
		-->
		<method args="e" name="setDefaultPropertyValues">
			<![CDATA[
			if (typeof(e) == "undefined") e = null;
			this.setDefaultPropertyValuesDel.disconnectAll();
			for (var key in this.objectDefinition.propertyDefinitions) {
				var propDef = this.objectDefinition.getPropertyDefinition(this, key);
				var defaultValue = propDef ? propDef.getDefaultPropertyValue(this, this.setDefaultPropertyValuesDel) : null;
				if (defaultValue != null && defaultValue.value != "") {
					var property = this.propertyMap[propDef.propertyName];
					if (property) {
						if (!property.dirty && property.value == "") {
							property.setVariable("value", defaultValue.value);
						}
					}
					else {
						var rawData = this.rawDataPropertyMap[propDef.propertyName];
						if (!rawData) {
							rawData = {};
							this.rawDataPropertyMap[propDef.propertyName] = rawData;
							rawData.propertyReadOnly = null;
							rawData.trimmed = false;
							rawData.propertyValue = defaultValue.value;
							EventUtil.trigger(this, "propertyChanged");
						}
					}
				}
			}
			]]>
		</method>
		
		<!---
			Gets the boolean value indicating if a property is read only for the property with the given 
			property name and object path to its parent object.
			@param String propertyName the name of the proprety whose value is to be found
			@param String objectPath the path of the property's parent object		
			@return boolean The boolean value of the found property's read only state. 
		 -->
		<method args="propertyName, objectPath" name="getPropertyReadOnly">
			<![CDATA[
			if (typeof(objectPath) == "undefined") objectPath = null;
			var readOnly = false;
			var o = this;
			if (objectPath && objectPath != "") {
				o = this.getObject(objectPath, false);
			}
			if (o) {
				if (o.readOnly) {
					readOnly = true;
				}
				else {
					if (o.propertyMap[propertyName]) {
						var prop = o.propertyMap[propertyName];
						readOnly = prop.propertyReadOnly == "true";
					}
					else if (o.rawDataPropertyMap[propertyName]) {
						var rawData = o.rawDataPropertyMap[propertyName];
						readOnly = rawData.propertyReadOnly == "true";
						var isEnabled = true;
						if (o.objectDefinition.propertyDefinitions[propertyName] && !o.objectDefinition.getPropertyDefinition(o, propertyName)) {
							isEnabled = false;
						}
						readOnly = !isEnabled || readOnly;
					}
				}
			}
			return readOnly;
			]]>
		</method>	
		
		<!---
			Gets the child object that matches the specified object path. This method allows the optional creation of new object if no existing
			object matches the given object path.
			@param string objectPath the object path that the returned object matches. If objectPath is null, this model object will be returned.
			@param boolean create if "true", then create object if object is not found for objectPath.
			@param cmc/foundation/ModelObject descendant optional object instance used to choose between multiple possible objects paths. The resulting object must be an ancestor of this decendant if it is not null.
			@param cmc/foundation/EventHandler delegate Optional {@link cmc/foundation/EventHandler delegate instance}. If this delegate and the given objectPath are not null, register this delegate to the event onchildObjects to each object found when seaching down the given objectPath.
			@param boolean triggerLoadChildren: if "true", load the child objects required to resolve the specified object path
			@return cmc/foundation/ModelObject the first matching object
		-->
		<method args="objectPath, create, descendant, delegate, triggerLoadChildren" name="getObject">
			<![CDATA[
			if (typeof(create) == "undefined") create = false;
			if (typeof(descendant) == "undefined") descendant = null;
			if (typeof(delegate) == "undefined") delegate = null;
			if (typeof(triggerLoadChildren) == "undefined") triggerLoadChildren = false;
			var o = null;
			var objects = this.getObjects(objectPath, delegate, descendant, true, triggerLoadChildren);
			if (objects.length > 0) {
				o = objects[0];
			}
			else if (create) {
				if (delegate) {
					delegate.disable();
				}
				var o = this;
				var newObjects = false;
				var types = objectPath.split("/");
				for (var i = 0; i < types.length && o != null; i++) {
					var type = types[i];
					var parentO = o;
					if (newObjects && delegate) {
						delegate.connect(parentO, "onchildObjects");
					}
					o = null;
					if (!newObjects) {
						o = parentO.getObject(type, false, descendant);
					}
					if (o == null) {
						newObjects = true;
						var pathSelector = ModelUtil.Singleton.getPathSelectors(type)[0];
						var objectDef = this.model.getObjectDefinition(parentO, pathSelector.type);
						if (objectDef && !objectDef.primary && !objectDef.reference) {
							o = this.model.createNewObject(objectDef, parentO, true, null, true);
							ModelUtil.Singleton.applySelectors(o, pathSelector.selectors);
						}
					}
				}
				if (delegate) {
					delegate.enable();
				}
			}
			return o;
			]]>
		</method>
		
		<!---
			Gets all the child objects that match the specified object path.
			@param string objectPath the object path
			@param cmc/foundation/EventHandler delegate Optional {@link cmc/foundation/EventHandler delegate instance}. If this delegate and the given objectPath are not null, register this delegate to the event onchildObjects to each object found when seaching down the given objectPath.
			@param cmc/foundation/ModelObject descendant optional object instance used to choose between multiple possible objects paths. The resulting object must be an ancestor of this decendant if it is not null.
			@param boolean defaultLanguage: if "true", if the child object is not language sensitive, and if there are no selectors in the path selector,
											then the default language child object is returned
			@param boolean triggerLoadChildren: if "true", load the child objects required to resolve the specified object path
			@return cmc/foundation/ModelObject[] an array of cmc/foundation/ModelObject instances that match the specified object path
		-->
		<method args="objectPath, delegate, descendant, defaultLanguage, triggerLoadChildren" name="getObjects">
			<![CDATA[
			if (typeof(delegate) == "undefined") delegate = null;
			if (typeof(descendant) == "undefined") descendant = null;
			if (typeof(defaultLanguage) == "undefined") defaultLanguage = false;
			if (typeof(triggerLoadChildren) == "undefined") triggerLoadChildren = false;
			if (Logger.Singleton.enabled) {
				Logger.Singleton.entering("com.ibm.commerce.lobtools.foundation.model", "cmc/foundation/ModelObject", "getObjects(parentObject, pathSelector, descendant, defaultLanguage, triggerLoadChildren)", [this.parentObject, pathSelector, descendant, defaultLanguage, triggerLoadChildren]);
			}
			if (delegate) {
				delegate.disable();
			}
			var matchingObjects = [];
			if (objectPath) {
				matchingObjects.push(this);
				var pathSelectors = ModelUtil.Singleton.getPathSelectors(objectPath);
				for (var i = 0; i < pathSelectors.length; i++) {
					var pathSelector = pathSelectors[i];
					var parentObjects = matchingObjects;
					matchingObjects = [];
					for (var j = 0; j < parentObjects.length; j++) {
						if (delegate) {
							delegate.connect(parentObjects[j], "onchildObjects");
						}
						if (parentObjects[j].unparsedObjects != null) {
							parentObjects[j].parseObjects(true, pathSelector.type);
						}
						var objects = this.model.getObjects(parentObjects[j], pathSelector, descendant, defaultLanguage);
						while (objects.length > 0) {
							matchingObjects.push(objects.shift());
						}
						if (triggerLoadChildren) {
							var oDefs = parentObjects[j].objectDefinition.getChildDefinitions(pathSelector.type);
							if (oDefs.length > 0) {
								parentObjects[j].loadChildren(oDefs, false, false, true);
							}
						}
					}
					if (descendant != null && matchingObjects.length == 0) {
						descendant = null;
						for (var j = 0; j < parentObjects.length; j++) {
							var objects = this.model.getObjects(parentObjects[j], pathSelector, null, defaultLanguage);
							while (objects.length > 0) {
								matchingObjects.push(objects.shift());
							}
						}
					}
				}
			}
			else {
				matchingObjects.push(this);
			}
			if (delegate) {
				delegate.enable();
			}
			if (Logger.Singleton.enabled) {
				Logger.Singleton.exiting("com.ibm.commerce.lobtools.foundation.model", "cmc/foundation/ModelObject", "getObjects(parentObject, pathSelector, descendant, defaultLanguage)", matchingObjects);
			}
			return matchingObjects;
			]]>
		</method>

		<!---
			Gets the parent primary object for this object. The parent primary object
			is the closest primary object in the current object's hierarchy.
			If "parentType" is specified, then the search will continue until
			a matching primary object is found.
			@param string parentType optional parent object type.
			@param cmc/foundation/EventHandler del optional, if passed to this method it will register the delegate to the "onreferencesLoaded" event and load references
			@return cmc/foundation/ModelObject the parent primary object
		-->
		<method args="parentType, del" name="getParentPrimaryObject">
			<![CDATA[
			if (typeof(parentType) == "undefined") parentType = null;
			if (typeof(del) == "undefined") del = null;
			if (Logger.Singleton.enabled) {
				Logger.Singleton.entering("com.ibm.commerce.lobtools.foundation.model", "cmc/foundation/ModelObject", "getParentPrimaryObject()");
			}
			var o = null;
			if (this.parentObject != null) {
				o = this.parentPrimaryObject;
			}
			else {
				var isVersionObject = this.getIsVersionObject();
				for (var key in this.referenceMap) {
					var ref = this.referenceMap[key];
					if (!ref.pendingDelete && ref.objectDefinition.parentReference && (isVersionObject || !ref.getIsVersionObject())) {
						o = ref;
						break;
					}
				}
				if (del) {
					del.connect(this, "onreferences");
				}
				if (o != null) {
					o = o.getParentPrimaryObject(null, del);
				}
			}
			if (o != null && parentType != null && !o.objectDefinition.matchesType(parentType)) {
				o = o.getParentPrimaryObject(parentType, del);
			}
			else if (o == null && !this.referencesLoaded && del) {
				del.connect(this, "onreferencesLoaded");
				this.loadReferences();
			}
			if (Logger.Singleton.enabled) {
				Logger.Singleton.exiting("com.ibm.commerce.lobtools.foundation.model", "cmc/foundation/ModelObject", "getParentPrimaryObject()", [o]);
			}
			return o;
			]]>
		</method>
		
		<!---
			Gets all the parent primary objects linked by collection reference to this object. 
			@return cmc/foundation/ModelObject[] an array of cmc/foundation/ModelObject instances
		-->
		<method name="getCollectionPrimaryObjects">
			<![CDATA[
			if (Logger.Singleton.enabled) {
				Logger.Singleton.entering("com.ibm.commerce.lobtools.foundation.model", "cmc/foundation/ModelObject", "getCollectionPrimaryObjects()");
			}
			var collectionObjects = [];
			var isVersionObject = this.getIsVersionObject();
			for (var key in this.referenceMap) {
				var ref = this.referenceMap[key];
				if (!ref.pendingDelete && ref.objectDefinition.collectionReference && (isVersionObject || !ref.getIsVersionObject())) {
					collectionObjects.push(ref.getParentPrimaryObject());
				}
			}
			if (Logger.Singleton.enabled) {
				Logger.Singleton.exiting("com.ibm.commerce.lobtools.foundation.model", "cmc/foundation/ModelObject", "getCollectionPrimaryObjects()");
			}
			return collectionObjects;
			]]>
		</method>
		
		<!---
			@keywords private
			Returns "true" if all the references are loaded up to a certain parent type if it is there.
			@param string parentType optional parent object type or object group.
			@return boolean "true" if all the references are loaded
		-->
		<method args="parentType" name="isParentLoaded">
			<![CDATA[
			if (Logger.Singleton.enabled) {
				Logger.Singleton.entering("com.ibm.commerce.lobtools.foundation.model", "cmc/foundation/ModelObject", "isParentLoaded()");
			}
			var allReferencesLoaded = false;
			if (this.referencesLoaded && parentType) {
				var o = null;
				if (this.parentObject != null) {
					o = this.parentObject;
					while (o.parentObject != null) {
						o = o.parentObject;
					}
				}
				else {
					var isVersionObject = this.getIsVersionObject();
					for (var key in this.referenceMap) {
						var ref = this.referenceMap[key];
						if (!ref.pendingDelete && ref.objectDefinition.parentReference && (isVersionObject || !ref.getIsVersionObject())) {
							o = ref;
							break;
						}
					}
					if (o != null) {
						o = o.getParentPrimaryObject();
					}
				}
				if (o == null || o.objectDefinition.matchesType(parentType)) {
					allReferencesLoaded = true;
				}
				else {
					allReferencesLoaded = o.isParentLoaded(parentType);
				}
			}
			else if (this.referencesLoaded) {
				allReferencesLoaded = true;
			}
			if (Logger.Singleton.enabled) {
				Logger.Singleton.exiting("com.ibm.commerce.lobtools.foundation.model", "cmc/foundation/ModelObject", "isParentLoaded()", [allReferencesLoaded]);
			}
			return allReferencesLoaded;
			]]>
		</method>
		
		<!---
			@keywords private
			Sets the open attribute of this model object to the given new state.
			@param cmc/foundation/State the new state to assign to the open attribute
			@event onopen will be sent if this event exists
		 -->
		<method args="newState" name="setOpen">
			<![CDATA[
			if (Logger.Singleton.enabled) {
				Logger.Singleton.entering("com.ibm.commerce.lobtools.foundation.model", "cmc/foundation/ModelObject", "setOpen(newState)", [newState]);
			}
			if (this.testObject) {
				this.open = false;
			}
			else if (typeof (this.open) == "undefined" || this.open != newState) {
				this.open = newState;
				EventUtil.trigger(this, "onopen", this);
				if (this.parentObject != null) {
					var po = this.getParentPrimaryObject();
					if (this.open) {
						po.openChildCount++;
						if (Logger.Singleton.enabled) {
							Logger.Singleton.log("com.ibm.commerce.lobtools.foundation.model", "FINER", "cmc/foundation/ModelObject", "setOpen(newState)", "Model object: Object key=" + this.objectKey + ". Increment open child count for: Object key=" + po.objectKey + ", new open child count=" + po.openChildCount);
						}
					}
					else {
						po.openChildCount--;
						if (Logger.Singleton.enabled) {
							Logger.Singleton.log("com.ibm.commerce.lobtools.foundation.model", "FINER", "cmc/foundation/ModelObject", "setOpen(newState)", "Model object: Object key=" + this.objectKey + ". Decrement open child count for: Object key=" + po.objectKey + ", new open child count=" + po.openChildCount);
						}
					}
				}
				this.loadLanguageSensitiveChildrenDel.disconnectAll();
				if (this.open) {
					this.setHasReleasableChildren();
					this.lastViewedTime = (new Date()).getTime();
					this.model.addOpenObject(this);
					ContextUtil.Singleton.findContextValue(this, "inputLanguageIds", this.loadLanguageSensitiveChildrenDel);
				}
				else {
					this.viewState = "";
					this.viewed = false;
					this.lastViewedTime = 0;
					this.model.removeOpenObject(this);
				}
				this.updateLogMessages();
			}
			if (Logger.Singleton.enabled) {
				Logger.Singleton.exiting("com.ibm.commerce.lobtools.foundation.model", "cmc/foundation/ModelObject", "setOpen(newState)");
			}
			]]>
		</method>
		
		<!---
			@keywords private
			Loads this object's language sensitive children when the selected input languages change.
		-->
		<method args="e" name="loadLanguageSensitiveChildren">
			<![CDATA[
			if (typeof(e) == "undefined") e = null;
			this.loadChildren(this.objectDefinition.getOpenGroupObjectDefinitions());
			]]>
		</method>

		<!---
			@keywords private
			Adds the specified object to the list of objects that reference
			this object.
			@param cmc/foundation/ModelObject o the new reference object to be added
			@param boolean update trigger update of all the reference objects if "true". The default is "true".
		-->
		<method args="o, update" name="addReference">
			<![CDATA[
			if (typeof(update) == "undefined") update = true;
			if (Logger.Singleton.enabled) {
				Logger.Singleton.entering("com.ibm.commerce.lobtools.foundation.model", "cmc/foundation/ModelObject", "addReference(o, update)", [o, update]);
			}
			var key = o.getUID();
			var isVersionObject = this.getIsVersionObject();
			if (this.referenceMap[key] != o) {
				this.referenceMap[key] = o;
				var oDef = o.objectDefinition;
				if (oDef.parentReference || oDef.collectionReference) {
					for (var mapKey in this.referenceMap) {
						var ref = this.referenceMap[mapKey];
						if (o == ref || !ref.objectDefinition.parentReference || (!isVersionObject && o.getIsVersionObject())) {
							continue;
						}
						var refParent = ref.parentObject;
						if (o.newObject) {
							if (!ref.newObject) {
								ref.setVariable("pendingDelete", true);
							}
							else {
								delete this.referenceMap[mapKey];
								ModelUtil.Singleton.releaseModelObject(ref);
							}
						}
						else {
							if (!ref.newObject) {
								o.setVariable("pendingDelete", ref.pendingDelete);
								delete this.referenceMap[mapKey];
								ModelUtil.Singleton.releaseModelObject(ref);
							}
							else {
								o.setVariable("pendingDelete", true);
							}
						}
						refParent.childObjectListsStale = true;
						refParent.updateChildObjects();
					}
					o.initOpenGroupObject();
					if (o.newObject && o.openGroupObject != null) {
						o.openGroupObject.setVariable("open", true);
						o.openGroupObject.setVariable("openGroupDirty", true);
					}
				}
				this.referenceListsStale = true;
				if (update) {
					this.updateReferences();
				}
			}
			if (Logger.Singleton.enabled) {
				Logger.Singleton.exiting("com.ibm.commerce.lobtools.foundation.model", "cmc/foundation/ModelObject", "addReference(o, update)");
			}
			]]>
		</method>
		
		<!---
			@keywords private
			Removes the specified object from the list of objects that reference
			this object.
			@param cmc/foundation/ModelObject o The object to remove.
			@param boolean update Trigger update of all the reference objects if "true". The default is "true" if undefined.
		-->
		<method args="o, update" name="removeReference">
			<![CDATA[
			if (typeof(update) == "undefined") update = true;
			if (Logger.Singleton.enabled) {
				Logger.Singleton.entering("com.ibm.commerce.lobtools.foundation.model", "cmc/foundation/ModelObject", "removeReference(o, update)", [o, update]);
			}
			delete this.referenceMap[o.getUID()];
			this.referenceListsStale = true;
			this.referencesStale = true;
			if (update) {
				this.updateReferences();
			}
			if (Logger.Singleton.enabled) {
				Logger.Singleton.exiting("com.ibm.commerce.lobtools.foundation.model", "cmc/foundation/ModelObject", "removeReference(o, update)");
			}
			]]>
		</method>
		
		<!---
			@keywords private
			Updates the list of objects that reference this object.
			@param boolean immediate "true" to update the references immediately without a deferred callback
		-->
		<method args="immediate" name="updateReferences">
			<![CDATA[
			if (typeof(immediate) == "undefined") immediate = false;
			if (this.referenceListsStale && this.lockCount == 0) {
				if (this.updateReferencesListsCallbackCount > 0) {
					CallbackUtil.Singleton.cancelCallback(this.updateReferencesListsDel);
					this.updateReferencesListsCallbackCount--;
				}
				this.updateReferencesListsCallbackCount++;
				if (immediate) {
					this.updateReferencesLists();
				}
				else {
					CallbackUtil.Singleton.addDeferredCallback(this.updateReferencesListsDel);
				}
			}
			]]>
		</method>
		
		<!---
			@keywords private
			Updates the list of objects that reference this object immediately
			@event onreferences
		-->
		<method args="e" name="updateReferencesLists">
			<![CDATA[
			if (typeof(e) == "undefined") e = null;
			this.updateReferencesListsCallbackCount--;
			if (this.referenceListsStale) {
				this.references = [];
				for (var key in this.referenceMap) {
					var o = this.referenceMap[key];
					if (!o.pendingDelete && (o.parentPrimaryObject == null || o.parentPrimaryObject.objectVersionId == null || o.parentPrimaryObject.objectVersionId == "")) {
						this.references.unshift(o);
					}
				}
				var bindings = this.referenceListBindings;
				for (var i = 0; i < bindings.length; i++) {
					this.updateReferenceListBinding(bindings[i]);
				}
				this.referenceListsStale = false;
				EventUtil.trigger(this, "onreferences", this.references);
				this.validate(false);
				this.checkErrors();
				this.checkOpenGroupReadOnly();
			}
			]]>
		</method>
		
		<!---
			@keywords private
			Get the list of references that match the specified type.
			@param string type: the object type
			@return array: array of cmc/foundation/ModelObject instances
		-->
		<method args="type" name="getReferences">
			<![CDATA[
			var matchingObjects = [];
			for (var i = 0; i < this.references.length; i++) {
				var o = this.references[i];
				if (o.objectDefinition.matchesType(type)) {
					matchingObjects.push(o);
				}
			}
			return matchingObjects;
			]]>
		</method>
		
		<!---
			@keywords private
			This method is called when an intermediate object associated with a reference list binding triggers its "onreferences"
			event. This means that the reference lists for this object need to be recalculated.
			@param cmc/foundation/ModelObject o: the model object to release
		-->
		<method args="e" name="updateIntermediateReferences">
			<![CDATA[
			if (typeof(e) == "undefined") e = null;
			this.referenceListsStale = true;
			this.updateReferences();
			]]>
		</method>
		
		<!---
			@keywords private
			Release the specified intermediate object associated with a reference list binding.
			@param cmc/foundation/ModelObject o: the model object to release
		-->
		<method args="o" name="releaseIntermediateObject">
			<![CDATA[
			var bindings = this.referenceListBindings;
			for (var i = 0; i < bindings.length; i++) {
				var binding = bindings[i];
				binding.updateIntermediateReferencesDel.disconnectAll();
				binding.releaseIntermediateObjectDel.disconnectAll();
				var objects = binding.intermediateObjects;
				for (var j = 0; j < objects.length; j++) {
					if (objects[j] == o) {
						o.referenceCount--;
						objects.splice(j, 1);
						j--;
					}
					else {
						binding.updateIntermediateReferencesDel.connect(objects[j], "onreferences");
						binding.releaseIntermediateObjectDel.connect(objects[j], "beingDestroyed");
					}
				}
			}
			]]>
		</method>
		
		<!---
			@keywords private
			Release all the intermediate objects for the specified reference list binding.
			@param cmc/foundation/ModelObject o: the model object to release
		-->
		<method args="binding" name="releaseIntermediateObjects">
			<![CDATA[
			binding.updateIntermediateReferencesDel.disconnectAll();
			binding.releaseIntermediateObjectDel.disconnectAll();
			var objects = binding.intermediateObjects;
			while (objects.length > 0) {
				var o = objects.shift();
				o.referenceCount--;
			}
			]]>
		</method>
		
		<!---
			@keywords private
			Refreshes a list view that is bound to this object's references.
		-->
		<method args="binding" name="updateReferenceListBinding">
			<![CDATA[
			this.releaseIntermediateObjects(binding);
			var intermediateObjects = [];
			var listObjects = [];
			var statusObject = null;
			if (binding.paths) {
				for (var i = 0; i < binding.paths.length; i++) {
					var types = binding.paths[i];
					if (statusObject == null) {
						for (var j = 0; j < this.loadReferencesStatusObjects.length; j++) {
							var messageObject = this.loadReferencesStatusObjects[j];
							if (messageObject.service.matchesObjectTypes(this.objectDefinition, types)) {
								statusObject = messageObject;
								break;
							}
						}
					}
					if (types.length > 0) {
						var type = types[0];
						var matchingObjects = this.getReferences(type);
						for (var j = 1; j < types.length; j++) {
							type = types[j];
							var childObjects = matchingObjects;
							matchingObjects = [];
							for (var k = 0; k < childObjects.length; k++) {
								var o = childObjects[k];
								if (o.parentObject != null) {
									if (o.parentObject.objectDefinition.matchesType(type)) {
										if (type == "*") {
											var nextType = j + 1 < types.length ? types[j + 1] : null;
											while (true) {
												if (nextType != null && o.parentObject.objectDefinition.matchesType(nextType)) {
													matchingObjects.push(o);
													break;
												}
												o = o.parentObject;
												if (o.parentObject == null) {
													matchingObjects.push(o);
													break;
												}
											}
										}
										else {
											matchingObjects.push(o.parentObject);
										}
									}
								}
								else {
									if (j < types.length - 1 && intermediateObjects.indexOf(o) == -1) {
										intermediateObjects.push(o);
										o.referenceCount++;
										binding.updateIntermediateReferencesDel.connect(o, "onreferences");
										binding.releaseIntermediateObjectDel.connect(o, "beingDestroyed");
										o.loadReferences();
										if (statusObject == null && o.loadReferencesStatusObjects.length > 0) {
											var intermediateObjectTypes = types.slice(j);
											for (var l = 0; l < o.loadReferencesStatusObjects.length; l++) {
												if (o.loadReferencesStatusObjects[l].service.matchesObjectTypes(o.objectDefinition, intermediateObjectTypes)) {
													statusObject = o.loadReferencesStatusObjects[l];
													break;
												}
											}
										}
									}
									var parentObjects = o.getReferences(type);
									while (parentObjects.length > 0) {
										matchingObjects.push(parentObjects.shift());
									}
								}
							}
						}
						while (matchingObjects.length > 0) {
							var o = matchingObjects.shift();
							if (listObjects.indexOf(o) == -1) {
								listObjects.push(o);
							}
						}
					}
				}
			}
			binding.intermediateObjects = intermediateObjects;
			binding.list.setVariable("modelObjects", listObjects);
			binding.list.setVariable("statusObject", statusObject);
			]]>
		</method>
		
		<!---
			Gets the object being referenced by this reference object. Null will be returned if no reference is found, or if
			this model object is not a reference object.
			@return cmc/foundation/ModelObject the model object referenced by this model object.
		-->
		<method name="getReferencedObject" args="del">
			<![CDATA[
			var o = this.referencedObject;
			if (o == null && this.objectDefinition != null) {
				o = this;
				var referencedDefinitions = this.objectDefinition.getReferencedDefinitions(del);
				if (referencedDefinitions != null) {
					var i = 0;
					var referencedObject = null;
					while (!referencedObject && i < referencedDefinitions.length) {
						if (referencedDefinitions[i] != null) {
							referencedObject = o.getObject(referencedDefinitions[i].objectType);
						}
						i++;
					}
					o = referencedObject;
				}
				this.referencedObject = o;
			}
			return o;
			]]>
		</method>

		<!---
			@keywords private
			Makes a new cmc/foundation/ModelObject that is a copy of this with the specified parent.
			@param cmc/foundation/ModelObject parent optional parent object for the newly created copy
			@return cmc/foundation/ModelObject A copy of this with the specified parent.
		-->
		<method args="parent" name="copy">
			<![CDATA[
			return this.model.createNewObject(this.objectDefinition, parent, false, this);
			]]>
		</method>
		
		<!---
			@keywords private
			Adds the specified transaction to the list of pending transactions.
			@param cmc/foundation/ServiceTransaction t Pending Transaction
		-->
		<method args="t" name="addPendingTransaction">
			<![CDATA[
			if (Logger.Singleton.enabled) {
				Logger.Singleton.log("com.ibm.commerce.lobtools.foundation.model", "FINER", "cmc/foundation/ModelObject", "addPendingTransaction", t.service.url);
			}
			t.deferred = true;
			this.pendingTransactions.push(t);
			]]>
		</method>
		
		<!---
			@keywords private
			Triggers any pending transactions.
		-->
		<method name="triggerPendingTransactions">
			<![CDATA[
			if (Logger.Singleton.enabled) {
				Logger.Singleton.log("com.ibm.commerce.lobtools.foundation.model", "FINER", "cmc/foundation/ModelObject", "triggerPendingTransactions", this.objectType + this.objectId);
			}
			var transactions = this.pendingTransactions;
			this.pendingTransactions = [];
			while (transactions.length > 0) {
				ServiceTransactionUtil.Singleton.addPendingTransaction(transactions.shift());
			}
			]]>
		</method>

		<!---
			@keywords private
			Gets the language sensitive child object that matches
			the default language.
			@return cmc/foundation/ModelObject the default language object
		-->
		<method name="getDefaultLanguageObject">
			<![CDATA[
			if (this.defaultLanguageObject == null) {
				var defaultLanguageIdContext = ContextUtil.Singleton.findContextValue(this, "defaultLanguageId");
				var defaultLanguageId = ((defaultLanguageIdContext != null) ? defaultLanguageIdContext.value : "");
				for (var key in this.childObjectMap) {
					var o = this.childObjectMap[key];
					if (!o.pendingDelete && o.objectDefinition.languageSensitive) {
						var languageId = o.getPropertyValue("languageId");
						if (languageId != "" && languageId == defaultLanguageId) {
							this.defaultLanguageObject = o;
							break;
						}
					}
				}
			}
			return this.defaultLanguageObject;
			]]>
		</method>
		
		<!---
			@keywords private
			Discards and rolls back any pending transactions.
		-->
		<method name="discardPendingTransactions">
			<![CDATA[
			var transactions = this.pendingTransactions;
			this.pendingTransactions = [];
			while (transactions.length > 0) {
				var t = transactions.shift();
				ServiceTransactionUtil.Singleton.rollback(t);
			}
			]]>
		</method>
		
		<!---
			Load the specified page of child objects.
		-->
		<method args="args" name="doLoadPage">
			<![CDATA[
			this.model.refreshDescendants(this, true, args.oList.getChildObjectDefinitions(), args.pageNum);
			]]>
		</method>
		
		<!---
			@keywords private
			Returns "true" if the specified object is an ancestor of this object.
			@return "true" if the object is an ancestor. False otherwise.
		-->
		<method args="o" name="isAncestor">
			<![CDATA[
			if (Logger.Singleton.enabled) {
				Logger.Singleton.entering("com.ibm.commerce.lobtools.foundation.model", "cmc/foundation/ModelObject", "isAncestor(o)", [o]);
			}
			var ancestor = false;
			if (o != null && this != o) {
				var parentO = this.parentObject ? this.parentObject : this.getParentPrimaryObject();
				while (parentO != null) {
					if (parentO == o) {
						ancestor = true;
						break;
					}
					parentO = parentO.parentObject ? parentO.parentObject : parentO.getParentPrimaryObject();
				}
			}
			if (Logger.Singleton.enabled) {
				Logger.Singleton.exiting("com.ibm.commerce.lobtools.foundation.model", "cmc/foundation/ModelObject", "isAncestor(o)", ancestor);
			}
			return ancestor;
			]]>
		</method>
		
		<!---
			@keywords private
			Returns "true" if the specified object is a descendant of this object.
			@return "true" if the object is a descendant. False otherwise.
		-->
		<method args="o" name="isDescendant">
			<![CDATA[
			return o.isAncestor(this);
			]]>
		</method>
		
		<!---
			@keywords private
			Returns "true" if the specified object is a sibling of this object.
			@return "true" if the object is a sibling. False otherwise.
		-->
		<method args="o" name="isSibling">
			<![CDATA[
			var sibling = false;
			if (o != null && this != o) {
				if (this.parentObject != null) {
					sibling = this.parentObject == o.parentObject;
				}
				else {
					sibling = this.getParentPrimaryObject() == o.getParentPrimaryObject();
				}
			}
			return sibling;
			]]>
		</method>
		
		<!---
			@keywords private
			Checks if the object is referenced already in this model object.
			@param cmc/foundation/ObjectDefinition refDef the referenced definition checked against
			@param cmc/foundation/ModelObject o source object to be checked
		-->
		<method args="refDef, o" name="isDuplicateReference">
			<![CDATA[
			var isVersionObject = this.getIsVersionObject();
			for (var key in this.childObjectMap) {
				var childObject = this.childObjectMap[key];
				if (childObject.objectDefinition == refDef && childObject.getReferencedObject() == o && !childObject.pendingDelete && (isVersionObject || !childObject.getIsVersionObject())) {
					return true;
				}
			}
			return false;
			]]>
		</method>
		
		<!---
			@keywords private
			Checks if the object's context is read only.
		-->
		<method name="isContextReadOnly">
			<![CDATA[
			return this.localContext != null && this.localContext != this.model.oEditor.localContext;
			]]>
		</method>
		
		<!---
			@keywords private
			Closes this object. A closed object will be released for reuse.
			@param boolean prompt Prompt the user if the object has unsaved changes. The default is false.
		-->
		<method args="prompt" name="closeObject">
			<![CDATA[
			if (typeof(prompt) == "undefined") prompt = false;
			if (Logger.Singleton.enabled) {
				Logger.Singleton.entering("com.ibm.commerce.lobtools.foundation.model", "cmc/foundation/ModelObject", "closeObject(prompt)", [prompt]);
			}
			var dirty = this.openGroupObject && this.openGroupObject.openGroupDirty;
			if (prompt && dirty) {
				var ancestorHasErrors = false;
				if (this.isOpenGroupObject()) {
					var unsavedOpenAncestors = this.getUnsavedOpenAncestors();
					for (var i = 0; i < unsavedOpenAncestors.length; i++) {
						if (unsavedOpenAncestors[i].hasErrors(true)) {
							ancestorHasErrors = true;
							break;
						}
					}
				}
				if (ancestorHasErrors || this.hasErrors(true)) {
					var caller = this;
					require(["cmc/foundation/CloseWithErrorConfirmationDialog"], function(CloseWithErrorConfirmationDialog) {
						CloseWithErrorConfirmationDialog.Singleton.openCloseWithErrorConfirmationDialog(caller);
					});
				}
				else {
					var caller = this;
					require(["cmc/foundation/CloseConfirmationDialog"], function(CloseConfirmationDialog) {
						CloseConfirmationDialog.Singleton.openCloseConfirmationDialog(caller);
					});
				}
			}
			else {
				if (this.newObject && !this.creating) {
					ModelUtil.Singleton.releaseModelObject(this);
				}
				else {
					if (dirty && !this.hasTransaction()) {
						this.discardChanges();
					}
					this.setVariable("open", false);
				}
			}
			if (Logger.Singleton.enabled) {
				Logger.Singleton.exiting("com.ibm.commerce.lobtools.foundation.model", "cmc/foundation/ModelObject", "closeObject(prompt)");
			}
			]]>
		</method>
		
		<!---
			@keywords private
			Saves and closes this object.
			@param boolean prompt if "true", the user will be prompted if the object has errrors.
		 -->
		<method args="prompt" name="saveAndCloseObject">
			<![CDATA[
			if (typeof (prompt) == "undefined") {
				prompt = false;
			}
			if (prompt && this.isOpenGroupObject() && this.hasErrors(true)) {
				var caller = this;
				require(["cmc/foundation/SaveAndCloseConfirmationDialog"], function(SaveAndCloseConfirmationDialog) {
					SaveAndCloseConfirmationDialog.Singleton.openSaveAndCloseConfirmationDialog(caller);
				});
			}
			else {
				this.saveObject(false);
				this.closeObject(false);
			}
			]]>
		</method>


		<!---
			@keywords private
			Retrieves all ancestors for this object that have unsaved changes
			@return Array list of objects
		-->
		<method name="getUnsavedOpenAncestors">
			<![CDATA[
			var currentOpenObjects = this.model.openObjects;
			var unsavedOpenAncestors = [];
			var saveableParentPrimaryObject = this.getSaveableParentPrimaryObject();
			for (var i = 0; i < currentOpenObjects.length; i++) {
				var o = currentOpenObjects[i];
				if (o.openGroupDirty && this.isAncestor(o) && (saveableParentPrimaryObject == null || saveableParentPrimaryObject.openGroupObject != o)) {
					unsavedOpenAncestors.push(o);
				}
			}
			ModelUtil.Singleton.sortObjectsBySaveOrder(unsavedOpenAncestors);
			return unsavedOpenAncestors;
			]]>
		</method>

		<!---
			@keywords private
			Refreshes this object with data from the server. Unsaved changes may be discarded if user allows or if the user is not prompt.
			This object's children and references will be refershed too.
			
			@param boolean prompt Prompt the user if the object has unsaved changes. The default is false.
		-->
		<method args="prompt" name="refreshObject">
			<![CDATA[
			if (typeof(prompt) == "undefined") prompt = false;
			if (Logger.Singleton.enabled) {
				Logger.Singleton.entering("com.ibm.commerce.lobtools.foundation.model", "cmc/foundation/ModelObject", "refreshObject(prompt)", [prompt]);
			}
			var hasUnsavedChildren = false;
			for (var i = 0; i < this.model.openObjects.length; i++) {
				var o = this.model.openObjects[i];
				if (!o.objectDefinition.primary && this.isDescendant(o) && o.openGroupObject.openGroupDirty) {
					hasUnsavedChildren = true;
					break;
				}
			}
			var refreshableParent = null;
			if (this.objectDefinition.saveParentPrimaryObject && this.viewed) {
				refreshableParent = this.getParentPrimaryObject();
				if (refreshableParent && this.openGroupObject == refreshableParent.openGroupObject) {
					refreshableParent = null;
				}
			}
			var dirty = hasUnsavedChildren || (this.openGroupObject != null && this.openGroupObject.openGroupDirty) || (refreshableParent != null && refreshableParent.openGroupObject != null && refreshableParent.openGroupObject.openGroupDirty);
			if (prompt && dirty) {
				var caller = this;
				require(["cmc/foundation/RefreshConfirmationDialog"], function(RefreshConfirmationDialog) {
					RefreshConfirmationDialog.Singleton.openRefreshConfirmationDialog(caller);
				});
			}
			else {
				if (refreshableParent != null) {
					refreshableParent.refreshObject();
				}
				this.clearServiceErrors();
				if (dirty && !this.hasTransaction()) {
					this.discardChanges();
				}
				if (this.objectDefinition.refreshService != null && !this.refreshing) {
					if (this.objectDefinition.propertyDefinitions) {
						for (var propertyName in this.objectDefinition.propertyDefinitions) {
							if (propertyName.indexOf(this.objectDefinition.userDataPrefix) == 0) {
								if (this.propertyMap[propertyName]) {
									var prop = this.propertyMap[propertyName];
									prop.setVariable("value", "");
								}
								else if (this.rawDataPropertyMap[propertyName]) {
									delete this.rawDataPropertyMap[propertyName];
								}
							}
						}
					}
					this.refreshing = true;
					this.objectDefinition.refreshService.doRequest(this);
				}
				this.refreshReferences();
				this.refreshChildren();
			}
			if (Logger.Singleton.enabled) {
				Logger.Singleton.exiting("com.ibm.commerce.lobtools.foundation.model", "cmc/foundation/ModelObject", "refreshObject(prompt)");
			}
			]]>
		</method>
		
		<!---
			@keywords private
			Refreshes this object's children from the server.
			@param [cmc/foundation/ObjectDefinition] oDefs: Optional parameter to load services with specified object definitions
			@param number pageNum: The page number to be loaded.
		-->
		<method args="oDefs, pageNum" name="refreshChildren">
			<![CDATA[
			if (typeof(oDefs) == "undefined") oDefs = null;
			if (typeof(pageNum) == "undefined") pageNum = null;
			if (oDefs != null && oDefs.length == 0) {
				oDefs = null;
			}
			if (oDefs != null) {
				for (var i = 0; i < oDefs.length; i++) {
					this.setGetChildrenServicesStale(oDefs[i], false);
				}
			}
			var checkLoadedChildrenRequired = false;
			if (this.loadChildrenStatusObjects.length > 0) {
				this.childObjectListsStale = true;
				if (pageNum == null) {
					checkLoadedChildrenRequired = true;
					this.loadChildrenStatusObjects = [];
				}
				else {
					for (var i = 0; i < this.loadChildrenStatusObjects.length; i++) {
						var statusObject = this.loadChildrenStatusObjects[i];
						if (oDefs == null || statusObject.service.matchesObjectDefinitions(this.objectDefinition, oDefs)) {
							statusObject.message = "";
							statusObject.messageForTree = null;
							if (statusObject.serviceObjectList != null) {
								statusObject.serviceObjectList = null;
								checkLoadedChildrenRequired = true;
							}
						}
					}
				}
			}
			if (checkLoadedChildrenRequired) {
				this.checkLoadedChildren();
			}
			var childObjectMapList = [];
			for (var key in this.childObjectMap) {
				childObjectMapList.push(this.childObjectMap[key]);
			}
			var isVersionObject = this.getIsVersionObject();
			for (var i = 0; i < childObjectMapList.length; i++) {
				var o = childObjectMapList[i];
				if (oDefs == null || oDefs.indexOf(o.objectDefinition) != -1) {
					if (o.parentObject == this) {
						if (!((o.objectDefinition.parentReference || o.objectDefinition.collectionReference) && o.getReferencedObject().open) && (isVersionObject || !o.getIsVersionObject()) && (o.openGroupObject != this.openGroupObject || !o.hasUnsavedChanges()) && !o.hasTransaction()) {
							EventUtil.trigger(o, "beingDestroyed", o);
							this.removeChild(o, false);
							ModelUtil.Singleton.releaseModelObject(o);
						}
					}
					else if (this.objectDefinition.organizational && !o.newObject && !o.objectDefinition.organizational) {
						this.removeChild(o, false);
					}
				}
			}
			this.loadChildren(oDefs, false, oDefs == null, false, pageNum);
			this.updateChildObjects();
			if (this.modelInitializationIdentifier == this.model.initializationIdentifier) {
				this.model.removeNotReferencedObjects();
			}
			]]>
		</method>

		<!---
			@keywords private
			Refreshes this object's references from the server.
		-->
		<method name="refreshReferences">
			<![CDATA[
			if (this.loadReferencesStatusObjects.length > 0) {
				this.referenceListsStale = true;
				this.loadReferencesStatusObjects = [];
			}
			var referenceMapList = [];
			for (var key in this.referenceMap) {
				referenceMapList.push(this.referenceMap[key]);
			}
			var isVersionObject = this.getIsVersionObject();
			for (var i = 0; i < referenceMapList.length; i++) {
				var o = referenceMapList[i];
				if (o.getReferencedObject() == this) {
					var referenceObjParentObject = o.getParentPrimaryObject();
					if ((!referenceObjParentObject.open || o.objectDefinition.parentReference || o.objectDefinition.collectionReference) && (isVersionObject || !o.getIsVersionObject()) && (o.transaction == null)) {
						referenceObjParentObject.setGetChildrenServicesStale(o.objectDefinition);
						ModelUtil.Singleton.releaseModelObject(o);
					}
				}
			}
			if (this.referencesLoaded) {
				this.referencesLoaded = false;
				this.referencesStale = true;
				this.loadReferences();
			}
			this.updateReferences(true);
			]]>
		</method>
		
		<!---
			@keywords private
			Updates the hasAccessRight flag.
		-->
		<method args="e" name="updateAccessRight">
			<![CDATA[
			if (typeof(e) == "undefined") e = null;
			if (this.updateAccessRightDel) {
				this.updateAccessRightDel.disconnectAll();
			}
			else {
				this.updateAccessRightDel = new EventHandler.Class(this, "updateAccessRight");
			}
			var storeId = this.getObjectStoreId(this.updateAccessRightDel);
			if (storeId.length > 0) {
				var usage = this.getWriteUsage();
				var objectStore = ModelUtil.Singleton.objectStoreMap[storeId + usage];
				if (objectStore == null) {
					objectStore = ModelUtil.Singleton.createObjectStore({
						storeId: storeId,
						usage: usage
					});
					ModelUtil.Singleton.objectStoreMap[storeId + usage] = objectStore;
				}
				var accessRightChanged = false;
				if (objectStore.accessRightChecked) {
					if (this.hasAccessRight != objectStore.hasAccessRight) {
						accessRightChanged = true;
					}
					this.setVariable("hasAccessRight", objectStore.hasAccessRight);
				}
				else {
					if (this.hasAccessRight) {
						accessRightChanged = true;
					}
					this.setVariable("hasAccessRight", false);
					this.updateAccessRightDel.connect(objectStore, "onaccessRightChecked");
				}
				if (accessRightChanged) {
					this.checkOpenGroupPartiallyEditable();
				}
			}
			]]>
		</method>
		
		<!---
			@keywords private
			Updates the readOnly flag.
		-->
		<method args="e" name="updateReadOnly">
			<![CDATA[
			if (typeof(e) == "undefined") e = null;
			if (Logger.Singleton.enabled) {
				Logger.Singleton.entering("com.ibm.commerce.lobtools.foundation.model", "cmc/foundation/ModelObject", "updateReadOnly", [this.objectKey, this.readOnly]);
			}
			this.updateReadOnlyDel.disconnectAll();
			var newReadOnly = false;
			if (this.isContextReadOnly() || (this.model.oEditor.respectWorkspaceContext && ContextUtil.Singleton.findContextValue(null, "readOnlyMode", this.updateReadOnlyDel).value == "true") || this.getObjectReadOnly(this.updateReadOnlyDel) || !this.getChangeControlModifiable(this.updateReadOnlyDel) || !this.getHasAccessRight(this.updateReadOnlyDel) || this.getIsVersionObject()) {
				newReadOnly = true;
			}
			if (this.readOnly != newReadOnly) {
				this.setVariable("readOnly", newReadOnly);
				this.checkOpenGroupReadOnly();
			}
			if (Logger.Singleton.enabled) {
				Logger.Singleton.exiting("com.ibm.commerce.lobtools.foundation.model", "cmc/foundation/ModelObject", "updateReadOnly", [this.readOnly]);
			}
			]]>
		</method>
		
		<!---
			@keywords private
			Returns true if objectReadOnly flag is set to "true".
			@param cmc/foundation/EventHandler del optional, if passed to this method it will register the delegate to the "onobjectReadOnly" event of this object or its inherit object.
		-->
		<method args="del" name="getObjectReadOnly">
			<![CDATA[
			if (typeof(del) == "undefined") del = null;
			if (Logger.Singleton.enabled) {
				Logger.Singleton.entering("com.ibm.commerce.lobtools.foundation.model", "cmc/foundation/ModelObject", "getObjectReadOnly(del)", [this.objectKey, del, this.objectReadOnly]);
			}
			var isObjectReadOnly = false;
			if (this.objectReadOnly == null) {
				if (this.objectDefinition.parentReference || this.objectDefinition.collectionReference) {
					var referencedObject = this.getReferencedObject();
					if (referencedObject != null) {
						isObjectReadOnly = referencedObject.getObjectReadOnly(del);
					}
				}
				else {
					if (this.parentObject != null) {
						isObjectReadOnly = this.parentObject.getObjectReadOnly(del);
					}
				}
			}
			else if (this.objectReadOnly == "true") {
				isObjectReadOnly = true;
			}
			if (isObjectReadOnly && this.newObject && !this.implicitNewObject) {
				isObjectReadOnly = false;
				if (del) {
					del.connect(this, "onnewObject");
					del.connect(this, "onimplicitNewObject");
				}
			}
			if (del) {
				del.connect(this, "onobjectReadOnly");
			}
			if (Logger.Singleton.enabled) {
				Logger.Singleton.exiting("com.ibm.commerce.lobtools.foundation.model", "cmc/foundation/ModelObject", "getObjectReadOnly(del)", [isObjectReadOnly]);
			}
			return isObjectReadOnly;
			]]>
		</method>
		
		<!---
			@keywords private
			Returns true if this object is a version object.
		-->
		<method name="getIsVersionObject">
			<![CDATA[
			if (Logger.Singleton.enabled) {
				Logger.Singleton.entering("com.ibm.commerce.lobtools.foundation.model", "cmc/foundation/ModelObject", "getIsVersionObject", [this.objectKey]);
			}
			var isVersionObject = this.objectVersionId != null && this.objectVersionId != "";
			if (!isVersionObject && this.parentPrimaryObject != null) {
				isVersionObject = this.parentPrimaryObject.objectVersionId != null && this.parentPrimaryObject.objectVersionId != "";
			}
			if (Logger.Singleton.enabled) {
				Logger.Singleton.exiting("com.ibm.commerce.lobtools.foundation.model", "cmc/foundation/ModelObject", "getIsVersionObject", [isVersionObject]);
			}
			return isVersionObject;
			]]>
		</method>
		
		<!---
			@keywords private
			Returns true if this object is deletable
			@param cmc/foundation/EventHandler del optional, if passed to this method it will register the delegate
		-->
		<method args="del" name="isDeletable">
			<![CDATA[
			if (typeof(del) == "undefined") del = null;
			if (Logger.Singleton.enabled) {
				Logger.Singleton.entering("com.ibm.commerce.lobtools.foundation.model", "cmc/foundation/ModelObject", "isDeletable(del)", [this.objectKey, del, this.objectDeletable]);
			}
			var deletable = false;
			if (!this.objectDefinition.organizational && (!this.objectDefinition.primary || this.objectDefinition.deleteService != null)) {
				if (del) {
					del.connect(this, "onobjectDeletable");
				}
				if (this.objectDeletable == "true") {
					deletable = true;
					if (this.isContextReadOnly()) {
						deletable = false;
					}
					if (deletable && this.model.oEditor.respectWorkspaceContext && (ContextUtil.Singleton.findContextValue(null, "readOnlyMode", del).value == "true")) {
						deletable = false;
					}
					if (deletable) {
						if (!this.getChangeControlModifiable(del)) {
							deletable = false;
						}
						else if (!this.getHasAccessRight(del)) {
							deletable = false;
						}
						else if (this.getIsVersionObject()) {
							deletable = false;
						}
					}
				}
				else if (this.objectDeletable == "false") {
					deletable = false;
				}
				else {
					if (del) {
						del.connect(this, "onreadOnly");
					}
					deletable = !this.readOnly;
				}
			}
			if (Logger.Singleton.enabled) {
				Logger.Singleton.exiting("com.ibm.commerce.lobtools.foundation.model", "cmc/foundation/ModelObject", "isDeletable(del)", [deletable]);
			}
			return deletable;
			]]>
		</method>
		
		<!---
			@keywords private
			Returns true if changeControlModifiable flag is set to "true".
			@param cmc/foundation/EventHandler del optional, if passed to this method it will register the delegate to the "onchangeControlModifiable" event of this object or its inherit object.
		-->
		<method args="del" name="getChangeControlModifiable">
			<![CDATA[
			if (typeof(del) == "undefined") del = null;
			if (Logger.Singleton.enabled) {
				Logger.Singleton.entering("com.ibm.commerce.lobtools.foundation.model", "cmc/foundation/ModelObject", "getChangeControlModifiable(del)", [this.objectKey, del, this.changeControlModifiable]);
			}
			var isChangeControlModifiable = true;
			if (this.changeControlModifiable == null) {
				if (this.objectDefinition.parentReference || this.objectDefinition.collectionReference) {
					var referencedObject = this.getReferencedObject();
					if (referencedObject != null) {
						isChangeControlModifiable = referencedObject.getChangeControlModifiable(del);
					}
				}
				else {
					if (this.parentObject != null) {
						isChangeControlModifiable = this.parentObject.getChangeControlModifiable(del);
					}
				}
			}
			else if (this.changeControlModifiable == "false") {
				isChangeControlModifiable = false;
			}
			if (!isChangeControlModifiable && this.newObject && !this.implicitNewObject) {
				isChangeControlModifiable = true;
				if (del) {
					del.connect(this, "onnewObject");
					del.connect(this, "onimplicitNewObject");
				}
			}
			if (del) {
				del.connect(this, "onchangeControlModifiable");
			}
			if (Logger.Singleton.enabled) {
				Logger.Singleton.exiting("com.ibm.commerce.lobtools.foundation.model", "cmc/foundation/ModelObject", "getChangeControlModifiable(del)", [isChangeControlModifiable]);
			}
			return isChangeControlModifiable;
			]]>
		</method>
		
		<!---
			@keywords private
			Returns true if hasAccessRight flag is true.
			@param cmc/foundation/EventHandler del optional, if passed to this method it will register the delegate to the "onhasAccessRight" event of this object.
		-->
		<method args="del" name="getHasAccessRight">
			<![CDATA[
			if (typeof(del) == "undefined") del = null;
			if (Logger.Singleton.enabled) {
				Logger.Singleton.entering("com.ibm.commerce.lobtools.foundation.model", "cmc/foundation/ModelObject", "getHasAccessRight(del)", [this.objectKey, del, this.hasAccessRight, this.objectStoreId]);
			}
			var hasAccessRight = this.hasAccessRight;
			if (!hasAccessRight && this.newObject && !this.implicitNewObject) {
				hasAccessRight = true;
				if (del) {
					del.connect(this, "onnewObject");
					del.connect(this, "onimplicitNewObject");
				}
			}
			if (del) {
				del.connect(this, "onhasAccessRight");
			}
			if (Logger.Singleton.enabled) {
				Logger.Singleton.exiting("com.ibm.commerce.lobtools.foundation.model", "cmc/foundation/ModelObject", "getHasAccessRight(del)", [hasAccessRight]);
			}
			return hasAccessRight;
			]]>
		</method>
		
		<!---
			@keywords private
			Returns object store id.
			@param cmc/foundation/EventHandler del optional, if passed to this method it will register the delegate to the "onobjectStoreId" event of this object or its inherit object.
		-->
		<method args="del" name="getObjectStoreId">
			<![CDATA[
			if (typeof(del) == "undefined") del = null;
			var storeId = this.objectStoreId;
			if (storeId.length == 0) {
				if (this.objectDefinition.parentReference || this.objectDefinition.collectionReference) {
					var referencedObject = this.getReferencedObject();
					if (referencedObject != null) {
						storeId = referencedObject.getObjectStoreId(del);
					}
				}
				else {
					if (this.parentObject != null) {
						storeId = this.parentObject.getObjectStoreId(del);
					}
				}
			}
			if (del) {
				del.connect(this, "onobjectStoreId");
			}
			return storeId;
			]]>
		</method>
		
		<!---
			@keywords private
			Returns write usage.
		-->
		<method name="getWriteUsage">
			<![CDATA[
			var usage = this.objectDefinition.writeUsage;
			if (usage == null) {
				if (this.objectDefinition.parentReference || this.objectDefinition.collectionReference) {
					var referencedObject = this.getReferencedObject();
					if (referencedObject != null) {
						usage = referencedObject.getWriteUsage();
					}
				}
				else {
					if (this.parentObject != null) {
						usage = this.parentObject.getWriteUsage();
					}
				}
			}
			if (usage == null) {
				usage = this.model.oEditor.usage;
			}
			return usage;
			]]>
		</method>
		
		<!---
			@keywords private
			Check the openGroupPartiallyEditable flag.
		-->
		<method name="checkOpenGroupPartiallyEditable">
			<![CDATA[
			if (this.openGroupObject != null) {
				var newOpenGroupPartiallyEditable = false;
				if (!this.openGroupObject.openGroupReadOnly) {
					newOpenGroupPartiallyEditable = this.openGroupObject.isPartiallyEditable();
				}
				if (this.openGroupObject.openGroupPartiallyEditable != newOpenGroupPartiallyEditable) {
					this.openGroupObject.setVariable("openGroupPartiallyEditable", newOpenGroupPartiallyEditable);
				}
			}
			]]>
		</method>
		
		<!---
			@keywords private
			Check the openGroupReadOnly flag.
		-->
		<method args="e" name="checkOpenGroupReadOnly">
			<![CDATA[
			if (typeof(e) == "undefined") e = null;
			if (this.openGroupObject != null) {
				this.openGroupObject.checkOpenGroupReadOnlyDel.disconnectAll();
				var newOpenGroupReadOnly = !this.openGroupObject.isEditable(this.openGroupObject.checkOpenGroupReadOnlyDel);
				if (this.openGroupObject.openGroupReadOnly != newOpenGroupReadOnly) {
					this.openGroupObject.setVariable("openGroupReadOnly", newOpenGroupReadOnly);
					this.checkOpenGroupPartiallyEditable();
				}
			}
			]]>
		</method>

		<!---
			@keywords private
			Checks if any component of this object is is not accessible or not modifiable by checking
			the hasAccessRight and changeControlModifiable attribute.  This method recursively searches through
			the open group.
			@return boolean true if there is a component of the object is not accessible or not modifiable, false otherwise
		-->
		<method name="isPartiallyEditable">
			<![CDATA[
			var partiallyEditable = !this.hasAccessRight || this.changeControlModifiable == "false";
			if (!partiallyEditable) {
				for (var key in this.childObjectMap) {
					var o = this.childObjectMap[key];
					if (o.parentObject == this && o.openGroupObject == this.openGroupObject && !o.getIsVersionObject() && o.isPartiallyEditable()) {
						partiallyEditable = true;
						break;
					}
				}
			}
			if (!partiallyEditable) {
				for (var key in this.referenceMap) {
					var o = this.referenceMap[key];
					var oDef = o.objectDefinition;
					if ((oDef.parentReference || oDef.collectionReference) && o.openGroupObject == this.openGroupObject && (!o.hasAccessRight || o.changeControlModifiable == "false") && !o.getIsVersionObject()) {
						partiallyEditable = true;
						break;
					}
				}
			}
			return partiallyEditable;
			]]>
		</method>

		<!---
			@keywords private
			Checks if any component of this object is editable. This method recursively searches through
			the open group to find at least one editable object or property. It also checks child object definitions
			to see if it is possible to create child objects.
			@param cmc/foundation/EventHandler isCreatableDelegate: An optional parameter with a delegate that will be registered with the isCreatable method
												 when checked
			@return boolean "true" if there is a component of the object which is not read only, false otherwise.
		-->
		<method args="isCreatableDelegate" name="isEditable">
			<![CDATA[
			var editable = this.isObjectEditable(isCreatableDelegate);
			if (!editable) {
				for (var key in this.childObjectMap) {
					var o = this.childObjectMap[key];
					if (o.parentObject == this && o.openGroupObject == this.openGroupObject && o.isEditable(isCreatableDelegate) && !o.getIsVersionObject()) {
						editable = true;
						break;
					}
				}
			}
			if (!editable) {
				for (var key in this.referenceMap) {
					var o = this.referenceMap[key];
					var oDef = o.objectDefinition;
					if ((oDef.parentReference || oDef.collectionReference) && o.openGroupObject == this.openGroupObject && !o.getIsVersionObject() && o.isObjectEditable(isCreatableDelegate)) {
						editable = true;
						break;
					}
				}
			}
			return editable;
			]]>
		</method>
		
		<!---
			@keywords private
			Checks the current object to see if it has any editable properties or it has any child
			object definitions that allow the creation of new child objects.
			@param cmc/foundation/EventHandler isCreatableDelegate: An optional parameter with a delegate that will be registered with the isCreatable method
												 when checked
			@return boolean "true" if the current object is editable
		-->
		<method args="isCreatableDelegate" name="isObjectEditable">
			<![CDATA[
			var editable = !this.readOnly;
			if (!editable) {
				var propertyMap = this.propertyMap;
				for (var key in propertyMap) {
					if (!propertyMap[key].readOnly) {
						editable = true;
						break;
					}
				}
			}
			if (!editable) {
				var definitions = this.objectDefinition.objectDefinitions;
				for (var i = 0; i < definitions.length; i++) {
					var childDef = definitions[i].objectDefinition;
					if (!childDef.parentReference && !childDef.collectionReference && !childDef.openGroupTop && childDef.isCreatable(this, null, isCreatableDelegate)) {
						editable = true;
						break;
					}
				}
			}
			return editable;
			]]>
		</method>
		
		<!---
			@keywords private
			Returns true if this object can be opened.
			@param cmc/foundation/EventHandler del: An optional delegate that will be registered with events that may effect the isOpenEnabled state.
			@return boolean "true" if the current object can be opened
		-->
		<method args="del" name="isOpenEnabled">
			<![CDATA[
			if (typeof(del) == "undefined") del = null;
			var openEnabled = false;
			if (this.objectDefinition.openHandler) {
				openEnabled = this.objectDefinition.openHandler.isEnabled(this, del);
			}
			else {
				var po = this.getReferencedObject();
				if (po.openGroupObject != null && po.openGroupObject == po && (po.openGroupObject.objectDefinition.propertiesClass_moduleName != null || po.openGroupObject.objectDefinition.defaultNavigationList != null)) {
					openEnabled = true;
				}
			}
			return openEnabled;
			]]>
		</method>

		<!---
			@keywords private
			Opens this object
			@param boolean select: select the newly opened object if set to true
		-->
		<method args="select" name="doOpen">
			<![CDATA[
			if (typeof(select) == "undefined") select = true;
			if (this.isOpenEnabled()) {
				if (this.objectDefinition.openHandler) {
					this.objectDefinition.openHandler.open(this, select);
				}
				else {
					var po = this.getReferencedObject();
					po.openGroupObject.setVariable("open", true);
					if (select) {
						po.model.oEditor.selectOpenObject(po.openGroupObject);
					}
				}
			}
			]]>
		</method>
		
		<!---
			@keywords private
			Returns true if this object can be opened in the compare view.
			@param cmc/foundation/EventHandler del: An optional delegate that will be registered with events that may effect the isOpenEnabled state.
			@return boolean "true" if the current object can be opened
		-->
		<method args="del" name="isOpenInCompareViewEnabled">
			<![CDATA[
			if (typeof(del) == "undefined") del = null;
			var openEnabled = false;
			if (this.objectDefinition.openHandler) {
				openEnabled = this.objectDefinition.openHandler.isOpenInCompareViewEnabled(this, del);
			}
			else {
				var po = this.getReferencedObject();
				if (po.openGroupObject != null && po.openGroupObject == po && po.openGroupObject.objectDefinition.propertiesClass_moduleName != null) {
					openEnabled = true;
				}
			}
			return openEnabled;
			]]>
		</method>

		<!---
			@keywords private
			Opens this object in the compare view.
		-->
		<method name="doOpenInCompareView">
			<![CDATA[
			if (this.isOpenInCompareViewEnabled()) {
				if (this.objectDefinition.openHandler) {
					this.objectDefinition.openHandler.openInCompareView(this);
				}
				else {
					var po = this.getReferencedObject();
					var compareViewTreeNode = this.model.oEditor.navigationTree.compareViewTree;
					if (compareViewTreeNode.compareObject1Cache == null) {
						compareViewTreeNode.setVariable("compareObject1Cache", this);
					}
					else if (compareViewTreeNode.compareObject2Cache == null) {
						compareViewTreeNode.setVariable("compareObject2Cache", this);
					}
				}
			}
			]]>
		</method>

		<!---
			@keywords private
			Locks this model object. A model object will not be updated if it is locked.
		-->
		<method name="lock">
			<![CDATA[
			this.lockCount++;
			this.model.lock();
			]]>
		</method>
		
		<!---
			@keywords private
			Unlock a model object. A model object will be available for update after it is unlocked.
			@param boolean immediateUpdate "true" to immediately update the children and references
		-->
		<method args="immediateUpdate" name="unlock">
			<![CDATA[
			if (typeof(immediateUpdate) == "undefined") immediateUpdate = false;
			if (this.lockCount > 0) {
				this.lockCount--;
				if (this.lockCount == 0) {
					this.updateChildObjects(immediateUpdate);
					this.updateReferences(immediateUpdate);
				}
				this.model.unlock();
			}
			]]>
		</method>
		
		<!---
			@keywords private
			Increments the reference count of this object by 1 if it is a primary object, otherwise
			increments the reference count of its parent primary object by 1.
		-->
		<method name="incrementReferenceCount">
			<![CDATA[
			if (Logger.Singleton.enabled) {
				Logger.Singleton.entering("com.ibm.commerce.lobtools.foundation.model", "cmc/foundation/ModelObject", "incrementReferenceCount");
			}
			if (this.objectDefinition.primary) {
				this.referenceCount++;
				if (Logger.Singleton.enabled) {
					Logger.Singleton.log("com.ibm.commerce.lobtools.foundation.model", "FINER", "cmc/foundation/ModelObject", "incrementReferenceCount", "Increment reference count: object key=" + this.objectKey + ", new reference count=" + this.referenceCount);
				}
			}
			else if (!this.objectDefinition.organizational) {
				var parent = this.getParentPrimaryObject();
				if (parent != null) {
					parent.referenceCount++;
					if (Logger.Singleton.enabled) {
						Logger.Singleton.log("com.ibm.commerce.lobtools.foundation.model", "FINER", "cmc/foundation/ModelObject", "incrementReferenceCount", "Increment reference count of the parent: object key=" + parent.objectKey + ", new reference count=" + parent.referenceCount);
					}
				}
			}
			if (Logger.Singleton.enabled) {
				Logger.Singleton.exiting("com.ibm.commerce.lobtools.foundation.model", "cmc/foundation/ModelObject", "incrementReferenceCount");
			}
			]]>
		</method>
		
		<!---
			@keywords private
			Decrements the reference count of this object by 1 if it is a primary object, otherwise
			decrements the reference count of its parent primary object by 1.
		-->
		<method name="decrementReferenceCount">
			<![CDATA[
			if (Logger.Singleton.enabled) {
				Logger.Singleton.entering("com.ibm.commerce.lobtools.foundation.model", "cmc/foundation/ModelObject", "decrementReferenceCount");
			}
			if (this.objectDefinition) {
				if (this.objectDefinition.primary) {
					this.referenceCount--;
					if (Logger.Singleton.enabled) {
						Logger.Singleton.log("com.ibm.commerce.lobtools.foundation.model", "FINER", "cmc/foundation/ModelObject", "decrementReferenceCount", "Decrement reference count: object key=" + this.objectKey + ", new reference count=" + this.referenceCount);
					}
				}
				else if (!this.objectDefinition.organizational) {
					var parent = this.getParentPrimaryObject();
					if (parent != null) {
						parent.referenceCount--;
						if (Logger.Singleton.enabled) {
							Logger.Singleton.log("com.ibm.commerce.lobtools.foundation.model", "FINER", "cmc/foundation/ModelObject", "decrementReferenceCount", "Decrement reference count of the parent: object key=" + parent.objectKey + ", new reference count=" + parent.referenceCount);
						}
					}
				}
			}
			if (Logger.Singleton.enabled) {
				Logger.Singleton.exiting("com.ibm.commerce.lobtools.foundation.model", "cmc/foundation/ModelObject", "decrementReferenceCount");
			}
			]]>
		</method>
		
		<!---
			Returns a string suitable for representing this object in a log message.
			@return string the description of the object to be logged
		-->
		<method name="logString">
			<![CDATA[
			return this.toString() + "type=" + this.objectType + " id=" + this.objectId + " version id=" + this.objectVersionId + " objectDisplayName=" + this.objectDisplayName;
			]]>
		</method>
		
		<!---
			@keywords private
			Logs the current object.
		-->
		<method name="logObject">
			<![CDATA[
			Logger.Singleton.log("com.ibm.commerce.lobtools.foundation.model", "INFO", "cmc/foundation/ModelObject", "logObject", "--- " + this.logString() + " ---");
			Logger.Singleton.log("com.ibm.commerce.lobtools.foundation.model", "INFO", "cmc/foundation/ModelObject", "logObject", "objectKey = " + this.objectKey);
			Logger.Singleton.log("com.ibm.commerce.lobtools.foundation.model", "INFO", "cmc/foundation/ModelObject", "logObject", "newObject = " + this.newObject);
			Logger.Singleton.log("com.ibm.commerce.lobtools.foundation.model", "INFO", "cmc/foundation/ModelObject", "logObject", "pendingDelete = " + this.pendingDelete);
			Logger.Singleton.log("com.ibm.commerce.lobtools.foundation.model", "INFO", "cmc/foundation/ModelObject", "logObject", "errorInOpenGroup = " + this.errorInOpenGroup);
			Logger.Singleton.log("com.ibm.commerce.lobtools.foundation.model", "INFO", "cmc/foundation/ModelObject", "logObject", "openGroupDirty = " + this.openGroupDirty);
			Logger.Singleton.log("com.ibm.commerce.lobtools.foundation.model", "INFO", "cmc/foundation/ModelObject", "logObject", "changeToDirtyTime = " + this.changeToDirtyTime);
			Logger.Singleton.log("com.ibm.commerce.lobtools.foundation.model", "INFO", "cmc/foundation/ModelObject", "logObject", "PropertyMap for " + this.logString());
			for (var propertyName in this.propertyMap) {
				var p = this.propertyMap[propertyName];
				Logger.Singleton.log("com.ibm.commerce.lobtools.foundation.model", "INFO", "cmc/foundation/ModelObject", "logObject", "propertyName = " + propertyName);
				Logger.Singleton.log("com.ibm.commerce.lobtools.foundation.model", "INFO", "cmc/foundation/ModelObject", "logObject", "value = " + p.value);
				Logger.Singleton.log("com.ibm.commerce.lobtools.foundation.model", "INFO", "cmc/foundation/ModelObject", "logObject", "dirty = " + p.dirty);
				Logger.Singleton.log("com.ibm.commerce.lobtools.foundation.model", "INFO", "cmc/foundation/ModelObject", "logObject", "enabled = " + p.enabled);
				Logger.Singleton.log("com.ibm.commerce.lobtools.foundation.model", "INFO", "cmc/foundation/ModelObject", "logObject", "readOnly = " + p.readOnly);
				Logger.Singleton.log("com.ibm.commerce.lobtools.foundation.model", "INFO", "cmc/foundation/ModelObject", "logObject", "has Validation Error = " + p.hasValidationError());
			}
			Logger.Singleton.log("com.ibm.commerce.lobtools.foundation.model", "INFO", "cmc/foundation/ModelObject", "logObject", "Raw data property map for " + this.logString());
			for (var propertyName in this.rawDataPropertyMap) {
				var p = this.rawDataPropertyMap[propertyName];
				Logger.Singleton.log("com.ibm.commerce.lobtools.foundation.model", "INFO", "cmc/foundation/ModelObject", "logObject", "propertyName = " + propertyName);
				Logger.Singleton.log("com.ibm.commerce.lobtools.foundation.model", "INFO", "cmc/foundation/ModelObject", "logObject", "propertyValue = " + p.propertyValue);
				Logger.Singleton.log("com.ibm.commerce.lobtools.foundation.model", "INFO", "cmc/foundation/ModelObject", "logObject", "propertyReadOnly = " + p.propertyReadOnly);
			}
			Logger.Singleton.log("com.ibm.commerce.lobtools.foundation.model", "INFO", "cmc/foundation/ModelObject", "logObject", "ChildObject Map for " + this.logString());
			for (var key in this.childObjectMap) {
				var co = this.childObjectMap[key];
				Logger.Singleton.log("com.ibm.commerce.lobtools.foundation.model", "INFO", "cmc/foundation/ModelObject", "logObject", co.logString());
			}
			Logger.Singleton.log("com.ibm.commerce.lobtools.foundation.model", "INFO", "cmc/foundation/ModelObject", "logObject", "Reference Map for " + this.logString());
			for (var key in this.referenceMap) {
				var ro = this.referenceMap[key];
				Logger.Singleton.log("com.ibm.commerce.lobtools.foundation.model", "INFO", "cmc/foundation/ModelObject", "logObject", ro.logString());
			}
			Logger.Singleton.flush();
			]]>
		</method>
		
		<!---
			@keywords private
			Logs all of the objects in this object's open group.
		-->
		<method name="logObjectGroup">
			<![CDATA[
			this.logObject();
			for (var key in this.childObjectMap) {
				var o = this.childObjectMap[key];
				if (o.parentObject == this && o.openGroupObject == this.openGroupObject) {
					o.logObjectGroup();
				}
			}
			for (var key in this.referenceMap) {
				var o = this.referenceMap[key];
				var oDef = o.objectDefinition;
				if ((oDef.parentReference || oDef.collectionReference) && o.openGroupObject == this.openGroupObject) {
					o.logObject();
				}
			}
			]]>
		</method>
		
		<!---
			@keywords private
			@return cmc/foundation/ParentReferenceObject the parent reference object (return null if not found or it is pending to delete)
		-->
		<method name="getParentReferenceObject">
			<![CDATA[
			var parentReferenceObject = null;
			var isVersionObject = this.getIsVersionObject();
			for (var key in this.referenceMap) {
				var ro = this.referenceMap[key];
				if (!ro.pendingDelete && ro.objectDefinition.parentReference && (isVersionObject || !ro.getIsVersionObject())) {
					parentReferenceObject = ro;
				}
			}
			return parentReferenceObject;
			]]>
		</method>
		
		<!---
			@keywords private
			Set the openGroupDirty attribute of this model object to the given new state.
			@param cmc/foundation/State the new state to assign to the openGroupDirty attribute
			@event onopenGroupDirty will be sent if this event exists
		 -->
		<method args="newState" name="setOpenGroupDirty">
			<![CDATA[
			if (this.openGroupDirty != newState) {
				this.openGroupDirty = newState;
				if (this.openGroupDirty) {
					this.changeToDirtyTime = (new Date()).getTime();
				}
				else {
					this.changeToDirtyTime = 0;
				}
				EventUtil.trigger(this, "onopenGroupDirty", this);
			}
			]]>
		</method>
		
		<!---
			@keywords private
			Mark this object as having releaseable children. This will be used by releaseReleasableChildren
			to release child objects for closed objects.
		-->
		<method name="setHasReleasableChildren">
			<![CDATA[
			if (!this.hasReleasableChildren) {
				this.hasReleasableChildren = true;
				var isVersionObject = this.getIsVersionObject();
				for (var key in this.childObjectMap) {
					var o = this.childObjectMap[key];
					if (o.parentObject == this && o.openGroupObject == this.openGroupObject && (isVersionObject || !o.getIsVersionObject())) {
						o.setHasReleasableChildren();
					}
				}
			}
			]]>
		</method>
		
		<!---
			@keywords private
			Release this objects releasable children
			@return boolean true if all the objects children have been released
		-->
		<method name="releaseReleasableChildren">
			<![CDATA[
			var allChildrenReleased = true;
			var releasableChildren = [];
			var isVersionObject = this.getIsVersionObject();
			for (var key in this.childObjectMap) {
				var o = this.childObjectMap[key];
				if (!isVersionObject && o.getIsVersionObject()) {
					continue;
				}
				var releasable = false;
				if (o.objectDefinition.reference) {
					var referencedObject = o.getReferencedObject();
					if (referencedObject != null && referencedObject.referenceCount == 0 && !referencedObject.open) {
						releasable = true;
					}
				}
				else if (!this.isOpenGroupObject() || (!o.open && !o.hasTransaction())) {
					releasable = o.releaseReleasableChildren();
				}
				if (releasable && !o.objectDefinition.releaseWhenClosed) {
					if (o.objectDefinition.languageSensitive) {
						if (o == this.getDefaultLanguageObject()) {
							releasable = false;
						}
					}
					else {
						releasable = false;
					}
				}
				if (!o.hasReleasableChildren && releasable) {
					releasableChildren.push(o);
				}
				else {
					allChildrenReleased = false;
				}
			}
			while (releasableChildren.length > 0) {
				var o = releasableChildren.shift();
				this.setGetChildrenServicesStale(o.objectDefinition);
				ModelUtil.Singleton.releaseModelObject(o);
			}
			return allChildrenReleased;
			]]>
		</method>
		
		<!---
			@keywords private
			Release this object's releasable properties. The property value will be
			returned to the raw data map.
			@return boolean true if any properties were released
		-->
		<method name="releaseReleasableProperties">
			<![CDATA[
			var propertiesReleased = false;
			var releaseProperties = [];
			for (var key in this.propertyMap) {
				if (this.propertyMap[key].isReleaseCandidate()) {
					releaseProperties.push(this.propertyMap[key]);
				}
			}
			if (releaseProperties.length > 0) {
				for (var i = 0; i < releaseProperties.length; i++) {
					var property = releaseProperties[i];
					if (property.value != "" || property.propertyReadOnly) {
						var rawData = {};
						this.rawDataPropertyMap[property.propertyName] = rawData;
						rawData.propertyValue = property.value;
						rawData.propertyReadOnly = property.propertyReadOnly;
						rawData.trimmed = property.trimmed;
					}
					ModelUtil.Singleton.releaseModelProperty(property);
				}
				propertiesReleased = true;
			}
			var isVersionObject = this.getIsVersionObject();
			for (var key in this.childObjectMap) {
				var o = this.childObjectMap[key];
				if (o.parentObject == this && (isVersionObject || !o.getIsVersionObject())) {
					if (o.releaseReleasableProperties()) {
						propertiesReleased = true;
					}
				}
			}
			return propertiesReleased;
			]]>
		</method>
		
		<!---
			Gets the business object editor this object belongs to.
			@return cmc/foundation/BusinessObjectEditor the business object editor
		-->
		<method name="getBusinessObjectEditor">
			<![CDATA[
			return this.model.oEditor;
			]]>
		</method>
		
		<!---
			@keywords private 
			Check the objects that were loaded by get children services. This method is called when objects are deleted.
			@param cmc/foundation/ModelObject destroyedObject: the object that is being destroyed
		-->
		<method args="destroyedObject" name="checkLoadedChildren">
			<![CDATA[
			if (typeof(destroyedObject) == "undefined") destroyedObject = null;
			this.checkLoadedChildrenDel.disconnectAll();
			for (var i = 0; i < this.loadChildrenStatusObjects.length; i++) {
				var statusObject = this.loadChildrenStatusObjects[i];
				if (statusObject.serviceObjectList != null) {
					var objectList = statusObject.serviceObjectList;
					if (objectList != null) {
						for (var j = 0; j < objectList.length; j++) {
							var o = objectList[j];
							if (o == destroyedObject) {
								objectList.splice(j, 1);
								statusObject.totalRecords--;
								statusObject.deleteCount++;
								j--;
							}
							else {
								this.checkLoadedChildrenDel.connect(o, "beingDestroyed");
							}
						}
					}
				}
			}
			]]>
		</method>
		
		<!--- 
			@keywords private 
			Add the specified object to the list of objects that were loaded by the specified service.
			@param cmc/foundation/GetChildrenService service: the service that loaded the object
			@param cmc/foundation/ModelObject o: the child object that was loaded
		-->
		<method args="service, o" name="addLoadedChild">
			<![CDATA[
			var statusObject = null;
			for (var i = 0; i < this.loadChildrenStatusObjects.length; i++) {
				if (this.loadChildrenStatusObjects[i].service == service) {
					statusObject = this.loadChildrenStatusObjects[i];
					break;
				}
			}
			if (statusObject == null) {
				statusObject = {
					service: service,
					message: null,
					messageForTree: null,
					hasError: null,
					startIndex: 0,
					totalRecords: 0,
					currPageNum: -1,
					lastPageNum: -1,
					deleteCount: 0,
					serviceObjectList: null
				};
				this.loadChildrenStatusObjects.push(statusObject);
			}
			if (statusObject.serviceObjectList == null) {
				statusObject.serviceObjectList = [];
			}
			statusObject.serviceObjectList.push(o);
			this.checkLoadedChildrenDel.connect(o, "beingDestroyed");
			]]>
		</method>	
		
		<!--- @keywords private -->
		<method args="open" name="set_open">
			<![CDATA[
			this.setOpen(open);
			]]>
		</method>
		<!--- @keywords private -->
		<method args="openGroupDirty" name="set_openGroupDirty">
			<![CDATA[
			this.setOpenGroupDirty(openGroupDirty);
			]]>
		</method>
	</Node>


	<!---
		A model object property is the representation of a business object property. A property should be used to model a single
		value of a business object. For example, the name of a product should be represented as model object property.
		The characteristics of a model property can be specified in a {@link cmc/foundation/PropertyDefinition cmc/foundation/PropertyDefinition instance}.
		
		<p>
		 A {@link cmc/foundation/ModelObject model object} aggregates a set of model properties to describe its values. In Management Center, a price object
		contains both currency and monetary value as its properties. A property's value must be able to be represented by a string because it
		needs to be transferred to the server.A property in a model object is should be created once if needed and only once. Therefore, a
		property instance should not be instantiated directly. The framework will instantiate and destroy instances of this class as required.
		
		<p>
		A property can be implicitly created based on values returned by server. In that case, a property definition is not needed.
		
		<p>
		The property description below describes the characteristics of a property for weight measurement. The property's name will
		be xprop_weightMeasure, and it has three values to choose, KGM for kilogram, LBR for milligram, and C62 for "1 Unit".
		
		@START_CODE	
			<PropertyDefinition propertyName="xprop_weightMeasure">
				<PropertyValue displayName="Kilogram" value="KGM"/>
				<PropertyValue displayName="milligram" value="LBR"/>
				<PropertyValue displayName="1 Unit" value="C62"/>
			</PropertyDefinition>
		@END_CODE
		
		@see cmc/foundation/PropertyDefinition
	-->
	<Node classDefinition="true" definitionName="cmc/foundation/ModelProperty">
		<dependency localName="ServiceTransactionUtil" moduleName="cmc/foundation/ServiceTransactionUtil"/>
		<dependency localName="StringUtil" moduleName="cmc/foundation/StringUtil"/>
		<dependency localName="EventHandler" moduleName="cmc/foundation/EventHandler"/>
		<dependency localName="EventUtil" moduleName="cmc/foundation/EventUtil"/>
		<dependency localName="Logger" moduleName="cmc/shell/Logger"/>
		<dependency localName="MessageLogger" moduleName="cmc/shell/MessageLogger"/>
		<!---
			Parent model object of this property
			@type cmc/foundation/ModelObject
		-->
		<variable name="o" value="${null}"/>
		
		<!---
			The value for this property.
		-->
		<variable name="value" type="string" value=""/>
		
		<!---
			The name of this property.
		-->
		<variable name="propertyName" type="string" value="${null}"/>
		
		<!---
			Indicates that the property has been changed and needs to be saved.
		-->
		<variable name="dirty" type="boolean" value="false"/>
		
		<!---
			Indicates that the property is enabled.
		-->
		<variable name="enabled" type="boolean" value="true"/>
		
		<!---
			@keywords private
			Property's Read Only State, if explicitely set
		-->
		<variable name="propertyReadOnly" value="${null}"/>
		
		<!---
			Property's Read Only State, either explicitly set or inherited. If this attribute is
			"true", this model object including its properties and child objects can not be modified.
		-->
		<variable name="readOnly" type="boolean" value="false"/>
		
		<!---
			@keywords private
			The restore value for the property. This value is used to restore
			the original property value if the object is closed without being saved.
		-->
		<variable name="restoreValue" type="string"/>
		
		<!---
			@keywords private
			This attribute indicates whether this property can be "redone".
		-->
		<variable name="redoable" type="boolean" value="false"/>
		
		<!---
			@keywords private
			The redo value for the property. This value is used by the {@link cmc/foundation/ModelProperty#redo redo} method to redo an undone change.		
		-->
		<variable name="redoValue" type="string"/>
		
		<!---
			The property definition for this property instance.
			@type cmc/foundation/PropertyDefinition
		-->
		<variable name="propertyDefinition"/>
		
		<!---
			@keywords private
			The service transaction object associated with this property. A transaction
			object will be created for service requests that are persisting the current
			state of a model object. If this value is null, it indicates that there
			is no active transaction request for this property.
		-->
		<variable name="transaction" value="${null}"/>
		
		<!---
			@keywords private
			An array of client validation errors. Validation errors are stored as objects that contain two properties:
			"message" and "validator".
		-->
		<variable name="clientErrors" value="${[]}"/>
		<!---
			@keywords private
			An array of server validation errors for this property. Server validation errors are stored as
			strings. Each element of the array is a string that represents a error message.
		-->
		<variable name="serverErrors" value="${[]}"/>
		
		<!---
			@keywords private
			Indicates that this property value has been trimmed.
		-->
		<variable name="trimmed" type="boolean" value="false"/>
		
		<!--- @keywords private -->
		<method name="init">
			<![CDATA[
			this.inherited(arguments);
			this.updateEnablementDel = new EventHandler.Class(this, "updateEnablement");
			this.updateReadOnlyDel = new EventHandler.Class(this, "updateReadOnly");
			this.updatePropertyDefDel = new EventHandler.Class(this, "updatePropertyDefinition");
			]]>
		</method>
		
		<!--- @keywords private -->
		<method name="destroy">
			<![CDATA[
			this.updateEnablementDel.disconnectAll();
			delete this.updateEnablementDel;
			this.updateReadOnlyDel.disconnectAll();
			delete this.updateReadOnlyDel;
			this.updatePropertyDefDel.disconnectAll();
			delete this.updatePropertyDefDel;
			Logger.Singleton.log("com.ibm.commerce.lobtools.foundation.model", "SEVERE", "cmc/foundation/ModelProperty", "destroy", "Unexpected cmc/foundation/ModelProperty destroy.");
			this.inherited(arguments);
			]]>
		</method>

		<!---
			@keywords private
			Gets and updates this property's property definition.
		-->
		<method args="e" name="updatePropertyDefinition">
			<![CDATA[
			if (typeof(e) == "undefined") e = null;
			var def = this.o.objectDefinition.getPropertyDefinition(this.o, this.propertyName, this.updatePropertyDefDel);
			if (typeof (def) == "undefined") {
				def = null;
			}
			if (this.propertyDefinition != def) {
				if (this.propertyDefinition){
					var validators = this.propertyDefinition.validators;
					for (var i = 0; i < validators.length; i++) {
						var validator = validators[i];
						this.clearValidationError(validator);
					}
				}
				this.setVariable("propertyDefinition", def);
			}
			]]>
		</method>

		<!---
			@keywords private
			Initializes this property definition.
			@param cmc/foundation/ModelObject o the parent model object of this property
			@param string propertyName the name of this property
		-->
		<method args="o, propertyName" name="initializeProperty">
			<![CDATA[
			this.o = o;
			this.propertyName = propertyName;
			o.propertyMap[propertyName] = this;
			this.updatePropertyDefinition();
			var rawData = o.rawDataPropertyMap[this.propertyName];
			if (rawData) {
				this.value = rawData.propertyValue;
				this.propertyReadOnly = rawData.propertyReadOnly;
				this.trimmed = rawData.trimmed;
				delete o.rawDataPropertyMap[this.propertyName];
			}
			else {
				this.value = "";
			}
			this.updateEnablement();
			if (typeof (this.propertyReadOnly) == "undefined") {
				this.propertyReadOnly = null;
			}
			this.updateReadOnlyDel.connect(this, "onpropertyReadOnly");
			this.updateReadOnlyDel.connect(o, "onreadOnly");
			this.updateReadOnly();
			]]>
		</method>

		<!---
			@keywords private
			Releases this property instance so it can be reused.
		-->
		<method name="release">
			<![CDATA[
			this.updatePropertyDefDel.disconnectAll();
			this.updateEnablementDel.disconnectAll();
			this.updateReadOnlyDel.disconnectAll();
			if (this.propertyName != null && this.o != null) {
				delete this.o.propertyMap[this.propertyName];
			}
			this.o = null;
			this.propertyName = null;
			this.value = "";
			this.dirty = false;
			this.enabled = true;
			this.propertyReadOnly = null;
			this.readOnly = false;
			this.restoreValue = undefined;
			this.redoValue = undefined;
			this.redoable = false;
			this.propertyDefinition = null;
			this.transaction = null;
			if (this.transaction != null) {
				ServiceTransactionUtil.Singleton.removeSaveProperty(this.transaction, this);
				this.transaction = null;
			}
			this.clientErrors = [];
			this.serverErrors = [];
			this.trimmed = false;
			]]>
		</method>
		
		<!---
			@keywords private
			Updates the value of the readOnly attribute
			@event onreadOnly
		-->
		<method args="e" name="updateReadOnly">
			<![CDATA[
			if (typeof(e) == "undefined") e = null;
			var newReadOnly = this.o.readOnly;
			if (!newReadOnly && this.propertyReadOnly != null && this.propertyReadOnly == "true") {
				newReadOnly = true;
			}
			if (this.readOnly != newReadOnly) {
				this.setVariable("readOnly", newReadOnly);
				if (this.propertyReadOnly != null) {
					this.o.checkOpenGroupReadOnly();
				}
			}
			]]>
		</method>
		
		<!---
			@keywords private
			Updates whether this property is enabled based on the current value of the
			enablement condition.
		-->
		<method args="e" name="updateEnablement">
			<![CDATA[
			if (typeof(e) == "undefined") e = null;
			this.updateEnablementDel.disconnectAll();
			this.updateEnablementDel.connect(this, "onpropertyDefinition");
			var newEnabled = true;
			if (this.propertyDefinition && this.propertyDefinition.enablementCondition) {
				this.propertyDefinition.enablementCondition.registerDelegate(this.o, this.updateEnablementDel);
				newEnabled = this.propertyDefinition.enablementCondition.isEnabled(this.o);
			}
			if (newEnabled != this.enabled) {
				this.setVariable("enabled", newEnabled);
			}
			this.validate();
			]]>
		</method>
		
		<!---
			Changes this property's value to the given new value. The value will be set only if this
			property is dirty and its value is different from this new value. If the property is changed,
			the open group object that owns this property will be dirty.
			
			@param string newValue the new property value to set to this property
			@event onvalue if the value is actually changed
		-->
		<method args="newValue" name="change">
			<![CDATA[
			if (newValue != this.value) {
				if (!this.propertyDefinition || this.propertyDefinition.markDirtyOnChange) {
					if (!this.dirty) {
						this.restoreValue = this.value;
						this.setVariable("dirty", true);
					}
					this.redoValue = undefined;
					this.redoable = false;
					if (this.o.openGroupObject != null) {
						if (!this.o.openGroupObject.open) {
							this.o.openGroupObject.setVariable("open", true);
						}
						if (!this.o.openGroupObject.openGroupDirty) {
							this.o.openGroupObject.setVariable("openGroupDirty", true);
						}
					}
				}
				this.setVariable("value", newValue);
			}
			]]>
		</method>
		
		<!---
			@keywords private
			Restores this property to its original value before any
			changes were made.
		-->
		<method name="restore">
			<![CDATA[
			if (this.dirty) {
				this.setVariable("value", this.restoreValue);
				this.reset();
				this.o.checkUnsavedChanges();
			}
			]]>
		</method>
		
		<!---
			Resets the "dirty" indicator to false. The current value will
			become the new restore value.
		-->
		<method name="reset">
			<![CDATA[
			if (this.dirty) {
				this.setVariable("dirty", false);
				this.restoreValue = undefined;
			}
			this.redoValue = undefined;
			this.redoable = false;
			]]>
		</method>
		
		<!---
			@keywords private
			Undoes the changes to the property, and remembers the value that was entered by the user
			before this operation.
		-->
		<method name="undo">
			<![CDATA[
			var newRedoValue = this.value;
			this.change(this.restoreValue);
			this.redoValue = newRedoValue;
			this.redoable = true;
			]]>
		</method>
		
		<!---
			@keywords private
			Redoes the changes to the property, setting the value to what was entered by the user
			before the undo operation.
		-->
		<method name="redo">
			<![CDATA[
			this.change(this.redoValue);
			]]>
		</method>
		
		<!---
			@keywords private
			Updates object Id, validates this property, and removes this property from the saved property list of its transaction.
			@event propertyChanged. This property will be sent along the event
		-->
		<handler name="onvalue">
			<![CDATA[
			if (this.propertyName == this.o.objectDefinition.idProperty && this.value && !this.o._parsing) {
				this.o.updateObjectId();
			}
			this.trimmed = false;
			this.validate();
			if (this.propertyDefinition != null && this.propertyDefinition.forceParentValidation) {
				this.o.parentObject.validate();
			}
			EventUtil.trigger(this.o, "propertyChanged", this);
			if (this.transaction != null && !this.trimming) {
				ServiceTransactionUtil.Singleton.removeSaveProperty(this.transaction, this);
			}
			]]>
		</handler>
		
		<!---
			@keywords private
			Validates this property. Optionally validates the parent object of this property.
			@param validateObject "true" if the parent object of this property should be validated. False or undefined otherwise.
		-->
		<method args="validateObject" name="validate">
			<![CDATA[
			if (typeof(validateObject) == "undefined") validateObject = true;
			if (validateObject) {
				this.o.validate(false);
			}
			if (!this.o.testObject && this.o.openGroupObject != null && !this.o.openGroupObject.refreshing && this.propertyDefinition != null && !cmcConfig.noValidation) {
				var validators = this.propertyDefinition.validators;
				for (var i = 0; i < validators.length; i++) {
					var validator = validators[i];
					if (this.enabled) {
						validator.validate(this.o, this);
					}
					else {
						this.clearValidationError(validator);
					}
				}
			}
			]]>
		</method>
		
		<!---
			Registers a validation error to this property for the specified validator. Each
			validator can only register one error message.
			@param cmc/foundation/Validator validator validator that generates the given error message
			@param string errorMsg the error message of the validation error to be registered
			@event onvalidationErrors if the error is added and the event onvalidationErrors exists
		-->
		<method args="validator, errorMsg" name="addValidationError">
			<![CDATA[
			var update = false;
			if (validator != null) {
				var error = null;
				for (var i = 0; i < this.clientErrors.length; i++) {
					if (this.clientErrors[i].validator == validator) {
						error = this.clientErrors[i];
						if (error.message != errorMsg) {
							error.message = errorMsg;
							update = true;
						}
						break;
					}
				}
				if (error == null) {
					error = {
						message: errorMsg,
						validator: validator
					};
					this.clientErrors.push(error);
					update = true;
				}
			}
			else {
				this.serverErrors.push(errorMsg);
				if (this.serverErrors.length == 1 && this.o.openGroupObject.messagesLogged) {
					for (var i = 0; i < this.clientErrors.length; i++) {
						MessageLogger.Singleton.clearValidationError(this.o, this, this.clientErrors[i].validator);
					}
				}
				update = true;
			}
			if (update) {
				if (this.o.openGroupObject) {
					this.o.checkErrors();
					if (this.o.openGroupObject.messagesLogged && (validator == null || this.serverErrors.length == 0)) {
						MessageLogger.Singleton.logValidationError(errorMsg, this.o, this, validator);
					}
				}
				EventUtil.trigger(this, "onvalidationErrors");
			}
			]]>
		</method>

		<!---
			Returns the array of the validation errors in this property. If there are any service errors, all
			the client-side validation errors will be suppressed.
			@return String[] an array of a validation errors in this property. This array contains either
				service errors or client-side errors. An empty array if no validation errors. A validation
				error describes what this error is, and is NL-enabled.
		-->
		<method name="getValidationErrors">
			<![CDATA[
			var errors = this.serverErrors;
			if (errors.length == 0) {
				errors = [];
				for (var i = 0; i < this.clientErrors.length; i++) {
					var error = this.clientErrors[i];
					errors.push(error.message);
				}
			}
			return errors;
			]]>
		</method>
		
		<!---
			Returns "true" if this property has any validation errors.
			@param boolean ignoreServiceErrors if "true", ignore errors reported by service requests. False otherwise.
			@return boolean "true" if there are validation errors. False otherwise.
		-->
		<method args="ignoreServiceErrors" name="hasValidationError">
			<![CDATA[
			if (typeof(ignoreServiceErrors) == "undefined") ignoreServiceErrors = false;
			var hasError = false;
			if (ignoreServiceErrors) {
				hasError = this.clientErrors.length > 0;
			}
			else {
				hasError = this.clientErrors.length > 0 || this.serverErrors.length > 0;
			}
			return hasError;
			]]>
		</method>

		<!---
			Removes the validator error for the specified validator.
			@param cmc/foundation/Validator validator the validator that generated the validation error to be removed
			@event onvalidationErrors if validation error is cleared and the event exists
		-->
		<method args="validator" name="clearValidationError">
			<![CDATA[
			var update = false;
			if (validator != null) {
				for (var i = 0; i < this.clientErrors.length; i++) {
					if (this.clientErrors[i].validator == validator) {
						update = true;
						this.clientErrors.splice(i, 1);
						i--;
					}
				}
			}
			else {
				if (this.serverErrors.length > 0) {
					this.serverErrors = [];
					update = true;
				}
				if (this.o.openGroupObject && this.o.openGroupObject.messagesLogged) {
					for (var i = 0; i < this.clientErrors.length; i++) {
						var error = this.clientErrors[i];
						MessageLogger.Singleton.logValidationError(error.message, this.o, this, error.validator);
					}
				}
			}
			if (update) {
				this.o.checkErrors();
				if (this.o.openGroupObject && this.o.openGroupObject.messagesLogged) {
					MessageLogger.Singleton.clearValidationError(this.o, this, validator);
				}
				EventUtil.trigger(this, "onvalidationErrors");
			}
			]]>
		</method>
		
		<!---
			Trim the property value.
		-->
		<method name="trim">
			<![CDATA[
			if (!this.trimmed) {
				var newPropertyValue = StringUtil.Singleton.trim(this.value);
				if (newPropertyValue != this.value) {
					this.trimming = true;
					this.setVariable("value", newPropertyValue);
					this.trimming = false;
				}
				this.trimmed = true;
			}
			]]>
		</method>
		
		<!---
			Check if this property can be released back into the raw data map. Properties
			can be released if they have not been changed, they have no validation errors and
			they are not bound to any widgets.
		-->
		<method name="isReleaseCandidate">
			<![CDATA[
			return !this.dirty && this.transaction == null && !this.hasValidationError() && (!this.__cmcEventAgents || !this.__cmcEventAgents.onvalidationErrors || this.__cmcEventAgents.onvalidationErrors.length == 0) && (!this.__cmcEventAgents || !this.__cmcEventAgents.onvalue || this.__cmcEventAgents.onvalue.length <= 1);
			]]>
		</method>
	</Node>
	
	<!---
		@keywords private
		
		A filtered list of model objects. A model object list is bound to
		a single view and provides a filtered view on an underlying
		list of objects.
	-->
	<Node classDefinition="true" definitionName="cmc/foundation/ModelObjectList">
		<dependency localName="ObjectTypeFilter" moduleName="cmc/foundation/ObjectTypeFilter"/>
		<dependency localName="ViewUtil" moduleName="cmc/foundation/ViewUtil"/>
		<dependency localName="CallbackUtil" moduleName="cmc/foundation/CallbackUtil"/>
		<dependency localName="ModelUtil" moduleName="cmc/foundation/ModelUtil"/>
		<dependency localName="EventHandler" moduleName="cmc/foundation/EventHandler"/>
		<dependency localName="FocusUtil" moduleName="cmc/foundation/FocusUtil"/>
		<dependency localName="EventUtil" moduleName="cmc/foundation/EventUtil"/>
		<dependency localName="Logger" moduleName="cmc/shell/Logger"/>
		<!---
			The view to which this model object list is bound.
		-->
		<variable name="v" value="${null}"/>
		<!---
			@keywords private
			A base filter for this list. If specified it will always apply.
		-->
		<variable name="baseFilter" value="${null}"/>
		<!---
			A list of filters for this list. If this list is empty and
			no "objectDefinitions" is null, then
			the model object list will include all of the objects
			found in the underlying list of model objects.
		-->
		<variable name="filterList" value="${[]}"/>
		<!---
			Array of valid object selectors for this object list.
			Objects that don't match this list of definitions and their corresponding selectors will be
			filtered out of the list. If this value is null, then the model object list will include all
			of the objects found in the underlying list of model objects.  When an object definition is found
			for an object selector, it must match all the propertyName, propertyValue constraints within that
			object selector.
		-->
		<variable name="objectSelectors" value="${null}"/>
		<!---
			The underlying array of model objects.
		-->
		<variable name="modelObjects" value="${null}"/>
		<!---
			The filtered list of model objects.
		-->
		<variable name="filteredObjects" value="${null}"/>
		<!---
			The object that has an associated details view. Only one object can have details
			displayed.
		-->
		<variable name="detailsViewObject" value="${null}"/>
		<!---
			The details view that is associated with the details view object.
		-->
		<variable name="objectDetailsView" value="${null}"/>
		<!---
			The sort comparator
		-->
		<variable name="sortComparator" value="${null}"/>
		<!---
			Indicates that the list is currently sorted in ascending order.
		-->
		<variable name="sortAscending" type="boolean" value="true"/>
		<!---
			The row index this object model list starts from for its associated view.
		-->
		<variable name="fromIndex" type="number" value="0"/>
		<!---
			The row index this object model list ends for its associated view.
		-->
		<variable name="toIndex" type="number" value="0"/>
		<!---
			@keywords private
			When rows are rendered, the rendering starts at this index.  Furthermore, the pivotIndex
			is always rendered.
		-->
		<variable name="pivotIndex" type="number" value="0"/>
		<!---
			@keywords private
			Indicates the pivot index view's offset. This is the number
			of pixels of the pivot index view that will be clipped by the scrolling
			mechanism. If all of the views can be displayed in the available height,
			the the pivotIndexOffset will be reset to zero.
		-->
		<variable name="pivotIndexOffset" type="number" value="0"/>
		<!---
			@keywords private
			The incremement value that the model object list uses from the pivot, 1 or -1.  The
			model object list starts at the pivot index and renders rows based on this increment.
		-->
		<variable name="increment" type="number" value="1"/>
		<!---
			@keywords private
			The immediate parent of the object views being used and created.
		-->
		<variable name="objectViewsImmediateParent" value="${null}"/>
		<!---
			Ignore reference count.
		-->
		<variable name="ignoreReferenceCount" type="boolean" value="false"/>
		<!---
			Indicates that the list of model objects includes at least one destroyed object. All requests
			to refresh the list of objects will be ignored until the list of model objects is updated.
		-->
		<variable name="hasDestroyedObjects" type="boolean" value="false"/>
		<!---
			Status object associated with this model object list. It contains the following properties:
			service - the service associated with this status object
			message - the message to display to the user
			messageForTree - the status message that will be displayed to the user (on browse object tree)
			hasError - indicates that the status message is an error
			totalRecords - recordSetTotal returned from service.
			currPageNum - the current page number.
			lastPageNum - the last page number.
		-->
		<variable name="statusObject" value="${null}"/>
		<!---
			Indicates that a deferred refreshFilteredObjects callback has been added to the list of deferred callbacks.
		-->
		<variable name="deferredRefreshAdded" type="boolean" value="false"/>
		<!---
			The index of the object that should be given focus. This value
                       is only used when one of the views already has focus.
                       If the object is not rendered, then focus will be given to the
                       closest rendered object.
		-->
		<variable name="focusObjectIndex" type="number" value="${-1}"/>
		
		<!---
			@keywords private
			The map of state of the views that are bound to the model objects.
		-->
		<variable name="viewStateMap" value="${{}}"/>
		<!---
			@keywords private
			A map of object unique IDs to views.
		-->
		<variable name="viewMap" value="${{}}"/>
		<!---
			@keywords private
			The average height of the views.
		-->
		<variable name="averageViewHeight" type="number" value="0"/>
		

		<!--- @keywords private -->
		<method name="init">
			<![CDATA[
			this.inherited(arguments);
			this.v.setVariable("oList", this);
			this.refreshFilteredObjects();
			]]>
		</method>
		
		<!--- @keywords private -->
		<method name="destroy">
			<![CDATA[
			if (Logger.Singleton.enabled) {
				Logger.Singleton.entering("com.ibm.commerce.lobtools.foundation.model", "cmc/foundation/ModelObjectList", "destroy");
				Logger.Singleton.log("com.ibm.commerce.lobtools.foundation.model", "FINER", "cmc/foundation/ModelObjectList", "destroy", "view=" + this.v);
			}
			if (this.updateAvailableHeightDel) {
				this.updateAvailableHeightDel.disconnectAll();
				delete this.updateAvailableHeightDel;
			}
			if (this.objectViewsHeightChangedDel) {
				this.objectViewsHeightChangedDel.disconnectAll();
				delete this.objectViewsHeightChangedDel;
			}
			if (this.v.oList == this) {
				this.v.setVariable("oList", null);
			}
			if (this.objectDestroyedDel) {
				this.objectDestroyedDel.disconnectAll();
				delete this.objectDestroyedDel;
			}
			if (this.deferredRefreshFilteredObjectsDel) {
				this.deferredRefreshFilteredObjectsDel.disconnectAll();
				delete this.deferredRefreshFilteredObjectsDel;
			}
			if (this.refreshFilteredObjectsDel) {
				delete this.refreshFilteredObjectsDel;
			}
			this.setModelObjects(null);
			this.inherited(arguments);
			if (Logger.Singleton.enabled) {
				Logger.Singleton.exiting("com.ibm.commerce.lobtools.foundation.model", "cmc/foundation/ModelObjectList", "destroy");
			}
			]]>
		</method>

		<!---
			Set the model objects for this model object list.
			@param array objects an array of cmc/foundation/ModelObject instances
			@event onmodelObjects
		-->
		<method args="objects" name="setModelObjects">
			<![CDATA[
			if (Logger.Singleton.enabled) {
				Logger.Singleton.entering("com.ibm.commerce.lobtools.foundation.model", "cmc/foundation/ModelObjectList", "setModelObjects(objects)", [objects]);
				Logger.Singleton.log("com.ibm.commerce.lobtools.foundation.model", "FINER", "cmc/foundation/ModelObjectList", "setModelObjects(objects)", "view=" + this.v);
			}
			var originalModelObjectsLength = 0;
			var newListLength = objects ? objects.length : 0;
			var firstChangeIndex = 0;
			var noChange = true;
			if (typeof (this.modelObjects) != "undefined" && this.modelObjects != null) {
				originalModelObjectsLength = this.modelObjects.length;
				if (!this.ignoreReferenceCount) {
					for (var i = 0; i < originalModelObjectsLength; i++) {
						var obj = this.modelObjects[i];
						if (noChange && newListLength > i && obj == objects[i]) {
							firstChangeIndex++;
						}
						else {
							noChange = false;
							if (obj != null) {
								obj = obj.getReferencedObject();
								if (obj != null) {
									obj.referenceCount--;
									if (Logger.Singleton.enabled) {
										Logger.Singleton.log("com.ibm.commerce.lobtools.foundation.model", "FINER", "cmc/foundation/ModelObjectList", "setModelObjects(objects)", "Old list: Object key=" + this.modelObjects[i].objectKey + ". Decrement counter for: Object key=" + obj.objectKey + ", new reference count=" + obj.referenceCount);
									}
								}
							}
						}
					}
				}
			}
			var isAppending = false;
			if (typeof (objects) != "undefined" && objects != null) {
				isAppending = this.filteredObjects && !this.hasDestroyedObjects && !this.deferredRefreshAdded && originalModelObjectsLength > 0 && objects.length > originalModelObjectsLength;
				this.hasDestroyedObjects = false;
				if (!this.objectDestroyedDel) {
					this.objectDestroyedDel = new EventHandler.Class(this, "objectDestroyed");
				}
				else {
					this.objectDestroyedDel.disconnectAll();
				}
				var newObjects = [];
				for (var i = 0; i < objects.length; i++) {
					var obj = objects[i];
					if (isAppending && i < originalModelObjectsLength && obj != this.modelObjects[i]) {
						isAppending = false;
					}
					this.objectDestroyedDel.connect(obj, "beingDestroyed");
					newObjects.push(obj);
					if (!this.ignoreReferenceCount && i >= firstChangeIndex) {
						obj = obj.getReferencedObject();
						if (obj != null) {
							obj.referenceCount++;
							if (Logger.Singleton.enabled) {
								Logger.Singleton.log("com.ibm.commerce.lobtools.foundation.model", "FINER", "cmc/foundation/ModelObjectList", "setModelObjects(objects)", "New list: Object key=" + objects[i].objectKey + ". Increment counter for: Object key=" + obj.objectKey + ", new reference count=" + obj.referenceCount);
							}
						}
					}
				}
				this.modelObjects = newObjects;
			}
			else {
				this.modelObjects = null;
			}
			if (isAppending) {
				for (var i = originalModelObjectsLength; i < this.modelObjects.length; i++) {
					var o = this.modelObjects[i];
					if (!o.isDeleting(this.deferredRefreshFilteredObjectsDel)) {
						ModelUtil.Singleton.objectSelectorsRegisterDelegate(o, this.objectSelectors, this.deferredRefreshFilteredObjectsDel);
						if (this.baseFilter) {
							this.baseFilter.registerDelegate(o, this.deferredRefreshFilteredObjectsDel);
						}
						for (var j = 0; this.filterList != null && j < this.filterList.length; j++) {
							this.filterList[j].registerDelegate(o, this.deferredRefreshFilteredObjectsDel);
						}
						if (this.matchesFilters(o)) {
							if (this.sortComparator != null && this.v.activeSort && this.sortComparator.registerDelegate) {
								this.sortComparator.registerDelegate(o, this.deferredRefreshFilteredObjectsDel);
							}
							this.filteredObjects.push(o);
						}
					}
				}
				this.applySort(this.filteredObjects);
				this.setVariable("filteredObjects", this.filteredObjects);
			}
			else {
				this.refreshFilteredObjects();
			}
			EventUtil.trigger(this, "onmodelObjects", this);
			if (Logger.Singleton.enabled) {
				Logger.Singleton.exiting("com.ibm.commerce.lobtools.foundation.model", "cmc/foundation/ModelObjectList", "setModelObjects(objects)");
			}
			]]>
		</method>

		<!---
			Set the details view object for this model object list.
			@param cmc/foundation/ModelObject newDetailsViewObject the new details view object
			@event ondetailsViewObject
		-->
		<method args="newDetailsViewObject" name="setDetailsViewObject">
			<![CDATA[
			var oldDetailsViewObject = this.detailsViewObject;
			this.detailsViewObject = newDetailsViewObject;
			if (newDetailsViewObject != oldDetailsViewObject) {
				this.updateObjectViews();
			}
			EventUtil.trigger(this, "ondetailsViewObject", this);
			]]>
		</method>
		
		<!--- @keywords private -->
		<method args="o" name="objectDestroyed">
			<![CDATA[
			this.hasDestroyedObjects = true;
			var key = o.getUID();
			if (typeof (this.viewStateMap[key]) != "undefined") {
				delete this.viewStateMap[key];
			}
			var index = this.modelObjects.indexOf(o);
			if (index != -1) {
				this.modelObjects[index] = null;
				if (!this.ignoreReferenceCount) {
					var po = o.getReferencedObject();
					if (po != null) {
						po.referenceCount--;
					}
					if (Logger.Singleton.enabled) {
						Logger.Singleton.log("com.ibm.commerce.lobtools.foundation.model", "FINER", "cmc/foundation/ModelObjectList", "objectDestroyed", "Object key=" + o.objectKey + ". Decrement counter for: Object key=" + po.objectKey + ", new reference count=" + po.referenceCount);
					}
				}
			}
			if (o == this.detailsViewObject) {
				this.detailsViewObject = null;
			}
			]]>
		</method>
		
		<!--- @keywords private -->
		<method args="o" name="matchesFilters">
			<![CDATA[
			var match = ModelUtil.Singleton.matchesObjectSelectors(o, this.objectSelectors);
			if (match && this.baseFilter) {
				match = this.baseFilter.matchesFilter(o);
			}
			var numFilters = this.filterList != null ? this.filterList.length : 0;
			if (match && numFilters > 0) {
				for (var j = 0; j < numFilters; j++) {
					var curFilter = this.filterList[j];
					match = curFilter.matchesFilter(o);
					if (match == false) {
						break;
					}
				}
			}
			return match;
			]]>
		</method>
		
		<!--- @keywords private -->
		<handler name="onbaseFilter">
			<![CDATA[
			this.loadChildren();
			this.refreshFilteredObjects();
			]]>
		</handler>
		
		<!--- @keywords private -->
		<handler name="onfilterList">
			<![CDATA[
			this.refreshFilteredObjects();
			]]>
		</handler>

		<!--- @keywords private -->
		<method name="getMatchingModelObjects">
			<![CDATA[
			var modelObjectsList = [];
			if (this.modelObjects) {
				var objects = this.modelObjects;
				for (var i = 0; i < objects.length; i++) {
					var o = objects[i];
					if (ModelUtil.Singleton.matchesObjectSelectors(o, this.objectSelectors) && (!this.baseFilter || this.baseFilter.matchesFilter(o))) {
						modelObjectsList.push(o);
					}
				}
			}
			return modelObjectsList;
			]]>
		</method>

		<!--- @keywords private -->
		<method args="e" name="deferredRefreshFilteredObjects">
			<![CDATA[
			if (typeof(e) == "undefined") e = null;
			if (!this.deferredRefreshAdded) {
				this.deferredRefreshAdded = true;
				if (!this.refreshFilteredObjectsDel) {
					this.refreshFilteredObjectsDel = new EventHandler.Class(this, "refreshFilteredObjects");
				}
				CallbackUtil.Singleton.addDeferredCallback(this.refreshFilteredObjectsDel, null, CallbackUtil.Singleton.PRIORITY_FOREGROUND);
			}
			]]>
		</method>

		<!--- @keywords private -->
		<method args="e" name="refreshFilteredObjects">
			<![CDATA[
			if (typeof(e) == "undefined") e = null;
			this.deferredRefreshAdded = false;
			if (this.deferredRefreshFilteredObjectsDel) {
				this.deferredRefreshFilteredObjectsDel.disconnectAll();
			}
			else {
				this.deferredRefreshFilteredObjectsDel = new EventHandler.Class(this, "deferredRefreshFilteredObjects");
			}
			var newList = [];
			var newViewStateMap = {};
			var focusView = null;
			var viewsLength = this.getViewsLength();
			for (var j = 0; j < viewsLength; j++) {
				var view = this.getView(j);
				if (ViewUtil.Singleton.containsView(view, FocusUtil.getFocus())) {
					focusView = view;
				}
			}
			this.focusObjectIndex = -1;
			var focusObject = null;
			if (this.modelObjects) {
				var objects = this.modelObjects;
				for (var i = 0; i < objects.length; i++) {
					var o = objects[i];
					if (o != null && !o.isDeleting(this.deferredRefreshFilteredObjectsDel)) {
						ModelUtil.Singleton.objectSelectorsRegisterDelegate(o, this.objectSelectors, this.deferredRefreshFilteredObjectsDel);
						if (this.baseFilter) {
							this.baseFilter.registerDelegate(o, this.deferredRefreshFilteredObjectsDel);
						}
						for (var j = 0; this.filterList != null && j < this.filterList.length; j++) {
							this.filterList[j].registerDelegate(o, this.deferredRefreshFilteredObjectsDel);
						}
						if (this.matchesFilters(o)) {
							if (this.sortComparator != null && this.v.activeSort && this.sortComparator.registerDelegate) {
								this.sortComparator.registerDelegate(o, this.deferredRefreshFilteredObjectsDel);
							}
							newList.push(o);
							if (focusView != null && o == focusView.o) {
								focusObject = o;
							}
							var key = o.getUID();
							if (this.viewStateMap != null && typeof (this.viewStateMap[key]) != "undefined") {
								newViewStateMap[key] = this.viewStateMap[key];
							}
						}
					}
				}
			}
			this.viewStateMap = newViewStateMap;
			this.applySort(newList);
			if (focusObject != null) {
				this.focusObjectIndex = newList.indexOf(focusObject);
			}
			if (this.focusObjectIndex == -1 && focusView != null) {
				var oldIndex = focusView._objectIndex;
				var oldLength = this.filteredObjects.length;
				while (oldIndex + 1 < oldLength) {
					var o = this.filteredObjects[oldIndex + 1];
					var newIndex = newList.indexOf(o);
					if (newIndex == -1) {
						oldIndex++;
					}
					else {
						this.focusObjectIndex = newIndex;
						break;
					}
				}
				if (this.focusObjectIndex == -1) {
					while (oldIndex > 0) {
						var o = this.filteredObjects[oldIndex - 1];
						var newIndex = newList.indexOf(o);
						if (newIndex == -1) {
							oldIndex--;
						}
						else {
							this.focusObjectIndex = newIndex;
							break;
						}
					}
				}
			}
			this.setVariable("filteredObjects", newList);
			]]>
		</method>
		
		<!--- @keywords private -->
		<handler name="onfilteredObjects">
			<![CDATA[
			this.updateObjectViews();
			]]>
		</handler>
		
		<!---
			@keywords private
			This method finds the index of a given object in its filtered objects and shows this object in the view
			by setting the fromIndex or toIndex.  If the objectIndex is within the current fromIndex or toIndex,
			then it is allready displayed and no update is required to the views.  If the objectIndex is less than
			the fromIndex, then we must pivot against the fromIndex so that the object is displayed at the beginning.
			If the objectIndex is greater than the toIndex, then we must pivot against the toIndex so that the object
			is displayed at the end.  In both these scenarios we do the least amount of the scrolling.
		-->
		<method args="o" name="showObjectInView">
			<![CDATA[
			var objectIndex = -1;
			var objects = this.filteredObjects;
			for (var i = 0; i < objects.length; i++) {
				if (objects[i] == o) {
					objectIndex = i;
					break;
				}
			}
			if (objectIndex >= 0) {
				if (objectIndex < this.fromIndex || (this.pivotIndexOffset != 0 && objectIndex == this.pivotIndex && this.increment > 0) || (objectIndex == this.fromIndex && this.increment < 0)) {
					this.setFromIndex(objectIndex);
				}
				else if (objectIndex > this.toIndex || (this.pivotIndexOffset != 0 && objectIndex == this.pivotIndex && this.increment < 0) || (objectIndex == this.toIndex && this.increment > 0)) {
					this.setToIndex(objectIndex);
					if (this.fromIndex == this.toIndex) {
						this.setFromIndex(objectIndex);
					}
				}
			}
			]]>
		</method>
		
		<!--- @keywords private -->
		<method args="e" name="updateAvailableHeight">
			<![CDATA[
			if (typeof(e) == "undefined") e = null;
			this.updateObjectViews();
			]]>
		</method>
		
		<!---
			@keywords private
			This method listens for the object views height to change and determines whether the updateObjectViews method should
			be called.  The threshold for when to trigger the updateObjectViews re-rendering algorithm is that we try to render
			one object view that is rendered past the available height if they can fit. This occurs in the following
			two circumstances.
			<ul>
				<li>The last object view's ending co-ordinate (objectView.y + objectView.height) is less than the availableHeight and
				there are more filtered objects that can be rendered.  This means we have more vertical space or available height to show
				more rows, and we should add rows until the first row passes the available height as described above.</li>
				<li>The second last object view's ending co-ordinate (objectView.y + objectView.height) is greater than the available height.
				This means that we have atleast one row that isn't within the available height, meaning we have too many rows rendered.</li>
			</ul>
			
			This method acts as a constraint in a feedback loop.  The error that is determined to be significant is the scenario defined above.
			When the error is significant as defined above, then it will recall the updateObjectViews method, rendering the object views.
		-->
		<method args="e" name="objectViewsHeightChanged">
			<![CDATA[
			if (typeof(e) == "undefined") e = null;
			if (this._objectViewsHeightChangedLock) {
				return;
			}
			this._objectViewsHeightChangedLock = true;
			var updateObjectViewsInvoked = false;
			var viewsLength = this.getViewsLength();
			var objectView = this.getView(viewsLength - 1);
			if ((objectView.y + this.getViewHeight(objectView)) < (this.v.availableHeight - this.pivotIndexOffset) && viewsLength < this.filteredObjects.length) {
				this.updateObjectViews();
				updateObjectViewsInvoked = true;
			}
			else if (viewsLength >= 2) {
				objectView = this.getView(viewsLength - 2);
				if ((objectView.y + this.getViewHeight(objectView)) > (this.v.availableHeight - this.pivotIndexOffset)) {
					this.updateObjectViews();
					updateObjectViewsInvoked = true;
				}
			}
			if (!updateObjectViewsInvoked) {
				EventUtil.trigger(this, "objectViewsUpdated");
			}
			this._objectViewsHeightChangedLock = false;
			]]>
		</method>
		
		<!---
			@keywords private
			This method sets the index where the object list will start rendering.  This
			means that it sets the pivot index to the given fromIndex and sets the increment
			value to 1.
			
			It is advisable that this method is used for paging down and when scrolling up one
			item at a time.  The fromIndex is the appropriate pivot in these cases.  When
			paging down, we want the fromIndex to pivot because we have a starting point for
			a new page.  When scrolling up we want the fromIndex to be the pivot point, because
			we want to make sure we see the next item that is scrolled into view.
			
			You may optionally pass in the number of pixels that will be clipped from the 
			pivot index view by the scrolling mechanism. This will change the
			calculations to assume that only part of the pivot index view is visible.
		-->
		<method args="newFromIndex, offset" name="setFromIndex">
			<![CDATA[
			if (typeof(offset) == "undefined") offset = 0;
			this.pivotIndex = newFromIndex;
			this.pivotIndexOffset = offset;
			this.increment = 1;
			this.updateObjectViews();
			]]>
		</method>
		
		<!---
			@keywords private
			This method sets the index where the object list will stop rendering.  This
			means that it sets the pivot index to the given toIndex and sets the increment
			value to -1.
			
			It is advisable that this method is used for paging up and when scrolling down one
			item at a time.  The toIndex is the appropriate pivot in these cases.  When
			paging up, we want the toIndex to pivot because we have an ending point for
			a new page.  When scrolling down we want the toIndex to be the pivot point, because
			we want to make sure we see the next item that is scrolled into view.
			
			You may optionally pass in the number of pixels that will be clipped from the 
			pivot index view by the scrolling mechanism. This will change the
			calculations to assume that only part of the pivot index view is visible.
		-->
		<method args="newToIndex, offset" name="setToIndex">
			<![CDATA[
			if (typeof(offset) == "undefined") offset = 0;
			this.pivotIndex = newToIndex;
			this.pivotIndexOffset = offset;
			this.increment = -1;
			this.updateObjectViews();
			]]>
		</method>
		
		<!--- @keywords private -->
		<method args="index" name="getView">
			<![CDATA[
			if (this.v._objectViewsImmediateParent) {
				var views = this.v._objectViewsImmediateParent.layouts[0].components;
				var visibleIndex = -1;
				for (var i = 0; i < views.length; i++) {
					var v = views[i];
					if (v.parentOList == this && v.visible) {
						visibleIndex++;
						if (visibleIndex == index) {
							return v;
						}
					}
				}
			}
			return null;
			]]>
		</method>
		
		<!--- @keywords private -->
		<method args="v" name="getViewHeight">
			<![CDATA[
			var viewHeight = v.height;
			if (v.o != null && v.o == this.detailsViewObject && this.objectDetailsView != null) {
				viewHeight += this.objectDetailsView.height;
			}
			return viewHeight;
			]]>
		</method>
		
		<!--- @keywords private -->
		<method name="getFirstView">
			<![CDATA[
			var views = this.v._objectViewsImmediateParent.layouts[0].components;
			for (var i = 0; i < views.length; i++) {
				var v = views[i];
				if (v.parentOList == this && !v._used) {
					return v;
				}
			}
			return null;
			]]>
		</method>
		
		<!--- @keywords private -->
		<method name="getLastView">
			<![CDATA[
			var views = this.v._objectViewsImmediateParent.layouts[0].components;
			for (var i = (views.length - 1); i > -1; i--) {
				var v = views[i];
				if (v.parentOList == this && !v._used) {
					return v;
				}
			}
			return null;
			]]>
		</method>
		
		<!--- @keywords private -->
		<method name="getAnyView">
			<![CDATA[
			var views = this.v._objectViewsImmediateParent.childComponents;
			for (var i = 0; i < views.length; i++) {
				var v = views[i];
				if (v.parentOList == this && !v._used) {
					return v;
				}
			}
			return null;
			]]>
		</method>
		
		<!--- @keywords private -->
		<method name="getViewsLength">
			<![CDATA[
			var len = 0;
			if (this.v._objectViewsImmediateParent) {
				var views = this.v._objectViewsImmediateParent.childComponents;
				for (var i = 0; i < views.length; i++) {
					if (views[i].parentOList == this && views[i].visible) {
						len++;
					}
				}
			}
			return len;
			]]>
		</method>
		
		<!--- @keywords private -->
		<method args="view" name="setViewPosition">
			<![CDATA[
			if (!this.v._objectViewsImmediateParent) {
				this.v._objectViewsImmediateParent = view.immediateParent;
				this.v._objectViewsImmediateParent.layouts[0].lock();
			}
			var objectViewLayout = this.v._objectViewsImmediateParent.layouts[0];
			var objectViewSubviews = this.v._objectViewsImmediateParent.childComponents;
			var beforeView = null;
			var beforeViewIndex = -1;
			for (var i = 0; i < objectViewSubviews.length; i++) {
				var v = objectViewSubviews[i];
				if (v._used) {
					if (view._objectIndex > v._objectIndex) {
						if (beforeView == null || beforeView._objectIndex < v._objectIndex) {
							beforeView = v;
							beforeViewIndex = i;
						}
					}
				}
			}
			while (beforeViewIndex + 1 < objectViewSubviews.length) {
				var v = objectViewSubviews[beforeViewIndex + 1];
				if (v.parentOList != this && v.visible) {
					beforeViewIndex++;
					beforeView = v;
				}
				else {
					break;
				}
			}
			if (beforeView != null) {
				objectViewLayout.setLayoutOrder(beforeView, view);
				this.reorderSubviews(objectViewSubviews, beforeView, view);
			}
			else {
				objectViewLayout.setLayoutOrder("first", view);
				this.reorderSubviews(objectViewSubviews, "first", view);
			}
			if (this.objectDetailsView != null && this.objectDetailsView.o == view.o) {
				objectViewLayout.setLayoutOrder(view, this.objectDetailsView);
				this.reorderSubviews(objectViewSubviews, view, this.objectDetailsView);
			}
			]]>
		</method>
		
		<!---
			Move the second view right after the first view in the specifed list of subviews. If the first view has a value
			of "first", the second view will be moved to the beginning of the list of subviews. If the first view has a value
			of "last", the second view will be moved to the end of the list of subviews.
			@param subviews the list of subviews where views will be reorderd
			@param cmc/foundation/Component1 v the view where the second view will be moved after, it can also have a value of "first" or "last"
			@param cmc/foundation/Component2 v the view to be moved right after the first view
		-->
		<method args="subviews, view1, view2" name="reorderSubviews">
			<![CDATA[
			var len = subviews.length;
			var startIndex = -1;
			if (view1 == "first") {
				startIndex = 0;
			}
			else if (view1 == "last") {
				startIndex = len;
			}
			var view2Index = -1;
			var i = 0;
			while ((i < len) && (startIndex < 0 || view2Index < 0)) {
				if (startIndex < 0 && subviews[i] == view1) {
					startIndex = i + 1;
				}
				if (view2Index < 0 && subviews[i] == view2) {
					view2Index = i;
				}
				i++;
			}
			if (startIndex > -1 && view2Index > -1 && startIndex != view2Index) {
				subviews.splice(view2Index, 1);
				if (view2Index < startIndex) {
					startIndex = startIndex - 1;
				}
				subviews.splice(startIndex, 0, view2);
			}
			]]>
		</method>
		
		<!---
			@keywords private
			This method will setup object views for each object in this model object list.  If the attributes availableHeight and maxObjectViews
			are not set for this model object list's view, then all matching objects and filtered in objects are attempted to be rendered.  This method
			starts at the pivot index and renders new views based on the increment.  It will stop when the maxObjectViews limit has been reached, or
			if the when the available height has been reached.
			
			This algorithm reuses object views.  It will attempt to reuse the same object view for a given object if that object is to be displayed
			in this list and it allready is rendered, otherwise it will attempt to reuse another object view before creating new ones.  It never
			destroys object views, but pools them when we do not need them.
			
			This method is called when the pivotIndex for this object list has changed, and it can be called when the availableHeight or objectViews
			height has changed.  The object list uses a feedback loop through the method objectViewsHeightChanged.  The model object list monitors
			whether the object views have changed and the objectViewsHeightChanged method is called, this method determines whether we should call
			this method.  The reason for this is that this method can be very expensive, and the object views height may have changed but it may not
			be a significant change.  The criteria for what a significant change in height is outlined in the objectViewsHeightChanged method.
		-->
		<method name="updateObjectViews">
			<![CDATA[
			if (!this.hasDestroyedObjects) {
				if (this.v._objectViewsImmediateParent) {
					this.v._objectViewsImmediateParent.layouts[0].lock();
				}
				if (this.objectDetailsView != null && this.objectDetailsView.o != this.detailsViewObject) {
					this.objectDetailsView.setVariable("o", null);
					this.objectDetailsView.setVariable("visible", false);
					this.setVariable("objectDetailsView", null);
				}
				var detailsViewObjectVisible = false;
				var totalViewHeight = 0;
				var focusView = null;
				var viewsLength = this.getViewsLength();
				for (var j = 0; j < viewsLength; j++) {
					var view = this.getView(j);
					if (ViewUtil.Singleton.containsView(view, FocusUtil.getFocus())) {
						focusView = view;
						if (this.focusObjectIndex == -1) {
							this.focusObjectIndex = focusView._objectIndex;
						}
					}
					view._used = false;
					if (view.o) {
						view.o.unregisterObjectView(view);
					}
				}
				if (focusView == null) {
					this.focusObjectIndex == -1;
				}
				var availableHeight = null;
				if (typeof (this.v.availableHeight) != "undefined") {
					if (!this.updateAvailableHeightDel) {
						this.updateAvailableHeightDel = new EventHandler.Class(this, "updateAvailableHeight");
					}
					else {
						this.updateAvailableHeightDel.disconnectAll();
					}
					availableHeight = this.v.availableHeight;
				}
				if (availableHeight != null) {
					if (!this.objectViewsHeightChangedDel) {
						this.objectViewsHeightChangedDel = new EventHandler.Class(this, "objectViewsHeightChanged");
					}
					else {
						this.objectViewsHeightChangedDel.disconnectAll();
					}
				}
				var maxObjectViews = null;
				if (typeof (this.v.maxObjectViews) != "undefined") {
					maxObjectViews = this.v.maxObjectViews;
				}
				var objects = this.filteredObjects;
				if (objects) {
					if (this.pivotIndex > (objects.length - 1)) {
						this.pivotIndex = objects.length - 1;
						this.pivotIndexOffset = 0;
					}
					if (this.pivotIndex < 0) {
						this.pivotIndex = 0;
						this.pivotIndexOffset = 0;
					}
				}
				this.averageViewHeight = 0;
				if (objects && objects.length > 0) {
					var targetFocusView = null;
					var newHeight = -this.pivotIndexOffset;
					this.fromIndex = this.pivotIndex;
					this.toIndex = this.pivotIndex;
					var viewCount = 0;
					var i = this.pivotIndex;
					while ((availableHeight == null || newHeight < availableHeight) && (maxObjectViews == null || viewCount < maxObjectViews)) {
						var objectIndex = i;
						var forward = this.increment > 0;
						if (objectIndex < 0 || objectIndex > (objects.length - 1)) {
							if (forward) {
								objectIndex = this.pivotIndex - (i - objects.length + 1);
							}
							else {
								objectIndex = this.pivotIndex - i;
							}
							newHeight += this.pivotIndexOffset;
							this.pivotIndexOffset = 0;
							forward = !forward;
						}
						var o = null;
						if (objectIndex < 0 || objectIndex > (objects.length - 1)) {
							break;
						}
						else {
							o = objects[objectIndex];
						}
						i = i + this.increment;
						var objectView = null;
						viewsLength = this.getViewsLength();
						for (var j = 0; j < viewsLength; j++) {
							var view = this.getView(j);
							if (view.o == o) {
								objectView = view;
								break;
							}
						}
						if (objectView == null && this.v._objectViewsImmediateParent) {
							if (forward) {
								objectView = this.getLastView();
							}
							else {
								objectView = this.getFirstView();
							}
							if (objectView == null) {
								objectView = this.getAnyView();
							}
						}
						if (objectView == null) {
							objectView = new this.v.objectClass.Class(this.v, {
								parentOList: this
							});
						}
						o.registerObjectView(objectView);
						if (objectView.o != o) {
							objectView.setVariable("o", o);
							if (!objectView.visible) {
								objectView.setVariable("visible", true);
							}
						}
						objectView._objectIndex = objectIndex;
						objectView._used = true;
						if (this.detailsViewObject == o) {
							detailsViewObjectVisible = true;
							if (this.objectDetailsView == null) {
								this.setVariable("objectDetailsView", objectView.getObjectDetailsView());
							}
							else if (!this.objectDetailsView.visible) {
								this.objectDetailsView.setVariable("visible", true);
							}
							if (this.objectDetailsView != null) {
								this.objectDetailsView._objectIndex = objectIndex;
							}
						}
						newHeight += this.getViewHeight(objectView);
						totalViewHeight += objectView.height;
						if (forward) {
							this.toIndex = objectIndex;
						}
						else {
							this.fromIndex = objectIndex;
						}
						this.setViewPosition(objectView);
						viewCount++;
						if (focusView != null) {
							if (targetFocusView == null) {
								targetFocusView = objectView;
							}
							else if (this.focusObjectIndex != -1 && targetFocusView._objectIndex != this.focusObjectIndex) {
								if ((targetFocusView._objectIndex > objectIndex && this.focusObjectIndex <= objectIndex) || (targetFocusView._objectIndex < objectIndex && this.focusObjectIndex >= objectIndex)) {
									targetFocusView = objectView;
								}
							}
						}
					}
					if (viewCount > 0) {
						this.averageViewHeight = totalViewHeight / viewCount;
					}
				}
				if (focusView != null) {
					if (targetFocusView == null) {
						if (this.parent.restoreFocus) {
							this.parent.restoreFocus();
						}
						else {
							FocusUtil.setFocus(this.parent);
						}
					}
					else if (targetFocusView != focusView) {
						var o = targetFocusView.o;
						var objectIndex = targetFocusView._objectIndex;
						if (focusView._used) {
							focusView._used = false;
							focusView.o.unregisterObjectView(focusView);
							focusView.o.registerObjectView(targetFocusView);
							targetFocusView.setVariable("o", focusView.o);
							targetFocusView._objectIndex = focusView._objectIndex;
							this.setViewPosition(targetFocusView);
						}
						else {
							targetFocusView._used = false;
						}
						o.unregisterObjectView(targetFocusView);
						o.registerObjectView(focusView);
						focusView._used = true;
						focusView.setVariable("o", o);
						focusView._objectIndex = objectIndex;
						this.setViewPosition(focusView);
					}
				}
				this.viewMap = {};
				if (this.v._objectViewsImmediateParent) {
					var views = this.v._objectViewsImmediateParent.childComponents;
					for (var i = 0; i < views.length; i++) {
						var view = views[i];
						if (view.parentOList == this) {
							if (!view._used) {
								if (view.visible) {
									view.setVariable("visible", false);
								}
								if (view.o != null) {
									view.setVariable("o", null);
								}
							}
							else {
								this.viewMap[view.o.getUID()] = view;
							}
						}
					}
				}
				this.focusObjectIndex = -1;
				if (!detailsViewObjectVisible && this.objectDetailsView != null && this.objectDetailsView.visible) {
					this.objectDetailsView.setVariable("visible", false);
				}
				if (this.v._objectViewsImmediateParent) {
					this.v._objectViewsImmediateParent.layouts[0].unlock();
				}
				if (availableHeight != null) {
					if (this.getViewsLength() > 0) {
						this.objectViewsHeightChangedDel.connect(this.v._objectViewsImmediateParent, "onheight");
					}
					this.updateAvailableHeightDel.connect(this.v, "onavailableHeight");
				}
				EventUtil.trigger(this, "objectViewsUpdated");
			}
			]]>
		</method>
		
		<!--- Sort the list based on the specified sort comparator 
			@param object comparator The sort comparator.
			@param boolean overrideAscending A flag to indicate whether to override the list's current {@link cmc/foundation/ModelObjectList#sortAscending sortAscending} value. When this is true, the list will always be sorted into ascending order. The default value is false.
		-->
		<method args="comparator, overrideAscending" name="doSort">
			<![CDATA[
			if (typeof(overrideAscending) == "undefined") overrideAscending = false;
			if (Logger.Singleton.enabled) {
				Logger.Singleton.entering("com.ibm.commerce.lobtools.foundation.model", "cmc/foundation/ModelObjectList", "doSort(comparator)", [comparator]);
			}
			if (!overrideAscending && comparator == this.sortComparator) {
				this.sortAscending = !this.sortAscending;
				this.filteredObjects.reverse();
			}
			else {
				this.sortAscending = true;
			}
			this.sortComparator = comparator;
			this.applySort(this.filteredObjects);
			this.setVariable("filteredObjects", this.filteredObjects);
			if (Logger.Singleton.enabled) {
				Logger.Singleton.exiting("com.ibm.commerce.lobtools.foundation.model", "cmc/foundation/ModelObjectList", "doSort(comparator)");
			}
			]]>
		</method>
		
		<!--- Sort the list based on the stored specified sort comparator -->
		<method args="unsortedObjects" name="applySort">
			<![CDATA[
			for (var i = 0; i < unsortedObjects.length; i++) {
				unsortedObjects[i]._compareValue = null;
			}
			if (this.sortComparator != null) {
				var caller = this;
				require(["cmc/foundation/SortUtil"], function(SortUtil) {
					SortUtil.Singleton.sort(unsortedObjects, caller);
				});
			}
			]]>
		</method>

		<!--- Compare function for the list using the sort comparator -->		
		<method args="o1, o2" name="compare">
			<![CDATA[
			var result = this.sortComparator.compare(o1, o2, this.sortAscending);
			if (Logger.Singleton.enabled) {
				Logger.Singleton.log("com.ibm.commerce.lobtools.foundation.model", "FINER", "cmc/foundation/ModelObjectList", "compare(o1,o2)", "o1=" + o1.objectDisplayName + ",o2=" + o2.objectDisplayName + ",result=" + result);
			}
			return result;
			]]>
		</method>
		
		<!---
			@keywords private
			Loads the children associated for this model object list
		-->	
		<method name="loadChildren">
			<![CDATA[
			if (this.loadChildrenDel) {
				this.loadChildrenDel.disconnectAll();
			}
			else {
				this.loadChildrenDel = new EventHandler.Class(this, "loadChildren");
			}
			if (this.v && this.v.parentO) {
				this.v.parentO.loadChildren(this.getChildObjectDefinitions(this.loadChildrenDel));
			}
			]]>
		</method>
		
		<!---
			@keywords private
			Get the child object definitions associated with this model object list.
		-->
		<method name="getChildObjectDefinitions" args="del">
			<![CDATA[
			var objectDefinitions = null;
			if (this.v && this.v.parentO) {
				var oSelectors = null;
				if (this.objectSelectors) {
					oSelectors = this.objectSelectors;
				}
				else if (this.baseFilter && this.baseFilter instanceof ObjectTypeFilter.Class && this.baseFilter.objectTypes) {
					oSelectors = this.v.parentO.model.getObjectSelectors(this.v.parentO, this.baseFilter.objectTypes, del);
				}
				if (oSelectors != null) {
					objectDefinitions = [];
					for (var i = 0; i < oSelectors.length; i++) {
						if (objectDefinitions.indexOf(oSelectors[i].objectDefinition) < 0) {
							objectDefinitions.push(oSelectors[i].objectDefinition);
						}
					}
				}
			}
			return objectDefinitions;
			]]>
		</method>
		
		<!--- @keywords private -->
		<method args="o" name="getViewState">
			<![CDATA[
			return this.viewStateMap[o.getUID()];
			]]>
		</method>

		<!--- @keywords private -->
		<method args="o, viewState" name="setViewState">
			<![CDATA[
			this.viewStateMap[o.getUID()] = viewState;
			]]>
		</method>
	
		<!--- @keywords private -->
		<method args="o" name="getObjectView">
			<![CDATA[
			return this.viewMap[o.getUID()];
			]]>
		</method>
		
		<!--- @keywords private -->
		<method args="pageNum" name="doLoadPage">
			<![CDATA[
			if (this.statusObject && this.statusObject.pageController) {
				if (this.v.deselectAll) {
					this.v.deselectAll();
				}
				this.statusObject.pageController.doLoadPage({
					oList: this,
					pageNum: pageNum
				});
			}
			]]>
		</method>
		<!--- @keywords private -->
		<method args="detailsViewObject" name="set_detailsViewObject">
			<![CDATA[
			this.setDetailsViewObject(detailsViewObject);
			]]>
		</method>
		<!--- @keywords private -->
		<method args="modelObjects" name="set_modelObjects">
			<![CDATA[
			this.setModelObjects(modelObjects);
			]]>
		</method>
	</Node>
	
	<!---
		@keywords private
		
		Selection manager for a view that is controlled by a model object list.
	-->
	<Node classDefinition="true" definitionName="cmc/foundation/ModelObjectListSelectionManager">
		<dependency localName="EventHandler" moduleName="cmc/foundation/EventHandler"/>
		<dependency localName="EventUtil" moduleName="cmc/foundation/EventUtil"/>
		<dependency localName="KeyUtil" moduleName="cmc/foundation/KeyUtil"/>
		<!---
			The model object list.
		-->
		<variable name="oList"/>
		<!---
			Array of currently selected objects.
		-->
		<variable name="selectedObjects" value="${[]}"/>
		<!--- @keywords private -->
		<variable name="multiSelect" type="boolean" value="true"/>
		<!---
			The onselectedObjects event is triggered when the selection changes.
		-->
		
		
		<!---  @keywords private -->
		<method name="init">
			<![CDATA[
			this.inherited(arguments);
			this.unselectObjectDel = new EventHandler.Class(this, "unselectObject");
			this.pruneSelectionDel = new EventHandler.Class(this, "pruneSelection");
			]]>
		</method>
		
		<!---  @keywords private -->
		<method name="destroy">
			<![CDATA[
			this.pruneSelectionDel.disconnectAll();
			delete this.pruneSelectionDel;
			this.unselectObjectDel.disconnectAll();
			delete this.unselectObjectDel;
			this.inherited(arguments);
			]]>
		</method>
		
		<!---
			Handle new model object list.
		-->
		<handler name="onoList">
			<![CDATA[
			this.pruneSelectionDel.disconnectAll();
			if (this.oList) {
				this.pruneSelectionDel.connect(this.oList, "onfilteredObjects");
			}
			else {
				this.selectedObjects = [];
				this.selectionChanged();
			}
			]]>
		</handler>
		
		<!---
			Prune the selected objects list by removing
			entries that aren't being displayed
		-->
		<method args="e" name="pruneSelection">
			<![CDATA[
			if (typeof(e) == "undefined") e = null;
			var change = false;
			for (var i = 0; i < this.selectedObjects.length; i++) {
				if (this.oList.filteredObjects.indexOf(this.selectedObjects[i]) == -1) {
					this.selectedObjects.splice(i, 1);
					i--;
					change = true;
				}
			}
			if (!this.multiSelect && this.selectedObjects.length == 0 && this.oList.filteredObjects.length > 0) {
				this.selectedObjects.push(this.oList.filteredObjects[0]);
				this.setViewSelection(this.oList.filteredObjects[0], true);
				change = true;
			}
			if (change) {
				this.selectionChanged();
			}
			]]>
		</method>
		
		<!---
			Handle change to the list of selected objects.
		-->
		<method name="selectionChanged">
			<![CDATA[
			this.unselectObjectDel.disconnectAll();
			var objects = this.selectedObjects;
			for (var i = 0; i < objects.length; i++) {
				this.unselectObjectDel.connect(objects[i], "beingDestroyed");
			}
			EventUtil.trigger(this, "onselectedObjects");
			]]>
		</method>

		<!---
			Select the specified object view.
			@param cmc/foundation/Component v the view
		-->		
		<method args="v" name="select">
			<![CDATA[
			this.selectObject(v.o);
			]]>
		</method>
		
		<!---
			Deselect the specified object view.
			@param cmc/foundation/Component v the view
		-->
		<method args="v" name="unselect">
			<![CDATA[
			this.unselectObject(v.o);
			]]>
		</method>

		<!---
			Select the specified object.
			@param cmc/foundation/ModelObject o the model object
		-->
		<method args="o" name="selectObject">
			<![CDATA[
			var change = false;
			if (this.isRangeSelect() && this.selectedObjects.length > 0) {
				var firstSelectedObject = this.selectedObjects[0];
				var i1 = this.oList.filteredObjects.indexOf(firstSelectedObject);
				var i2 = this.oList.filteredObjects.indexOf(o);
				this._clearSelection();
				if (i2 > i1) {
					for (var i = i1; i <= i2; i++) {
						this.selectedObjects.push(this.oList.filteredObjects[i]);
						this.setViewSelection(this.oList.filteredObjects[i], true);
					}
				}
				else {
					for (var i = i1; i >= i2; i--) {
						this.selectedObjects.push(this.oList.filteredObjects[i]);
						this.setViewSelection(this.oList.filteredObjects[i], true);
					}
				}
				change = true;
			}
			else if (this.isMultiSelect() && this.isSelectedObject(o)) {
				this._unselectObject(o);
				change = true;
			}
			else if (this.isMultiSelect()) {
				this.selectedObjects.push(o);
				this.setViewSelection(o, true);
				change = true;
			}
			else {
				if (this.selectedObjects.length != 1 || this.selectedObjects[0] != o) {
					this._clearSelection();
					this.selectedObjects.push(o);
					this.setViewSelection(o, true);
					change = true;
				}
			}
			if (change) {
				this.selectionChanged();
			}
			]]>
		</method>

		<!---
			Deselect the specified model object.
			@param cmc/foundation/ModelObject o the model object
		-->		
		<method args="o" name="unselectObject">
			<![CDATA[
			if (this._unselectObject(o)) {
				this.selectionChanged();
			}
			]]>
		</method>
		
		<method args="o" name="_unselectObject">
			<![CDATA[
			var change = false;
			var i = this.selectedObjects.indexOf(o);
			if (i >= 0) {
				this.setViewSelection(o, false);
				this.selectedObjects.splice(i, 1);
				change = true;
			}
			return change;
			]]>
		</method>
		
		<!---
			Set the view selection for the specified object.
			@param cmc/foundation/ModelObject o the model object
			@param boolean isSelected "true" if the object is to be selected, false otherwise
		-->
		<method args="o, isSelected" name="setViewSelection">
			<![CDATA[
			var viewsLength = this.oList.getViewsLength();
			for (var i = 0; i < viewsLength; i++) {
				var view = this.oList.getView(i);
				if (view.o == o) {
					view.setSelected(isSelected);
					break;
				}
			}
			]]>
		</method>
		
		<!---
			Returns "true" if the specified object view is selected.
			@param cmc/foundation/Component v the object view
			@return boolean "true" if selected
		-->
		<method args="v" name="isSelected">
			<![CDATA[
			return this.isSelectedObject(v.o);
			]]>
		</method>
		
		<!---
			Returns tru
		-->
		<method args="o" name="isSelectedObject">
			<![CDATA[
			return this.selectedObjects.indexOf(o) >= 0;
			]]>
		</method>
		
		<method name="clearSelection">
			<![CDATA[
			if (_clearSelection()) {
				this.selectionChanged();
			}
			]]>
		</method>
		
		<method name="_clearSelection">
			<![CDATA[
			var change = false;
			if (this.selectedObjects.length > 0) {
				change = true;
				while (this.selectedObjects.length > 0) {
					this._unselectObject(this.selectedObjects[0]);
				}
			}
			return change;
			]]>
		</method>
		
		<method name="selectAllObjects">
			<![CDATA[
			this.clearSelection();
			for (var i = 0; i < this.oList.filteredObjects.length; i++) {
				this.selectedObjects.push(this.oList.filteredObjects[i]);
				this.setViewSelection(this.oList.filteredObjects[i], true);
			}
			this.selectionChanged();
			]]>
		</method>
		
		<method name="getSelection">
			<![CDATA[
			var selectedViews = [];
			var viewsLength = this.oList.getViewsLength();
			for (var i = 0; i < viewsLength; i++) {
				var view = this.oList.getView(i);
				if (view.selected) {
					selectedViews.push(view);
				}
			}
			return selectedViews;
			]]>
		</method>
		
		<method args="o" name="getObjectView">
			<![CDATA[
			return this.oList.getObjectView(o);
			]]>
		</method>
		
		<method name="getSelectedObjects">
			<![CDATA[
			return this.selectedObjects;
			]]>
		</method>
		
		<method name="isRangeSelect">
			<![CDATA[
			return KeyUtil.isKeyDown("shift") && this.selectedObjects.length > 0 && !KeyUtil.isKeyDown("enter") && !KeyUtil.isKeyDown("tab");
			]]>
		</method>
		
		<method name="isMultiSelect">
			<![CDATA[
			return this.multiSelect && KeyUtil.isKeyDown("control");
			]]>
		</method>
		
	</Node>

	<!---
		@keywords private

		This class defines the sort comparator to sort a list of objects by the given sequence property. This will be used when
		the value of the sequencePropertyName attribute is defined.
	-->
	<Node classDefinition="true" definitionName="cmc/foundation/SequenceSortComparator">
		<!--- @keywords private -->
		<variable name="sequencePropertyName" type="string" value="${null}"/>

		<!--- @keywords private -->
		<variable name="sequencePropertyPath" type="string" value="${null}"/>

		<!--- @keywords private -->
		<method args="o" name="getSortOrder">
			<![CDATA[
			var value = o.getPropertyValue(this.sequencePropertyName, this.sequencePropertyPath);
			value = Number(value);
			if (isNaN(value)) {
				value = null;
			}
			return value;
			]]>
		</method>

		<!---
			The compare function used to sort the list of objects.

			@param cmc/foundation/ModelObject o1 The first model object to compare.
			@param cmc/foundation/ModelObject o2 The second model object to compare.
			@param boolean sortAscending A boolean indicator of whether the required sort is into ascending order.
			@return number If sortAscending is true, this method will return 1 when the value of o1 is greater than
			the value of o2 and -1 otherwise. If sortAscending is false, the comparison will return 1 if
			the value of o1 is less than the value of o2 and -1 otherwise. If the value of o1 is equal to the
			value of o2, this method will return 0.
		-->
		<method args="o1, o2, sortAscending" name="compare">
			<![CDATA[
			var result = 0;
			var v1 = this.getSortOrder(o1);
			var v2 = this.getSortOrder(o2);
			if (v1 > v2) {
				result = sortAscending ? 1 : -1;
			}
			else if (v1 < v2) {
				result = sortAscending ? -1 : 1;
			}
			return result;
			]]>
		</method>

		<!---
			@keywords private
			Register a delegate to be executed when the resolved value changes for the specified model object.
			@param cmc/foundation/ModelObject o: the model object
			@param cmc/foundation/EventHandler del: the delegate
		-->
		<method args="o, del" name="registerDelegate">
			<![CDATA[
			if (this.sequencePropertyPath) {
				o = o.getObject(this.sequencePropertyPath, false, null, del);
			}
			del.connect(o.getProperty(this.sequencePropertyName), "onvalue");
			]]>
		</method>
	</Node>

</Definitions>