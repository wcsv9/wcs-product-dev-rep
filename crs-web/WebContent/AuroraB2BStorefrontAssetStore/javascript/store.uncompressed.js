/*eslint-disable no-unused-vars*/
/*!
 * jQuery JavaScript Library v3.1.0
 * https://jquery.com/
 *
 * Includes Sizzle.js
 * https://sizzlejs.com/
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
 *
 * Date: 2016-07-07T21:44Z
 */
( function( global, factory ) {

	"use strict";

	if ( typeof module === "object" && typeof module.exports === "object" ) {

		// For CommonJS and CommonJS-like environments where a proper `window`
		// is present, execute the factory and get jQuery.
		// For environments that do not have a `window` with a `document`
		// (such as Node.js), expose a factory as module.exports.
		// This accentuates the need for the creation of a real `window`.
		// e.g. var jQuery = require("jquery")(window);
		// See ticket #14549 for more info.
		module.exports = global.document ?
			factory( global, true ) :
			function( w ) {
				if ( !w.document ) {
					throw new Error( "jQuery requires a window with a document" );
				}
				return factory( w );
			};
	} else {
		factory( global );
	}

// Pass this if window is not defined yet
} )( typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
// enough that all such attempts are guarded in a try block.
"use strict";

var arr = [];

var document = window.document;

var getProto = Object.getPrototypeOf;

var slice = arr.slice;

var concat = arr.concat;

var push = arr.push;

var indexOf = arr.indexOf;

var class2type = {};

var toString = class2type.toString;

var hasOwn = class2type.hasOwnProperty;

var fnToString = hasOwn.toString;

var ObjectFunctionString = fnToString.call( Object );

var support = {};



	function DOMEval( code, doc ) {
		doc = doc || document;

		var script = doc.createElement( "script" );

		script.text = code;
		doc.head.appendChild( script ).parentNode.removeChild( script );
	}
/* global Symbol */
// Defining this global in .eslintrc would create a danger of using the global
// unguarded in another place, it seems safer to define global only for this module



var
	version = "3.1.0",

	// Define a local copy of jQuery
	jQuery = function( selector, context ) {

		// The jQuery object is actually just the init constructor 'enhanced'
		// Need init if jQuery is called (just allow error to be thrown if not included)
		return new jQuery.fn.init( selector, context );
	},

	// Support: Android <=4.0 only
	// Make sure we trim BOM and NBSP
	rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,

	// Matches dashed string for camelizing
	rmsPrefix = /^-ms-/,
	rdashAlpha = /-([a-z])/g,

	// Used by jQuery.camelCase as callback to replace()
	fcamelCase = function( all, letter ) {
		return letter.toUpperCase();
	};

jQuery.fn = jQuery.prototype = {

	// The current version of jQuery being used
	jquery: version,

	constructor: jQuery,

	// The default length of a jQuery object is 0
	length: 0,

	toArray: function() {
		return slice.call( this );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {
		return num != null ?

			// Return just the one element from the set
			( num < 0 ? this[ num + this.length ] : this[ num ] ) :

			// Return all the elements in a clean array
			slice.call( this );
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems ) {

		// Build a new jQuery matched element set
		var ret = jQuery.merge( this.constructor(), elems );

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	each: function( callback ) {
		return jQuery.each( this, callback );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map( this, function( elem, i ) {
			return callback.call( elem, i, elem );
		} ) );
	},

	slice: function() {
		return this.pushStack( slice.apply( this, arguments ) );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	eq: function( i ) {
		var len = this.length,
			j = +i + ( i < 0 ? len : 0 );
		return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
	},

	end: function() {
		return this.prevObject || this.constructor();
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: push,
	sort: arr.sort,
	splice: arr.splice
};

jQuery.extend = jQuery.fn.extend = function() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[ 0 ] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;

		// Skip the boolean and the target
		target = arguments[ i ] || {};
		i++;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !jQuery.isFunction( target ) ) {
		target = {};
	}

	// Extend jQuery itself if only one argument is passed
	if ( i === length ) {
		target = this;
		i--;
	}

	for ( ; i < length; i++ ) {

		// Only deal with non-null/undefined values
		if ( ( options = arguments[ i ] ) != null ) {

			// Extend the base object
			for ( name in options ) {
				src = target[ name ];
				copy = options[ name ];

				// Prevent never-ending loop
				if ( target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
					( copyIsArray = jQuery.isArray( copy ) ) ) ) {

					if ( copyIsArray ) {
						copyIsArray = false;
						clone = src && jQuery.isArray( src ) ? src : [];

					} else {
						clone = src && jQuery.isPlainObject( src ) ? src : {};
					}

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend( {

	// Unique for each copy of jQuery on the page
	expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

	// Assume jQuery is ready without the ready module
	isReady: true,

	error: function( msg ) {
		throw new Error( msg );
	},

	noop: function() {},

	isFunction: function( obj ) {
		return jQuery.type( obj ) === "function";
	},

	isArray: Array.isArray,

	isWindow: function( obj ) {
		return obj != null && obj === obj.window;
	},

	isNumeric: function( obj ) {

		// As of jQuery 3.0, isNumeric is limited to
		// strings and numbers (primitives or objects)
		// that can be coerced to finite numbers (gh-2662)
		var type = jQuery.type( obj );
		return ( type === "number" || type === "string" ) &&

			// parseFloat NaNs numeric-cast false positives ("")
			// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
			// subtraction forces infinities to NaN
			!isNaN( obj - parseFloat( obj ) );
	},

	isPlainObject: function( obj ) {
		var proto, Ctor;

		// Detect obvious negatives
		// Use toString instead of jQuery.type to catch host objects
		if ( !obj || toString.call( obj ) !== "[object Object]" ) {
			return false;
		}

		proto = getProto( obj );

		// Objects with no prototype (e.g., `Object.create( null )`) are plain
		if ( !proto ) {
			return true;
		}

		// Objects with prototype are plain iff they were constructed by a global Object function
		Ctor = hasOwn.call( proto, "constructor" ) && proto.constructor;
		return typeof Ctor === "function" && fnToString.call( Ctor ) === ObjectFunctionString;
	},

	isEmptyObject: function( obj ) {

		/* eslint-disable no-unused-vars */
		// See https://github.com/eslint/eslint/issues/6125
		var name;

		for ( name in obj ) {
			return false;
		}
		return true;
	},

	type: function( obj ) {
		if ( obj == null ) {
			return obj + "";
		}

		// Support: Android <=2.3 only (functionish RegExp)
		return typeof obj === "object" || typeof obj === "function" ?
			class2type[ toString.call( obj ) ] || "object" :
			typeof obj;
	},

	// Evaluates a script in a global context
	globalEval: function( code ) {
		DOMEval( code );
	},

	// Convert dashed to camelCase; used by the css and data modules
	// Support: IE <=9 - 11, Edge 12 - 13
	// Microsoft forgot to hump their vendor prefix (#9572)
	camelCase: function( string ) {
		return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
	},

	nodeName: function( elem, name ) {
		return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
	},

	each: function( obj, callback ) {
		var length, i = 0;

		if ( isArrayLike( obj ) ) {
			length = obj.length;
			for ( ; i < length; i++ ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		} else {
			for ( i in obj ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		}

		return obj;
	},

	// Support: Android <=4.0 only
	trim: function( text ) {
		return text == null ?
			"" :
			( text + "" ).replace( rtrim, "" );
	},

	// results is for internal usage only
	makeArray: function( arr, results ) {
		var ret = results || [];

		if ( arr != null ) {
			if ( isArrayLike( Object( arr ) ) ) {
				jQuery.merge( ret,
					typeof arr === "string" ?
					[ arr ] : arr
				);
			} else {
				push.call( ret, arr );
			}
		}

		return ret;
	},

	inArray: function( elem, arr, i ) {
		return arr == null ? -1 : indexOf.call( arr, elem, i );
	},

	// Support: Android <=4.0 only, PhantomJS 1 only
	// push.apply(_, arraylike) throws on ancient WebKit
	merge: function( first, second ) {
		var len = +second.length,
			j = 0,
			i = first.length;

		for ( ; j < len; j++ ) {
			first[ i++ ] = second[ j ];
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, invert ) {
		var callbackInverse,
			matches = [],
			i = 0,
			length = elems.length,
			callbackExpect = !invert;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( ; i < length; i++ ) {
			callbackInverse = !callback( elems[ i ], i );
			if ( callbackInverse !== callbackExpect ) {
				matches.push( elems[ i ] );
			}
		}

		return matches;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var length, value,
			i = 0,
			ret = [];

		// Go through the array, translating each of the items to their new values
		if ( isArrayLike( elems ) ) {
			length = elems.length;
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}

		// Go through every key on the object,
		} else {
			for ( i in elems ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}
		}

		// Flatten any nested arrays
		return concat.apply( [], ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// Bind a function to a context, optionally partially applying any
	// arguments.
	proxy: function( fn, context ) {
		var tmp, args, proxy;

		if ( typeof context === "string" ) {
			tmp = fn[ context ];
			context = fn;
			fn = tmp;
		}

		// Quick check to determine if target is callable, in the spec
		// this throws a TypeError, but we will just return undefined.
		if ( !jQuery.isFunction( fn ) ) {
			return undefined;
		}

		// Simulated bind
		args = slice.call( arguments, 2 );
		proxy = function() {
			return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
		};

		// Set the guid of unique handler to the same of original handler, so it can be removed
		proxy.guid = fn.guid = fn.guid || jQuery.guid++;

		return proxy;
	},

	now: Date.now,

	// jQuery.support is not used in Core but other projects attach their
	// properties to it so it needs to exist.
	support: support
} );

if ( typeof Symbol === "function" ) {
	jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
}

// Populate the class2type map
jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
function( i, name ) {
	class2type[ "[object " + name + "]" ] = name.toLowerCase();
} );

function isArrayLike( obj ) {

	// Support: real iOS 8.2 only (not reproducible in simulator)
	// `in` check used to prevent JIT error (gh-2145)
	// hasOwn isn't used here due to false negatives
	// regarding Nodelist length in IE
	var length = !!obj && "length" in obj && obj.length,
		type = jQuery.type( obj );

	if ( type === "function" || jQuery.isWindow( obj ) ) {
		return false;
	}

	return type === "array" || length === 0 ||
		typeof length === "number" && length > 0 && ( length - 1 ) in obj;
}
var Sizzle =
/*!
 * Sizzle CSS Selector Engine v2.3.0
 * https://sizzlejs.com/
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2016-01-04
 */
(function( window ) {

var i,
	support,
	Expr,
	getText,
	isXML,
	tokenize,
	compile,
	select,
	outermostContext,
	sortInput,
	hasDuplicate,

	// Local document vars
	setDocument,
	document,
	docElem,
	documentIsHTML,
	rbuggyQSA,
	rbuggyMatches,
	matches,
	contains,

	// Instance-specific data
	expando = "sizzle" + 1 * new Date(),
	preferredDoc = window.document,
	dirruns = 0,
	done = 0,
	classCache = createCache(),
	tokenCache = createCache(),
	compilerCache = createCache(),
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
		}
		return 0;
	},

	// Instance methods
	hasOwn = ({}).hasOwnProperty,
	arr = [],
	pop = arr.pop,
	push_native = arr.push,
	push = arr.push,
	slice = arr.slice,
	// Use a stripped-down indexOf as it's faster than native
	// https://jsperf.com/thor-indexof-vs-for/5
	indexOf = function( list, elem ) {
		var i = 0,
			len = list.length;
		for ( ; i < len; i++ ) {
			if ( list[i] === elem ) {
				return i;
			}
		}
		return -1;
	},

	booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

	// Regular expressions

	// http://www.w3.org/TR/css3-selectors/#whitespace
	whitespace = "[\\x20\\t\\r\\n\\f]",

	// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
	identifier = "(?:\\\\.|[\\w-]|[^\0-\\xa0])+",

	// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
	attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +
		// Operator (capture 2)
		"*([*^$|!~]?=)" + whitespace +
		// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
		"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
		"*\\]",

	pseudos = ":(" + identifier + ")(?:\\((" +
		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
		// 1. quoted (capture 3; capture 4 or capture 5)
		"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
		// 2. simple (capture 6)
		"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
		// 3. anything else (capture 2)
		".*" +
		")\\)|)",

	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	rwhitespace = new RegExp( whitespace + "+", "g" ),
	rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
	rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),

	rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),

	rpseudo = new RegExp( pseudos ),
	ridentifier = new RegExp( "^" + identifier + "$" ),

	matchExpr = {
		"ID": new RegExp( "^#(" + identifier + ")" ),
		"CLASS": new RegExp( "^\\.(" + identifier + ")" ),
		"TAG": new RegExp( "^(" + identifier + "|[*])" ),
		"ATTR": new RegExp( "^" + attributes ),
		"PSEUDO": new RegExp( "^" + pseudos ),
		"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
			"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
			"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
		"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
		// For use in libraries implementing .is()
		// We use this for POS matching in `select`
		"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
			whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
	},

	rinputs = /^(?:input|select|textarea|button)$/i,
	rheader = /^h\d$/i,

	rnative = /^[^{]+\{\s*\[native \w/,

	// Easily-parseable/retrievable ID or TAG or CLASS selectors
	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

	rsibling = /[+~]/,

	// CSS escapes
	// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
	runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
	funescape = function( _, escaped, escapedWhitespace ) {
		var high = "0x" + escaped - 0x10000;
		// NaN means non-codepoint
		// Support: Firefox<24
		// Workaround erroneous numeric interpretation of +"0x"
		return high !== high || escapedWhitespace ?
			escaped :
			high < 0 ?
				// BMP codepoint
				String.fromCharCode( high + 0x10000 ) :
				// Supplemental Plane codepoint (surrogate pair)
				String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
	},

	// CSS string/identifier serialization
	// https://drafts.csswg.org/cssom/#common-serializing-idioms
	rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\x80-\uFFFF\w-]/g,
	fcssescape = function( ch, asCodePoint ) {
		if ( asCodePoint ) {

			// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
			if ( ch === "\0" ) {
				return "\uFFFD";
			}

			// Control characters and (dependent upon position) numbers get escaped as code points
			return ch.slice( 0, -1 ) + "\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + " ";
		}

		// Other potentially-special ASCII characters get backslash-escaped
		return "\\" + ch;
	},

	// Used for iframes
	// See setDocument()
	// Removing the function wrapper causes a "Permission Denied"
	// error in IE
	unloadHandler = function() {
		setDocument();
	},

	disabledAncestor = addCombinator(
		function( elem ) {
			return elem.disabled === true;
		},
		{ dir: "parentNode", next: "legend" }
	);

// Optimize for push.apply( _, NodeList )
try {
	push.apply(
		(arr = slice.call( preferredDoc.childNodes )),
		preferredDoc.childNodes
	);
	// Support: Android<4.0
	// Detect silently failing push.apply
	arr[ preferredDoc.childNodes.length ].nodeType;
} catch ( e ) {
	push = { apply: arr.length ?

		// Leverage slice if possible
		function( target, els ) {
			push_native.apply( target, slice.call(els) );
		} :

		// Support: IE<9
		// Otherwise append directly
		function( target, els ) {
			var j = target.length,
				i = 0;
			// Can't trust NodeList.length
			while ( (target[j++] = els[i++]) ) {}
			target.length = j - 1;
		}
	};
}

function Sizzle( selector, context, results, seed ) {
	var m, i, elem, nid, match, groups, newSelector,
		newContext = context && context.ownerDocument,

		// nodeType defaults to 9, since context defaults to document
		nodeType = context ? context.nodeType : 9;

	results = results || [];

	// Return early from calls with invalid selector or context
	if ( typeof selector !== "string" || !selector ||
		nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

		return results;
	}

	// Try to shortcut find operations (as opposed to filters) in HTML documents
	if ( !seed ) {

		if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
			setDocument( context );
		}
		context = context || document;

		if ( documentIsHTML ) {

			// If the selector is sufficiently simple, try using a "get*By*" DOM method
			// (excepting DocumentFragment context, where the methods don't exist)
			if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {

				// ID selector
				if ( (m = match[1]) ) {

					// Document context
					if ( nodeType === 9 ) {
						if ( (elem = context.getElementById( m )) ) {

							// Support: IE, Opera, Webkit
							// TODO: identify versions
							// getElementById can match elements by name instead of ID
							if ( elem.id === m ) {
								results.push( elem );
								return results;
							}
						} else {
							return results;
						}

					// Element context
					} else {

						// Support: IE, Opera, Webkit
						// TODO: identify versions
						// getElementById can match elements by name instead of ID
						if ( newContext && (elem = newContext.getElementById( m )) &&
							contains( context, elem ) &&
							elem.id === m ) {

							results.push( elem );
							return results;
						}
					}

				// Type selector
				} else if ( match[2] ) {
					push.apply( results, context.getElementsByTagName( selector ) );
					return results;

				// Class selector
				} else if ( (m = match[3]) && support.getElementsByClassName &&
					context.getElementsByClassName ) {

					push.apply( results, context.getElementsByClassName( m ) );
					return results;
				}
			}

			// Take advantage of querySelectorAll
			if ( support.qsa &&
				!compilerCache[ selector + " " ] &&
				(!rbuggyQSA || !rbuggyQSA.test( selector )) ) {

				if ( nodeType !== 1 ) {
					newContext = context;
					newSelector = selector;

				// qSA looks outside Element context, which is not what we want
				// Thanks to Andrew Dupont for this workaround technique
				// Support: IE <=8
				// Exclude object elements
				} else if ( context.nodeName.toLowerCase() !== "object" ) {

					// Capture the context ID, setting it first if necessary
					if ( (nid = context.getAttribute( "id" )) ) {
						nid = nid.replace( rcssescape, fcssescape );
					} else {
						context.setAttribute( "id", (nid = expando) );
					}

					// Prefix every selector in the list
					groups = tokenize( selector );
					i = groups.length;
					while ( i-- ) {
						groups[i] = "#" + nid + " " + toSelector( groups[i] );
					}
					newSelector = groups.join( "," );

					// Expand context for sibling selectors
					newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
						context;
				}

				if ( newSelector ) {
					try {
						push.apply( results,
							newContext.querySelectorAll( newSelector )
						);
						return results;
					} catch ( qsaError ) {
					} finally {
						if ( nid === expando ) {
							context.removeAttribute( "id" );
						}
					}
				}
			}
		}
	}

	// All others
	return select( selector.replace( rtrim, "$1" ), context, results, seed );
}

/**
 * Create key-value caches of limited size
 * @returns {function(string, object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */
function createCache() {
	var keys = [];

	function cache( key, value ) {
		// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
		if ( keys.push( key + " " ) > Expr.cacheLength ) {
			// Only keep the most recent entries
			delete cache[ keys.shift() ];
		}
		return (cache[ key + " " ] = value);
	}
	return cache;
}

/**
 * Mark a function for special use by Sizzle
 * @param {Function} fn The function to mark
 */
function markFunction( fn ) {
	fn[ expando ] = true;
	return fn;
}

/**
 * Support testing using an element
 * @param {Function} fn Passed the created element and returns a boolean result
 */
function assert( fn ) {
	var el = document.createElement("fieldset");

	try {
		return !!fn( el );
	} catch (e) {
		return false;
	} finally {
		// Remove from its parent by default
		if ( el.parentNode ) {
			el.parentNode.removeChild( el );
		}
		// release memory in IE
		el = null;
	}
}

/**
 * Adds the same handler for all of the specified attrs
 * @param {String} attrs Pipe-separated list of attributes
 * @param {Function} handler The method that will be applied
 */
function addHandle( attrs, handler ) {
	var arr = attrs.split("|"),
		i = arr.length;

	while ( i-- ) {
		Expr.attrHandle[ arr[i] ] = handler;
	}
}

/**
 * Checks document order of two siblings
 * @param {Element} a
 * @param {Element} b
 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
 */
function siblingCheck( a, b ) {
	var cur = b && a,
		diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
			a.sourceIndex - b.sourceIndex;

	// Use IE sourceIndex if available on both nodes
	if ( diff ) {
		return diff;
	}

	// Check if b follows a
	if ( cur ) {
		while ( (cur = cur.nextSibling) ) {
			if ( cur === b ) {
				return -1;
			}
		}
	}

	return a ? 1 : -1;
}

/**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */
function createInputPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return name === "input" && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */
function createButtonPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return (name === "input" || name === "button") && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for :enabled/:disabled
 * @param {Boolean} disabled true for :disabled; false for :enabled
 */
function createDisabledPseudo( disabled ) {
	// Known :disabled false positives:
	// IE: *[disabled]:not(button, input, select, textarea, optgroup, option, menuitem, fieldset)
	// not IE: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
	return function( elem ) {

		// Check form elements and option elements for explicit disabling
		return "label" in elem && elem.disabled === disabled ||
			"form" in elem && elem.disabled === disabled ||

			// Check non-disabled form elements for fieldset[disabled] ancestors
			"form" in elem && elem.disabled === false && (
				// Support: IE6-11+
				// Ancestry is covered for us
				elem.isDisabled === disabled ||

				// Otherwise, assume any non-<option> under fieldset[disabled] is disabled
				/* jshint -W018 */
				elem.isDisabled !== !disabled &&
					("label" in elem || !disabledAncestor( elem )) !== disabled
			);
	};
}

/**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
function createPositionalPseudo( fn ) {
	return markFunction(function( argument ) {
		argument = +argument;
		return markFunction(function( seed, matches ) {
			var j,
				matchIndexes = fn( [], seed.length, argument ),
				i = matchIndexes.length;

			// Match elements found at the specified indexes
			while ( i-- ) {
				if ( seed[ (j = matchIndexes[i]) ] ) {
					seed[j] = !(matches[j] = seed[j]);
				}
			}
		});
	});
}

/**
 * Checks a node for validity as a Sizzle context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */
function testContext( context ) {
	return context && typeof context.getElementsByTagName !== "undefined" && context;
}

// Expose support vars for convenience
support = Sizzle.support = {};

/**
 * Detects XML nodes
 * @param {Element|Object} elem An element or a document
 * @returns {Boolean} True iff elem is a non-HTML XML node
 */
isXML = Sizzle.isXML = function( elem ) {
	// documentElement is verified for cases where it doesn't yet exist
	// (such as loading iframes in IE - #4833)
	var documentElement = elem && (elem.ownerDocument || elem).documentElement;
	return documentElement ? documentElement.nodeName !== "HTML" : false;
};

/**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [doc] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
setDocument = Sizzle.setDocument = function( node ) {
	var hasCompare, subWindow,
		doc = node ? node.ownerDocument || node : preferredDoc;

	// Return early if doc is invalid or already selected
	if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
		return document;
	}

	// Update global variables
	document = doc;
	docElem = document.documentElement;
	documentIsHTML = !isXML( document );

	// Support: IE 9-11, Edge
	// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
	if ( preferredDoc !== document &&
		(subWindow = document.defaultView) && subWindow.top !== subWindow ) {

		// Support: IE 11, Edge
		if ( subWindow.addEventListener ) {
			subWindow.addEventListener( "unload", unloadHandler, false );

		// Support: IE 9 - 10 only
		} else if ( subWindow.attachEvent ) {
			subWindow.attachEvent( "onunload", unloadHandler );
		}
	}

	/* Attributes
	---------------------------------------------------------------------- */

	// Support: IE<8
	// Verify that getAttribute really returns attributes and not properties
	// (excepting IE8 booleans)
	support.attributes = assert(function( el ) {
		el.className = "i";
		return !el.getAttribute("className");
	});

	/* getElement(s)By*
	---------------------------------------------------------------------- */

	// Check if getElementsByTagName("*") returns only elements
	support.getElementsByTagName = assert(function( el ) {
		el.appendChild( document.createComment("") );
		return !el.getElementsByTagName("*").length;
	});

	// Support: IE<9
	support.getElementsByClassName = rnative.test( document.getElementsByClassName );

	// Support: IE<10
	// Check if getElementById returns elements by name
	// The broken getElementById methods don't pick up programmatically-set names,
	// so use a roundabout getElementsByName test
	support.getById = assert(function( el ) {
		docElem.appendChild( el ).id = expando;
		return !document.getElementsByName || !document.getElementsByName( expando ).length;
	});

	// ID find and filter
	if ( support.getById ) {
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var m = context.getElementById( id );
				return m ? [ m ] : [];
			}
		};
		Expr.filter["ID"] = function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				return elem.getAttribute("id") === attrId;
			};
		};
	} else {
		// Support: IE6/7
		// getElementById is not reliable as a find shortcut
		delete Expr.find["ID"];

		Expr.filter["ID"] =  function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				var node = typeof elem.getAttributeNode !== "undefined" &&
					elem.getAttributeNode("id");
				return node && node.value === attrId;
			};
		};
	}

	// Tag
	Expr.find["TAG"] = support.getElementsByTagName ?
		function( tag, context ) {
			if ( typeof context.getElementsByTagName !== "undefined" ) {
				return context.getElementsByTagName( tag );

			// DocumentFragment nodes don't have gEBTN
			} else if ( support.qsa ) {
				return context.querySelectorAll( tag );
			}
		} :

		function( tag, context ) {
			var elem,
				tmp = [],
				i = 0,
				// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
				results = context.getElementsByTagName( tag );

			// Filter out possible comments
			if ( tag === "*" ) {
				while ( (elem = results[i++]) ) {
					if ( elem.nodeType === 1 ) {
						tmp.push( elem );
					}
				}

				return tmp;
			}
			return results;
		};

	// Class
	Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
		if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
			return context.getElementsByClassName( className );
		}
	};

	/* QSA/matchesSelector
	---------------------------------------------------------------------- */

	// QSA and matchesSelector support

	// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
	rbuggyMatches = [];

	// qSa(:focus) reports false when true (Chrome 21)
	// We allow this because of a bug in IE8/9 that throws an error
	// whenever `document.activeElement` is accessed on an iframe
	// So, we allow :focus to pass through QSA all the time to avoid the IE error
	// See https://bugs.jquery.com/ticket/13378
	rbuggyQSA = [];

	if ( (support.qsa = rnative.test( document.querySelectorAll )) ) {
		// Build QSA regex
		// Regex strategy adopted from Diego Perini
		assert(function( el ) {
			// Select is set to empty string on purpose
			// This is to test IE's treatment of not explicitly
			// setting a boolean content attribute,
			// since its presence should be enough
			// https://bugs.jquery.com/ticket/12359
			docElem.appendChild( el ).innerHTML = "<a id='" + expando + "'></a>" +
				"<select id='" + expando + "-\r\\' msallowcapture=''>" +
				"<option selected=''></option></select>";

			// Support: IE8, Opera 11-12.16
			// Nothing should be selected when empty strings follow ^= or $= or *=
			// The test attribute must be unknown in Opera but "safe" for WinRT
			// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
			if ( el.querySelectorAll("[msallowcapture^='']").length ) {
				rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
			}

			// Support: IE8
			// Boolean attributes and "value" are not treated correctly
			if ( !el.querySelectorAll("[selected]").length ) {
				rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
			}

			// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
			if ( !el.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
				rbuggyQSA.push("~=");
			}

			// Webkit/Opera - :checked should return selected option elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			// IE8 throws error here and will not see later tests
			if ( !el.querySelectorAll(":checked").length ) {
				rbuggyQSA.push(":checked");
			}

			// Support: Safari 8+, iOS 8+
			// https://bugs.webkit.org/show_bug.cgi?id=136851
			// In-page `selector#id sibling-combinator selector` fails
			if ( !el.querySelectorAll( "a#" + expando + "+*" ).length ) {
				rbuggyQSA.push(".#.+[+~]");
			}
		});

		assert(function( el ) {
			el.innerHTML = "<a href='' disabled='disabled'></a>" +
				"<select disabled='disabled'><option/></select>";

			// Support: Windows 8 Native Apps
			// The type and name attributes are restricted during .innerHTML assignment
			var input = document.createElement("input");
			input.setAttribute( "type", "hidden" );
			el.appendChild( input ).setAttribute( "name", "D" );

			// Support: IE8
			// Enforce case-sensitivity of name attribute
			if ( el.querySelectorAll("[name=d]").length ) {
				rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
			}

			// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
			// IE8 throws error here and will not see later tests
			if ( el.querySelectorAll(":enabled").length !== 2 ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Support: IE9-11+
			// IE's :disabled selector does not pick up the children of disabled fieldsets
			docElem.appendChild( el ).disabled = true;
			if ( el.querySelectorAll(":disabled").length !== 2 ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Opera 10-11 does not throw on post-comma invalid pseudos
			el.querySelectorAll("*,:x");
			rbuggyQSA.push(",.*:");
		});
	}

	if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
		docElem.webkitMatchesSelector ||
		docElem.mozMatchesSelector ||
		docElem.oMatchesSelector ||
		docElem.msMatchesSelector) )) ) {

		assert(function( el ) {
			// Check to see if it's possible to do matchesSelector
			// on a disconnected node (IE 9)
			support.disconnectedMatch = matches.call( el, "*" );

			// This should fail with an exception
			// Gecko does not error, returns false instead
			matches.call( el, "[s!='']:x" );
			rbuggyMatches.push( "!=", pseudos );
		});
	}

	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
	rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

	/* Contains
	---------------------------------------------------------------------- */
	hasCompare = rnative.test( docElem.compareDocumentPosition );

	// Element contains another
	// Purposefully self-exclusive
	// As in, an element does not contain itself
	contains = hasCompare || rnative.test( docElem.contains ) ?
		function( a, b ) {
			var adown = a.nodeType === 9 ? a.documentElement : a,
				bup = b && b.parentNode;
			return a === bup || !!( bup && bup.nodeType === 1 && (
				adown.contains ?
					adown.contains( bup ) :
					a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
			));
		} :
		function( a, b ) {
			if ( b ) {
				while ( (b = b.parentNode) ) {
					if ( b === a ) {
						return true;
					}
				}
			}
			return false;
		};

	/* Sorting
	---------------------------------------------------------------------- */

	// Document order sorting
	sortOrder = hasCompare ?
	function( a, b ) {

		// Flag for duplicate removal
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		// Sort on method existence if only one input has compareDocumentPosition
		var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
		if ( compare ) {
			return compare;
		}

		// Calculate position if both inputs belong to the same document
		compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
			a.compareDocumentPosition( b ) :

			// Otherwise we know they are disconnected
			1;

		// Disconnected nodes
		if ( compare & 1 ||
			(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

			// Choose the first element that is related to our preferred document
			if ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
				return -1;
			}
			if ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
				return 1;
			}

			// Maintain original order
			return sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;
		}

		return compare & 4 ? -1 : 1;
	} :
	function( a, b ) {
		// Exit early if the nodes are identical
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		var cur,
			i = 0,
			aup = a.parentNode,
			bup = b.parentNode,
			ap = [ a ],
			bp = [ b ];

		// Parentless nodes are either documents or disconnected
		if ( !aup || !bup ) {
			return a === document ? -1 :
				b === document ? 1 :
				aup ? -1 :
				bup ? 1 :
				sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;

		// If the nodes are siblings, we can do a quick check
		} else if ( aup === bup ) {
			return siblingCheck( a, b );
		}

		// Otherwise we need full lists of their ancestors for comparison
		cur = a;
		while ( (cur = cur.parentNode) ) {
			ap.unshift( cur );
		}
		cur = b;
		while ( (cur = cur.parentNode) ) {
			bp.unshift( cur );
		}

		// Walk down the tree looking for a discrepancy
		while ( ap[i] === bp[i] ) {
			i++;
		}

		return i ?
			// Do a sibling check if the nodes have a common ancestor
			siblingCheck( ap[i], bp[i] ) :

			// Otherwise nodes in our document sort first
			ap[i] === preferredDoc ? -1 :
			bp[i] === preferredDoc ? 1 :
			0;
	};

	return document;
};

Sizzle.matches = function( expr, elements ) {
	return Sizzle( expr, null, null, elements );
};

Sizzle.matchesSelector = function( elem, expr ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	// Make sure that attribute selectors are quoted
	expr = expr.replace( rattributeQuotes, "='$1']" );

	if ( support.matchesSelector && documentIsHTML &&
		!compilerCache[ expr + " " ] &&
		( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
		( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

		try {
			var ret = matches.call( elem, expr );

			// IE 9's matchesSelector returns false on disconnected nodes
			if ( ret || support.disconnectedMatch ||
					// As well, disconnected nodes are said to be in a document
					// fragment in IE 9
					elem.document && elem.document.nodeType !== 11 ) {
				return ret;
			}
		} catch (e) {}
	}

	return Sizzle( expr, document, null, [ elem ] ).length > 0;
};

Sizzle.contains = function( context, elem ) {
	// Set document vars if needed
	if ( ( context.ownerDocument || context ) !== document ) {
		setDocument( context );
	}
	return contains( context, elem );
};

Sizzle.attr = function( elem, name ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	var fn = Expr.attrHandle[ name.toLowerCase() ],
		// Don't get fooled by Object.prototype properties (jQuery #13807)
		val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
			fn( elem, name, !documentIsHTML ) :
			undefined;

	return val !== undefined ?
		val :
		support.attributes || !documentIsHTML ?
			elem.getAttribute( name ) :
			(val = elem.getAttributeNode(name)) && val.specified ?
				val.value :
				null;
};

Sizzle.escape = function( sel ) {
	return (sel + "").replace( rcssescape, fcssescape );
};

Sizzle.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */
Sizzle.uniqueSort = function( results ) {
	var elem,
		duplicates = [],
		j = 0,
		i = 0;

	// Unless we *know* we can detect duplicates, assume their presence
	hasDuplicate = !support.detectDuplicates;
	sortInput = !support.sortStable && results.slice( 0 );
	results.sort( sortOrder );

	if ( hasDuplicate ) {
		while ( (elem = results[i++]) ) {
			if ( elem === results[ i ] ) {
				j = duplicates.push( i );
			}
		}
		while ( j-- ) {
			results.splice( duplicates[ j ], 1 );
		}
	}

	// Clear input after sorting to release objects
	// See https://github.com/jquery/sizzle/pull/225
	sortInput = null;

	return results;
};

/**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
getText = Sizzle.getText = function( elem ) {
	var node,
		ret = "",
		i = 0,
		nodeType = elem.nodeType;

	if ( !nodeType ) {
		// If no nodeType, this is expected to be an array
		while ( (node = elem[i++]) ) {
			// Do not traverse comment nodes
			ret += getText( node );
		}
	} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
		// Use textContent for elements
		// innerText usage removed for consistency of new lines (jQuery #11153)
		if ( typeof elem.textContent === "string" ) {
			return elem.textContent;
		} else {
			// Traverse its children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				ret += getText( elem );
			}
		}
	} else if ( nodeType === 3 || nodeType === 4 ) {
		return elem.nodeValue;
	}
	// Do not include comment or processing instruction nodes

	return ret;
};

Expr = Sizzle.selectors = {

	// Can be adjusted by the user
	cacheLength: 50,

	createPseudo: markFunction,

	match: matchExpr,

	attrHandle: {},

	find: {},

	relative: {
		">": { dir: "parentNode", first: true },
		" ": { dir: "parentNode" },
		"+": { dir: "previousSibling", first: true },
		"~": { dir: "previousSibling" }
	},

	preFilter: {
		"ATTR": function( match ) {
			match[1] = match[1].replace( runescape, funescape );

			// Move the given value to match[3] whether quoted or unquoted
			match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );

			if ( match[2] === "~=" ) {
				match[3] = " " + match[3] + " ";
			}

			return match.slice( 0, 4 );
		},

		"CHILD": function( match ) {
			/* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
			match[1] = match[1].toLowerCase();

			if ( match[1].slice( 0, 3 ) === "nth" ) {
				// nth-* requires argument
				if ( !match[3] ) {
					Sizzle.error( match[0] );
				}

				// numeric x and y parameters for Expr.filter.CHILD
				// remember that false/true cast respectively to 0/1
				match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
				match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

			// other types prohibit arguments
			} else if ( match[3] ) {
				Sizzle.error( match[0] );
			}

			return match;
		},

		"PSEUDO": function( match ) {
			var excess,
				unquoted = !match[6] && match[2];

			if ( matchExpr["CHILD"].test( match[0] ) ) {
				return null;
			}

			// Accept quoted arguments as-is
			if ( match[3] ) {
				match[2] = match[4] || match[5] || "";

			// Strip excess characters from unquoted arguments
			} else if ( unquoted && rpseudo.test( unquoted ) &&
				// Get excess from tokenize (recursively)
				(excess = tokenize( unquoted, true )) &&
				// advance to the next closing parenthesis
				(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

				// excess is a negative index
				match[0] = match[0].slice( 0, excess );
				match[2] = unquoted.slice( 0, excess );
			}

			// Return only captures needed by the pseudo filter method (type and argument)
			return match.slice( 0, 3 );
		}
	},

	filter: {

		"TAG": function( nodeNameSelector ) {
			var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
			return nodeNameSelector === "*" ?
				function() { return true; } :
				function( elem ) {
					return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
				};
		},

		"CLASS": function( className ) {
			var pattern = classCache[ className + " " ];

			return pattern ||
				(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
				classCache( className, function( elem ) {
					return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );
				});
		},

		"ATTR": function( name, operator, check ) {
			return function( elem ) {
				var result = Sizzle.attr( elem, name );

				if ( result == null ) {
					return operator === "!=";
				}
				if ( !operator ) {
					return true;
				}

				result += "";

				return operator === "=" ? result === check :
					operator === "!=" ? result !== check :
					operator === "^=" ? check && result.indexOf( check ) === 0 :
					operator === "*=" ? check && result.indexOf( check ) > -1 :
					operator === "$=" ? check && result.slice( -check.length ) === check :
					operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
					operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
					false;
			};
		},

		"CHILD": function( type, what, argument, first, last ) {
			var simple = type.slice( 0, 3 ) !== "nth",
				forward = type.slice( -4 ) !== "last",
				ofType = what === "of-type";

			return first === 1 && last === 0 ?

				// Shortcut for :nth-*(n)
				function( elem ) {
					return !!elem.parentNode;
				} :

				function( elem, context, xml ) {
					var cache, uniqueCache, outerCache, node, nodeIndex, start,
						dir = simple !== forward ? "nextSibling" : "previousSibling",
						parent = elem.parentNode,
						name = ofType && elem.nodeName.toLowerCase(),
						useCache = !xml && !ofType,
						diff = false;

					if ( parent ) {

						// :(first|last|only)-(child|of-type)
						if ( simple ) {
							while ( dir ) {
								node = elem;
								while ( (node = node[ dir ]) ) {
									if ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) {

										return false;
									}
								}
								// Reverse direction for :only-* (if we haven't yet done so)
								start = dir = type === "only" && !start && "nextSibling";
							}
							return true;
						}

						start = [ forward ? parent.firstChild : parent.lastChild ];

						// non-xml :nth-child(...) stores cache data on `parent`
						if ( forward && useCache ) {

							// Seek `elem` from a previously-cached index

							// ...in a gzip-friendly way
							node = parent;
							outerCache = node[ expando ] || (node[ expando ] = {});

							// Support: IE <9 only
							// Defend against cloned attroperties (jQuery gh-1709)
							uniqueCache = outerCache[ node.uniqueID ] ||
								(outerCache[ node.uniqueID ] = {});

							cache = uniqueCache[ type ] || [];
							nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
							diff = nodeIndex && cache[ 2 ];
							node = nodeIndex && parent.childNodes[ nodeIndex ];

							while ( (node = ++nodeIndex && node && node[ dir ] ||

								// Fallback to seeking `elem` from the start
								(diff = nodeIndex = 0) || start.pop()) ) {

								// When found, cache indexes on `parent` and break
								if ( node.nodeType === 1 && ++diff && node === elem ) {
									uniqueCache[ type ] = [ dirruns, nodeIndex, diff ];
									break;
								}
							}

						} else {
							// Use previously-cached element index if available
							if ( useCache ) {
								// ...in a gzip-friendly way
								node = elem;
								outerCache = node[ expando ] || (node[ expando ] = {});

								// Support: IE <9 only
								// Defend against cloned attroperties (jQuery gh-1709)
								uniqueCache = outerCache[ node.uniqueID ] ||
									(outerCache[ node.uniqueID ] = {});

								cache = uniqueCache[ type ] || [];
								nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
								diff = nodeIndex;
							}

							// xml :nth-child(...)
							// or :nth-last-child(...) or :nth(-last)?-of-type(...)
							if ( diff === false ) {
								// Use the same loop as above to seek `elem` from the start
								while ( (node = ++nodeIndex && node && node[ dir ] ||
									(diff = nodeIndex = 0) || start.pop()) ) {

									if ( ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) &&
										++diff ) {

										// Cache the index of each encountered element
										if ( useCache ) {
											outerCache = node[ expando ] || (node[ expando ] = {});

											// Support: IE <9 only
											// Defend against cloned attroperties (jQuery gh-1709)
											uniqueCache = outerCache[ node.uniqueID ] ||
												(outerCache[ node.uniqueID ] = {});

											uniqueCache[ type ] = [ dirruns, diff ];
										}

										if ( node === elem ) {
											break;
										}
									}
								}
							}
						}

						// Incorporate the offset, then check against cycle size
						diff -= last;
						return diff === first || ( diff % first === 0 && diff / first >= 0 );
					}
				};
		},

		"PSEUDO": function( pseudo, argument ) {
			// pseudo-class names are case-insensitive
			// http://www.w3.org/TR/selectors/#pseudo-classes
			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
			// Remember that setFilters inherits from pseudos
			var args,
				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
					Sizzle.error( "unsupported pseudo: " + pseudo );

			// The user may use createPseudo to indicate that
			// arguments are needed to create the filter function
			// just as Sizzle does
			if ( fn[ expando ] ) {
				return fn( argument );
			}

			// But maintain support for old signatures
			if ( fn.length > 1 ) {
				args = [ pseudo, pseudo, "", argument ];
				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
					markFunction(function( seed, matches ) {
						var idx,
							matched = fn( seed, argument ),
							i = matched.length;
						while ( i-- ) {
							idx = indexOf( seed, matched[i] );
							seed[ idx ] = !( matches[ idx ] = matched[i] );
						}
					}) :
					function( elem ) {
						return fn( elem, 0, args );
					};
			}

			return fn;
		}
	},

	pseudos: {
		// Potentially complex pseudos
		"not": markFunction(function( selector ) {
			// Trim the selector passed to compile
			// to avoid treating leading and trailing
			// spaces as combinators
			var input = [],
				results = [],
				matcher = compile( selector.replace( rtrim, "$1" ) );

			return matcher[ expando ] ?
				markFunction(function( seed, matches, context, xml ) {
					var elem,
						unmatched = matcher( seed, null, xml, [] ),
						i = seed.length;

					// Match elements unmatched by `matcher`
					while ( i-- ) {
						if ( (elem = unmatched[i]) ) {
							seed[i] = !(matches[i] = elem);
						}
					}
				}) :
				function( elem, context, xml ) {
					input[0] = elem;
					matcher( input, null, xml, results );
					// Don't keep the element (issue #299)
					input[0] = null;
					return !results.pop();
				};
		}),

		"has": markFunction(function( selector ) {
			return function( elem ) {
				return Sizzle( selector, elem ).length > 0;
			};
		}),

		"contains": markFunction(function( text ) {
			text = text.replace( runescape, funescape );
			return function( elem ) {
				return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
			};
		}),

		// "Whether an element is represented by a :lang() selector
		// is based solely on the element's language value
		// being equal to the identifier C,
		// or beginning with the identifier C immediately followed by "-".
		// The matching of C against the element's language value is performed case-insensitively.
		// The identifier C does not have to be a valid language name."
		// http://www.w3.org/TR/selectors/#lang-pseudo
		"lang": markFunction( function( lang ) {
			// lang value must be a valid identifier
			if ( !ridentifier.test(lang || "") ) {
				Sizzle.error( "unsupported lang: " + lang );
			}
			lang = lang.replace( runescape, funescape ).toLowerCase();
			return function( elem ) {
				var elemLang;
				do {
					if ( (elemLang = documentIsHTML ?
						elem.lang :
						elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {

						elemLang = elemLang.toLowerCase();
						return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
					}
				} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
				return false;
			};
		}),

		// Miscellaneous
		"target": function( elem ) {
			var hash = window.location && window.location.hash;
			return hash && hash.slice( 1 ) === elem.id;
		},

		"root": function( elem ) {
			return elem === docElem;
		},

		"focus": function( elem ) {
			return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
		},

		// Boolean properties
		"enabled": createDisabledPseudo( false ),
		"disabled": createDisabledPseudo( true ),

		"checked": function( elem ) {
			// In CSS3, :checked should return both checked and selected elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			var nodeName = elem.nodeName.toLowerCase();
			return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
		},

		"selected": function( elem ) {
			// Accessing this property makes selected-by-default
			// options in Safari work properly
			if ( elem.parentNode ) {
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		// Contents
		"empty": function( elem ) {
			// http://www.w3.org/TR/selectors/#empty-pseudo
			// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
			//   but not by others (comment: 8; processing instruction: 7; etc.)
			// nodeType < 6 works because attributes (2) do not appear as children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				if ( elem.nodeType < 6 ) {
					return false;
				}
			}
			return true;
		},

		"parent": function( elem ) {
			return !Expr.pseudos["empty"]( elem );
		},

		// Element/input types
		"header": function( elem ) {
			return rheader.test( elem.nodeName );
		},

		"input": function( elem ) {
			return rinputs.test( elem.nodeName );
		},

		"button": function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === "button" || name === "button";
		},

		"text": function( elem ) {
			var attr;
			return elem.nodeName.toLowerCase() === "input" &&
				elem.type === "text" &&

				// Support: IE<8
				// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
				( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
		},

		// Position-in-collection
		"first": createPositionalPseudo(function() {
			return [ 0 ];
		}),

		"last": createPositionalPseudo(function( matchIndexes, length ) {
			return [ length - 1 ];
		}),

		"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
			return [ argument < 0 ? argument + length : argument ];
		}),

		"even": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 0;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"odd": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 1;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; --i >= 0; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; ++i < length; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		})
	}
};

Expr.pseudos["nth"] = Expr.pseudos["eq"];

// Add button/input type pseudos
for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
	Expr.pseudos[ i ] = createInputPseudo( i );
}
for ( i in { submit: true, reset: true } ) {
	Expr.pseudos[ i ] = createButtonPseudo( i );
}

// Easy API for creating new setFilters
function setFilters() {}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = new setFilters();

tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
	var matched, match, tokens, type,
		soFar, groups, preFilters,
		cached = tokenCache[ selector + " " ];

	if ( cached ) {
		return parseOnly ? 0 : cached.slice( 0 );
	}

	soFar = selector;
	groups = [];
	preFilters = Expr.preFilter;

	while ( soFar ) {

		// Comma and first run
		if ( !matched || (match = rcomma.exec( soFar )) ) {
			if ( match ) {
				// Don't consume trailing commas as valid
				soFar = soFar.slice( match[0].length ) || soFar;
			}
			groups.push( (tokens = []) );
		}

		matched = false;

		// Combinators
		if ( (match = rcombinators.exec( soFar )) ) {
			matched = match.shift();
			tokens.push({
				value: matched,
				// Cast descendant combinators to space
				type: match[0].replace( rtrim, " " )
			});
			soFar = soFar.slice( matched.length );
		}

		// Filters
		for ( type in Expr.filter ) {
			if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
				(match = preFilters[ type ]( match ))) ) {
				matched = match.shift();
				tokens.push({
					value: matched,
					type: type,
					matches: match
				});
				soFar = soFar.slice( matched.length );
			}
		}

		if ( !matched ) {
			break;
		}
	}

	// Return the length of the invalid excess
	// if we're just parsing
	// Otherwise, throw an error or return tokens
	return parseOnly ?
		soFar.length :
		soFar ?
			Sizzle.error( selector ) :
			// Cache the tokens
			tokenCache( selector, groups ).slice( 0 );
};

function toSelector( tokens ) {
	var i = 0,
		len = tokens.length,
		selector = "";
	for ( ; i < len; i++ ) {
		selector += tokens[i].value;
	}
	return selector;
}

function addCombinator( matcher, combinator, base ) {
	var dir = combinator.dir,
		skip = combinator.next,
		key = skip || dir,
		checkNonElements = base && key === "parentNode",
		doneName = done++;

	return combinator.first ?
		// Check against closest ancestor/preceding element
		function( elem, context, xml ) {
			while ( (elem = elem[ dir ]) ) {
				if ( elem.nodeType === 1 || checkNonElements ) {
					return matcher( elem, context, xml );
				}
			}
		} :

		// Check against all ancestor/preceding elements
		function( elem, context, xml ) {
			var oldCache, uniqueCache, outerCache,
				newCache = [ dirruns, doneName ];

			// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
			if ( xml ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						if ( matcher( elem, context, xml ) ) {
							return true;
						}
					}
				}
			} else {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						outerCache = elem[ expando ] || (elem[ expando ] = {});

						// Support: IE <9 only
						// Defend against cloned attroperties (jQuery gh-1709)
						uniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});

						if ( skip && skip === elem.nodeName.toLowerCase() ) {
							elem = elem[ dir ] || elem;
						} else if ( (oldCache = uniqueCache[ key ]) &&
							oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

							// Assign to newCache so results back-propagate to previous elements
							return (newCache[ 2 ] = oldCache[ 2 ]);
						} else {
							// Reuse newcache so results back-propagate to previous elements
							uniqueCache[ key ] = newCache;

							// A match means we're done; a fail means we have to keep checking
							if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
								return true;
							}
						}
					}
				}
			}
		};
}

function elementMatcher( matchers ) {
	return matchers.length > 1 ?
		function( elem, context, xml ) {
			var i = matchers.length;
			while ( i-- ) {
				if ( !matchers[i]( elem, context, xml ) ) {
					return false;
				}
			}
			return true;
		} :
		matchers[0];
}

function multipleContexts( selector, contexts, results ) {
	var i = 0,
		len = contexts.length;
	for ( ; i < len; i++ ) {
		Sizzle( selector, contexts[i], results );
	}
	return results;
}

function condense( unmatched, map, filter, context, xml ) {
	var elem,
		newUnmatched = [],
		i = 0,
		len = unmatched.length,
		mapped = map != null;

	for ( ; i < len; i++ ) {
		if ( (elem = unmatched[i]) ) {
			if ( !filter || filter( elem, context, xml ) ) {
				newUnmatched.push( elem );
				if ( mapped ) {
					map.push( i );
				}
			}
		}
	}

	return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
	if ( postFilter && !postFilter[ expando ] ) {
		postFilter = setMatcher( postFilter );
	}
	if ( postFinder && !postFinder[ expando ] ) {
		postFinder = setMatcher( postFinder, postSelector );
	}
	return markFunction(function( seed, results, context, xml ) {
		var temp, i, elem,
			preMap = [],
			postMap = [],
			preexisting = results.length,

			// Get initial elements from seed or context
			elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

			// Prefilter to get matcher input, preserving a map for seed-results synchronization
			matcherIn = preFilter && ( seed || !selector ) ?
				condense( elems, preMap, preFilter, context, xml ) :
				elems,

			matcherOut = matcher ?
				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
				postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

					// ...intermediate processing is necessary
					[] :

					// ...otherwise use results directly
					results :
				matcherIn;

		// Find primary matches
		if ( matcher ) {
			matcher( matcherIn, matcherOut, context, xml );
		}

		// Apply postFilter
		if ( postFilter ) {
			temp = condense( matcherOut, postMap );
			postFilter( temp, [], context, xml );

			// Un-match failing elements by moving them back to matcherIn
			i = temp.length;
			while ( i-- ) {
				if ( (elem = temp[i]) ) {
					matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
				}
			}
		}

		if ( seed ) {
			if ( postFinder || preFilter ) {
				if ( postFinder ) {
					// Get the final matcherOut by condensing this intermediate into postFinder contexts
					temp = [];
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) ) {
							// Restore matcherIn since elem is not yet a final match
							temp.push( (matcherIn[i] = elem) );
						}
					}
					postFinder( null, (matcherOut = []), temp, xml );
				}

				// Move matched elements from seed to results to keep them synchronized
				i = matcherOut.length;
				while ( i-- ) {
					if ( (elem = matcherOut[i]) &&
						(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {

						seed[temp] = !(results[temp] = elem);
					}
				}
			}

		// Add elements to results, through postFinder if defined
		} else {
			matcherOut = condense(
				matcherOut === results ?
					matcherOut.splice( preexisting, matcherOut.length ) :
					matcherOut
			);
			if ( postFinder ) {
				postFinder( null, results, matcherOut, xml );
			} else {
				push.apply( results, matcherOut );
			}
		}
	});
}

function matcherFromTokens( tokens ) {
	var checkContext, matcher, j,
		len = tokens.length,
		leadingRelative = Expr.relative[ tokens[0].type ],
		implicitRelative = leadingRelative || Expr.relative[" "],
		i = leadingRelative ? 1 : 0,

		// The foundational matcher ensures that elements are reachable from top-level context(s)
		matchContext = addCombinator( function( elem ) {
			return elem === checkContext;
		}, implicitRelative, true ),
		matchAnyContext = addCombinator( function( elem ) {
			return indexOf( checkContext, elem ) > -1;
		}, implicitRelative, true ),
		matchers = [ function( elem, context, xml ) {
			var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
				(checkContext = context).nodeType ?
					matchContext( elem, context, xml ) :
					matchAnyContext( elem, context, xml ) );
			// Avoid hanging onto element (issue #299)
			checkContext = null;
			return ret;
		} ];

	for ( ; i < len; i++ ) {
		if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
			matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
		} else {
			matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

			// Return special upon seeing a positional matcher
			if ( matcher[ expando ] ) {
				// Find the next relative operator (if any) for proper handling
				j = ++i;
				for ( ; j < len; j++ ) {
					if ( Expr.relative[ tokens[j].type ] ) {
						break;
					}
				}
				return setMatcher(
					i > 1 && elementMatcher( matchers ),
					i > 1 && toSelector(
						// If the preceding token was a descendant combinator, insert an implicit any-element `*`
						tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
					).replace( rtrim, "$1" ),
					matcher,
					i < j && matcherFromTokens( tokens.slice( i, j ) ),
					j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
					j < len && toSelector( tokens )
				);
			}
			matchers.push( matcher );
		}
	}

	return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
	var bySet = setMatchers.length > 0,
		byElement = elementMatchers.length > 0,
		superMatcher = function( seed, context, xml, results, outermost ) {
			var elem, j, matcher,
				matchedCount = 0,
				i = "0",
				unmatched = seed && [],
				setMatched = [],
				contextBackup = outermostContext,
				// We must always have either seed elements or outermost context
				elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
				// Use integer dirruns iff this is the outermost matcher
				dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
				len = elems.length;

			if ( outermost ) {
				outermostContext = context === document || context || outermost;
			}

			// Add elements passing elementMatchers directly to results
			// Support: IE<9, Safari
			// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
			for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
				if ( byElement && elem ) {
					j = 0;
					if ( !context && elem.ownerDocument !== document ) {
						setDocument( elem );
						xml = !documentIsHTML;
					}
					while ( (matcher = elementMatchers[j++]) ) {
						if ( matcher( elem, context || document, xml) ) {
							results.push( elem );
							break;
						}
					}
					if ( outermost ) {
						dirruns = dirrunsUnique;
					}
				}

				// Track unmatched elements for set filters
				if ( bySet ) {
					// They will have gone through all possible matchers
					if ( (elem = !matcher && elem) ) {
						matchedCount--;
					}

					// Lengthen the array for every element, matched or not
					if ( seed ) {
						unmatched.push( elem );
					}
				}
			}

			// `i` is now the count of elements visited above, and adding it to `matchedCount`
			// makes the latter nonnegative.
			matchedCount += i;

			// Apply set filters to unmatched elements
			// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
			// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
			// no element matchers and no seed.
			// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
			// case, which will result in a "00" `matchedCount` that differs from `i` but is also
			// numerically zero.
			if ( bySet && i !== matchedCount ) {
				j = 0;
				while ( (matcher = setMatchers[j++]) ) {
					matcher( unmatched, setMatched, context, xml );
				}

				if ( seed ) {
					// Reintegrate element matches to eliminate the need for sorting
					if ( matchedCount > 0 ) {
						while ( i-- ) {
							if ( !(unmatched[i] || setMatched[i]) ) {
								setMatched[i] = pop.call( results );
							}
						}
					}

					// Discard index placeholder values to get only actual matches
					setMatched = condense( setMatched );
				}

				// Add matches to results
				push.apply( results, setMatched );

				// Seedless set matches succeeding multiple successful matchers stipulate sorting
				if ( outermost && !seed && setMatched.length > 0 &&
					( matchedCount + setMatchers.length ) > 1 ) {

					Sizzle.uniqueSort( results );
				}
			}

			// Override manipulation of globals by nested matchers
			if ( outermost ) {
				dirruns = dirrunsUnique;
				outermostContext = contextBackup;
			}

			return unmatched;
		};

	return bySet ?
		markFunction( superMatcher ) :
		superMatcher;
}

compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
	var i,
		setMatchers = [],
		elementMatchers = [],
		cached = compilerCache[ selector + " " ];

	if ( !cached ) {
		// Generate a function of recursive functions that can be used to check each element
		if ( !match ) {
			match = tokenize( selector );
		}
		i = match.length;
		while ( i-- ) {
			cached = matcherFromTokens( match[i] );
			if ( cached[ expando ] ) {
				setMatchers.push( cached );
			} else {
				elementMatchers.push( cached );
			}
		}

		// Cache the compiled function
		cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );

		// Save selector and tokenization
		cached.selector = selector;
	}
	return cached;
};

/**
 * A low-level selection function that works with Sizzle's compiled
 *  selector functions
 * @param {String|Function} selector A selector or a pre-compiled
 *  selector function built with Sizzle.compile
 * @param {Element} context
 * @param {Array} [results]
 * @param {Array} [seed] A set of elements to match against
 */
select = Sizzle.select = function( selector, context, results, seed ) {
	var i, tokens, token, type, find,
		compiled = typeof selector === "function" && selector,
		match = !seed && tokenize( (selector = compiled.selector || selector) );

	results = results || [];

	// Try to minimize operations if there is only one selector in the list and no seed
	// (the latter of which guarantees us context)
	if ( match.length === 1 ) {

		// Reduce context if the leading compound selector is an ID
		tokens = match[0] = match[0].slice( 0 );
		if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
				support.getById && context.nodeType === 9 && documentIsHTML &&
				Expr.relative[ tokens[1].type ] ) {

			context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
			if ( !context ) {
				return results;

			// Precompiled matchers will still verify ancestry, so step up a level
			} else if ( compiled ) {
				context = context.parentNode;
			}

			selector = selector.slice( tokens.shift().value.length );
		}

		// Fetch a seed set for right-to-left matching
		i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
		while ( i-- ) {
			token = tokens[i];

			// Abort if we hit a combinator
			if ( Expr.relative[ (type = token.type) ] ) {
				break;
			}
			if ( (find = Expr.find[ type ]) ) {
				// Search, expanding context for leading sibling combinators
				if ( (seed = find(
					token.matches[0].replace( runescape, funescape ),
					rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
				)) ) {

					// If seed is empty or no tokens remain, we can return early
					tokens.splice( i, 1 );
					selector = seed.length && toSelector( tokens );
					if ( !selector ) {
						push.apply( results, seed );
						return results;
					}

					break;
				}
			}
		}
	}

	// Compile and execute a filtering function if one is not provided
	// Provide `match` to avoid retokenization if we modified the selector above
	( compiled || compile( selector, match ) )(
		seed,
		context,
		!documentIsHTML,
		results,
		!context || rsibling.test( selector ) && testContext( context.parentNode ) || context
	);
	return results;
};

// One-time assignments

// Sort stability
support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;

// Support: Chrome 14-35+
// Always assume duplicates if they aren't passed to the comparison function
support.detectDuplicates = !!hasDuplicate;

// Initialize against the default document
setDocument();

// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
// Detached nodes confoundingly follow *each other*
support.sortDetached = assert(function( el ) {
	// Should return 1, but returns 4 (following)
	return el.compareDocumentPosition( document.createElement("fieldset") ) & 1;
});

// Support: IE<8
// Prevent attribute/property "interpolation"
// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
if ( !assert(function( el ) {
	el.innerHTML = "<a href='#'></a>";
	return el.firstChild.getAttribute("href") === "#" ;
}) ) {
	addHandle( "type|href|height|width", function( elem, name, isXML ) {
		if ( !isXML ) {
			return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
		}
	});
}

// Support: IE<9
// Use defaultValue in place of getAttribute("value")
if ( !support.attributes || !assert(function( el ) {
	el.innerHTML = "<input/>";
	el.firstChild.setAttribute( "value", "" );
	return el.firstChild.getAttribute( "value" ) === "";
}) ) {
	addHandle( "value", function( elem, name, isXML ) {
		if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
			return elem.defaultValue;
		}
	});
}

// Support: IE<9
// Use getAttributeNode to fetch booleans when getAttribute lies
if ( !assert(function( el ) {
	return el.getAttribute("disabled") == null;
}) ) {
	addHandle( booleans, function( elem, name, isXML ) {
		var val;
		if ( !isXML ) {
			return elem[ name ] === true ? name.toLowerCase() :
					(val = elem.getAttributeNode( name )) && val.specified ?
					val.value :
				null;
		}
	});
}

return Sizzle;

})( window );



jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;

// Deprecated
jQuery.expr[ ":" ] = jQuery.expr.pseudos;
jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;
jQuery.escapeSelector = Sizzle.escape;




var dir = function( elem, dir, until ) {
	var matched = [],
		truncate = until !== undefined;

	while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
		if ( elem.nodeType === 1 ) {
			if ( truncate && jQuery( elem ).is( until ) ) {
				break;
			}
			matched.push( elem );
		}
	}
	return matched;
};


var siblings = function( n, elem ) {
	var matched = [];

	for ( ; n; n = n.nextSibling ) {
		if ( n.nodeType === 1 && n !== elem ) {
			matched.push( n );
		}
	}

	return matched;
};


var rneedsContext = jQuery.expr.match.needsContext;

var rsingleTag = ( /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i );



var risSimple = /^.[^:#\[\.,]*$/;

// Implement the identical functionality for filter and not
function winnow( elements, qualifier, not ) {
	if ( jQuery.isFunction( qualifier ) ) {
		return jQuery.grep( elements, function( elem, i ) {
			return !!qualifier.call( elem, i, elem ) !== not;
		} );

	}

	if ( qualifier.nodeType ) {
		return jQuery.grep( elements, function( elem ) {
			return ( elem === qualifier ) !== not;
		} );

	}

	if ( typeof qualifier === "string" ) {
		if ( risSimple.test( qualifier ) ) {
			return jQuery.filter( qualifier, elements, not );
		}

		qualifier = jQuery.filter( qualifier, elements );
	}

	return jQuery.grep( elements, function( elem ) {
		return ( indexOf.call( qualifier, elem ) > -1 ) !== not && elem.nodeType === 1;
	} );
}

jQuery.filter = function( expr, elems, not ) {
	var elem = elems[ 0 ];

	if ( not ) {
		expr = ":not(" + expr + ")";
	}

	return elems.length === 1 && elem.nodeType === 1 ?
		jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [] :
		jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
			return elem.nodeType === 1;
		} ) );
};

jQuery.fn.extend( {
	find: function( selector ) {
		var i, ret,
			len = this.length,
			self = this;

		if ( typeof selector !== "string" ) {
			return this.pushStack( jQuery( selector ).filter( function() {
				for ( i = 0; i < len; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			} ) );
		}

		ret = this.pushStack( [] );

		for ( i = 0; i < len; i++ ) {
			jQuery.find( selector, self[ i ], ret );
		}

		return len > 1 ? jQuery.uniqueSort( ret ) : ret;
	},
	filter: function( selector ) {
		return this.pushStack( winnow( this, selector || [], false ) );
	},
	not: function( selector ) {
		return this.pushStack( winnow( this, selector || [], true ) );
	},
	is: function( selector ) {
		return !!winnow(
			this,

			// If this is a positional/relative selector, check membership in the returned set
			// so $("p:first").is("p:last") won't return true for a doc with two "p".
			typeof selector === "string" && rneedsContext.test( selector ) ?
				jQuery( selector ) :
				selector || [],
			false
		).length;
	}
} );


// Initialize a jQuery object


// A central reference to the root jQuery(document)
var rootjQuery,

	// A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	// Strict HTML recognition (#11290: must start with <)
	// Shortcut simple #id case for speed
	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,

	init = jQuery.fn.init = function( selector, context, root ) {
		var match, elem;

		// HANDLE: $(""), $(null), $(undefined), $(false)
		if ( !selector ) {
			return this;
		}

		// Method init() accepts an alternate rootjQuery
		// so migrate can support jQuery.sub (gh-2101)
		root = root || rootjQuery;

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			if ( selector[ 0 ] === "<" &&
				selector[ selector.length - 1 ] === ">" &&
				selector.length >= 3 ) {

				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = rquickExpr.exec( selector );
			}

			// Match html or make sure no context is specified for #id
			if ( match && ( match[ 1 ] || !context ) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[ 1 ] ) {
					context = context instanceof jQuery ? context[ 0 ] : context;

					// Option to run scripts is true for back-compat
					// Intentionally let the error be thrown if parseHTML is not present
					jQuery.merge( this, jQuery.parseHTML(
						match[ 1 ],
						context && context.nodeType ? context.ownerDocument || context : document,
						true
					) );

					// HANDLE: $(html, props)
					if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
						for ( match in context ) {

							// Properties of context are called as methods if possible
							if ( jQuery.isFunction( this[ match ] ) ) {
								this[ match ]( context[ match ] );

							// ...and otherwise set as attributes
							} else {
								this.attr( match, context[ match ] );
							}
						}
					}

					return this;

				// HANDLE: $(#id)
				} else {
					elem = document.getElementById( match[ 2 ] );

					if ( elem ) {

						// Inject the element directly into the jQuery object
						this[ 0 ] = elem;
						this.length = 1;
					}
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || root ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(DOMElement)
		} else if ( selector.nodeType ) {
			this[ 0 ] = selector;
			this.length = 1;
			return this;

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( jQuery.isFunction( selector ) ) {
			return root.ready !== undefined ?
				root.ready( selector ) :

				// Execute immediately if ready is not present
				selector( jQuery );
		}

		return jQuery.makeArray( selector, this );
	};

// Give the init function the jQuery prototype for later instantiation
init.prototype = jQuery.fn;

// Initialize central reference
rootjQuery = jQuery( document );


var rparentsprev = /^(?:parents|prev(?:Until|All))/,

	// Methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.fn.extend( {
	has: function( target ) {
		var targets = jQuery( target, this ),
			l = targets.length;

		return this.filter( function() {
			var i = 0;
			for ( ; i < l; i++ ) {
				if ( jQuery.contains( this, targets[ i ] ) ) {
					return true;
				}
			}
		} );
	},

	closest: function( selectors, context ) {
		var cur,
			i = 0,
			l = this.length,
			matched = [],
			targets = typeof selectors !== "string" && jQuery( selectors );

		// Positional selectors never match, since there's no _selection_ context
		if ( !rneedsContext.test( selectors ) ) {
			for ( ; i < l; i++ ) {
				for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {

					// Always skip document fragments
					if ( cur.nodeType < 11 && ( targets ?
						targets.index( cur ) > -1 :

						// Don't pass non-elements to Sizzle
						cur.nodeType === 1 &&
							jQuery.find.matchesSelector( cur, selectors ) ) ) {

						matched.push( cur );
						break;
					}
				}
			}
		}

		return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
	},

	// Determine the position of an element within the set
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
		}

		// Index in selector
		if ( typeof elem === "string" ) {
			return indexOf.call( jQuery( elem ), this[ 0 ] );
		}

		// Locate the position of the desired element
		return indexOf.call( this,

			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[ 0 ] : elem
		);
	},

	add: function( selector, context ) {
		return this.pushStack(
			jQuery.uniqueSort(
				jQuery.merge( this.get(), jQuery( selector, context ) )
			)
		);
	},

	addBack: function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter( selector )
		);
	}
} );

function sibling( cur, dir ) {
	while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
	return cur;
}

jQuery.each( {
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, i, until ) {
		return dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return sibling( elem, "nextSibling" );
	},
	prev: function( elem ) {
		return sibling( elem, "previousSibling" );
	},
	nextAll: function( elem ) {
		return dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, i, until ) {
		return dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, i, until ) {
		return dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return siblings( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
		return siblings( elem.firstChild );
	},
	contents: function( elem ) {
		return elem.contentDocument || jQuery.merge( [], elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var matched = jQuery.map( this, fn, until );

		if ( name.slice( -5 ) !== "Until" ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			matched = jQuery.filter( selector, matched );
		}

		if ( this.length > 1 ) {

			// Remove duplicates
			if ( !guaranteedUnique[ name ] ) {
				jQuery.uniqueSort( matched );
			}

			// Reverse order for parents* and prev-derivatives
			if ( rparentsprev.test( name ) ) {
				matched.reverse();
			}
		}

		return this.pushStack( matched );
	};
} );
var rnotwhite = ( /\S+/g );



// Convert String-formatted options into Object-formatted ones
function createOptions( options ) {
	var object = {};
	jQuery.each( options.match( rnotwhite ) || [], function( _, flag ) {
		object[ flag ] = true;
	} );
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( options ) {

	// Convert options from String-formatted to Object-formatted if needed
	// (we check in cache first)
	options = typeof options === "string" ?
		createOptions( options ) :
		jQuery.extend( {}, options );

	var // Flag to know if list is currently firing
		firing,

		// Last fire value for non-forgettable lists
		memory,

		// Flag to know if list was already fired
		fired,

		// Flag to prevent firing
		locked,

		// Actual callback list
		list = [],

		// Queue of execution data for repeatable lists
		queue = [],

		// Index of currently firing callback (modified by add/remove as needed)
		firingIndex = -1,

		// Fire callbacks
		fire = function() {

			// Enforce single-firing
			locked = options.once;

			// Execute callbacks for all pending executions,
			// respecting firingIndex overrides and runtime changes
			fired = firing = true;
			for ( ; queue.length; firingIndex = -1 ) {
				memory = queue.shift();
				while ( ++firingIndex < list.length ) {

					// Run callback and check for early termination
					if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
						options.stopOnFalse ) {

						// Jump to end and forget the data so .add doesn't re-fire
						firingIndex = list.length;
						memory = false;
					}
				}
			}

			// Forget the data if we're done with it
			if ( !options.memory ) {
				memory = false;
			}

			firing = false;

			// Clean up if we're done firing for good
			if ( locked ) {

				// Keep an empty list if we have data for future add calls
				if ( memory ) {
					list = [];

				// Otherwise, this object is spent
				} else {
					list = "";
				}
			}
		},

		// Actual Callbacks object
		self = {

			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {

					// If we have memory from a past run, we should fire after adding
					if ( memory && !firing ) {
						firingIndex = list.length - 1;
						queue.push( memory );
					}

					( function add( args ) {
						jQuery.each( args, function( _, arg ) {
							if ( jQuery.isFunction( arg ) ) {
								if ( !options.unique || !self.has( arg ) ) {
									list.push( arg );
								}
							} else if ( arg && arg.length && jQuery.type( arg ) !== "string" ) {

								// Inspect recursively
								add( arg );
							}
						} );
					} )( arguments );

					if ( memory && !firing ) {
						fire();
					}
				}
				return this;
			},

			// Remove a callback from the list
			remove: function() {
				jQuery.each( arguments, function( _, arg ) {
					var index;
					while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
						list.splice( index, 1 );

						// Handle firing indexes
						if ( index <= firingIndex ) {
							firingIndex--;
						}
					}
				} );
				return this;
			},

			// Check if a given callback is in the list.
			// If no argument is given, return whether or not list has callbacks attached.
			has: function( fn ) {
				return fn ?
					jQuery.inArray( fn, list ) > -1 :
					list.length > 0;
			},

			// Remove all callbacks from the list
			empty: function() {
				if ( list ) {
					list = [];
				}
				return this;
			},

			// Disable .fire and .add
			// Abort any current/pending executions
			// Clear all callbacks and values
			disable: function() {
				locked = queue = [];
				list = memory = "";
				return this;
			},
			disabled: function() {
				return !list;
			},

			// Disable .fire
			// Also disable .add unless we have memory (since it would have no effect)
			// Abort any pending executions
			lock: function() {
				locked = queue = [];
				if ( !memory && !firing ) {
					list = memory = "";
				}
				return this;
			},
			locked: function() {
				return !!locked;
			},

			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				if ( !locked ) {
					args = args || [];
					args = [ context, args.slice ? args.slice() : args ];
					queue.push( args );
					if ( !firing ) {
						fire();
					}
				}
				return this;
			},

			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},

			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!fired;
			}
		};

	return self;
};


function Identity( v ) {
	return v;
}
function Thrower( ex ) {
	throw ex;
}

function adoptValue( value, resolve, reject ) {
	var method;

	try {

		// Check for promise aspect first to privilege synchronous behavior
		if ( value && jQuery.isFunction( ( method = value.promise ) ) ) {
			method.call( value ).done( resolve ).fail( reject );

		// Other thenables
		} else if ( value && jQuery.isFunction( ( method = value.then ) ) ) {
			method.call( value, resolve, reject );

		// Other non-thenables
		} else {

			// Support: Android 4.0 only
			// Strict mode functions invoked without .call/.apply get global-object context
			resolve.call( undefined, value );
		}

	// For Promises/A+, convert exceptions into rejections
	// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
	// Deferred#then to conditionally suppress rejection.
	} catch ( value ) {

		// Support: Android 4.0 only
		// Strict mode functions invoked without .call/.apply get global-object context
		reject.call( undefined, value );
	}
}

jQuery.extend( {

	Deferred: function( func ) {
		var tuples = [

				// action, add listener, callbacks,
				// ... .then handlers, argument index, [final state]
				[ "notify", "progress", jQuery.Callbacks( "memory" ),
					jQuery.Callbacks( "memory" ), 2 ],
				[ "resolve", "done", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 0, "resolved" ],
				[ "reject", "fail", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 1, "rejected" ]
			],
			state = "pending",
			promise = {
				state: function() {
					return state;
				},
				always: function() {
					deferred.done( arguments ).fail( arguments );
					return this;
				},
				"catch": function( fn ) {
					return promise.then( null, fn );
				},

				// Keep pipe for back-compat
				pipe: function( /* fnDone, fnFail, fnProgress */ ) {
					var fns = arguments;

					return jQuery.Deferred( function( newDefer ) {
						jQuery.each( tuples, function( i, tuple ) {

							// Map tuples (progress, done, fail) to arguments (done, fail, progress)
							var fn = jQuery.isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];

							// deferred.progress(function() { bind to newDefer or newDefer.notify })
							// deferred.done(function() { bind to newDefer or newDefer.resolve })
							// deferred.fail(function() { bind to newDefer or newDefer.reject })
							deferred[ tuple[ 1 ] ]( function() {
								var returned = fn && fn.apply( this, arguments );
								if ( returned && jQuery.isFunction( returned.promise ) ) {
									returned.promise()
										.progress( newDefer.notify )
										.done( newDefer.resolve )
										.fail( newDefer.reject );
								} else {
									newDefer[ tuple[ 0 ] + "With" ](
										this,
										fn ? [ returned ] : arguments
									);
								}
							} );
						} );
						fns = null;
					} ).promise();
				},
				then: function( onFulfilled, onRejected, onProgress ) {
					var maxDepth = 0;
					function resolve( depth, deferred, handler, special ) {
						return function() {
							var that = this,
								args = arguments,
								mightThrow = function() {
									var returned, then;

									// Support: Promises/A+ section 2.3.3.3.3
									// https://promisesaplus.com/#point-59
									// Ignore double-resolution attempts
									if ( depth < maxDepth ) {
										return;
									}

									returned = handler.apply( that, args );

									// Support: Promises/A+ section 2.3.1
									// https://promisesaplus.com/#point-48
									if ( returned === deferred.promise() ) {
										throw new TypeError( "Thenable self-resolution" );
									}

									// Support: Promises/A+ sections 2.3.3.1, 3.5
									// https://promisesaplus.com/#point-54
									// https://promisesaplus.com/#point-75
									// Retrieve `then` only once
									then = returned &&

										// Support: Promises/A+ section 2.3.4
										// https://promisesaplus.com/#point-64
										// Only check objects and functions for thenability
										( typeof returned === "object" ||
											typeof returned === "function" ) &&
										returned.then;

									// Handle a returned thenable
									if ( jQuery.isFunction( then ) ) {

										// Special processors (notify) just wait for resolution
										if ( special ) {
											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special )
											);

										// Normal processors (resolve) also hook into progress
										} else {

											// ...and disregard older resolution values
											maxDepth++;

											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special ),
												resolve( maxDepth, deferred, Identity,
													deferred.notifyWith )
											);
										}

									// Handle all other returned values
									} else {

										// Only substitute handlers pass on context
										// and multiple values (non-spec behavior)
										if ( handler !== Identity ) {
											that = undefined;
											args = [ returned ];
										}

										// Process the value(s)
										// Default process is resolve
										( special || deferred.resolveWith )( that, args );
									}
								},

								// Only normal processors (resolve) catch and reject exceptions
								process = special ?
									mightThrow :
									function() {
										try {
											mightThrow();
										} catch ( e ) {

											if ( jQuery.Deferred.exceptionHook ) {
												jQuery.Deferred.exceptionHook( e,
													process.stackTrace );
											}

											// Support: Promises/A+ section 2.3.3.3.4.1
											// https://promisesaplus.com/#point-61
											// Ignore post-resolution exceptions
											if ( depth + 1 >= maxDepth ) {

												// Only substitute handlers pass on context
												// and multiple values (non-spec behavior)
												if ( handler !== Thrower ) {
													that = undefined;
													args = [ e ];
												}

												deferred.rejectWith( that, args );
											}
										}
									};

							// Support: Promises/A+ section 2.3.3.3.1
							// https://promisesaplus.com/#point-57
							// Re-resolve promises immediately to dodge false rejection from
							// subsequent errors
							if ( depth ) {
								process();
							} else {

								// Call an optional hook to record the stack, in case of exception
								// since it's otherwise lost when execution goes async
								if ( jQuery.Deferred.getStackHook ) {
									process.stackTrace = jQuery.Deferred.getStackHook();
								}
								window.setTimeout( process );
							}
						};
					}

					return jQuery.Deferred( function( newDefer ) {

						// progress_handlers.add( ... )
						tuples[ 0 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								jQuery.isFunction( onProgress ) ?
									onProgress :
									Identity,
								newDefer.notifyWith
							)
						);

						// fulfilled_handlers.add( ... )
						tuples[ 1 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								jQuery.isFunction( onFulfilled ) ?
									onFulfilled :
									Identity
							)
						);

						// rejected_handlers.add( ... )
						tuples[ 2 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								jQuery.isFunction( onRejected ) ?
									onRejected :
									Thrower
							)
						);
					} ).promise();
				},

				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					return obj != null ? jQuery.extend( obj, promise ) : promise;
				}
			},
			deferred = {};

		// Add list-specific methods
		jQuery.each( tuples, function( i, tuple ) {
			var list = tuple[ 2 ],
				stateString = tuple[ 5 ];

			// promise.progress = list.add
			// promise.done = list.add
			// promise.fail = list.add
			promise[ tuple[ 1 ] ] = list.add;

			// Handle state
			if ( stateString ) {
				list.add(
					function() {

						// state = "resolved" (i.e., fulfilled)
						// state = "rejected"
						state = stateString;
					},

					// rejected_callbacks.disable
					// fulfilled_callbacks.disable
					tuples[ 3 - i ][ 2 ].disable,

					// progress_callbacks.lock
					tuples[ 0 ][ 2 ].lock
				);
			}

			// progress_handlers.fire
			// fulfilled_handlers.fire
			// rejected_handlers.fire
			list.add( tuple[ 3 ].fire );

			// deferred.notify = function() { deferred.notifyWith(...) }
			// deferred.resolve = function() { deferred.resolveWith(...) }
			// deferred.reject = function() { deferred.rejectWith(...) }
			deferred[ tuple[ 0 ] ] = function() {
				deferred[ tuple[ 0 ] + "With" ]( this === deferred ? undefined : this, arguments );
				return this;
			};

			// deferred.notifyWith = list.fireWith
			// deferred.resolveWith = list.fireWith
			// deferred.rejectWith = list.fireWith
			deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
		} );

		// Make the deferred a promise
		promise.promise( deferred );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( singleValue ) {
		var

			// count of uncompleted subordinates
			remaining = arguments.length,

			// count of unprocessed arguments
			i = remaining,

			// subordinate fulfillment data
			resolveContexts = Array( i ),
			resolveValues = slice.call( arguments ),

			// the master Deferred
			master = jQuery.Deferred(),

			// subordinate callback factory
			updateFunc = function( i ) {
				return function( value ) {
					resolveContexts[ i ] = this;
					resolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
					if ( !( --remaining ) ) {
						master.resolveWith( resolveContexts, resolveValues );
					}
				};
			};

		// Single- and empty arguments are adopted like Promise.resolve
		if ( remaining <= 1 ) {
			adoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject );

			// Use .then() to unwrap secondary thenables (cf. gh-3000)
			if ( master.state() === "pending" ||
				jQuery.isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {

				return master.then();
			}
		}

		// Multiple arguments are aggregated like Promise.all array elements
		while ( i-- ) {
			adoptValue( resolveValues[ i ], updateFunc( i ), master.reject );
		}

		return master.promise();
	}
} );


// These usually indicate a programmer mistake during development,
// warn about them ASAP rather than swallowing them by default.
var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

jQuery.Deferred.exceptionHook = function( error, stack ) {

	// Support: IE 8 - 9 only
	// Console exists when dev tools are open, which can happen at any time
	if ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {
		window.console.warn( "jQuery.Deferred exception: " + error.message, error.stack, stack );
	}
};




jQuery.readyException = function( error ) {
	window.setTimeout( function() {
		throw error;
	} );
};




// The deferred used on DOM ready
var readyList = jQuery.Deferred();

jQuery.fn.ready = function( fn ) {

	readyList
		.then( fn )

		// Wrap jQuery.readyException in a function so that the lookup
		// happens at the time of error handling instead of callback
		// registration.
		.catch( function( error ) {
			jQuery.readyException( error );
		} );

	return this;
};

jQuery.extend( {

	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See #6781
	readyWait: 1,

	// Hold (or release) the ready event
	holdReady: function( hold ) {
		if ( hold ) {
			jQuery.readyWait++;
		} else {
			jQuery.ready( true );
		}
	},

	// Handle when the DOM is ready
	ready: function( wait ) {

		// Abort if there are pending holds or we're already ready
		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
			return;
		}

		// Remember that the DOM is ready
		jQuery.isReady = true;

		// If a normal DOM Ready event fired, decrement, and wait if need be
		if ( wait !== true && --jQuery.readyWait > 0 ) {
			return;
		}

		// If there are functions bound, to execute
		readyList.resolveWith( document, [ jQuery ] );
	}
} );

jQuery.ready.then = readyList.then;

// The ready event handler and self cleanup method
function completed() {
	document.removeEventListener( "DOMContentLoaded", completed );
	window.removeEventListener( "load", completed );
	jQuery.ready();
}

// Catch cases where $(document).ready() is called
// after the browser event has already occurred.
// Support: IE <=9 - 10 only
// Older IE sometimes signals "interactive" too soon
if ( document.readyState === "complete" ||
	( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {

	// Handle it asynchronously to allow scripts the opportunity to delay ready
	window.setTimeout( jQuery.ready );

} else {

	// Use the handy event callback
	document.addEventListener( "DOMContentLoaded", completed );

	// A fallback to window.onload, that will always work
	window.addEventListener( "load", completed );
}




// Multifunctional method to get and set values of a collection
// The value/s can optionally be executed if it's a function
var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
	var i = 0,
		len = elems.length,
		bulk = key == null;

	// Sets many values
	if ( jQuery.type( key ) === "object" ) {
		chainable = true;
		for ( i in key ) {
			access( elems, fn, i, key[ i ], true, emptyGet, raw );
		}

	// Sets one value
	} else if ( value !== undefined ) {
		chainable = true;

		if ( !jQuery.isFunction( value ) ) {
			raw = true;
		}

		if ( bulk ) {

			// Bulk operations run against the entire set
			if ( raw ) {
				fn.call( elems, value );
				fn = null;

			// ...except when executing function values
			} else {
				bulk = fn;
				fn = function( elem, key, value ) {
					return bulk.call( jQuery( elem ), value );
				};
			}
		}

		if ( fn ) {
			for ( ; i < len; i++ ) {
				fn(
					elems[ i ], key, raw ?
					value :
					value.call( elems[ i ], i, fn( elems[ i ], key ) )
				);
			}
		}
	}

	return chainable ?
		elems :

		// Gets
		bulk ?
			fn.call( elems ) :
			len ? fn( elems[ 0 ], key ) : emptyGet;
};
var acceptData = function( owner ) {

	// Accepts only:
	//  - Node
	//    - Node.ELEMENT_NODE
	//    - Node.DOCUMENT_NODE
	//  - Object
	//    - Any
	return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
};




function Data() {
	this.expando = jQuery.expando + Data.uid++;
}

Data.uid = 1;

Data.prototype = {

	cache: function( owner ) {

		// Check if the owner object already has a cache
		var value = owner[ this.expando ];

		// If not, create one
		if ( !value ) {
			value = {};

			// We can accept data for non-element nodes in modern browsers,
			// but we should not, see #8335.
			// Always return an empty object.
			if ( acceptData( owner ) ) {

				// If it is a node unlikely to be stringify-ed or looped over
				// use plain assignment
				if ( owner.nodeType ) {
					owner[ this.expando ] = value;

				// Otherwise secure it in a non-enumerable property
				// configurable must be true to allow the property to be
				// deleted when data is removed
				} else {
					Object.defineProperty( owner, this.expando, {
						value: value,
						configurable: true
					} );
				}
			}
		}

		return value;
	},
	set: function( owner, data, value ) {
		var prop,
			cache = this.cache( owner );

		// Handle: [ owner, key, value ] args
		// Always use camelCase key (gh-2257)
		if ( typeof data === "string" ) {
			cache[ jQuery.camelCase( data ) ] = value;

		// Handle: [ owner, { properties } ] args
		} else {

			// Copy the properties one-by-one to the cache object
			for ( prop in data ) {
				cache[ jQuery.camelCase( prop ) ] = data[ prop ];
			}
		}
		return cache;
	},
	get: function( owner, key ) {
		return key === undefined ?
			this.cache( owner ) :

			// Always use camelCase key (gh-2257)
			owner[ this.expando ] && owner[ this.expando ][ jQuery.camelCase( key ) ];
	},
	access: function( owner, key, value ) {

		// In cases where either:
		//
		//   1. No key was specified
		//   2. A string key was specified, but no value provided
		//
		// Take the "read" path and allow the get method to determine
		// which value to return, respectively either:
		//
		//   1. The entire cache object
		//   2. The data stored at the key
		//
		if ( key === undefined ||
				( ( key && typeof key === "string" ) && value === undefined ) ) {

			return this.get( owner, key );
		}

		// When the key is not a string, or both a key and value
		// are specified, set or extend (existing objects) with either:
		//
		//   1. An object of properties
		//   2. A key and value
		//
		this.set( owner, key, value );

		// Since the "set" path can have two possible entry points
		// return the expected data based on which path was taken[*]
		return value !== undefined ? value : key;
	},
	remove: function( owner, key ) {
		var i,
			cache = owner[ this.expando ];

		if ( cache === undefined ) {
			return;
		}

		if ( key !== undefined ) {

			// Support array or space separated string of keys
			if ( jQuery.isArray( key ) ) {

				// If key is an array of keys...
				// We always set camelCase keys, so remove that.
				key = key.map( jQuery.camelCase );
			} else {
				key = jQuery.camelCase( key );

				// If a key with the spaces exists, use it.
				// Otherwise, create an array by matching non-whitespace
				key = key in cache ?
					[ key ] :
					( key.match( rnotwhite ) || [] );
			}

			i = key.length;

			while ( i-- ) {
				delete cache[ key[ i ] ];
			}
		}

		// Remove the expando if there's no more data
		if ( key === undefined || jQuery.isEmptyObject( cache ) ) {

			// Support: Chrome <=35 - 45
			// Webkit & Blink performance suffers when deleting properties
			// from DOM nodes, so set to undefined instead
			// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
			if ( owner.nodeType ) {
				owner[ this.expando ] = undefined;
			} else {
				delete owner[ this.expando ];
			}
		}
	},
	hasData: function( owner ) {
		var cache = owner[ this.expando ];
		return cache !== undefined && !jQuery.isEmptyObject( cache );
	}
};
var dataPriv = new Data();

var dataUser = new Data();



//	Implementation Summary
//
//	1. Enforce API surface and semantic compatibility with 1.9.x branch
//	2. Improve the module's maintainability by reducing the storage
//		paths to a single mechanism.
//	3. Use the same single mechanism to support "private" and "user" data.
//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
//	5. Avoid exposing implementation details on user objects (eg. expando properties)
//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
	rmultiDash = /[A-Z]/g;

function dataAttr( elem, key, data ) {
	var name;

	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {
		name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = data === "true" ? true :
					data === "false" ? false :
					data === "null" ? null :

					// Only convert to a number if it doesn't change the string
					+data + "" === data ? +data :
					rbrace.test( data ) ? JSON.parse( data ) :
					data;
			} catch ( e ) {}

			// Make sure we set the data so it isn't changed later
			dataUser.set( elem, key, data );
		} else {
			data = undefined;
		}
	}
	return data;
}

jQuery.extend( {
	hasData: function( elem ) {
		return dataUser.hasData( elem ) || dataPriv.hasData( elem );
	},

	data: function( elem, name, data ) {
		return dataUser.access( elem, name, data );
	},

	removeData: function( elem, name ) {
		dataUser.remove( elem, name );
	},

	// TODO: Now that all calls to _data and _removeData have been replaced
	// with direct calls to dataPriv methods, these can be deprecated.
	_data: function( elem, name, data ) {
		return dataPriv.access( elem, name, data );
	},

	_removeData: function( elem, name ) {
		dataPriv.remove( elem, name );
	}
} );

jQuery.fn.extend( {
	data: function( key, value ) {
		var i, name, data,
			elem = this[ 0 ],
			attrs = elem && elem.attributes;

		// Gets all values
		if ( key === undefined ) {
			if ( this.length ) {
				data = dataUser.get( elem );

				if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
					i = attrs.length;
					while ( i-- ) {

						// Support: IE 11 only
						// The attrs elements can be null (#14894)
						if ( attrs[ i ] ) {
							name = attrs[ i ].name;
							if ( name.indexOf( "data-" ) === 0 ) {
								name = jQuery.camelCase( name.slice( 5 ) );
								dataAttr( elem, name, data[ name ] );
							}
						}
					}
					dataPriv.set( elem, "hasDataAttrs", true );
				}
			}

			return data;
		}

		// Sets multiple values
		if ( typeof key === "object" ) {
			return this.each( function() {
				dataUser.set( this, key );
			} );
		}

		return access( this, function( value ) {
			var data;

			// The calling jQuery object (element matches) is not empty
			// (and therefore has an element appears at this[ 0 ]) and the
			// `value` parameter was not undefined. An empty jQuery object
			// will result in `undefined` for elem = this[ 0 ] which will
			// throw an exception if an attempt to read a data cache is made.
			if ( elem && value === undefined ) {

				// Attempt to get data from the cache
				// The key will always be camelCased in Data
				data = dataUser.get( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// Attempt to "discover" the data in
				// HTML5 custom data-* attrs
				data = dataAttr( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// We tried really hard, but the data doesn't exist.
				return;
			}

			// Set the data...
			this.each( function() {

				// We always store the camelCased key
				dataUser.set( this, key, value );
			} );
		}, null, value, arguments.length > 1, null, true );
	},

	removeData: function( key ) {
		return this.each( function() {
			dataUser.remove( this, key );
		} );
	}
} );


jQuery.extend( {
	queue: function( elem, type, data ) {
		var queue;

		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			queue = dataPriv.get( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !queue || jQuery.isArray( data ) ) {
					queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
				} else {
					queue.push( data );
				}
			}
			return queue || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			startLength = queue.length,
			fn = queue.shift(),
			hooks = jQuery._queueHooks( elem, type ),
			next = function() {
				jQuery.dequeue( elem, type );
			};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
			startLength--;
		}

		if ( fn ) {

			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			// Clear up the last queue stop function
			delete hooks.stop;
			fn.call( elem, next, hooks );
		}

		if ( !startLength && hooks ) {
			hooks.empty.fire();
		}
	},

	// Not public - generate a queueHooks object, or return the current one
	_queueHooks: function( elem, type ) {
		var key = type + "queueHooks";
		return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
			empty: jQuery.Callbacks( "once memory" ).add( function() {
				dataPriv.remove( elem, [ type + "queue", key ] );
			} )
		} );
	}
} );

jQuery.fn.extend( {
	queue: function( type, data ) {
		var setter = 2;

		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
			setter--;
		}

		if ( arguments.length < setter ) {
			return jQuery.queue( this[ 0 ], type );
		}

		return data === undefined ?
			this :
			this.each( function() {
				var queue = jQuery.queue( this, type, data );

				// Ensure a hooks for this queue
				jQuery._queueHooks( this, type );

				if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
					jQuery.dequeue( this, type );
				}
			} );
	},
	dequeue: function( type ) {
		return this.each( function() {
			jQuery.dequeue( this, type );
		} );
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},

	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, obj ) {
		var tmp,
			count = 1,
			defer = jQuery.Deferred(),
			elements = this,
			i = this.length,
			resolve = function() {
				if ( !( --count ) ) {
					defer.resolveWith( elements, [ elements ] );
				}
			};

		if ( typeof type !== "string" ) {
			obj = type;
			type = undefined;
		}
		type = type || "fx";

		while ( i-- ) {
			tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
			if ( tmp && tmp.empty ) {
				count++;
				tmp.empty.add( resolve );
			}
		}
		resolve();
		return defer.promise( obj );
	}
} );
var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;

var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );


var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

var isHiddenWithinTree = function( elem, el ) {

		// isHiddenWithinTree might be called from jQuery#filter function;
		// in that case, element will be second argument
		elem = el || elem;

		// Inline style trumps all
		return elem.style.display === "none" ||
			elem.style.display === "" &&

			// Otherwise, check computed style
			// Support: Firefox <=43 - 45
			// Disconnected elements can have computed display: none, so first confirm that elem is
			// in the document.
			jQuery.contains( elem.ownerDocument, elem ) &&

			jQuery.css( elem, "display" ) === "none";
	};

var swap = function( elem, options, callback, args ) {
	var ret, name,
		old = {};

	// Remember the old values, and insert the new ones
	for ( name in options ) {
		old[ name ] = elem.style[ name ];
		elem.style[ name ] = options[ name ];
	}

	ret = callback.apply( elem, args || [] );

	// Revert the old values
	for ( name in options ) {
		elem.style[ name ] = old[ name ];
	}

	return ret;
};




function adjustCSS( elem, prop, valueParts, tween ) {
	var adjusted,
		scale = 1,
		maxIterations = 20,
		currentValue = tween ?
			function() {
				return tween.cur();
			} :
			function() {
				return jQuery.css( elem, prop, "" );
			},
		initial = currentValue(),
		unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

		// Starting value computation is required for potential unit mismatches
		initialInUnit = ( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
			rcssNum.exec( jQuery.css( elem, prop ) );

	if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {

		// Trust units reported by jQuery.css
		unit = unit || initialInUnit[ 3 ];

		// Make sure we update the tween properties later on
		valueParts = valueParts || [];

		// Iteratively approximate from a nonzero starting point
		initialInUnit = +initial || 1;

		do {

			// If previous iteration zeroed out, double until we get *something*.
			// Use string for doubling so we don't accidentally see scale as unchanged below
			scale = scale || ".5";

			// Adjust and apply
			initialInUnit = initialInUnit / scale;
			jQuery.style( elem, prop, initialInUnit + unit );

		// Update scale, tolerating zero or NaN from tween.cur()
		// Break the loop if scale is unchanged or perfect, or if we've just had enough.
		} while (
			scale !== ( scale = currentValue() / initial ) && scale !== 1 && --maxIterations
		);
	}

	if ( valueParts ) {
		initialInUnit = +initialInUnit || +initial || 0;

		// Apply relative offset (+=/-=) if specified
		adjusted = valueParts[ 1 ] ?
			initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
			+valueParts[ 2 ];
		if ( tween ) {
			tween.unit = unit;
			tween.start = initialInUnit;
			tween.end = adjusted;
		}
	}
	return adjusted;
}


var defaultDisplayMap = {};

function getDefaultDisplay( elem ) {
	var temp,
		doc = elem.ownerDocument,
		nodeName = elem.nodeName,
		display = defaultDisplayMap[ nodeName ];

	if ( display ) {
		return display;
	}

	temp = doc.body.appendChild( doc.createElement( nodeName ) ),
	display = jQuery.css( temp, "display" );

	temp.parentNode.removeChild( temp );

	if ( display === "none" ) {
		display = "block";
	}
	defaultDisplayMap[ nodeName ] = display;

	return display;
}

function showHide( elements, show ) {
	var display, elem,
		values = [],
		index = 0,
		length = elements.length;

	// Determine new display value for elements that need to change
	for ( ; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}

		display = elem.style.display;
		if ( show ) {

			// Since we force visibility upon cascade-hidden elements, an immediate (and slow)
			// check is required in this first loop unless we have a nonempty display value (either
			// inline or about-to-be-restored)
			if ( display === "none" ) {
				values[ index ] = dataPriv.get( elem, "display" ) || null;
				if ( !values[ index ] ) {
					elem.style.display = "";
				}
			}
			if ( elem.style.display === "" && isHiddenWithinTree( elem ) ) {
				values[ index ] = getDefaultDisplay( elem );
			}
		} else {
			if ( display !== "none" ) {
				values[ index ] = "none";

				// Remember what we're overwriting
				dataPriv.set( elem, "display", display );
			}
		}
	}

	// Set the display of the elements in a second loop to avoid constant reflow
	for ( index = 0; index < length; index++ ) {
		if ( values[ index ] != null ) {
			elements[ index ].style.display = values[ index ];
		}
	}

	return elements;
}

jQuery.fn.extend( {
	show: function() {
		return showHide( this, true );
	},
	hide: function() {
		return showHide( this );
	},
	toggle: function( state ) {
		if ( typeof state === "boolean" ) {
			return state ? this.show() : this.hide();
		}

		return this.each( function() {
			if ( isHiddenWithinTree( this ) ) {
				jQuery( this ).show();
			} else {
				jQuery( this ).hide();
			}
		} );
	}
} );
var rcheckableType = ( /^(?:checkbox|radio)$/i );

var rtagName = ( /<([a-z][^\/\0>\x20\t\r\n\f]+)/i );

var rscriptType = ( /^$|\/(?:java|ecma)script/i );



// We have to close these tags to support XHTML (#13200)
var wrapMap = {

	// Support: IE <=9 only
	option: [ 1, "<select multiple='multiple'>", "</select>" ],

	// XHTML parsers do not magically insert elements in the
	// same way that tag soup parsers do. So we cannot shorten
	// this by omitting <tbody> or other required elements.
	thead: [ 1, "<table>", "</table>" ],
	col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
	tr: [ 2, "<table><tbody>", "</tbody></table>" ],
	td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

	_default: [ 0, "", "" ]
};

// Support: IE <=9 only
wrapMap.optgroup = wrapMap.option;

wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;


function getAll( context, tag ) {

	// Support: IE <=9 - 11 only
	// Use typeof to avoid zero-argument method invocation on host objects (#15151)
	var ret = typeof context.getElementsByTagName !== "undefined" ?
			context.getElementsByTagName( tag || "*" ) :
			typeof context.querySelectorAll !== "undefined" ?
				context.querySelectorAll( tag || "*" ) :
			[];

	return tag === undefined || tag && jQuery.nodeName( context, tag ) ?
		jQuery.merge( [ context ], ret ) :
		ret;
}


// Mark scripts as having already been evaluated
function setGlobalEval( elems, refElements ) {
	var i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		dataPriv.set(
			elems[ i ],
			"globalEval",
			!refElements || dataPriv.get( refElements[ i ], "globalEval" )
		);
	}
}


var rhtml = /<|&#?\w+;/;

function buildFragment( elems, context, scripts, selection, ignored ) {
	var elem, tmp, tag, wrap, contains, j,
		fragment = context.createDocumentFragment(),
		nodes = [],
		i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		elem = elems[ i ];

		if ( elem || elem === 0 ) {

			// Add nodes directly
			if ( jQuery.type( elem ) === "object" ) {

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

			// Convert non-html into a text node
			} else if ( !rhtml.test( elem ) ) {
				nodes.push( context.createTextNode( elem ) );

			// Convert html into DOM nodes
			} else {
				tmp = tmp || fragment.appendChild( context.createElement( "div" ) );

				// Deserialize a standard representation
				tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
				wrap = wrapMap[ tag ] || wrapMap._default;
				tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];

				// Descend through wrappers to the right content
				j = wrap[ 0 ];
				while ( j-- ) {
					tmp = tmp.lastChild;
				}

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, tmp.childNodes );

				// Remember the top-level container
				tmp = fragment.firstChild;

				// Ensure the created nodes are orphaned (#12392)
				tmp.textContent = "";
			}
		}
	}

	// Remove wrapper from fragment
	fragment.textContent = "";

	i = 0;
	while ( ( elem = nodes[ i++ ] ) ) {

		// Skip elements already in the context collection (trac-4087)
		if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
			if ( ignored ) {
				ignored.push( elem );
			}
			continue;
		}

		contains = jQuery.contains( elem.ownerDocument, elem );

		// Append to fragment
		tmp = getAll( fragment.appendChild( elem ), "script" );

		// Preserve script evaluation history
		if ( contains ) {
			setGlobalEval( tmp );
		}

		// Capture executables
		if ( scripts ) {
			j = 0;
			while ( ( elem = tmp[ j++ ] ) ) {
				if ( rscriptType.test( elem.type || "" ) ) {
					scripts.push( elem );
				}
			}
		}
	}

	return fragment;
}


( function() {
	var fragment = document.createDocumentFragment(),
		div = fragment.appendChild( document.createElement( "div" ) ),
		input = document.createElement( "input" );

	// Support: Android 4.0 - 4.3 only
	// Check state lost if the name is set (#11217)
	// Support: Windows Web Apps (WWA)
	// `name` and `type` must use .setAttribute for WWA (#14901)
	input.setAttribute( "type", "radio" );
	input.setAttribute( "checked", "checked" );
	input.setAttribute( "name", "t" );

	div.appendChild( input );

	// Support: Android <=4.1 only
	// Older WebKit doesn't clone checked state correctly in fragments
	support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Support: IE <=11 only
	// Make sure textarea (and checkbox) defaultValue is properly cloned
	div.innerHTML = "<textarea>x</textarea>";
	support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
} )();
var documentElement = document.documentElement;



var
	rkeyEvent = /^key/,
	rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
	rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

function returnTrue() {
	return true;
}

function returnFalse() {
	return false;
}

// Support: IE <=9 only
// See #13393 for more info
function safeActiveElement() {
	try {
		return document.activeElement;
	} catch ( err ) { }
}

function on( elem, types, selector, data, fn, one ) {
	var origFn, type;

	// Types can be a map of types/handlers
	if ( typeof types === "object" ) {

		// ( types-Object, selector, data )
		if ( typeof selector !== "string" ) {

			// ( types-Object, data )
			data = data || selector;
			selector = undefined;
		}
		for ( type in types ) {
			on( elem, type, selector, data, types[ type ], one );
		}
		return elem;
	}

	if ( data == null && fn == null ) {

		// ( types, fn )
		fn = selector;
		data = selector = undefined;
	} else if ( fn == null ) {
		if ( typeof selector === "string" ) {

			// ( types, selector, fn )
			fn = data;
			data = undefined;
		} else {

			// ( types, data, fn )
			fn = data;
			data = selector;
			selector = undefined;
		}
	}
	if ( fn === false ) {
		fn = returnFalse;
	} else if ( !fn ) {
		return elem;
	}

	if ( one === 1 ) {
		origFn = fn;
		fn = function( event ) {

			// Can use an empty set, since event contains the info
			jQuery().off( event );
			return origFn.apply( this, arguments );
		};

		// Use same guid so caller can remove using origFn
		fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
	}
	return elem.each( function() {
		jQuery.event.add( this, types, fn, data, selector );
	} );
}

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

	global: {},

	add: function( elem, types, handler, data, selector ) {

		var handleObjIn, eventHandle, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.get( elem );

		// Don't attach events to noData or text/comment nodes (but allow plain objects)
		if ( !elemData ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// Ensure that invalid selectors throw exceptions at attach time
		// Evaluate against documentElement in case elem is a non-element node (e.g., document)
		if ( selector ) {
			jQuery.find.matchesSelector( documentElement, selector );
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		if ( !( events = elemData.events ) ) {
			events = elemData.events = {};
		}
		if ( !( eventHandle = elemData.handle ) ) {
			eventHandle = elemData.handle = function( e ) {

				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
					jQuery.event.dispatch.apply( elem, arguments ) : undefined;
			};
		}

		// Handle multiple events separated by a space
		types = ( types || "" ).match( rnotwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// There *must* be a type, no attaching namespace-only handlers
			if ( !type ) {
				continue;
			}

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend( {
				type: type,
				origType: origType,
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
				namespace: namespaces.join( "." )
			}, handleObjIn );

			// Init the event handler queue if we're the first
			if ( !( handlers = events[ type ] ) ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener if the special events handler returns false
				if ( !special.setup ||
					special.setup.call( elem, data, namespaces, eventHandle ) === false ) {

					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

	},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {

		var j, origCount, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );

		if ( !elemData || !( events = elemData.events ) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = ( types || "" ).match( rnotwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector ? special.delegateType : special.bindType ) || type;
			handlers = events[ type ] || [];
			tmp = tmp[ 2 ] &&
				new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );

			// Remove matching events
			origCount = j = handlers.length;
			while ( j-- ) {
				handleObj = handlers[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					( !handler || handler.guid === handleObj.guid ) &&
					( !tmp || tmp.test( handleObj.namespace ) ) &&
					( !selector || selector === handleObj.selector ||
						selector === "**" && handleObj.selector ) ) {
					handlers.splice( j, 1 );

					if ( handleObj.selector ) {
						handlers.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( origCount && !handlers.length ) {
				if ( !special.teardown ||
					special.teardown.call( elem, namespaces, elemData.handle ) === false ) {

					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove data and the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			dataPriv.remove( elem, "handle events" );
		}
	},

	dispatch: function( nativeEvent ) {

		// Make a writable jQuery.Event from the native event object
		var event = jQuery.event.fix( nativeEvent );

		var i, j, ret, matched, handleObj, handlerQueue,
			args = new Array( arguments.length ),
			handlers = ( dataPriv.get( this, "events" ) || {} )[ event.type ] || [],
			special = jQuery.event.special[ event.type ] || {};

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[ 0 ] = event;

		for ( i = 1; i < arguments.length; i++ ) {
			args[ i ] = arguments[ i ];
		}

		event.delegateTarget = this;

		// Call the preDispatch hook for the mapped type, and let it bail if desired
		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
			return;
		}

		// Determine handlers
		handlerQueue = jQuery.event.handlers.call( this, event, handlers );

		// Run delegates first; they may want to stop propagation beneath us
		i = 0;
		while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
			event.currentTarget = matched.elem;

			j = 0;
			while ( ( handleObj = matched.handlers[ j++ ] ) &&
				!event.isImmediatePropagationStopped() ) {

				// Triggered event must either 1) have no namespace, or 2) have namespace(s)
				// a subset or equal to those in the bound event (both can have no namespace).
				if ( !event.rnamespace || event.rnamespace.test( handleObj.namespace ) ) {

					event.handleObj = handleObj;
					event.data = handleObj.data;

					ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
						handleObj.handler ).apply( matched.elem, args );

					if ( ret !== undefined ) {
						if ( ( event.result = ret ) === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		// Call the postDispatch hook for the mapped type
		if ( special.postDispatch ) {
			special.postDispatch.call( this, event );
		}

		return event.result;
	},

	handlers: function( event, handlers ) {
		var i, matches, sel, handleObj,
			handlerQueue = [],
			delegateCount = handlers.delegateCount,
			cur = event.target;

		// Support: IE <=9
		// Find delegate handlers
		// Black-hole SVG <use> instance trees (#13180)
		//
		// Support: Firefox <=42
		// Avoid non-left-click in FF but don't block IE radio events (#3861, gh-2343)
		if ( delegateCount && cur.nodeType &&
			( event.type !== "click" || isNaN( event.button ) || event.button < 1 ) ) {

			for ( ; cur !== this; cur = cur.parentNode || this ) {

				// Don't check non-elements (#13208)
				// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
				if ( cur.nodeType === 1 && ( cur.disabled !== true || event.type !== "click" ) ) {
					matches = [];
					for ( i = 0; i < delegateCount; i++ ) {
						handleObj = handlers[ i ];

						// Don't conflict with Object.prototype properties (#13203)
						sel = handleObj.selector + " ";

						if ( matches[ sel ] === undefined ) {
							matches[ sel ] = handleObj.needsContext ?
								jQuery( sel, this ).index( cur ) > -1 :
								jQuery.find( sel, this, null, [ cur ] ).length;
						}
						if ( matches[ sel ] ) {
							matches.push( handleObj );
						}
					}
					if ( matches.length ) {
						handlerQueue.push( { elem: cur, handlers: matches } );
					}
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		if ( delegateCount < handlers.length ) {
			handlerQueue.push( { elem: this, handlers: handlers.slice( delegateCount ) } );
		}

		return handlerQueue;
	},

	addProp: function( name, hook ) {
		Object.defineProperty( jQuery.Event.prototype, name, {
			enumerable: true,
			configurable: true,

			get: jQuery.isFunction( hook ) ?
				function() {
					if ( this.originalEvent ) {
							return hook( this.originalEvent );
					}
				} :
				function() {
					if ( this.originalEvent ) {
							return this.originalEvent[ name ];
					}
				},

			set: function( value ) {
				Object.defineProperty( this, name, {
					enumerable: true,
					configurable: true,
					writable: true,
					value: value
				} );
			}
		} );
	},

	fix: function( originalEvent ) {
		return originalEvent[ jQuery.expando ] ?
			originalEvent :
			new jQuery.Event( originalEvent );
	},

	special: {
		load: {

			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},
		focus: {

			// Fire native event if possible so blur/focus sequence is correct
			trigger: function() {
				if ( this !== safeActiveElement() && this.focus ) {
					this.focus();
					return false;
				}
			},
			delegateType: "focusin"
		},
		blur: {
			trigger: function() {
				if ( this === safeActiveElement() && this.blur ) {
					this.blur();
					return false;
				}
			},
			delegateType: "focusout"
		},
		click: {

			// For checkbox, fire native event so checked state will be right
			trigger: function() {
				if ( this.type === "checkbox" && this.click && jQuery.nodeName( this, "input" ) ) {
					this.click();
					return false;
				}
			},

			// For cross-browser consistency, don't fire native .click() on links
			_default: function( event ) {
				return jQuery.nodeName( event.target, "a" );
			}
		},

		beforeunload: {
			postDispatch: function( event ) {

				// Support: Firefox 20+
				// Firefox doesn't alert if the returnValue field is not set.
				if ( event.result !== undefined && event.originalEvent ) {
					event.originalEvent.returnValue = event.result;
				}
			}
		}
	}
};

jQuery.removeEvent = function( elem, type, handle ) {

	// This "if" is needed for plain objects
	if ( elem.removeEventListener ) {
		elem.removeEventListener( type, handle );
	}
};

jQuery.Event = function( src, props ) {

	// Allow instantiation without the 'new' keyword
	if ( !( this instanceof jQuery.Event ) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = src.defaultPrevented ||
				src.defaultPrevented === undefined &&

				// Support: Android <=2.3 only
				src.returnValue === false ?
			returnTrue :
			returnFalse;

		// Create target properties
		// Support: Safari <=6 - 7 only
		// Target should not be a text node (#504, #13143)
		this.target = ( src.target && src.target.nodeType === 3 ) ?
			src.target.parentNode :
			src.target;

		this.currentTarget = src.currentTarget;
		this.relatedTarget = src.relatedTarget;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || jQuery.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	constructor: jQuery.Event,
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse,
	isSimulated: false,

	preventDefault: function() {
		var e = this.originalEvent;

		this.isDefaultPrevented = returnTrue;

		if ( e && !this.isSimulated ) {
			e.preventDefault();
		}
	},
	stopPropagation: function() {
		var e = this.originalEvent;

		this.isPropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopPropagation();
		}
	},
	stopImmediatePropagation: function() {
		var e = this.originalEvent;

		this.isImmediatePropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopImmediatePropagation();
		}

		this.stopPropagation();
	}
};

// Includes all common event props including KeyEvent and MouseEvent specific props
jQuery.each( {
	altKey: true,
	bubbles: true,
	cancelable: true,
	changedTouches: true,
	ctrlKey: true,
	detail: true,
	eventPhase: true,
	metaKey: true,
	pageX: true,
	pageY: true,
	shiftKey: true,
	view: true,
	"char": true,
	charCode: true,
	key: true,
	keyCode: true,
	button: true,
	buttons: true,
	clientX: true,
	clientY: true,
	offsetX: true,
	offsetY: true,
	pointerId: true,
	pointerType: true,
	screenX: true,
	screenY: true,
	targetTouches: true,
	toElement: true,
	touches: true,

	which: function( event ) {
		var button = event.button;

		// Add which for key events
		if ( event.which == null && rkeyEvent.test( event.type ) ) {
			return event.charCode != null ? event.charCode : event.keyCode;
		}

		// Add which for click: 1 === left; 2 === middle; 3 === right
		if ( !event.which && button !== undefined && rmouseEvent.test( event.type ) ) {
			return ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );
		}

		return event.which;
	}
}, jQuery.event.addProp );

// Create mouseenter/leave events using mouseover/out and event-time checks
// so that event delegation works in jQuery.
// Do the same for pointerenter/pointerleave and pointerover/pointerout
//
// Support: Safari 7 only
// Safari sends mouseenter too often; see:
// https://bugs.chromium.org/p/chromium/issues/detail?id=470258
// for the description of the bug (it existed in older Chrome versions as well).
jQuery.each( {
	mouseenter: "mouseover",
	mouseleave: "mouseout",
	pointerenter: "pointerover",
	pointerleave: "pointerout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var ret,
				target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj;

			// For mouseenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
} );

jQuery.fn.extend( {

	on: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn );
	},
	one: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		var handleObj, type;
		if ( types && types.preventDefault && types.handleObj ) {

			// ( event )  dispatched jQuery.Event
			handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace ?
					handleObj.origType + "." + handleObj.namespace :
					handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {

			// ( types-object [, selector] )
			for ( type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {

			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each( function() {
			jQuery.event.remove( this, types, fn, selector );
		} );
	}
} );


var

	/* eslint-disable max-len */

	// See https://github.com/eslint/eslint/issues/3229
	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,

	/* eslint-enable */

	// Support: IE <=10 - 11, Edge 12 - 13
	// In IE/Edge using regex groups here causes severe slowdowns.
	// See https://connect.microsoft.com/IE/feedback/details/1736512/
	rnoInnerhtml = /<script|<style|<link/i,

	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	rscriptTypeMasked = /^true\/(.*)/,
	rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

function manipulationTarget( elem, content ) {
	if ( jQuery.nodeName( elem, "table" ) &&
		jQuery.nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ) {

		return elem.getElementsByTagName( "tbody" )[ 0 ] || elem;
	}

	return elem;
}

// Replace/restore the type attribute of script elements for safe DOM manipulation
function disableScript( elem ) {
	elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
	return elem;
}
function restoreScript( elem ) {
	var match = rscriptTypeMasked.exec( elem.type );

	if ( match ) {
		elem.type = match[ 1 ];
	} else {
		elem.removeAttribute( "type" );
	}

	return elem;
}

function cloneCopyEvent( src, dest ) {
	var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

	if ( dest.nodeType !== 1 ) {
		return;
	}

	// 1. Copy private data: events, handlers, etc.
	if ( dataPriv.hasData( src ) ) {
		pdataOld = dataPriv.access( src );
		pdataCur = dataPriv.set( dest, pdataOld );
		events = pdataOld.events;

		if ( events ) {
			delete pdataCur.handle;
			pdataCur.events = {};

			for ( type in events ) {
				for ( i = 0, l = events[ type ].length; i < l; i++ ) {
					jQuery.event.add( dest, type, events[ type ][ i ] );
				}
			}
		}
	}

	// 2. Copy user data
	if ( dataUser.hasData( src ) ) {
		udataOld = dataUser.access( src );
		udataCur = jQuery.extend( {}, udataOld );

		dataUser.set( dest, udataCur );
	}
}

// Fix IE bugs, see support tests
function fixInput( src, dest ) {
	var nodeName = dest.nodeName.toLowerCase();

	// Fails to persist the checked state of a cloned checkbox or radio button.
	if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
		dest.checked = src.checked;

	// Fails to return the selected option to the default selected state when cloning options
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;
	}
}

function domManip( collection, args, callback, ignored ) {

	// Flatten any nested arrays
	args = concat.apply( [], args );

	var fragment, first, scripts, hasScripts, node, doc,
		i = 0,
		l = collection.length,
		iNoClone = l - 1,
		value = args[ 0 ],
		isFunction = jQuery.isFunction( value );

	// We can't cloneNode fragments that contain checked, in WebKit
	if ( isFunction ||
			( l > 1 && typeof value === "string" &&
				!support.checkClone && rchecked.test( value ) ) ) {
		return collection.each( function( index ) {
			var self = collection.eq( index );
			if ( isFunction ) {
				args[ 0 ] = value.call( this, index, self.html() );
			}
			domManip( self, args, callback, ignored );
		} );
	}

	if ( l ) {
		fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
		first = fragment.firstChild;

		if ( fragment.childNodes.length === 1 ) {
			fragment = first;
		}

		// Require either new content or an interest in ignored elements to invoke the callback
		if ( first || ignored ) {
			scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
			hasScripts = scripts.length;

			// Use the original fragment for the last item
			// instead of the first because it can end up
			// being emptied incorrectly in certain situations (#8070).
			for ( ; i < l; i++ ) {
				node = fragment;

				if ( i !== iNoClone ) {
					node = jQuery.clone( node, true, true );

					// Keep references to cloned scripts for later restoration
					if ( hasScripts ) {

						// Support: Android <=4.0 only, PhantomJS 1 only
						// push.apply(_, arraylike) throws on ancient WebKit
						jQuery.merge( scripts, getAll( node, "script" ) );
					}
				}

				callback.call( collection[ i ], node, i );
			}

			if ( hasScripts ) {
				doc = scripts[ scripts.length - 1 ].ownerDocument;

				// Reenable scripts
				jQuery.map( scripts, restoreScript );

				// Evaluate executable scripts on first document insertion
				for ( i = 0; i < hasScripts; i++ ) {
					node = scripts[ i ];
					if ( rscriptType.test( node.type || "" ) &&
						!dataPriv.access( node, "globalEval" ) &&
						jQuery.contains( doc, node ) ) {

						if ( node.src ) {

							// Optional AJAX dependency, but won't run scripts if not present
							if ( jQuery._evalUrl ) {
								jQuery._evalUrl( node.src );
							}
						} else {
							DOMEval( node.textContent.replace( rcleanScript, "" ), doc );
						}
					}
				}
			}
		}
	}

	return collection;
}

function remove( elem, selector, keepData ) {
	var node,
		nodes = selector ? jQuery.filter( selector, elem ) : elem,
		i = 0;

	for ( ; ( node = nodes[ i ] ) != null; i++ ) {
		if ( !keepData && node.nodeType === 1 ) {
			jQuery.cleanData( getAll( node ) );
		}

		if ( node.parentNode ) {
			if ( keepData && jQuery.contains( node.ownerDocument, node ) ) {
				setGlobalEval( getAll( node, "script" ) );
			}
			node.parentNode.removeChild( node );
		}
	}

	return elem;
}

jQuery.extend( {
	htmlPrefilter: function( html ) {
		return html.replace( rxhtmlTag, "<$1></$2>" );
	},

	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var i, l, srcElements, destElements,
			clone = elem.cloneNode( true ),
			inPage = jQuery.contains( elem.ownerDocument, elem );

		// Fix IE cloning issues
		if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
				!jQuery.isXMLDoc( elem ) ) {

			// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
			destElements = getAll( clone );
			srcElements = getAll( elem );

			for ( i = 0, l = srcElements.length; i < l; i++ ) {
				fixInput( srcElements[ i ], destElements[ i ] );
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			if ( deepDataAndEvents ) {
				srcElements = srcElements || getAll( elem );
				destElements = destElements || getAll( clone );

				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					cloneCopyEvent( srcElements[ i ], destElements[ i ] );
				}
			} else {
				cloneCopyEvent( elem, clone );
			}
		}

		// Preserve script evaluation history
		destElements = getAll( clone, "script" );
		if ( destElements.length > 0 ) {
			setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
		}

		// Return the cloned set
		return clone;
	},

	cleanData: function( elems ) {
		var data, elem, type,
			special = jQuery.event.special,
			i = 0;

		for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
			if ( acceptData( elem ) ) {
				if ( ( data = elem[ dataPriv.expando ] ) ) {
					if ( data.events ) {
						for ( type in data.events ) {
							if ( special[ type ] ) {
								jQuery.event.remove( elem, type );

							// This is a shortcut to avoid jQuery.event.remove's overhead
							} else {
								jQuery.removeEvent( elem, type, data.handle );
							}
						}
					}

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataPriv.expando ] = undefined;
				}
				if ( elem[ dataUser.expando ] ) {

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataUser.expando ] = undefined;
				}
			}
		}
	}
} );

jQuery.fn.extend( {
	detach: function( selector ) {
		return remove( this, selector, true );
	},

	remove: function( selector ) {
		return remove( this, selector );
	},

	text: function( value ) {
		return access( this, function( value ) {
			return value === undefined ?
				jQuery.text( this ) :
				this.empty().each( function() {
					if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
						this.textContent = value;
					}
				} );
		}, null, value, arguments.length );
	},

	append: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.appendChild( elem );
			}
		} );
	},

	prepend: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.insertBefore( elem, target.firstChild );
			}
		} );
	},

	before: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this );
			}
		} );
	},

	after: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			}
		} );
	},

	empty: function() {
		var elem,
			i = 0;

		for ( ; ( elem = this[ i ] ) != null; i++ ) {
			if ( elem.nodeType === 1 ) {

				// Prevent memory leaks
				jQuery.cleanData( getAll( elem, false ) );

				// Remove any remaining nodes
				elem.textContent = "";
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map( function() {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		} );
	},

	html: function( value ) {
		return access( this, function( value ) {
			var elem = this[ 0 ] || {},
				i = 0,
				l = this.length;

			if ( value === undefined && elem.nodeType === 1 ) {
				return elem.innerHTML;
			}

			// See if we can take a shortcut and just use innerHTML
			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
				!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

				value = jQuery.htmlPrefilter( value );

				try {
					for ( ; i < l; i++ ) {
						elem = this[ i ] || {};

						// Remove element nodes and prevent memory leaks
						if ( elem.nodeType === 1 ) {
							jQuery.cleanData( getAll( elem, false ) );
							elem.innerHTML = value;
						}
					}

					elem = 0;

				// If using innerHTML throws an exception, use the fallback method
				} catch ( e ) {}
			}

			if ( elem ) {
				this.empty().append( value );
			}
		}, null, value, arguments.length );
	},

	replaceWith: function() {
		var ignored = [];

		// Make the changes, replacing each non-ignored context element with the new content
		return domManip( this, arguments, function( elem ) {
			var parent = this.parentNode;

			if ( jQuery.inArray( this, ignored ) < 0 ) {
				jQuery.cleanData( getAll( this ) );
				if ( parent ) {
					parent.replaceChild( elem, this );
				}
			}

		// Force callback invocation
		}, ignored );
	}
} );

jQuery.each( {
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var elems,
			ret = [],
			insert = jQuery( selector ),
			last = insert.length - 1,
			i = 0;

		for ( ; i <= last; i++ ) {
			elems = i === last ? this : this.clone( true );
			jQuery( insert[ i ] )[ original ]( elems );

			// Support: Android <=4.0 only, PhantomJS 1 only
			// .get() because push.apply(_, arraylike) throws on ancient WebKit
			push.apply( ret, elems.get() );
		}

		return this.pushStack( ret );
	};
} );
var rmargin = ( /^margin/ );

var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

var getStyles = function( elem ) {

		// Support: IE <=11 only, Firefox <=30 (#15098, #14150)
		// IE throws on elements created in popups
		// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
		var view = elem.ownerDocument.defaultView;

		if ( !view || !view.opener ) {
			view = window;
		}

		return view.getComputedStyle( elem );
	};



( function() {

	// Executing both pixelPosition & boxSizingReliable tests require only one layout
	// so they're executed at the same time to save the second computation.
	function computeStyleTests() {

		// This is a singleton, we need to execute it only once
		if ( !div ) {
			return;
		}

		div.style.cssText =
			"box-sizing:border-box;" +
			"position:relative;display:block;" +
			"margin:auto;border:1px;padding:1px;" +
			"top:1%;width:50%";
		div.innerHTML = "";
		documentElement.appendChild( container );

		var divStyle = window.getComputedStyle( div );
		pixelPositionVal = divStyle.top !== "1%";

		// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
		reliableMarginLeftVal = divStyle.marginLeft === "2px";
		boxSizingReliableVal = divStyle.width === "4px";

		// Support: Android 4.0 - 4.3 only
		// Some styles come back with percentage values, even though they shouldn't
		div.style.marginRight = "50%";
		pixelMarginRightVal = divStyle.marginRight === "4px";

		documentElement.removeChild( container );

		// Nullify the div so it wouldn't be stored in the memory and
		// it will also be a sign that checks already performed
		div = null;
	}

	var pixelPositionVal, boxSizingReliableVal, pixelMarginRightVal, reliableMarginLeftVal,
		container = document.createElement( "div" ),
		div = document.createElement( "div" );

	// Finish early in limited (non-browser) environments
	if ( !div.style ) {
		return;
	}

	// Support: IE <=9 - 11 only
	// Style of cloned element affects source element cloned (#8908)
	div.style.backgroundClip = "content-box";
	div.cloneNode( true ).style.backgroundClip = "";
	support.clearCloneStyle = div.style.backgroundClip === "content-box";

	container.style.cssText = "border:0;width:8px;height:0;top:0;left:-9999px;" +
		"padding:0;margin-top:1px;position:absolute";
	container.appendChild( div );

	jQuery.extend( support, {
		pixelPosition: function() {
			computeStyleTests();
			return pixelPositionVal;
		},
		boxSizingReliable: function() {
			computeStyleTests();
			return boxSizingReliableVal;
		},
		pixelMarginRight: function() {
			computeStyleTests();
			return pixelMarginRightVal;
		},
		reliableMarginLeft: function() {
			computeStyleTests();
			return reliableMarginLeftVal;
		}
	} );
} )();


function curCSS( elem, name, computed ) {
	var width, minWidth, maxWidth, ret,
		style = elem.style;

	computed = computed || getStyles( elem );

	// Support: IE <=9 only
	// getPropertyValue is only needed for .css('filter') (#12537)
	if ( computed ) {
		ret = computed.getPropertyValue( name ) || computed[ name ];

		if ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {
			ret = jQuery.style( elem, name );
		}

		// A tribute to the "awesome hack by Dean Edwards"
		// Android Browser returns percentage for some values,
		// but width seems to be reliably pixels.
		// This is against the CSSOM draft spec:
		// https://drafts.csswg.org/cssom/#resolved-values
		if ( !support.pixelMarginRight() && rnumnonpx.test( ret ) && rmargin.test( name ) ) {

			// Remember the original values
			width = style.width;
			minWidth = style.minWidth;
			maxWidth = style.maxWidth;

			// Put in the new values to get a computed value out
			style.minWidth = style.maxWidth = style.width = ret;
			ret = computed.width;

			// Revert the changed values
			style.width = width;
			style.minWidth = minWidth;
			style.maxWidth = maxWidth;
		}
	}

	return ret !== undefined ?

		// Support: IE <=9 - 11 only
		// IE returns zIndex value as an integer.
		ret + "" :
		ret;
}


function addGetHookIf( conditionFn, hookFn ) {

	// Define the hook, we'll check on the first run if it's really needed.
	return {
		get: function() {
			if ( conditionFn() ) {

				// Hook not needed (or it's not possible to use it due
				// to missing dependency), remove it.
				delete this.get;
				return;
			}

			// Hook needed; redefine it so that the support test is not executed again.
			return ( this.get = hookFn ).apply( this, arguments );
		}
	};
}


var

	// Swappable if display is none or starts with table
	// except "table", "table-cell", or "table-caption"
	// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssNormalTransform = {
		letterSpacing: "0",
		fontWeight: "400"
	},

	cssPrefixes = [ "Webkit", "Moz", "ms" ],
	emptyStyle = document.createElement( "div" ).style;

// Return a css property mapped to a potentially vendor prefixed property
function vendorPropName( name ) {

	// Shortcut for names that are not vendor prefixed
	if ( name in emptyStyle ) {
		return name;
	}

	// Check for vendor prefixed names
	var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
		i = cssPrefixes.length;

	while ( i-- ) {
		name = cssPrefixes[ i ] + capName;
		if ( name in emptyStyle ) {
			return name;
		}
	}
}

function setPositiveNumber( elem, value, subtract ) {

	// Any relative (+/-) values have already been
	// normalized at this point
	var matches = rcssNum.exec( value );
	return matches ?

		// Guard against undefined "subtract", e.g., when used as in cssHooks
		Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
		value;
}

function augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {
	var i = extra === ( isBorderBox ? "border" : "content" ) ?

		// If we already have the right measurement, avoid augmentation
		4 :

		// Otherwise initialize for horizontal or vertical properties
		name === "width" ? 1 : 0,

		val = 0;

	for ( ; i < 4; i += 2 ) {

		// Both box models exclude margin, so add it if we want it
		if ( extra === "margin" ) {
			val += jQuery.css( elem, extra + cssExpand[ i ], true, styles );
		}

		if ( isBorderBox ) {

			// border-box includes padding, so remove it if we want content
			if ( extra === "content" ) {
				val -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
			}

			// At this point, extra isn't border nor margin, so remove border
			if ( extra !== "margin" ) {
				val -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		} else {

			// At this point, extra isn't content, so add padding
			val += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

			// At this point, extra isn't content nor padding, so add border
			if ( extra !== "padding" ) {
				val += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		}
	}

	return val;
}

function getWidthOrHeight( elem, name, extra ) {

	// Start with offset property, which is equivalent to the border-box value
	var val,
		valueIsBorderBox = true,
		styles = getStyles( elem ),
		isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

	// Support: IE <=11 only
	// Running getBoundingClientRect on a disconnected node
	// in IE throws an error.
	if ( elem.getClientRects().length ) {
		val = elem.getBoundingClientRect()[ name ];
	}

	// Some non-html elements return undefined for offsetWidth, so check for null/undefined
	// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
	// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
	if ( val <= 0 || val == null ) {

		// Fall back to computed then uncomputed css if necessary
		val = curCSS( elem, name, styles );
		if ( val < 0 || val == null ) {
			val = elem.style[ name ];
		}

		// Computed unit is not pixels. Stop here and return.
		if ( rnumnonpx.test( val ) ) {
			return val;
		}

		// Check for style in case a browser which returns unreliable values
		// for getComputedStyle silently falls back to the reliable elem.style
		valueIsBorderBox = isBorderBox &&
			( support.boxSizingReliable() || val === elem.style[ name ] );

		// Normalize "", auto, and prepare for extra
		val = parseFloat( val ) || 0;
	}

	// Use the active box-sizing model to add/subtract irrelevant styles
	return ( val +
		augmentWidthOrHeight(
			elem,
			name,
			extra || ( isBorderBox ? "border" : "content" ),
			valueIsBorderBox,
			styles
		)
	) + "px";
}

jQuery.extend( {

	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {

					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity" );
					return ret === "" ? "1" : ret;
				}
			}
		}
	},

	// Don't automatically add "px" to these possibly-unitless properties
	cssNumber: {
		"animationIterationCount": true,
		"columnCount": true,
		"fillOpacity": true,
		"flexGrow": true,
		"flexShrink": true,
		"fontWeight": true,
		"lineHeight": true,
		"opacity": true,
		"order": true,
		"orphans": true,
		"widows": true,
		"zIndex": true,
		"zoom": true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {
		"float": "cssFloat"
	},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {

		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, hooks,
			origName = jQuery.camelCase( name ),
			style = elem.style;

		name = jQuery.cssProps[ origName ] ||
			( jQuery.cssProps[ origName ] = vendorPropName( origName ) || origName );

		// Gets hook for the prefixed version, then unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// Convert "+=" or "-=" to relative numbers (#7345)
			if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
				value = adjustCSS( elem, name, ret );

				// Fixes bug #9237
				type = "number";
			}

			// Make sure that null and NaN values aren't set (#7116)
			if ( value == null || value !== value ) {
				return;
			}

			// If a number was passed in, add the unit (except for certain CSS properties)
			if ( type === "number" ) {
				value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
			}

			// background-* props affect original clone's values
			if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
				style[ name ] = "inherit";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !( "set" in hooks ) ||
				( value = hooks.set( elem, value, extra ) ) !== undefined ) {

				style[ name ] = value;
			}

		} else {

			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks &&
				( ret = hooks.get( elem, false, extra ) ) !== undefined ) {

				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra, styles ) {
		var val, num, hooks,
			origName = jQuery.camelCase( name );

		// Make sure that we're working with the right name
		name = jQuery.cssProps[ origName ] ||
			( jQuery.cssProps[ origName ] = vendorPropName( origName ) || origName );

		// Try prefixed name followed by the unprefixed name
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks ) {
			val = hooks.get( elem, true, extra );
		}

		// Otherwise, if a way to get the computed value exists, use that
		if ( val === undefined ) {
			val = curCSS( elem, name, styles );
		}

		// Convert "normal" to computed value
		if ( val === "normal" && name in cssNormalTransform ) {
			val = cssNormalTransform[ name ];
		}

		// Make numeric if forced or a qualifier was provided and val looks numeric
		if ( extra === "" || extra ) {
			num = parseFloat( val );
			return extra === true || isFinite( num ) ? num || 0 : val;
		}
		return val;
	}
} );

jQuery.each( [ "height", "width" ], function( i, name ) {
	jQuery.cssHooks[ name ] = {
		get: function( elem, computed, extra ) {
			if ( computed ) {

				// Certain elements can have dimension info if we invisibly show them
				// but it must have a current display style that would benefit
				return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&

					// Support: Safari 8+
					// Table columns in Safari have non-zero offsetWidth & zero
					// getBoundingClientRect().width unless display is changed.
					// Support: IE <=11 only
					// Running getBoundingClientRect on a disconnected node
					// in IE throws an error.
					( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?
						swap( elem, cssShow, function() {
							return getWidthOrHeight( elem, name, extra );
						} ) :
						getWidthOrHeight( elem, name, extra );
			}
		},

		set: function( elem, value, extra ) {
			var matches,
				styles = extra && getStyles( elem ),
				subtract = extra && augmentWidthOrHeight(
					elem,
					name,
					extra,
					jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
					styles
				);

			// Convert to pixels if value adjustment is needed
			if ( subtract && ( matches = rcssNum.exec( value ) ) &&
				( matches[ 3 ] || "px" ) !== "px" ) {

				elem.style[ name ] = value;
				value = jQuery.css( elem, name );
			}

			return setPositiveNumber( elem, value, subtract );
		}
	};
} );

jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
	function( elem, computed ) {
		if ( computed ) {
			return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
				elem.getBoundingClientRect().left -
					swap( elem, { marginLeft: 0 }, function() {
						return elem.getBoundingClientRect().left;
					} )
				) + "px";
		}
	}
);

// These hooks are used by animate to expand properties
jQuery.each( {
	margin: "",
	padding: "",
	border: "Width"
}, function( prefix, suffix ) {
	jQuery.cssHooks[ prefix + suffix ] = {
		expand: function( value ) {
			var i = 0,
				expanded = {},

				// Assumes a single number if not a string
				parts = typeof value === "string" ? value.split( " " ) : [ value ];

			for ( ; i < 4; i++ ) {
				expanded[ prefix + cssExpand[ i ] + suffix ] =
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
			}

			return expanded;
		}
	};

	if ( !rmargin.test( prefix ) ) {
		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
	}
} );

jQuery.fn.extend( {
	css: function( name, value ) {
		return access( this, function( elem, name, value ) {
			var styles, len,
				map = {},
				i = 0;

			if ( jQuery.isArray( name ) ) {
				styles = getStyles( elem );
				len = name.length;

				for ( ; i < len; i++ ) {
					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
				}

				return map;
			}

			return value !== undefined ?
				jQuery.style( elem, name, value ) :
				jQuery.css( elem, name );
		}, name, value, arguments.length > 1 );
	}
} );


function Tween( elem, options, prop, end, easing ) {
	return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
	constructor: Tween,
	init: function( elem, options, prop, end, easing, unit ) {
		this.elem = elem;
		this.prop = prop;
		this.easing = easing || jQuery.easing._default;
		this.options = options;
		this.start = this.now = this.cur();
		this.end = end;
		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
	},
	cur: function() {
		var hooks = Tween.propHooks[ this.prop ];

		return hooks && hooks.get ?
			hooks.get( this ) :
			Tween.propHooks._default.get( this );
	},
	run: function( percent ) {
		var eased,
			hooks = Tween.propHooks[ this.prop ];

		if ( this.options.duration ) {
			this.pos = eased = jQuery.easing[ this.easing ](
				percent, this.options.duration * percent, 0, 1, this.options.duration
			);
		} else {
			this.pos = eased = percent;
		}
		this.now = ( this.end - this.start ) * eased + this.start;

		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		if ( hooks && hooks.set ) {
			hooks.set( this );
		} else {
			Tween.propHooks._default.set( this );
		}
		return this;
	}
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
	_default: {
		get: function( tween ) {
			var result;

			// Use a property on the element directly when it is not a DOM element,
			// or when there is no matching style property that exists.
			if ( tween.elem.nodeType !== 1 ||
				tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
				return tween.elem[ tween.prop ];
			}

			// Passing an empty string as a 3rd parameter to .css will automatically
			// attempt a parseFloat and fallback to a string if the parse fails.
			// Simple values such as "10px" are parsed to Float;
			// complex values such as "rotate(1rad)" are returned as-is.
			result = jQuery.css( tween.elem, tween.prop, "" );

			// Empty strings, null, undefined and "auto" are converted to 0.
			return !result || result === "auto" ? 0 : result;
		},
		set: function( tween ) {

			// Use step hook for back compat.
			// Use cssHook if its there.
			// Use .style if available and use plain properties where available.
			if ( jQuery.fx.step[ tween.prop ] ) {
				jQuery.fx.step[ tween.prop ]( tween );
			} else if ( tween.elem.nodeType === 1 &&
				( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null ||
					jQuery.cssHooks[ tween.prop ] ) ) {
				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
			} else {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	}
};

// Support: IE <=9 only
// Panic based approach to setting things on disconnected nodes
Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
	set: function( tween ) {
		if ( tween.elem.nodeType && tween.elem.parentNode ) {
			tween.elem[ tween.prop ] = tween.now;
		}
	}
};

jQuery.easing = {
	linear: function( p ) {
		return p;
	},
	swing: function( p ) {
		return 0.5 - Math.cos( p * Math.PI ) / 2;
	},
	_default: "swing"
};

jQuery.fx = Tween.prototype.init;

// Back compat <1.8 extension point
jQuery.fx.step = {};




var
	fxNow, timerId,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rrun = /queueHooks$/;

function raf() {
	if ( timerId ) {
		window.requestAnimationFrame( raf );
		jQuery.fx.tick();
	}
}

// Animations created synchronously will run synchronously
function createFxNow() {
	window.setTimeout( function() {
		fxNow = undefined;
	} );
	return ( fxNow = jQuery.now() );
}

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
	var which,
		i = 0,
		attrs = { height: type };

	// If we include width, step value is 1 to do all cssExpand values,
	// otherwise step value is 2 to skip over Left and Right
	includeWidth = includeWidth ? 1 : 0;
	for ( ; i < 4; i += 2 - includeWidth ) {
		which = cssExpand[ i ];
		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
	}

	if ( includeWidth ) {
		attrs.opacity = attrs.width = type;
	}

	return attrs;
}

function createTween( value, prop, animation ) {
	var tween,
		collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
		index = 0,
		length = collection.length;
	for ( ; index < length; index++ ) {
		if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {

			// We're done with this property
			return tween;
		}
	}
}

function defaultPrefilter( elem, props, opts ) {
	var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,
		isBox = "width" in props || "height" in props,
		anim = this,
		orig = {},
		style = elem.style,
		hidden = elem.nodeType && isHiddenWithinTree( elem ),
		dataShow = dataPriv.get( elem, "fxshow" );

	// Queue-skipping animations hijack the fx hooks
	if ( !opts.queue ) {
		hooks = jQuery._queueHooks( elem, "fx" );
		if ( hooks.unqueued == null ) {
			hooks.unqueued = 0;
			oldfire = hooks.empty.fire;
			hooks.empty.fire = function() {
				if ( !hooks.unqueued ) {
					oldfire();
				}
			};
		}
		hooks.unqueued++;

		anim.always( function() {

			// Ensure the complete handler is called before this completes
			anim.always( function() {
				hooks.unqueued--;
				if ( !jQuery.queue( elem, "fx" ).length ) {
					hooks.empty.fire();
				}
			} );
		} );
	}

	// Detect show/hide animations
	for ( prop in props ) {
		value = props[ prop ];
		if ( rfxtypes.test( value ) ) {
			delete props[ prop ];
			toggle = toggle || value === "toggle";
			if ( value === ( hidden ? "hide" : "show" ) ) {

				// Pretend to be hidden if this is a "show" and
				// there is still data from a stopped show/hide
				if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
					hidden = true;

				// Ignore all other no-op show/hide data
				} else {
					continue;
				}
			}
			orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
		}
	}

	// Bail out if this is a no-op like .hide().hide()
	propTween = !jQuery.isEmptyObject( props );
	if ( !propTween && jQuery.isEmptyObject( orig ) ) {
		return;
	}

	// Restrict "overflow" and "display" styles during box animations
	if ( isBox && elem.nodeType === 1 ) {

		// Support: IE <=9 - 11, Edge 12 - 13
		// Record all 3 overflow attributes because IE does not infer the shorthand
		// from identically-valued overflowX and overflowY
		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

		// Identify a display type, preferring old show/hide data over the CSS cascade
		restoreDisplay = dataShow && dataShow.display;
		if ( restoreDisplay == null ) {
			restoreDisplay = dataPriv.get( elem, "display" );
		}
		display = jQuery.css( elem, "display" );
		if ( display === "none" ) {
			if ( restoreDisplay ) {
				display = restoreDisplay;
			} else {

				// Get nonempty value(s) by temporarily forcing visibility
				showHide( [ elem ], true );
				restoreDisplay = elem.style.display || restoreDisplay;
				display = jQuery.css( elem, "display" );
				showHide( [ elem ] );
			}
		}

		// Animate inline elements as inline-block
		if ( display === "inline" || display === "inline-block" && restoreDisplay != null ) {
			if ( jQuery.css( elem, "float" ) === "none" ) {

				// Restore the original display value at the end of pure show/hide animations
				if ( !propTween ) {
					anim.done( function() {
						style.display = restoreDisplay;
					} );
					if ( restoreDisplay == null ) {
						display = style.display;
						restoreDisplay = display === "none" ? "" : display;
					}
				}
				style.display = "inline-block";
			}
		}
	}

	if ( opts.overflow ) {
		style.overflow = "hidden";
		anim.always( function() {
			style.overflow = opts.overflow[ 0 ];
			style.overflowX = opts.overflow[ 1 ];
			style.overflowY = opts.overflow[ 2 ];
		} );
	}

	// Implement show/hide animations
	propTween = false;
	for ( prop in orig ) {

		// General show/hide setup for this element animation
		if ( !propTween ) {
			if ( dataShow ) {
				if ( "hidden" in dataShow ) {
					hidden = dataShow.hidden;
				}
			} else {
				dataShow = dataPriv.access( elem, "fxshow", { display: restoreDisplay } );
			}

			// Store hidden/visible for toggle so `.stop().toggle()` "reverses"
			if ( toggle ) {
				dataShow.hidden = !hidden;
			}

			// Show elements before animating them
			if ( hidden ) {
				showHide( [ elem ], true );
			}

			/* eslint-disable no-loop-func */

			anim.done( function() {

			/* eslint-enable no-loop-func */

				// The final step of a "hide" animation is actually hiding the element
				if ( !hidden ) {
					showHide( [ elem ] );
				}
				dataPriv.remove( elem, "fxshow" );
				for ( prop in orig ) {
					jQuery.style( elem, prop, orig[ prop ] );
				}
			} );
		}

		// Per-property setup
		propTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
		if ( !( prop in dataShow ) ) {
			dataShow[ prop ] = propTween.start;
			if ( hidden ) {
				propTween.end = propTween.start;
				propTween.start = 0;
			}
		}
	}
}

function propFilter( props, specialEasing ) {
	var index, name, easing, value, hooks;

	// camelCase, specialEasing and expand cssHook pass
	for ( index in props ) {
		name = jQuery.camelCase( index );
		easing = specialEasing[ name ];
		value = props[ index ];
		if ( jQuery.isArray( value ) ) {
			easing = value[ 1 ];
			value = props[ index ] = value[ 0 ];
		}

		if ( index !== name ) {
			props[ name ] = value;
			delete props[ index ];
		}

		hooks = jQuery.cssHooks[ name ];
		if ( hooks && "expand" in hooks ) {
			value = hooks.expand( value );
			delete props[ name ];

			// Not quite $.extend, this won't overwrite existing keys.
			// Reusing 'index' because we have the correct "name"
			for ( index in value ) {
				if ( !( index in props ) ) {
					props[ index ] = value[ index ];
					specialEasing[ index ] = easing;
				}
			}
		} else {
			specialEasing[ name ] = easing;
		}
	}
}

function Animation( elem, properties, options ) {
	var result,
		stopped,
		index = 0,
		length = Animation.prefilters.length,
		deferred = jQuery.Deferred().always( function() {

			// Don't match elem in the :animated selector
			delete tick.elem;
		} ),
		tick = function() {
			if ( stopped ) {
				return false;
			}
			var currentTime = fxNow || createFxNow(),
				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),

				// Support: Android 2.3 only
				// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
				temp = remaining / animation.duration || 0,
				percent = 1 - temp,
				index = 0,
				length = animation.tweens.length;

			for ( ; index < length; index++ ) {
				animation.tweens[ index ].run( percent );
			}

			deferred.notifyWith( elem, [ animation, percent, remaining ] );

			if ( percent < 1 && length ) {
				return remaining;
			} else {
				deferred.resolveWith( elem, [ animation ] );
				return false;
			}
		},
		animation = deferred.promise( {
			elem: elem,
			props: jQuery.extend( {}, properties ),
			opts: jQuery.extend( true, {
				specialEasing: {},
				easing: jQuery.easing._default
			}, options ),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function( prop, end ) {
				var tween = jQuery.Tween( elem, animation.opts, prop, end,
						animation.opts.specialEasing[ prop ] || animation.opts.easing );
				animation.tweens.push( tween );
				return tween;
			},
			stop: function( gotoEnd ) {
				var index = 0,

					// If we are going to the end, we want to run all the tweens
					// otherwise we skip this part
					length = gotoEnd ? animation.tweens.length : 0;
				if ( stopped ) {
					return this;
				}
				stopped = true;
				for ( ; index < length; index++ ) {
					animation.tweens[ index ].run( 1 );
				}

				// Resolve when we played the last frame; otherwise, reject
				if ( gotoEnd ) {
					deferred.notifyWith( elem, [ animation, 1, 0 ] );
					deferred.resolveWith( elem, [ animation, gotoEnd ] );
				} else {
					deferred.rejectWith( elem, [ animation, gotoEnd ] );
				}
				return this;
			}
		} ),
		props = animation.props;

	propFilter( props, animation.opts.specialEasing );

	for ( ; index < length; index++ ) {
		result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
		if ( result ) {
			if ( jQuery.isFunction( result.stop ) ) {
				jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
					jQuery.proxy( result.stop, result );
			}
			return result;
		}
	}

	jQuery.map( props, createTween, animation );

	if ( jQuery.isFunction( animation.opts.start ) ) {
		animation.opts.start.call( elem, animation );
	}

	jQuery.fx.timer(
		jQuery.extend( tick, {
			elem: elem,
			anim: animation,
			queue: animation.opts.queue
		} )
	);

	// attach callbacks from options
	return animation.progress( animation.opts.progress )
		.done( animation.opts.done, animation.opts.complete )
		.fail( animation.opts.fail )
		.always( animation.opts.always );
}

jQuery.Animation = jQuery.extend( Animation, {

	tweeners: {
		"*": [ function( prop, value ) {
			var tween = this.createTween( prop, value );
			adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
			return tween;
		} ]
	},

	tweener: function( props, callback ) {
		if ( jQuery.isFunction( props ) ) {
			callback = props;
			props = [ "*" ];
		} else {
			props = props.match( rnotwhite );
		}

		var prop,
			index = 0,
			length = props.length;

		for ( ; index < length; index++ ) {
			prop = props[ index ];
			Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
			Animation.tweeners[ prop ].unshift( callback );
		}
	},

	prefilters: [ defaultPrefilter ],

	prefilter: function( callback, prepend ) {
		if ( prepend ) {
			Animation.prefilters.unshift( callback );
		} else {
			Animation.prefilters.push( callback );
		}
	}
} );

jQuery.speed = function( speed, easing, fn ) {
	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
		complete: fn || !fn && easing ||
			jQuery.isFunction( speed ) && speed,
		duration: speed,
		easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
	};

	// Go to the end state if fx are off or if document is hidden
	if ( jQuery.fx.off || document.hidden ) {
		opt.duration = 0;

	} else {
		opt.duration = typeof opt.duration === "number" ?
			opt.duration : opt.duration in jQuery.fx.speeds ?
				jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;
	}

	// Normalize opt.queue - true/undefined/null -> "fx"
	if ( opt.queue == null || opt.queue === true ) {
		opt.queue = "fx";
	}

	// Queueing
	opt.old = opt.complete;

	opt.complete = function() {
		if ( jQuery.isFunction( opt.old ) ) {
			opt.old.call( this );
		}

		if ( opt.queue ) {
			jQuery.dequeue( this, opt.queue );
		}
	};

	return opt;
};

jQuery.fn.extend( {
	fadeTo: function( speed, to, easing, callback ) {

		// Show any hidden elements after setting opacity to 0
		return this.filter( isHiddenWithinTree ).css( "opacity", 0 ).show()

			// Animate to the value specified
			.end().animate( { opacity: to }, speed, easing, callback );
	},
	animate: function( prop, speed, easing, callback ) {
		var empty = jQuery.isEmptyObject( prop ),
			optall = jQuery.speed( speed, easing, callback ),
			doAnimation = function() {

				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation( this, jQuery.extend( {}, prop ), optall );

				// Empty animations, or finishing resolves immediately
				if ( empty || dataPriv.get( this, "finish" ) ) {
					anim.stop( true );
				}
			};
			doAnimation.finish = doAnimation;

		return empty || optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},
	stop: function( type, clearQueue, gotoEnd ) {
		var stopQueue = function( hooks ) {
			var stop = hooks.stop;
			delete hooks.stop;
			stop( gotoEnd );
		};

		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue && type !== false ) {
			this.queue( type || "fx", [] );
		}

		return this.each( function() {
			var dequeue = true,
				index = type != null && type + "queueHooks",
				timers = jQuery.timers,
				data = dataPriv.get( this );

			if ( index ) {
				if ( data[ index ] && data[ index ].stop ) {
					stopQueue( data[ index ] );
				}
			} else {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
						stopQueue( data[ index ] );
					}
				}
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this &&
					( type == null || timers[ index ].queue === type ) ) {

					timers[ index ].anim.stop( gotoEnd );
					dequeue = false;
					timers.splice( index, 1 );
				}
			}

			// Start the next in the queue if the last step wasn't forced.
			// Timers currently will call their complete callbacks, which
			// will dequeue but only if they were gotoEnd.
			if ( dequeue || !gotoEnd ) {
				jQuery.dequeue( this, type );
			}
		} );
	},
	finish: function( type ) {
		if ( type !== false ) {
			type = type || "fx";
		}
		return this.each( function() {
			var index,
				data = dataPriv.get( this ),
				queue = data[ type + "queue" ],
				hooks = data[ type + "queueHooks" ],
				timers = jQuery.timers,
				length = queue ? queue.length : 0;

			// Enable finishing flag on private data
			data.finish = true;

			// Empty the queue first
			jQuery.queue( this, type, [] );

			if ( hooks && hooks.stop ) {
				hooks.stop.call( this, true );
			}

			// Look for any active animations, and finish them
			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
					timers[ index ].anim.stop( true );
					timers.splice( index, 1 );
				}
			}

			// Look for any animations in the old queue and finish them
			for ( index = 0; index < length; index++ ) {
				if ( queue[ index ] && queue[ index ].finish ) {
					queue[ index ].finish.call( this );
				}
			}

			// Turn off finishing flag
			delete data.finish;
		} );
	}
} );

jQuery.each( [ "toggle", "show", "hide" ], function( i, name ) {
	var cssFn = jQuery.fn[ name ];
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return speed == null || typeof speed === "boolean" ?
			cssFn.apply( this, arguments ) :
			this.animate( genFx( name, true ), speed, easing, callback );
	};
} );

// Generate shortcuts for custom animations
jQuery.each( {
	slideDown: genFx( "show" ),
	slideUp: genFx( "hide" ),
	slideToggle: genFx( "toggle" ),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
} );

jQuery.timers = [];
jQuery.fx.tick = function() {
	var timer,
		i = 0,
		timers = jQuery.timers;

	fxNow = jQuery.now();

	for ( ; i < timers.length; i++ ) {
		timer = timers[ i ];

		// Checks the timer has not already been removed
		if ( !timer() && timers[ i ] === timer ) {
			timers.splice( i--, 1 );
		}
	}

	if ( !timers.length ) {
		jQuery.fx.stop();
	}
	fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
	jQuery.timers.push( timer );
	if ( timer() ) {
		jQuery.fx.start();
	} else {
		jQuery.timers.pop();
	}
};

jQuery.fx.interval = 13;
jQuery.fx.start = function() {
	if ( !timerId ) {
		timerId = window.requestAnimationFrame ?
			window.requestAnimationFrame( raf ) :
			window.setInterval( jQuery.fx.tick, jQuery.fx.interval );
	}
};

jQuery.fx.stop = function() {
	if ( window.cancelAnimationFrame ) {
		window.cancelAnimationFrame( timerId );
	} else {
		window.clearInterval( timerId );
	}

	timerId = null;
};

jQuery.fx.speeds = {
	slow: 600,
	fast: 200,

	// Default speed
	_default: 400
};


// Based off of the plugin by Clint Helfers, with permission.
// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
jQuery.fn.delay = function( time, type ) {
	time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
	type = type || "fx";

	return this.queue( type, function( next, hooks ) {
		var timeout = window.setTimeout( next, time );
		hooks.stop = function() {
			window.clearTimeout( timeout );
		};
	} );
};


( function() {
	var input = document.createElement( "input" ),
		select = document.createElement( "select" ),
		opt = select.appendChild( document.createElement( "option" ) );

	input.type = "checkbox";

	// Support: Android <=4.3 only
	// Default value for a checkbox should be "on"
	support.checkOn = input.value !== "";

	// Support: IE <=11 only
	// Must access selectedIndex to make default options select
	support.optSelected = opt.selected;

	// Support: IE <=11 only
	// An input loses its value after becoming a radio
	input = document.createElement( "input" );
	input.value = "t";
	input.type = "radio";
	support.radioValue = input.value === "t";
} )();


var boolHook,
	attrHandle = jQuery.expr.attrHandle;

jQuery.fn.extend( {
	attr: function( name, value ) {
		return access( this, jQuery.attr, name, value, arguments.length > 1 );
	},

	removeAttr: function( name ) {
		return this.each( function() {
			jQuery.removeAttr( this, name );
		} );
	}
} );

jQuery.extend( {
	attr: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set attributes on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === "undefined" ) {
			return jQuery.prop( elem, name, value );
		}

		// Attribute hooks are determined by the lowercase version
		// Grab necessary hook if one is defined
		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
			hooks = jQuery.attrHooks[ name.toLowerCase() ] ||
				( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
		}

		if ( value !== undefined ) {
			if ( value === null ) {
				jQuery.removeAttr( elem, name );
				return;
			}

			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			elem.setAttribute( name, value + "" );
			return value;
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		ret = jQuery.find.attr( elem, name );

		// Non-existent attributes return null, we normalize to undefined
		return ret == null ? undefined : ret;
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				if ( !support.radioValue && value === "radio" &&
					jQuery.nodeName( elem, "input" ) ) {
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		}
	},

	removeAttr: function( elem, value ) {
		var name,
			i = 0,
			attrNames = value && value.match( rnotwhite );

		if ( attrNames && elem.nodeType === 1 ) {
			while ( ( name = attrNames[ i++ ] ) ) {
				elem.removeAttribute( name );
			}
		}
	}
} );

// Hooks for boolean attributes
boolHook = {
	set: function( elem, value, name ) {
		if ( value === false ) {

			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else {
			elem.setAttribute( name, name );
		}
		return name;
	}
};

jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
	var getter = attrHandle[ name ] || jQuery.find.attr;

	attrHandle[ name ] = function( elem, name, isXML ) {
		var ret, handle,
			lowercaseName = name.toLowerCase();

		if ( !isXML ) {

			// Avoid an infinite loop by temporarily removing this function from the getter
			handle = attrHandle[ lowercaseName ];
			attrHandle[ lowercaseName ] = ret;
			ret = getter( elem, name, isXML ) != null ?
				lowercaseName :
				null;
			attrHandle[ lowercaseName ] = handle;
		}
		return ret;
	};
} );




var rfocusable = /^(?:input|select|textarea|button)$/i,
	rclickable = /^(?:a|area)$/i;

jQuery.fn.extend( {
	prop: function( name, value ) {
		return access( this, jQuery.prop, name, value, arguments.length > 1 );
	},

	removeProp: function( name ) {
		return this.each( function() {
			delete this[ jQuery.propFix[ name ] || name ];
		} );
	}
} );

jQuery.extend( {
	prop: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set properties on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {

			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			return ( elem[ name ] = value );
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		return elem[ name ];
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {

				// Support: IE <=9 - 11 only
				// elem.tabIndex doesn't always return the
				// correct value when it hasn't been explicitly set
				// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
				// Use proper attribute retrieval(#12072)
				var tabindex = jQuery.find.attr( elem, "tabindex" );

				return tabindex ?
					parseInt( tabindex, 10 ) :
					rfocusable.test( elem.nodeName ) ||
						rclickable.test( elem.nodeName ) && elem.href ?
							0 :
							-1;
			}
		}
	},

	propFix: {
		"for": "htmlFor",
		"class": "className"
	}
} );

// Support: IE <=11 only
// Accessing the selectedIndex property
// forces the browser to respect setting selected
// on the option
// The getter ensures a default option is selected
// when in an optgroup
if ( !support.optSelected ) {
	jQuery.propHooks.selected = {
		get: function( elem ) {
			var parent = elem.parentNode;
			if ( parent && parent.parentNode ) {
				parent.parentNode.selectedIndex;
			}
			return null;
		},
		set: function( elem ) {
			var parent = elem.parentNode;
			if ( parent ) {
				parent.selectedIndex;

				if ( parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
			}
		}
	};
}

jQuery.each( [
	"tabIndex",
	"readOnly",
	"maxLength",
	"cellSpacing",
	"cellPadding",
	"rowSpan",
	"colSpan",
	"useMap",
	"frameBorder",
	"contentEditable"
], function() {
	jQuery.propFix[ this.toLowerCase() ] = this;
} );




var rclass = /[\t\r\n\f]/g;

function getClass( elem ) {
	return elem.getAttribute && elem.getAttribute( "class" ) || "";
}

jQuery.fn.extend( {
	addClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( jQuery.isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		if ( typeof value === "string" && value ) {
			classes = value.match( rnotwhite ) || [];

			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );
				cur = elem.nodeType === 1 &&
					( " " + curValue + " " ).replace( rclass, " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {
						if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
							cur += clazz + " ";
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = jQuery.trim( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	removeClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( jQuery.isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		if ( !arguments.length ) {
			return this.attr( "class", "" );
		}

		if ( typeof value === "string" && value ) {
			classes = value.match( rnotwhite ) || [];

			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );

				// This expression is here for better compressibility (see addClass)
				cur = elem.nodeType === 1 &&
					( " " + curValue + " " ).replace( rclass, " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {

						// Remove *all* instances
						while ( cur.indexOf( " " + clazz + " " ) > -1 ) {
							cur = cur.replace( " " + clazz + " ", " " );
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = jQuery.trim( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var type = typeof value;

		if ( typeof stateVal === "boolean" && type === "string" ) {
			return stateVal ? this.addClass( value ) : this.removeClass( value );
		}

		if ( jQuery.isFunction( value ) ) {
			return this.each( function( i ) {
				jQuery( this ).toggleClass(
					value.call( this, i, getClass( this ), stateVal ),
					stateVal
				);
			} );
		}

		return this.each( function() {
			var className, i, self, classNames;

			if ( type === "string" ) {

				// Toggle individual class names
				i = 0;
				self = jQuery( this );
				classNames = value.match( rnotwhite ) || [];

				while ( ( className = classNames[ i++ ] ) ) {

					// Check each className given, space separated list
					if ( self.hasClass( className ) ) {
						self.removeClass( className );
					} else {
						self.addClass( className );
					}
				}

			// Toggle whole class name
			} else if ( value === undefined || type === "boolean" ) {
				className = getClass( this );
				if ( className ) {

					// Store className if set
					dataPriv.set( this, "__className__", className );
				}

				// If the element has a class name or if we're passed `false`,
				// then remove the whole classname (if there was one, the above saved it).
				// Otherwise bring back whatever was previously saved (if anything),
				// falling back to the empty string if nothing was stored.
				if ( this.setAttribute ) {
					this.setAttribute( "class",
						className || value === false ?
						"" :
						dataPriv.get( this, "__className__" ) || ""
					);
				}
			}
		} );
	},

	hasClass: function( selector ) {
		var className, elem,
			i = 0;

		className = " " + selector + " ";
		while ( ( elem = this[ i++ ] ) ) {
			if ( elem.nodeType === 1 &&
				( " " + getClass( elem ) + " " ).replace( rclass, " " )
					.indexOf( className ) > -1
			) {
				return true;
			}
		}

		return false;
	}
} );




var rreturn = /\r/g,
	rspaces = /[\x20\t\r\n\f]+/g;

jQuery.fn.extend( {
	val: function( value ) {
		var hooks, ret, isFunction,
			elem = this[ 0 ];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] ||
					jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				if ( hooks &&
					"get" in hooks &&
					( ret = hooks.get( elem, "value" ) ) !== undefined
				) {
					return ret;
				}

				ret = elem.value;

				return typeof ret === "string" ?

					// Handle most common string cases
					ret.replace( rreturn, "" ) :

					// Handle cases where value is null/undef or number
					ret == null ? "" : ret;
			}

			return;
		}

		isFunction = jQuery.isFunction( value );

		return this.each( function( i ) {
			var val;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( isFunction ) {
				val = value.call( this, i, jQuery( this ).val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";

			} else if ( typeof val === "number" ) {
				val += "";

			} else if ( jQuery.isArray( val ) ) {
				val = jQuery.map( val, function( value ) {
					return value == null ? "" : value + "";
				} );
			}

			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		} );
	}
} );

jQuery.extend( {
	valHooks: {
		option: {
			get: function( elem ) {

				var val = jQuery.find.attr( elem, "value" );
				return val != null ?
					val :

					// Support: IE <=10 - 11 only
					// option.text throws exceptions (#14686, #14858)
					// Strip and collapse whitespace
					// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
					jQuery.trim( jQuery.text( elem ) ).replace( rspaces, " " );
			}
		},
		select: {
			get: function( elem ) {
				var value, option,
					options = elem.options,
					index = elem.selectedIndex,
					one = elem.type === "select-one",
					values = one ? null : [],
					max = one ? index + 1 : options.length,
					i = index < 0 ?
						max :
						one ? index : 0;

				// Loop through all the selected options
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// Support: IE <=9 only
					// IE8-9 doesn't update selected after form reset (#2551)
					if ( ( option.selected || i === index ) &&

							// Don't return options that are disabled or in a disabled optgroup
							!option.disabled &&
							( !option.parentNode.disabled ||
								!jQuery.nodeName( option.parentNode, "optgroup" ) ) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				return values;
			},

			set: function( elem, value ) {
				var optionSet, option,
					options = elem.options,
					values = jQuery.makeArray( value ),
					i = options.length;

				while ( i-- ) {
					option = options[ i ];

					/* eslint-disable no-cond-assign */

					if ( option.selected =
						jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
					) {
						optionSet = true;
					}

					/* eslint-enable no-cond-assign */
				}

				// Force browsers to behave consistently when non-matching value is set
				if ( !optionSet ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	}
} );

// Radios and checkboxes getter/setter
jQuery.each( [ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = {
		set: function( elem, value ) {
			if ( jQuery.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
			}
		}
	};
	if ( !support.checkOn ) {
		jQuery.valHooks[ this ].get = function( elem ) {
			return elem.getAttribute( "value" ) === null ? "on" : elem.value;
		};
	}
} );




// Return jQuery for attributes-only inclusion


var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/;

jQuery.extend( jQuery.event, {

	trigger: function( event, data, elem, onlyHandlers ) {

		var i, cur, tmp, bubbleType, ontype, handle, special,
			eventPath = [ elem || document ],
			type = hasOwn.call( event, "type" ) ? event.type : event,
			namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];

		cur = tmp = elem = elem || document;

		// Don't do events on text and comment nodes
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf( "." ) > -1 ) {

			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split( "." );
			type = namespaces.shift();
			namespaces.sort();
		}
		ontype = type.indexOf( ":" ) < 0 && "on" + type;

		// Caller can pass in a jQuery.Event object, Object, or just an event type string
		event = event[ jQuery.expando ] ?
			event :
			new jQuery.Event( type, typeof event === "object" && event );

		// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
		event.isTrigger = onlyHandlers ? 2 : 3;
		event.namespace = namespaces.join( "." );
		event.rnamespace = event.namespace ?
			new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
			null;

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data == null ?
			[ event ] :
			jQuery.makeArray( data, [ event ] );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (#9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
		if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			if ( !rfocusMorph.test( bubbleType + type ) ) {
				cur = cur.parentNode;
			}
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push( cur );
				tmp = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( tmp === ( elem.ownerDocument || document ) ) {
				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
			}
		}

		// Fire handlers on the event path
		i = 0;
		while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {

			event.type = i > 1 ?
				bubbleType :
				special.bindType || type;

			// jQuery handler
			handle = ( dataPriv.get( cur, "events" ) || {} )[ event.type ] &&
				dataPriv.get( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}

			// Native handler
			handle = ontype && cur[ ontype ];
			if ( handle && handle.apply && acceptData( cur ) ) {
				event.result = handle.apply( cur, data );
				if ( event.result === false ) {
					event.preventDefault();
				}
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( ( !special._default ||
				special._default.apply( eventPath.pop(), data ) === false ) &&
				acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name as the event.
				// Don't do default actions on window, that's where global variables be (#6170)
				if ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					tmp = elem[ ontype ];

					if ( tmp ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;
					elem[ type ]();
					jQuery.event.triggered = undefined;

					if ( tmp ) {
						elem[ ontype ] = tmp;
					}
				}
			}
		}

		return event.result;
	},

	// Piggyback on a donor event to simulate a different one
	// Used only for `focus(in | out)` events
	simulate: function( type, elem, event ) {
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{
				type: type,
				isSimulated: true
			}
		);

		jQuery.event.trigger( e, null, elem );
	}

} );

jQuery.fn.extend( {

	trigger: function( type, data ) {
		return this.each( function() {
			jQuery.event.trigger( type, data, this );
		} );
	},
	triggerHandler: function( type, data ) {
		var elem = this[ 0 ];
		if ( elem ) {
			return jQuery.event.trigger( type, data, elem, true );
		}
	}
} );


jQuery.each( ( "blur focus focusin focusout resize scroll click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup contextmenu" ).split( " " ),
	function( i, name ) {

	// Handle event binding
	jQuery.fn[ name ] = function( data, fn ) {
		return arguments.length > 0 ?
			this.on( name, null, data, fn ) :
			this.trigger( name );
	};
} );

jQuery.fn.extend( {
	hover: function( fnOver, fnOut ) {
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
	}
} );




support.focusin = "onfocusin" in window;


// Support: Firefox <=44
// Firefox doesn't have focus(in | out) events
// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
//
// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
// focus(in | out) events fire after focus & blur events,
// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
if ( !support.focusin ) {
	jQuery.each( { focus: "focusin", blur: "focusout" }, function( orig, fix ) {

		// Attach a single capturing handler on the document while someone wants focusin/focusout
		var handler = function( event ) {
			jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );
		};

		jQuery.event.special[ fix ] = {
			setup: function() {
				var doc = this.ownerDocument || this,
					attaches = dataPriv.access( doc, fix );

				if ( !attaches ) {
					doc.addEventListener( orig, handler, true );
				}
				dataPriv.access( doc, fix, ( attaches || 0 ) + 1 );
			},
			teardown: function() {
				var doc = this.ownerDocument || this,
					attaches = dataPriv.access( doc, fix ) - 1;

				if ( !attaches ) {
					doc.removeEventListener( orig, handler, true );
					dataPriv.remove( doc, fix );

				} else {
					dataPriv.access( doc, fix, attaches );
				}
			}
		};
	} );
}
var location = window.location;

var nonce = jQuery.now();

var rquery = ( /\?/ );



// Cross-browser xml parsing
jQuery.parseXML = function( data ) {
	var xml;
	if ( !data || typeof data !== "string" ) {
		return null;
	}

	// Support: IE 9 - 11 only
	// IE throws on parseFromString with invalid input.
	try {
		xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
	} catch ( e ) {
		xml = undefined;
	}

	if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
		jQuery.error( "Invalid XML: " + data );
	}
	return xml;
};


var
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	rsubmittable = /^(?:input|select|textarea|keygen)/i;

function buildParams( prefix, obj, traditional, add ) {
	var name;

	if ( jQuery.isArray( obj ) ) {

		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {

				// Treat each array item as a scalar.
				add( prefix, v );

			} else {

				// Item is non-scalar (array or object), encode its numeric index.
				buildParams(
					prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
					v,
					traditional,
					add
				);
			}
		} );

	} else if ( !traditional && jQuery.type( obj ) === "object" ) {

		// Serialize object item.
		for ( name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {

		// Serialize scalar item.
		add( prefix, obj );
	}
}

// Serialize an array of form elements or a set of
// key/values into a query string
jQuery.param = function( a, traditional ) {
	var prefix,
		s = [],
		add = function( key, valueOrFunction ) {

			// If value is a function, invoke it and use its return value
			var value = jQuery.isFunction( valueOrFunction ) ?
				valueOrFunction() :
				valueOrFunction;

			s[ s.length ] = encodeURIComponent( key ) + "=" +
				encodeURIComponent( value == null ? "" : value );
		};

	// If an array was passed in, assume that it is an array of form elements.
	if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {

		// Serialize the form elements
		jQuery.each( a, function() {
			add( this.name, this.value );
		} );

	} else {

		// If traditional, encode the "old" way (the way 1.3.2 or older
		// did it), otherwise encode params recursively.
		for ( prefix in a ) {
			buildParams( prefix, a[ prefix ], traditional, add );
		}
	}

	// Return the resulting serialization
	return s.join( "&" );
};

jQuery.fn.extend( {
	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},
	serializeArray: function() {
		return this.map( function() {

			// Can add propHook for "elements" to filter or add form elements
			var elements = jQuery.prop( this, "elements" );
			return elements ? jQuery.makeArray( elements ) : this;
		} )
		.filter( function() {
			var type = this.type;

			// Use .is( ":disabled" ) so that fieldset[disabled] works
			return this.name && !jQuery( this ).is( ":disabled" ) &&
				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
				( this.checked || !rcheckableType.test( type ) );
		} )
		.map( function( i, elem ) {
			var val = jQuery( this ).val();

			return val == null ?
				null :
				jQuery.isArray( val ) ?
					jQuery.map( val, function( val ) {
						return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
					} ) :
					{ name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		} ).get();
	}
} );


var
	r20 = /%20/g,
	rhash = /#.*$/,
	rts = /([?&])_=[^&]*/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,

	// #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	allTypes = "*/".concat( "*" ),

	// Anchor tag for parsing the document origin
	originAnchor = document.createElement( "a" );
	originAnchor.href = location.href;

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		var dataType,
			i = 0,
			dataTypes = dataTypeExpression.toLowerCase().match( rnotwhite ) || [];

		if ( jQuery.isFunction( func ) ) {

			// For each dataType in the dataTypeExpression
			while ( ( dataType = dataTypes[ i++ ] ) ) {

				// Prepend if requested
				if ( dataType[ 0 ] === "+" ) {
					dataType = dataType.slice( 1 ) || "*";
					( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );

				// Otherwise append
				} else {
					( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
				}
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

	var inspected = {},
		seekingTransport = ( structure === transports );

	function inspect( dataType ) {
		var selected;
		inspected[ dataType ] = true;
		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
			if ( typeof dataTypeOrTransport === "string" &&
				!seekingTransport && !inspected[ dataTypeOrTransport ] ) {

				options.dataTypes.unshift( dataTypeOrTransport );
				inspect( dataTypeOrTransport );
				return false;
			} else if ( seekingTransport ) {
				return !( selected = dataTypeOrTransport );
			}
		} );
		return selected;
	}

	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
	var key, deep,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};

	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}

	return target;
}

/* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

	var ct, type, finalDataType, firstDataType,
		contents = s.contents,
		dataTypes = s.dataTypes;

	// Remove auto dataType and get content-type in the process
	while ( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {

		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}

		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

/* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
function ajaxConvert( s, response, jqXHR, isSuccess ) {
	var conv2, current, conv, tmp, prev,
		converters = {},

		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice();

	// Create converters map with lowercased keys
	if ( dataTypes[ 1 ] ) {
		for ( conv in s.converters ) {
			converters[ conv.toLowerCase() ] = s.converters[ conv ];
		}
	}

	current = dataTypes.shift();

	// Convert to each sequential dataType
	while ( current ) {

		if ( s.responseFields[ current ] ) {
			jqXHR[ s.responseFields[ current ] ] = response;
		}

		// Apply the dataFilter if provided
		if ( !prev && isSuccess && s.dataFilter ) {
			response = s.dataFilter( response, s.dataType );
		}

		prev = current;
		current = dataTypes.shift();

		if ( current ) {

			// There's only work to do if current dataType is non-auto
			if ( current === "*" ) {

				current = prev;

			// Convert response if prev dataType is non-auto and differs from current
			} else if ( prev !== "*" && prev !== current ) {

				// Seek a direct converter
				conv = converters[ prev + " " + current ] || converters[ "* " + current ];

				// If none found, seek a pair
				if ( !conv ) {
					for ( conv2 in converters ) {

						// If conv2 outputs current
						tmp = conv2.split( " " );
						if ( tmp[ 1 ] === current ) {

							// If prev can be converted to accepted input
							conv = converters[ prev + " " + tmp[ 0 ] ] ||
								converters[ "* " + tmp[ 0 ] ];
							if ( conv ) {

								// Condense equivalence converters
								if ( conv === true ) {
									conv = converters[ conv2 ];

								// Otherwise, insert the intermediate dataType
								} else if ( converters[ conv2 ] !== true ) {
									current = tmp[ 0 ];
									dataTypes.unshift( tmp[ 1 ] );
								}
								break;
							}
						}
					}
				}

				// Apply converter (if not an equivalence)
				if ( conv !== true ) {

					// Unless errors are allowed to bubble, catch and return them
					if ( conv && s.throws ) {
						response = conv( response );
					} else {
						try {
							response = conv( response );
						} catch ( e ) {
							return {
								state: "parsererror",
								error: conv ? e : "No conversion from " + prev + " to " + current
							};
						}
					}
				}
			}
		}
	}

	return { state: "success", data: response };
}

jQuery.extend( {

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {},

	ajaxSettings: {
		url: location.href,
		type: "GET",
		isLocal: rlocalProtocol.test( location.protocol ),
		global: true,
		processData: true,
		async: true,
		contentType: "application/x-www-form-urlencoded; charset=UTF-8",

		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

		accepts: {
			"*": allTypes,
			text: "text/plain",
			html: "text/html",
			xml: "application/xml, text/xml",
			json: "application/json, text/javascript"
		},

		contents: {
			xml: /\bxml\b/,
			html: /\bhtml/,
			json: /\bjson\b/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText",
			json: "responseJSON"
		},

		// Data converters
		// Keys separate source (or catchall "*") and destination types with a single space
		converters: {

			// Convert anything to text
			"* text": String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": JSON.parse,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			url: true,
			context: true
		}
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		return settings ?

			// Building a settings object
			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

			// Extending ajaxSettings
			ajaxExtend( jQuery.ajaxSettings, target );
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var transport,

			// URL without anti-cache param
			cacheURL,

			// Response headers
			responseHeadersString,
			responseHeaders,

			// timeout handle
			timeoutTimer,

			// Url cleanup var
			urlAnchor,

			// Request state (becomes false upon send and true upon completion)
			completed,

			// To know if global events are to be dispatched
			fireGlobals,

			// Loop variable
			i,

			// uncached part of the url
			uncached,

			// Create the final options object
			s = jQuery.ajaxSetup( {}, options ),

			// Callbacks context
			callbackContext = s.context || s,

			// Context for global events is callbackContext if it is a DOM node or jQuery collection
			globalEventContext = s.context &&
				( callbackContext.nodeType || callbackContext.jquery ) ?
					jQuery( callbackContext ) :
					jQuery.event,

			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks( "once memory" ),

			// Status-dependent callbacks
			statusCode = s.statusCode || {},

			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},

			// Default abort message
			strAbort = "canceled",

			// Fake xhr
			jqXHR = {
				readyState: 0,

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( completed ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
								responseHeaders[ match[ 1 ].toLowerCase() ] = match[ 2 ];
							}
						}
						match = responseHeaders[ key.toLowerCase() ];
					}
					return match == null ? null : match;
				},

				// Raw string
				getAllResponseHeaders: function() {
					return completed ? responseHeadersString : null;
				},

				// Caches the header
				setRequestHeader: function( name, value ) {
					if ( completed == null ) {
						name = requestHeadersNames[ name.toLowerCase() ] =
							requestHeadersNames[ name.toLowerCase() ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( completed == null ) {
						s.mimeType = type;
					}
					return this;
				},

				// Status-dependent callbacks
				statusCode: function( map ) {
					var code;
					if ( map ) {
						if ( completed ) {

							// Execute the appropriate callbacks
							jqXHR.always( map[ jqXHR.status ] );
						} else {

							// Lazy-add the new callbacks in a way that preserves old ones
							for ( code in map ) {
								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
							}
						}
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					var finalText = statusText || strAbort;
					if ( transport ) {
						transport.abort( finalText );
					}
					done( 0, finalText );
					return this;
				}
			};

		// Attach deferreds
		deferred.promise( jqXHR );

		// Add protocol if not provided (prefilters might expect it)
		// Handle falsy url in the settings object (#10093: consistency with old signature)
		// We also use the url parameter if available
		s.url = ( ( url || s.url || location.href ) + "" )
			.replace( rprotocol, location.protocol + "//" );

		// Alias method option to type as per ticket #12004
		s.type = options.method || options.type || s.method || s.type;

		// Extract dataTypes list
		s.dataTypes = ( s.dataType || "*" ).toLowerCase().match( rnotwhite ) || [ "" ];

		// A cross-domain request is in order when the origin doesn't match the current origin.
		if ( s.crossDomain == null ) {
			urlAnchor = document.createElement( "a" );

			// Support: IE <=8 - 11, Edge 12 - 13
			// IE throws exception on accessing the href property if url is malformed,
			// e.g. http://example.com:80x/
			try {
				urlAnchor.href = s.url;

				// Support: IE <=8 - 11 only
				// Anchor's host property isn't correctly set when s.url is relative
				urlAnchor.href = urlAnchor.href;
				s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
					urlAnchor.protocol + "//" + urlAnchor.host;
			} catch ( e ) {

				// If there is an error parsing the URL, assume it is crossDomain,
				// it can be rejected by the transport if it is invalid
				s.crossDomain = true;
			}
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefilter, stop there
		if ( completed ) {
			return jqXHR;
		}

		// We can fire global events as of now if asked to
		// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
		fireGlobals = jQuery.event && s.global;

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger( "ajaxStart" );
		}

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Save the URL in case we're toying with the If-Modified-Since
		// and/or If-None-Match header later on
		// Remove hash to simplify url manipulation
		cacheURL = s.url.replace( rhash, "" );

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// Remember the hash so we can put it back
			uncached = s.url.slice( cacheURL.length );

			// If data is available, append data to url
			if ( s.data ) {
				cacheURL += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data;

				// #9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Add anti-cache in uncached url if needed
			if ( s.cache === false ) {
				cacheURL = cacheURL.replace( rts, "" );
				uncached = ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ( nonce++ ) + uncached;
			}

			// Put hash and anti-cache on the URL that will be requested (gh-1732)
			s.url = cacheURL + uncached;

		// Change '%20' to '+' if this is encoded form body content (gh-2658)
		} else if ( s.data && s.processData &&
			( s.contentType || "" ).indexOf( "application/x-www-form-urlencoded" ) === 0 ) {
			s.data = s.data.replace( r20, "+" );
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			if ( jQuery.lastModified[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
			}
			if ( jQuery.etag[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
				s.accepts[ s.dataTypes[ 0 ] ] +
					( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend &&
			( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {

			// Abort if not done already and return
			return jqXHR.abort();
		}

		// Aborting is no longer a cancellation
		strAbort = "abort";

		// Install callbacks on deferreds
		completeDeferred.add( s.complete );
		jqXHR.done( s.success );
		jqXHR.fail( s.error );

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;

			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}

			// If request was aborted inside ajaxSend, stop there
			if ( completed ) {
				return jqXHR;
			}

			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = window.setTimeout( function() {
					jqXHR.abort( "timeout" );
				}, s.timeout );
			}

			try {
				completed = false;
				transport.send( requestHeaders, done );
			} catch ( e ) {

				// Rethrow post-completion exceptions
				if ( completed ) {
					throw e;
				}

				// Propagate others as results
				done( -1, e );
			}
		}

		// Callback for when everything is done
		function done( status, nativeStatusText, responses, headers ) {
			var isSuccess, success, error, response, modified,
				statusText = nativeStatusText;

			// Ignore repeat invocations
			if ( completed ) {
				return;
			}

			completed = true;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				window.clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			// Determine if successful
			isSuccess = status >= 200 && status < 300 || status === 304;

			// Get response data
			if ( responses ) {
				response = ajaxHandleResponses( s, jqXHR, responses );
			}

			// Convert no matter what (that way responseXXX fields are always set)
			response = ajaxConvert( s, response, jqXHR, isSuccess );

			// If successful, handle type chaining
			if ( isSuccess ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {
					modified = jqXHR.getResponseHeader( "Last-Modified" );
					if ( modified ) {
						jQuery.lastModified[ cacheURL ] = modified;
					}
					modified = jqXHR.getResponseHeader( "etag" );
					if ( modified ) {
						jQuery.etag[ cacheURL ] = modified;
					}
				}

				// if no content
				if ( status === 204 || s.type === "HEAD" ) {
					statusText = "nocontent";

				// if not modified
				} else if ( status === 304 ) {
					statusText = "notmodified";

				// If we have data, let's convert it
				} else {
					statusText = response.state;
					success = response.data;
					error = response.error;
					isSuccess = !error;
				}
			} else {

				// Extract error from statusText and normalize for non-aborts
				error = statusText;
				if ( status || !statusText ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = ( nativeStatusText || statusText ) + "";

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
					[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );

				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger( "ajaxStop" );
				}
			}
		}

		return jqXHR;
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	}
} );

jQuery.each( [ "get", "post" ], function( i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {

		// Shift arguments if data argument was omitted
		if ( jQuery.isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		// The url can be an options object (which then must have .url)
		return jQuery.ajax( jQuery.extend( {
			url: url,
			type: method,
			dataType: type,
			data: data,
			success: callback
		}, jQuery.isPlainObject( url ) && url ) );
	};
} );


jQuery._evalUrl = function( url ) {
	return jQuery.ajax( {
		url: url,

		// Make this explicit, since user can override this through ajaxSetup (#11264)
		type: "GET",
		dataType: "script",
		cache: true,
		async: false,
		global: false,
		"throws": true
	} );
};


jQuery.fn.extend( {
	wrapAll: function( html ) {
		var wrap;

		if ( this[ 0 ] ) {
			if ( jQuery.isFunction( html ) ) {
				html = html.call( this[ 0 ] );
			}

			// The elements to wrap the target around
			wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

			if ( this[ 0 ].parentNode ) {
				wrap.insertBefore( this[ 0 ] );
			}

			wrap.map( function() {
				var elem = this;

				while ( elem.firstElementChild ) {
					elem = elem.firstElementChild;
				}

				return elem;
			} ).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( jQuery.isFunction( html ) ) {
			return this.each( function( i ) {
				jQuery( this ).wrapInner( html.call( this, i ) );
			} );
		}

		return this.each( function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		} );
	},

	wrap: function( html ) {
		var isFunction = jQuery.isFunction( html );

		return this.each( function( i ) {
			jQuery( this ).wrapAll( isFunction ? html.call( this, i ) : html );
		} );
	},

	unwrap: function( selector ) {
		this.parent( selector ).not( "body" ).each( function() {
			jQuery( this ).replaceWith( this.childNodes );
		} );
		return this;
	}
} );


jQuery.expr.pseudos.hidden = function( elem ) {
	return !jQuery.expr.pseudos.visible( elem );
};
jQuery.expr.pseudos.visible = function( elem ) {
	return !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );
};




jQuery.ajaxSettings.xhr = function() {
	try {
		return new window.XMLHttpRequest();
	} catch ( e ) {}
};

var xhrSuccessStatus = {

		// File protocol always yields status code 0, assume 200
		0: 200,

		// Support: IE <=9 only
		// #1450: sometimes IE returns 1223 when it should be 204
		1223: 204
	},
	xhrSupported = jQuery.ajaxSettings.xhr();

support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
support.ajax = xhrSupported = !!xhrSupported;

jQuery.ajaxTransport( function( options ) {
	var callback, errorCallback;

	// Cross domain only allowed if supported through XMLHttpRequest
	if ( support.cors || xhrSupported && !options.crossDomain ) {
		return {
			send: function( headers, complete ) {
				var i,
					xhr = options.xhr();

				xhr.open(
					options.type,
					options.url,
					options.async,
					options.username,
					options.password
				);

				// Apply custom fields if provided
				if ( options.xhrFields ) {
					for ( i in options.xhrFields ) {
						xhr[ i ] = options.xhrFields[ i ];
					}
				}

				// Override mime type if needed
				if ( options.mimeType && xhr.overrideMimeType ) {
					xhr.overrideMimeType( options.mimeType );
				}

				// X-Requested-With header
				// For cross-domain requests, seeing as conditions for a preflight are
				// akin to a jigsaw puzzle, we simply never set it to be sure.
				// (it can always be set on a per-request basis or even using ajaxSetup)
				// For same-domain requests, won't change header if already provided.
				if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
					headers[ "X-Requested-With" ] = "XMLHttpRequest";
				}

				// Set headers
				for ( i in headers ) {
					xhr.setRequestHeader( i, headers[ i ] );
				}

				// Callback
				callback = function( type ) {
					return function() {
						if ( callback ) {
							callback = errorCallback = xhr.onload =
								xhr.onerror = xhr.onabort = xhr.onreadystatechange = null;

							if ( type === "abort" ) {
								xhr.abort();
							} else if ( type === "error" ) {

								// Support: IE <=9 only
								// On a manual native abort, IE9 throws
								// errors on any property access that is not readyState
								if ( typeof xhr.status !== "number" ) {
									complete( 0, "error" );
								} else {
									complete(

										// File: protocol always yields status 0; see #8605, #14207
										xhr.status,
										xhr.statusText
									);
								}
							} else {
								complete(
									xhrSuccessStatus[ xhr.status ] || xhr.status,
									xhr.statusText,

									// Support: IE <=9 only
									// IE9 has no XHR2 but throws on binary (trac-11426)
									// For XHR2 non-text, let the caller handle it (gh-2498)
									( xhr.responseType || "text" ) !== "text"  ||
									typeof xhr.responseText !== "string" ?
										{ binary: xhr.response } :
										{ text: xhr.responseText },
									xhr.getAllResponseHeaders()
								);
							}
						}
					};
				};

				// Listen to events
				xhr.onload = callback();
				errorCallback = xhr.onerror = callback( "error" );

				// Support: IE 9 only
				// Use onreadystatechange to replace onabort
				// to handle uncaught aborts
				if ( xhr.onabort !== undefined ) {
					xhr.onabort = errorCallback;
				} else {
					xhr.onreadystatechange = function() {

						// Check readyState before timeout as it changes
						if ( xhr.readyState === 4 ) {

							// Allow onerror to be called first,
							// but that will not handle a native abort
							// Also, save errorCallback to a variable
							// as xhr.onerror cannot be accessed
							window.setTimeout( function() {
								if ( callback ) {
									errorCallback();
								}
							} );
						}
					};
				}

				// Create the abort callback
				callback = callback( "abort" );

				try {

					// Do send the request (this may raise an exception)
					xhr.send( options.hasContent && options.data || null );
				} catch ( e ) {

					// #14683: Only rethrow if this hasn't been notified as an error yet
					if ( callback ) {
						throw e;
					}
				}
			},

			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
jQuery.ajaxPrefilter( function( s ) {
	if ( s.crossDomain ) {
		s.contents.script = false;
	}
} );

// Install script dataType
jQuery.ajaxSetup( {
	accepts: {
		script: "text/javascript, application/javascript, " +
			"application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /\b(?:java|ecma)script\b/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
} );

// Handle cache's special case and crossDomain
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
	}
} );

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function( s ) {

	// This transport only deals with cross domain requests
	if ( s.crossDomain ) {
		var script, callback;
		return {
			send: function( _, complete ) {
				script = jQuery( "<script>" ).prop( {
					charset: s.scriptCharset,
					src: s.url
				} ).on(
					"load error",
					callback = function( evt ) {
						script.remove();
						callback = null;
						if ( evt ) {
							complete( evt.type === "error" ? 404 : 200, evt.type );
						}
					}
				);

				// Use native DOM manipulation to avoid our domManip AJAX trickery
				document.head.appendChild( script[ 0 ] );
			},
			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




var oldCallbacks = [],
	rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
jQuery.ajaxSetup( {
	jsonp: "callback",
	jsonpCallback: function() {
		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
		this[ callback ] = true;
		return callback;
	}
} );

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var callbackName, overwritten, responseContainer,
		jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
			"url" :
			typeof s.data === "string" &&
				( s.contentType || "" )
					.indexOf( "application/x-www-form-urlencoded" ) === 0 &&
				rjsonp.test( s.data ) && "data"
		);

	// Handle iff the expected data type is "jsonp" or we have a parameter to set
	if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

		// Get callback name, remembering preexisting value associated with it
		callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?
			s.jsonpCallback() :
			s.jsonpCallback;

		// Insert callback into url or form data
		if ( jsonProp ) {
			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
		} else if ( s.jsonp !== false ) {
			s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
		}

		// Use data converter to retrieve json after script execution
		s.converters[ "script json" ] = function() {
			if ( !responseContainer ) {
				jQuery.error( callbackName + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// Force json dataType
		s.dataTypes[ 0 ] = "json";

		// Install callback
		overwritten = window[ callbackName ];
		window[ callbackName ] = function() {
			responseContainer = arguments;
		};

		// Clean-up function (fires after converters)
		jqXHR.always( function() {

			// If previous value didn't exist - remove it
			if ( overwritten === undefined ) {
				jQuery( window ).removeProp( callbackName );

			// Otherwise restore preexisting value
			} else {
				window[ callbackName ] = overwritten;
			}

			// Save back as free
			if ( s[ callbackName ] ) {

				// Make sure that re-using the options doesn't screw things around
				s.jsonpCallback = originalSettings.jsonpCallback;

				// Save the callback name for future use
				oldCallbacks.push( callbackName );
			}

			// Call if it was a function and we have a response
			if ( responseContainer && jQuery.isFunction( overwritten ) ) {
				overwritten( responseContainer[ 0 ] );
			}

			responseContainer = overwritten = undefined;
		} );

		// Delegate to script
		return "script";
	}
} );




// Support: Safari 8 only
// In Safari 8 documents created via document.implementation.createHTMLDocument
// collapse sibling forms: the second one becomes a child of the first one.
// Because of that, this security measure has to be disabled in Safari 8.
// https://bugs.webkit.org/show_bug.cgi?id=137337
support.createHTMLDocument = ( function() {
	var body = document.implementation.createHTMLDocument( "" ).body;
	body.innerHTML = "<form></form><form></form>";
	return body.childNodes.length === 2;
} )();


// Argument "data" should be string of html
// context (optional): If specified, the fragment will be created in this context,
// defaults to document
// keepScripts (optional): If true, will include scripts passed in the html string
jQuery.parseHTML = function( data, context, keepScripts ) {
	if ( typeof data !== "string" ) {
		return [];
	}
	if ( typeof context === "boolean" ) {
		keepScripts = context;
		context = false;
	}

	var base, parsed, scripts;

	if ( !context ) {

		// Stop scripts or inline event handlers from being executed immediately
		// by using document.implementation
		if ( support.createHTMLDocument ) {
			context = document.implementation.createHTMLDocument( "" );

			// Set the base href for the created document
			// so any parsed elements with URLs
			// are based on the document's URL (gh-2965)
			base = context.createElement( "base" );
			base.href = document.location.href;
			context.head.appendChild( base );
		} else {
			context = document;
		}
	}

	parsed = rsingleTag.exec( data );
	scripts = !keepScripts && [];

	// Single tag
	if ( parsed ) {
		return [ context.createElement( parsed[ 1 ] ) ];
	}

	parsed = buildFragment( [ data ], context, scripts );

	if ( scripts && scripts.length ) {
		jQuery( scripts ).remove();
	}

	return jQuery.merge( [], parsed.childNodes );
};


/**
 * Load a url into a page
 */
jQuery.fn.load = function( url, params, callback ) {
	var selector, type, response,
		self = this,
		off = url.indexOf( " " );

	if ( off > -1 ) {
		selector = jQuery.trim( url.slice( off ) );
		url = url.slice( 0, off );
	}

	// If it's a function
	if ( jQuery.isFunction( params ) ) {

		// We assume that it's the callback
		callback = params;
		params = undefined;

	// Otherwise, build a param string
	} else if ( params && typeof params === "object" ) {
		type = "POST";
	}

	// If we have elements to modify, make the request
	if ( self.length > 0 ) {
		jQuery.ajax( {
			url: url,

			// If "type" variable is undefined, then "GET" method will be used.
			// Make value of this field explicit since
			// user can override it through ajaxSetup method
			type: type || "GET",
			dataType: "html",
			data: params
		} ).done( function( responseText ) {

			// Save response for use in complete callback
			response = arguments;

			self.html( selector ?

				// If a selector was specified, locate the right elements in a dummy div
				// Exclude scripts to avoid IE 'Permission Denied' errors
				jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :

				// Otherwise use the full result
				responseText );

		// If the request succeeds, this function gets "data", "status", "jqXHR"
		// but they are ignored because response was set above.
		// If it fails, this function gets "jqXHR", "status", "error"
		} ).always( callback && function( jqXHR, status ) {
			self.each( function() {
				callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
			} );
		} );
	}

	return this;
};




// Attach a bunch of functions for handling common AJAX events
jQuery.each( [
	"ajaxStart",
	"ajaxStop",
	"ajaxComplete",
	"ajaxError",
	"ajaxSuccess",
	"ajaxSend"
], function( i, type ) {
	jQuery.fn[ type ] = function( fn ) {
		return this.on( type, fn );
	};
} );




jQuery.expr.pseudos.animated = function( elem ) {
	return jQuery.grep( jQuery.timers, function( fn ) {
		return elem === fn.elem;
	} ).length;
};




/**
 * Gets a window from an element
 */
function getWindow( elem ) {
	return jQuery.isWindow( elem ) ? elem : elem.nodeType === 9 && elem.defaultView;
}

jQuery.offset = {
	setOffset: function( elem, options, i ) {
		var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
			position = jQuery.css( elem, "position" ),
			curElem = jQuery( elem ),
			props = {};

		// Set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		curOffset = curElem.offset();
		curCSSTop = jQuery.css( elem, "top" );
		curCSSLeft = jQuery.css( elem, "left" );
		calculatePosition = ( position === "absolute" || position === "fixed" ) &&
			( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;

		// Need to be able to calculate position if either
		// top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;

		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( jQuery.isFunction( options ) ) {

			// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
			options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );

		} else {
			curElem.css( props );
		}
	}
};

jQuery.fn.extend( {
	offset: function( options ) {

		// Preserve chaining for setter
		if ( arguments.length ) {
			return options === undefined ?
				this :
				this.each( function( i ) {
					jQuery.offset.setOffset( this, options, i );
				} );
		}

		var docElem, win, rect, doc,
			elem = this[ 0 ];

		if ( !elem ) {
			return;
		}

		// Support: IE <=11 only
		// Running getBoundingClientRect on a
		// disconnected node in IE throws an error
		if ( !elem.getClientRects().length ) {
			return { top: 0, left: 0 };
		}

		rect = elem.getBoundingClientRect();

		// Make sure element is not hidden (display: none)
		if ( rect.width || rect.height ) {
			doc = elem.ownerDocument;
			win = getWindow( doc );
			docElem = doc.documentElement;

			return {
				top: rect.top + win.pageYOffset - docElem.clientTop,
				left: rect.left + win.pageXOffset - docElem.clientLeft
			};
		}

		// Return zeros for disconnected and hidden elements (gh-2310)
		return rect;
	},

	position: function() {
		if ( !this[ 0 ] ) {
			return;
		}

		var offsetParent, offset,
			elem = this[ 0 ],
			parentOffset = { top: 0, left: 0 };

		// Fixed elements are offset from window (parentOffset = {top:0, left: 0},
		// because it is its only offset parent
		if ( jQuery.css( elem, "position" ) === "fixed" ) {

			// Assume getBoundingClientRect is there when computed position is fixed
			offset = elem.getBoundingClientRect();

		} else {

			// Get *real* offsetParent
			offsetParent = this.offsetParent();

			// Get correct offsets
			offset = this.offset();
			if ( !jQuery.nodeName( offsetParent[ 0 ], "html" ) ) {
				parentOffset = offsetParent.offset();
			}

			// Add offsetParent borders
			parentOffset = {
				top: parentOffset.top + jQuery.css( offsetParent[ 0 ], "borderTopWidth", true ),
				left: parentOffset.left + jQuery.css( offsetParent[ 0 ], "borderLeftWidth", true )
			};
		}

		// Subtract parent offsets and element margins
		return {
			top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
			left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
		};
	},

	// This method will return documentElement in the following cases:
	// 1) For the element inside the iframe without offsetParent, this method will return
	//    documentElement of the parent window
	// 2) For the hidden or detached element
	// 3) For body or html element, i.e. in case of the html node - it will return itself
	//
	// but those exceptions were never presented as a real life use-cases
	// and might be considered as more preferable results.
	//
	// This logic, however, is not guaranteed and can change at any point in the future
	offsetParent: function() {
		return this.map( function() {
			var offsetParent = this.offsetParent;

			while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
				offsetParent = offsetParent.offsetParent;
			}

			return offsetParent || documentElement;
		} );
	}
} );

// Create scrollLeft and scrollTop methods
jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
	var top = "pageYOffset" === prop;

	jQuery.fn[ method ] = function( val ) {
		return access( this, function( elem, method, val ) {
			var win = getWindow( elem );

			if ( val === undefined ) {
				return win ? win[ prop ] : elem[ method ];
			}

			if ( win ) {
				win.scrollTo(
					!top ? val : win.pageXOffset,
					top ? val : win.pageYOffset
				);

			} else {
				elem[ method ] = val;
			}
		}, method, val, arguments.length );
	};
} );

// Support: Safari <=7 - 9.1, Chrome <=37 - 49
// Add the top/left cssHooks using jQuery.fn.position
// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
// getComputedStyle returns percent when specified for top/left/bottom/right;
// rather than make the css module depend on the offset module, just check for it here
jQuery.each( [ "top", "left" ], function( i, prop ) {
	jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
		function( elem, computed ) {
			if ( computed ) {
				computed = curCSS( elem, prop );

				// If curCSS returns percentage, fallback to offset
				return rnumnonpx.test( computed ) ?
					jQuery( elem ).position()[ prop ] + "px" :
					computed;
			}
		}
	);
} );


// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
	jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name },
		function( defaultExtra, funcName ) {

		// Margin is only for outerHeight, outerWidth
		jQuery.fn[ funcName ] = function( margin, value ) {
			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

			return access( this, function( elem, type, value ) {
				var doc;

				if ( jQuery.isWindow( elem ) ) {

					// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
					return funcName.indexOf( "outer" ) === 0 ?
						elem[ "inner" + name ] :
						elem.document.documentElement[ "client" + name ];
				}

				// Get document width or height
				if ( elem.nodeType === 9 ) {
					doc = elem.documentElement;

					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
					// whichever is greatest
					return Math.max(
						elem.body[ "scroll" + name ], doc[ "scroll" + name ],
						elem.body[ "offset" + name ], doc[ "offset" + name ],
						doc[ "client" + name ]
					);
				}

				return value === undefined ?

					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css( elem, type, extra ) :

					// Set width or height on the element
					jQuery.style( elem, type, value, extra );
			}, type, chainable ? margin : undefined, chainable );
		};
	} );
} );


jQuery.fn.extend( {

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {

		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length === 1 ?
			this.off( selector, "**" ) :
			this.off( types, selector || "**", fn );
	}
} );

jQuery.parseJSON = JSON.parse;




// Register as a named AMD module, since jQuery can be concatenated with other
// files that may use define, but not via a proper concatenation script that
// understands anonymous AMD modules. A named AMD is safest and most robust
// way to register. Lowercase jquery is used because AMD module names are
// derived from file names, and jQuery is normally delivered in a lowercase
// file name. Do this after creating the global so that if an AMD module wants
// to call noConflict to hide this version of jQuery, it will work.

// Note that for maximum portability, libraries that are not jQuery should
// declare themselves as anonymous modules, and avoid setting a global if an
// AMD loader is present. jQuery is a special case. For more information, see
// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

if ( typeof define === "function" && define.amd ) {
	define( "jquery", [], function() {
		return jQuery;
	} );
}





var

	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$;

jQuery.noConflict = function( deep ) {
	if ( window.$ === jQuery ) {
		window.$ = _$;
	}

	if ( deep && window.jQuery === jQuery ) {
		window.jQuery = _jQuery;
	}

	return jQuery;
};

// Expose jQuery and $ identifiers, even in AMD
// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
// and CommonJS for browser emulators (#13566)
if ( !noGlobal ) {
	window.jQuery = window.$ = jQuery;
}


return jQuery;
} );
/*! jQuery UI - v1.12.0 - 2016-07-08
* http://jqueryui.com
* Includes: widget.js, position.js, data.js, disable-selection.js, effect.js, effects/effect-blind.js, effects/effect-bounce.js, effects/effect-clip.js, effects/effect-drop.js, effects/effect-explode.js, effects/effect-fade.js, effects/effect-fold.js, effects/effect-highlight.js, effects/effect-puff.js, effects/effect-pulsate.js, effects/effect-scale.js, effects/effect-shake.js, effects/effect-size.js, effects/effect-slide.js, effects/effect-transfer.js, focusable.js, form-reset-mixin.js, jquery-1-7.js, keycode.js, labels.js, scroll-parent.js, tabbable.js, unique-id.js, widgets/accordion.js, widgets/autocomplete.js, widgets/button.js, widgets/checkboxradio.js, widgets/controlgroup.js, widgets/datepicker.js, widgets/dialog.js, widgets/draggable.js, widgets/droppable.js, widgets/menu.js, widgets/mouse.js, widgets/progressbar.js, widgets/resizable.js, widgets/selectable.js, widgets/selectmenu.js, widgets/slider.js, widgets/sortable.js, widgets/spinner.js, widgets/tabs.js, widgets/tooltip.js
* Copyright jQuery Foundation and other contributors; Licensed MIT */

(function( factory ) {
	if ( typeof define === "function" && define.amd ) {

		// AMD. Register as an anonymous module.
		define([ "jquery" ], factory );
	} else {

		// Browser globals
		factory( jQuery );
	}
}(function( $ ) {

$.ui = $.ui || {};

var version = $.ui.version = "1.12.0";


/*!
 * jQuery UI Widget 1.12.0
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Widget
//>>group: Core
//>>description: Provides a factory for creating stateful widgets with a common API.
//>>docs: http://api.jqueryui.com/jQuery.widget/
//>>demos: http://jqueryui.com/widget/



var widgetUuid = 0;
var widgetSlice = Array.prototype.slice;

$.cleanData = ( function( orig ) {
	return function( elems ) {
		var events, elem, i;
		for ( i = 0; ( elem = elems[ i ] ) != null; i++ ) {
			try {

				// Only trigger remove when necessary to save time
				events = $._data( elem, "events" );
				if ( events && events.remove ) {
					$( elem ).triggerHandler( "remove" );
				}

			// Http://bugs.jquery.com/ticket/8235
			} catch ( e ) {}
		}
		orig( elems );
	};
} )( $.cleanData );

$.widget = function( name, base, prototype ) {
	var existingConstructor, constructor, basePrototype;

	// ProxiedPrototype allows the provided prototype to remain unmodified
	// so that it can be used as a mixin for multiple widgets (#8876)
	var proxiedPrototype = {};

	var namespace = name.split( "." )[ 0 ];
	name = name.split( "." )[ 1 ];
	var fullName = namespace + "-" + name;

	if ( !prototype ) {
		prototype = base;
		base = $.Widget;
	}

	if ( $.isArray( prototype ) ) {
		prototype = $.extend.apply( null, [ {} ].concat( prototype ) );
	}

	// Create selector for plugin
	$.expr[ ":" ][ fullName.toLowerCase() ] = function( elem ) {
		return !!$.data( elem, fullName );
	};

	$[ namespace ] = $[ namespace ] || {};
	existingConstructor = $[ namespace ][ name ];
	constructor = $[ namespace ][ name ] = function( options, element ) {

		// Allow instantiation without "new" keyword
		if ( !this._createWidget ) {
			return new constructor( options, element );
		}

		// Allow instantiation without initializing for simple inheritance
		// must use "new" keyword (the code above always passes args)
		if ( arguments.length ) {
			this._createWidget( options, element );
		}
	};

	// Extend with the existing constructor to carry over any static properties
	$.extend( constructor, existingConstructor, {
		version: prototype.version,

		// Copy the object used to create the prototype in case we need to
		// redefine the widget later
		_proto: $.extend( {}, prototype ),

		// Track widgets that inherit from this widget in case this widget is
		// redefined after a widget inherits from it
		_childConstructors: []
	} );

	basePrototype = new base();

	// We need to make the options hash a property directly on the new instance
	// otherwise we'll modify the options hash on the prototype that we're
	// inheriting from
	basePrototype.options = $.widget.extend( {}, basePrototype.options );
	$.each( prototype, function( prop, value ) {
		if ( !$.isFunction( value ) ) {
			proxiedPrototype[ prop ] = value;
			return;
		}
		proxiedPrototype[ prop ] = ( function() {
			function _super() {
				return base.prototype[ prop ].apply( this, arguments );
			}

			function _superApply( args ) {
				return base.prototype[ prop ].apply( this, args );
			}

			return function() {
				var __super = this._super;
				var __superApply = this._superApply;
				var returnValue;

				this._super = _super;
				this._superApply = _superApply;

				returnValue = value.apply( this, arguments );

				this._super = __super;
				this._superApply = __superApply;

				return returnValue;
			};
		} )();
	} );
	constructor.prototype = $.widget.extend( basePrototype, {

		// TODO: remove support for widgetEventPrefix
		// always use the name + a colon as the prefix, e.g., draggable:start
		// don't prefix for widgets that aren't DOM-based
		widgetEventPrefix: existingConstructor ? ( basePrototype.widgetEventPrefix || name ) : name
	}, proxiedPrototype, {
		constructor: constructor,
		namespace: namespace,
		widgetName: name,
		widgetFullName: fullName
	} );

	// If this widget is being redefined then we need to find all widgets that
	// are inheriting from it and redefine all of them so that they inherit from
	// the new version of this widget. We're essentially trying to replace one
	// level in the prototype chain.
	if ( existingConstructor ) {
		$.each( existingConstructor._childConstructors, function( i, child ) {
			var childPrototype = child.prototype;

			// Redefine the child widget using the same prototype that was
			// originally used, but inherit from the new version of the base
			$.widget( childPrototype.namespace + "." + childPrototype.widgetName, constructor,
				child._proto );
		} );

		// Remove the list of existing child constructors from the old constructor
		// so the old child constructors can be garbage collected
		delete existingConstructor._childConstructors;
	} else {
		base._childConstructors.push( constructor );
	}

	$.widget.bridge( name, constructor );

	return constructor;
};

$.widget.extend = function( target ) {
	var input = widgetSlice.call( arguments, 1 );
	var inputIndex = 0;
	var inputLength = input.length;
	var key;
	var value;

	for ( ; inputIndex < inputLength; inputIndex++ ) {
		for ( key in input[ inputIndex ] ) {
			value = input[ inputIndex ][ key ];
			if ( input[ inputIndex ].hasOwnProperty( key ) && value !== undefined ) {

				// Clone objects
				if ( $.isPlainObject( value ) ) {
					target[ key ] = $.isPlainObject( target[ key ] ) ?
						$.widget.extend( {}, target[ key ], value ) :

						// Don't extend strings, arrays, etc. with objects
						$.widget.extend( {}, value );

				// Copy everything else by reference
				} else {
					target[ key ] = value;
				}
			}
		}
	}
	return target;
};

$.widget.bridge = function( name, object ) {
	var fullName = object.prototype.widgetFullName || name;
	$.fn[ name ] = function( options ) {
		var isMethodCall = typeof options === "string";
		var args = widgetSlice.call( arguments, 1 );
		var returnValue = this;

		if ( isMethodCall ) {
			this.each( function() {
				var methodValue;
				var instance = $.data( this, fullName );

				if ( options === "instance" ) {
					returnValue = instance;
					return false;
				}

				if ( !instance ) {
					return $.error( "cannot call methods on " + name +
						" prior to initialization; " +
						"attempted to call method '" + options + "'" );
				}

				if ( !$.isFunction( instance[ options ] ) || options.charAt( 0 ) === "_" ) {
					return $.error( "no such method '" + options + "' for " + name +
						" widget instance" );
				}

				methodValue = instance[ options ].apply( instance, args );

				if ( methodValue !== instance && methodValue !== undefined ) {
					returnValue = methodValue && methodValue.jquery ?
						returnValue.pushStack( methodValue.get() ) :
						methodValue;
					return false;
				}
			} );
		} else {

			// Allow multiple hashes to be passed on init
			if ( args.length ) {
				options = $.widget.extend.apply( null, [ options ].concat( args ) );
			}

			this.each( function() {
				var instance = $.data( this, fullName );
				if ( instance ) {
					instance.option( options || {} );
					if ( instance._init ) {
						instance._init();
					}
				} else {
					$.data( this, fullName, new object( options, this ) );
				}
			} );
		}

		return returnValue;
	};
};

$.Widget = function( /* options, element */ ) {};
$.Widget._childConstructors = [];

$.Widget.prototype = {
	widgetName: "widget",
	widgetEventPrefix: "",
	defaultElement: "<div>",

	options: {
		classes: {},
		disabled: false,

		// Callbacks
		create: null
	},

	_createWidget: function( options, element ) {
		element = $( element || this.defaultElement || this )[ 0 ];
		this.element = $( element );
		this.uuid = widgetUuid++;
		this.eventNamespace = "." + this.widgetName + this.uuid;

		this.bindings = $();
		this.hoverable = $();
		this.focusable = $();
		this.classesElementLookup = {};

		if ( element !== this ) {
			$.data( element, this.widgetFullName, this );
			this._on( true, this.element, {
				remove: function( event ) {
					if ( event.target === element ) {
						this.destroy();
					}
				}
			} );
			this.document = $( element.style ?

				// Element within the document
				element.ownerDocument :

				// Element is window or document
				element.document || element );
			this.window = $( this.document[ 0 ].defaultView || this.document[ 0 ].parentWindow );
		}

		this.options = $.widget.extend( {},
			this.options,
			this._getCreateOptions(),
			options );

		this._create();

		if ( this.options.disabled ) {
			this._setOptionDisabled( this.options.disabled );
		}

		this._trigger( "create", null, this._getCreateEventData() );
		this._init();
	},

	_getCreateOptions: function() {
		return {};
	},

	_getCreateEventData: $.noop,

	_create: $.noop,

	_init: $.noop,

	destroy: function() {
		var that = this;

		this._destroy();
		$.each( this.classesElementLookup, function( key, value ) {
			that._removeClass( value, key );
		} );

		// We can probably remove the unbind calls in 2.0
		// all event bindings should go through this._on()
		this.element
			.off( this.eventNamespace )
			.removeData( this.widgetFullName );
		this.widget()
			.off( this.eventNamespace )
			.removeAttr( "aria-disabled" );

		// Clean up events and states
		this.bindings.off( this.eventNamespace );
	},

	_destroy: $.noop,

	widget: function() {
		return this.element;
	},

	option: function( key, value ) {
		var options = key;
		var parts;
		var curOption;
		var i;

		if ( arguments.length === 0 ) {

			// Don't return a reference to the internal hash
			return $.widget.extend( {}, this.options );
		}

		if ( typeof key === "string" ) {

			// Handle nested keys, e.g., "foo.bar" => { foo: { bar: ___ } }
			options = {};
			parts = key.split( "." );
			key = parts.shift();
			if ( parts.length ) {
				curOption = options[ key ] = $.widget.extend( {}, this.options[ key ] );
				for ( i = 0; i < parts.length - 1; i++ ) {
					curOption[ parts[ i ] ] = curOption[ parts[ i ] ] || {};
					curOption = curOption[ parts[ i ] ];
				}
				key = parts.pop();
				if ( arguments.length === 1 ) {
					return curOption[ key ] === undefined ? null : curOption[ key ];
				}
				curOption[ key ] = value;
			} else {
				if ( arguments.length === 1 ) {
					return this.options[ key ] === undefined ? null : this.options[ key ];
				}
				options[ key ] = value;
			}
		}

		this._setOptions( options );

		return this;
	},

	_setOptions: function( options ) {
		var key;

		for ( key in options ) {
			this._setOption( key, options[ key ] );
		}

		return this;
	},

	_setOption: function( key, value ) {
		if ( key === "classes" ) {
			this._setOptionClasses( value );
		}

		this.options[ key ] = value;

		if ( key === "disabled" ) {
			this._setOptionDisabled( value );
		}

		return this;
	},

	_setOptionClasses: function( value ) {
		var classKey, elements, currentElements;

		for ( classKey in value ) {
			currentElements = this.classesElementLookup[ classKey ];
			if ( value[ classKey ] === this.options.classes[ classKey ] ||
					!currentElements ||
					!currentElements.length ) {
				continue;
			}

			// We are doing this to create a new jQuery object because the _removeClass() call
			// on the next line is going to destroy the reference to the current elements being
			// tracked. We need to save a copy of this collection so that we can add the new classes
			// below.
			elements = $( currentElements.get() );
			this._removeClass( currentElements, classKey );

			// We don't use _addClass() here, because that uses this.options.classes
			// for generating the string of classes. We want to use the value passed in from
			// _setOption(), this is the new value of the classes option which was passed to
			// _setOption(). We pass this value directly to _classes().
			elements.addClass( this._classes( {
				element: elements,
				keys: classKey,
				classes: value,
				add: true
			} ) );
		}
	},

	_setOptionDisabled: function( value ) {
		this._toggleClass( this.widget(), this.widgetFullName + "-disabled", null, !!value );

		// If the widget is becoming disabled, then nothing is interactive
		if ( value ) {
			this._removeClass( this.hoverable, null, "ui-state-hover" );
			this._removeClass( this.focusable, null, "ui-state-focus" );
		}
	},

	enable: function() {
		return this._setOptions( { disabled: false } );
	},

	disable: function() {
		return this._setOptions( { disabled: true } );
	},

	_classes: function( options ) {
		var full = [];
		var that = this;

		options = $.extend( {
			element: this.element,
			classes: this.options.classes || {}
		}, options );

		function processClassString( classes, checkOption ) {
			var current, i;
			for ( i = 0; i < classes.length; i++ ) {
				current = that.classesElementLookup[ classes[ i ] ] || $();
				if ( options.add ) {
					current = $( $.unique( current.get().concat( options.element.get() ) ) );
				} else {
					current = $( current.not( options.element ).get() );
				}
				that.classesElementLookup[ classes[ i ] ] = current;
				full.push( classes[ i ] );
				if ( checkOption && options.classes[ classes[ i ] ] ) {
					full.push( options.classes[ classes[ i ] ] );
				}
			}
		}

		if ( options.keys ) {
			processClassString( options.keys.match( /\S+/g ) || [], true );
		}
		if ( options.extra ) {
			processClassString( options.extra.match( /\S+/g ) || [] );
		}

		return full.join( " " );
	},

	_removeClass: function( element, keys, extra ) {
		return this._toggleClass( element, keys, extra, false );
	},

	_addClass: function( element, keys, extra ) {
		return this._toggleClass( element, keys, extra, true );
	},

	_toggleClass: function( element, keys, extra, add ) {
		add = ( typeof add === "boolean" ) ? add : extra;
		var shift = ( typeof element === "string" || element === null ),
			options = {
				extra: shift ? keys : extra,
				keys: shift ? element : keys,
				element: shift ? this.element : element,
				add: add
			};
		options.element.toggleClass( this._classes( options ), add );
		return this;
	},

	_on: function( suppressDisabledCheck, element, handlers ) {
		var delegateElement;
		var instance = this;

		// No suppressDisabledCheck flag, shuffle arguments
		if ( typeof suppressDisabledCheck !== "boolean" ) {
			handlers = element;
			element = suppressDisabledCheck;
			suppressDisabledCheck = false;
		}

		// No element argument, shuffle and use this.element
		if ( !handlers ) {
			handlers = element;
			element = this.element;
			delegateElement = this.widget();
		} else {
			element = delegateElement = $( element );
			this.bindings = this.bindings.add( element );
		}

		$.each( handlers, function( event, handler ) {
			function handlerProxy() {

				// Allow widgets to customize the disabled handling
				// - disabled as an array instead of boolean
				// - disabled class as method for disabling individual parts
				if ( !suppressDisabledCheck &&
						( instance.options.disabled === true ||
						$( this ).hasClass( "ui-state-disabled" ) ) ) {
					return;
				}
				return ( typeof handler === "string" ? instance[ handler ] : handler )
					.apply( instance, arguments );
			}

			// Copy the guid so direct unbinding works
			if ( typeof handler !== "string" ) {
				handlerProxy.guid = handler.guid =
					handler.guid || handlerProxy.guid || $.guid++;
			}

			var match = event.match( /^([\w:-]*)\s*(.*)$/ );
			var eventName = match[ 1 ] + instance.eventNamespace;
			var selector = match[ 2 ];

			if ( selector ) {
				delegateElement.on( eventName, selector, handlerProxy );
			} else {
				element.on( eventName, handlerProxy );
			}
		} );
	},

	_off: function( element, eventName ) {
		eventName = ( eventName || "" ).split( " " ).join( this.eventNamespace + " " ) +
			this.eventNamespace;
		element.off( eventName ).off( eventName );

		// Clear the stack to avoid memory leaks (#10056)
		this.bindings = $( this.bindings.not( element ).get() );
		this.focusable = $( this.focusable.not( element ).get() );
		this.hoverable = $( this.hoverable.not( element ).get() );
	},

	_delay: function( handler, delay ) {
		function handlerProxy() {
			return ( typeof handler === "string" ? instance[ handler ] : handler )
				.apply( instance, arguments );
		}
		var instance = this;
		return setTimeout( handlerProxy, delay || 0 );
	},

	_hoverable: function( element ) {
		this.hoverable = this.hoverable.add( element );
		this._on( element, {
			mouseenter: function( event ) {
				this._addClass( $( event.currentTarget ), null, "ui-state-hover" );
			},
			mouseleave: function( event ) {
				this._removeClass( $( event.currentTarget ), null, "ui-state-hover" );
			}
		} );
	},

	_focusable: function( element ) {
		this.focusable = this.focusable.add( element );
		this._on( element, {
			focusin: function( event ) {
				this._addClass( $( event.currentTarget ), null, "ui-state-focus" );
			},
			focusout: function( event ) {
				this._removeClass( $( event.currentTarget ), null, "ui-state-focus" );
			}
		} );
	},

	_trigger: function( type, event, data ) {
		var prop, orig;
		var callback = this.options[ type ];

		data = data || {};
		event = $.Event( event );
		event.type = ( type === this.widgetEventPrefix ?
			type :
			this.widgetEventPrefix + type ).toLowerCase();

		// The original event may come from any element
		// so we need to reset the target on the new event
		event.target = this.element[ 0 ];

		// Copy original event properties over to the new event
		orig = event.originalEvent;
		if ( orig ) {
			for ( prop in orig ) {
				if ( !( prop in event ) ) {
					event[ prop ] = orig[ prop ];
				}
			}
		}

		this.element.trigger( event, data );
		return !( $.isFunction( callback ) &&
			callback.apply( this.element[ 0 ], [ event ].concat( data ) ) === false ||
			event.isDefaultPrevented() );
	}
};

$.each( { show: "fadeIn", hide: "fadeOut" }, function( method, defaultEffect ) {
	$.Widget.prototype[ "_" + method ] = function( element, options, callback ) {
		if ( typeof options === "string" ) {
			options = { effect: options };
		}

		var hasOptions;
		var effectName = !options ?
			method :
			options === true || typeof options === "number" ?
				defaultEffect :
				options.effect || defaultEffect;

		options = options || {};
		if ( typeof options === "number" ) {
			options = { duration: options };
		}

		hasOptions = !$.isEmptyObject( options );
		options.complete = callback;

		if ( options.delay ) {
			element.delay( options.delay );
		}

		if ( hasOptions && $.effects && $.effects.effect[ effectName ] ) {
			element[ method ]( options );
		} else if ( effectName !== method && element[ effectName ] ) {
			element[ effectName ]( options.duration, options.easing, callback );
		} else {
			element.queue( function( next ) {
				$( this )[ method ]();
				if ( callback ) {
					callback.call( element[ 0 ] );
				}
				next();
			} );
		}
	};
} );

var widget = $.widget;


/*!
 * jQuery UI Position 1.12.0
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/position/
 */

//>>label: Position
//>>group: Core
//>>description: Positions elements relative to other elements.
//>>docs: http://api.jqueryui.com/position/
//>>demos: http://jqueryui.com/position/


( function() {
var cachedScrollbarWidth, supportsOffsetFractions,
	max = Math.max,
	abs = Math.abs,
	round = Math.round,
	rhorizontal = /left|center|right/,
	rvertical = /top|center|bottom/,
	roffset = /[\+\-]\d+(\.[\d]+)?%?/,
	rposition = /^\w+/,
	rpercent = /%$/,
	_position = $.fn.position;

// Support: IE <=9 only
supportsOffsetFractions = function() {
	var element = $( "<div>" )
			.css( "position", "absolute" )
			.appendTo( "body" )
			.offset( {
				top: 1.5,
				left: 1.5
			} ),
		support = element.offset().top === 1.5;

	element.remove();

	supportsOffsetFractions = function() {
		return support;
	};

	return support;
};

function getOffsets( offsets, width, height ) {
	return [
		parseFloat( offsets[ 0 ] ) * ( rpercent.test( offsets[ 0 ] ) ? width / 100 : 1 ),
		parseFloat( offsets[ 1 ] ) * ( rpercent.test( offsets[ 1 ] ) ? height / 100 : 1 )
	];
}

function parseCss( element, property ) {
	return parseInt( $.css( element, property ), 10 ) || 0;
}

function getDimensions( elem ) {
	var raw = elem[ 0 ];
	if ( raw.nodeType === 9 ) {
		return {
			width: elem.width(),
			height: elem.height(),
			offset: { top: 0, left: 0 }
		};
	}
	if ( $.isWindow( raw ) ) {
		return {
			width: elem.width(),
			height: elem.height(),
			offset: { top: elem.scrollTop(), left: elem.scrollLeft() }
		};
	}
	if ( raw.preventDefault ) {
		return {
			width: 0,
			height: 0,
			offset: { top: raw.pageY, left: raw.pageX }
		};
	}
	return {
		width: elem.outerWidth(),
		height: elem.outerHeight(),
		offset: elem.offset()
	};
}

$.position = {
	scrollbarWidth: function() {
		if ( cachedScrollbarWidth !== undefined ) {
			return cachedScrollbarWidth;
		}
		var w1, w2,
			div = $( "<div " +
				"style='display:block;position:absolute;width:50px;height:50px;overflow:hidden;'>" +
				"<div style='height:100px;width:auto;'></div></div>" ),
			innerDiv = div.children()[ 0 ];

		$( "body" ).append( div );
		w1 = innerDiv.offsetWidth;
		div.css( "overflow", "scroll" );

		w2 = innerDiv.offsetWidth;

		if ( w1 === w2 ) {
			w2 = div[ 0 ].clientWidth;
		}

		div.remove();

		return ( cachedScrollbarWidth = w1 - w2 );
	},
	getScrollInfo: function( within ) {
		var overflowX = within.isWindow || within.isDocument ? "" :
				within.element.css( "overflow-x" ),
			overflowY = within.isWindow || within.isDocument ? "" :
				within.element.css( "overflow-y" ),
			hasOverflowX = overflowX === "scroll" ||
				( overflowX === "auto" && within.width < within.element[ 0 ].scrollWidth ),
			hasOverflowY = overflowY === "scroll" ||
				( overflowY === "auto" && within.height < within.element[ 0 ].scrollHeight );
		return {
			width: hasOverflowY ? $.position.scrollbarWidth() : 0,
			height: hasOverflowX ? $.position.scrollbarWidth() : 0
		};
	},
	getWithinInfo: function( element ) {
		var withinElement = $( element || window ),
			isWindow = $.isWindow( withinElement[ 0 ] ),
			isDocument = !!withinElement[ 0 ] && withinElement[ 0 ].nodeType === 9,
			hasOffset = !isWindow && !isDocument;
		return {
			element: withinElement,
			isWindow: isWindow,
			isDocument: isDocument,
			offset: hasOffset ? $( element ).offset() : { left: 0, top: 0 },
			scrollLeft: withinElement.scrollLeft(),
			scrollTop: withinElement.scrollTop(),
			width: withinElement.outerWidth(),
			height: withinElement.outerHeight()
		};
	}
};

$.fn.position = function( options ) {
	if ( !options || !options.of ) {
		return _position.apply( this, arguments );
	}

	// Make a copy, we don't want to modify arguments
	options = $.extend( {}, options );

	var atOffset, targetWidth, targetHeight, targetOffset, basePosition, dimensions,
		target = $( options.of ),
		within = $.position.getWithinInfo( options.within ),
		scrollInfo = $.position.getScrollInfo( within ),
		collision = ( options.collision || "flip" ).split( " " ),
		offsets = {};

	dimensions = getDimensions( target );
	if ( target[ 0 ].preventDefault ) {

		// Force left top to allow flipping
		options.at = "left top";
	}
	targetWidth = dimensions.width;
	targetHeight = dimensions.height;
	targetOffset = dimensions.offset;

	// Clone to reuse original targetOffset later
	basePosition = $.extend( {}, targetOffset );

	// Force my and at to have valid horizontal and vertical positions
	// if a value is missing or invalid, it will be converted to center
	$.each( [ "my", "at" ], function() {
		var pos = ( options[ this ] || "" ).split( " " ),
			horizontalOffset,
			verticalOffset;

		if ( pos.length === 1 ) {
			pos = rhorizontal.test( pos[ 0 ] ) ?
				pos.concat( [ "center" ] ) :
				rvertical.test( pos[ 0 ] ) ?
					[ "center" ].concat( pos ) :
					[ "center", "center" ];
		}
		pos[ 0 ] = rhorizontal.test( pos[ 0 ] ) ? pos[ 0 ] : "center";
		pos[ 1 ] = rvertical.test( pos[ 1 ] ) ? pos[ 1 ] : "center";

		// Calculate offsets
		horizontalOffset = roffset.exec( pos[ 0 ] );
		verticalOffset = roffset.exec( pos[ 1 ] );
		offsets[ this ] = [
			horizontalOffset ? horizontalOffset[ 0 ] : 0,
			verticalOffset ? verticalOffset[ 0 ] : 0
		];

		// Reduce to just the positions without the offsets
		options[ this ] = [
			rposition.exec( pos[ 0 ] )[ 0 ],
			rposition.exec( pos[ 1 ] )[ 0 ]
		];
	} );

	// Normalize collision option
	if ( collision.length === 1 ) {
		collision[ 1 ] = collision[ 0 ];
	}

	if ( options.at[ 0 ] === "right" ) {
		basePosition.left += targetWidth;
	} else if ( options.at[ 0 ] === "center" ) {
		basePosition.left += targetWidth / 2;
	}

	if ( options.at[ 1 ] === "bottom" ) {
		basePosition.top += targetHeight;
	} else if ( options.at[ 1 ] === "center" ) {
		basePosition.top += targetHeight / 2;
	}

	atOffset = getOffsets( offsets.at, targetWidth, targetHeight );
	basePosition.left += atOffset[ 0 ];
	basePosition.top += atOffset[ 1 ];

	return this.each( function() {
		var collisionPosition, using,
			elem = $( this ),
			elemWidth = elem.outerWidth(),
			elemHeight = elem.outerHeight(),
			marginLeft = parseCss( this, "marginLeft" ),
			marginTop = parseCss( this, "marginTop" ),
			collisionWidth = elemWidth + marginLeft + parseCss( this, "marginRight" ) +
				scrollInfo.width,
			collisionHeight = elemHeight + marginTop + parseCss( this, "marginBottom" ) +
				scrollInfo.height,
			position = $.extend( {}, basePosition ),
			myOffset = getOffsets( offsets.my, elem.outerWidth(), elem.outerHeight() );

		if ( options.my[ 0 ] === "right" ) {
			position.left -= elemWidth;
		} else if ( options.my[ 0 ] === "center" ) {
			position.left -= elemWidth / 2;
		}

		if ( options.my[ 1 ] === "bottom" ) {
			position.top -= elemHeight;
		} else if ( options.my[ 1 ] === "center" ) {
			position.top -= elemHeight / 2;
		}

		position.left += myOffset[ 0 ];
		position.top += myOffset[ 1 ];

		// If the browser doesn't support fractions, then round for consistent results
		if ( !supportsOffsetFractions() ) {
			position.left = round( position.left );
			position.top = round( position.top );
		}

		collisionPosition = {
			marginLeft: marginLeft,
			marginTop: marginTop
		};

		$.each( [ "left", "top" ], function( i, dir ) {
			if ( $.ui.position[ collision[ i ] ] ) {
				$.ui.position[ collision[ i ] ][ dir ]( position, {
					targetWidth: targetWidth,
					targetHeight: targetHeight,
					elemWidth: elemWidth,
					elemHeight: elemHeight,
					collisionPosition: collisionPosition,
					collisionWidth: collisionWidth,
					collisionHeight: collisionHeight,
					offset: [ atOffset[ 0 ] + myOffset[ 0 ], atOffset [ 1 ] + myOffset[ 1 ] ],
					my: options.my,
					at: options.at,
					within: within,
					elem: elem
				} );
			}
		} );

		if ( options.using ) {

			// Adds feedback as second argument to using callback, if present
			using = function( props ) {
				var left = targetOffset.left - position.left,
					right = left + targetWidth - elemWidth,
					top = targetOffset.top - position.top,
					bottom = top + targetHeight - elemHeight,
					feedback = {
						target: {
							element: target,
							left: targetOffset.left,
							top: targetOffset.top,
							width: targetWidth,
							height: targetHeight
						},
						element: {
							element: elem,
							left: position.left,
							top: position.top,
							width: elemWidth,
							height: elemHeight
						},
						horizontal: right < 0 ? "left" : left > 0 ? "right" : "center",
						vertical: bottom < 0 ? "top" : top > 0 ? "bottom" : "middle"
					};
				if ( targetWidth < elemWidth && abs( left + right ) < targetWidth ) {
					feedback.horizontal = "center";
				}
				if ( targetHeight < elemHeight && abs( top + bottom ) < targetHeight ) {
					feedback.vertical = "middle";
				}
				if ( max( abs( left ), abs( right ) ) > max( abs( top ), abs( bottom ) ) ) {
					feedback.important = "horizontal";
				} else {
					feedback.important = "vertical";
				}
				options.using.call( this, props, feedback );
			};
		}

		elem.offset( $.extend( position, { using: using } ) );
	} );
};

$.ui.position = {
	fit: {
		left: function( position, data ) {
			var within = data.within,
				withinOffset = within.isWindow ? within.scrollLeft : within.offset.left,
				outerWidth = within.width,
				collisionPosLeft = position.left - data.collisionPosition.marginLeft,
				overLeft = withinOffset - collisionPosLeft,
				overRight = collisionPosLeft + data.collisionWidth - outerWidth - withinOffset,
				newOverRight;

			// Element is wider than within
			if ( data.collisionWidth > outerWidth ) {

				// Element is initially over the left side of within
				if ( overLeft > 0 && overRight <= 0 ) {
					newOverRight = position.left + overLeft + data.collisionWidth - outerWidth -
						withinOffset;
					position.left += overLeft - newOverRight;

				// Element is initially over right side of within
				} else if ( overRight > 0 && overLeft <= 0 ) {
					position.left = withinOffset;

				// Element is initially over both left and right sides of within
				} else {
					if ( overLeft > overRight ) {
						position.left = withinOffset + outerWidth - data.collisionWidth;
					} else {
						position.left = withinOffset;
					}
				}

			// Too far left -> align with left edge
			} else if ( overLeft > 0 ) {
				position.left += overLeft;

			// Too far right -> align with right edge
			} else if ( overRight > 0 ) {
				position.left -= overRight;

			// Adjust based on position and margin
			} else {
				position.left = max( position.left - collisionPosLeft, position.left );
			}
		},
		top: function( position, data ) {
			var within = data.within,
				withinOffset = within.isWindow ? within.scrollTop : within.offset.top,
				outerHeight = data.within.height,
				collisionPosTop = position.top - data.collisionPosition.marginTop,
				overTop = withinOffset - collisionPosTop,
				overBottom = collisionPosTop + data.collisionHeight - outerHeight - withinOffset,
				newOverBottom;

			// Element is taller than within
			if ( data.collisionHeight > outerHeight ) {

				// Element is initially over the top of within
				if ( overTop > 0 && overBottom <= 0 ) {
					newOverBottom = position.top + overTop + data.collisionHeight - outerHeight -
						withinOffset;
					position.top += overTop - newOverBottom;

				// Element is initially over bottom of within
				} else if ( overBottom > 0 && overTop <= 0 ) {
					position.top = withinOffset;

				// Element is initially over both top and bottom of within
				} else {
					if ( overTop > overBottom ) {
						position.top = withinOffset + outerHeight - data.collisionHeight;
					} else {
						position.top = withinOffset;
					}
				}

			// Too far up -> align with top
			} else if ( overTop > 0 ) {
				position.top += overTop;

			// Too far down -> align with bottom edge
			} else if ( overBottom > 0 ) {
				position.top -= overBottom;

			// Adjust based on position and margin
			} else {
				position.top = max( position.top - collisionPosTop, position.top );
			}
		}
	},
	flip: {
		left: function( position, data ) {
			var within = data.within,
				withinOffset = within.offset.left + within.scrollLeft,
				outerWidth = within.width,
				offsetLeft = within.isWindow ? within.scrollLeft : within.offset.left,
				collisionPosLeft = position.left - data.collisionPosition.marginLeft,
				overLeft = collisionPosLeft - offsetLeft,
				overRight = collisionPosLeft + data.collisionWidth - outerWidth - offsetLeft,
				myOffset = data.my[ 0 ] === "left" ?
					-data.elemWidth :
					data.my[ 0 ] === "right" ?
						data.elemWidth :
						0,
				atOffset = data.at[ 0 ] === "left" ?
					data.targetWidth :
					data.at[ 0 ] === "right" ?
						-data.targetWidth :
						0,
				offset = -2 * data.offset[ 0 ],
				newOverRight,
				newOverLeft;

			if ( overLeft < 0 ) {
				newOverRight = position.left + myOffset + atOffset + offset + data.collisionWidth -
					outerWidth - withinOffset;
				if ( newOverRight < 0 || newOverRight < abs( overLeft ) ) {
					position.left += myOffset + atOffset + offset;
				}
			} else if ( overRight > 0 ) {
				newOverLeft = position.left - data.collisionPosition.marginLeft + myOffset +
					atOffset + offset - offsetLeft;
				if ( newOverLeft > 0 || abs( newOverLeft ) < overRight ) {
					position.left += myOffset + atOffset + offset;
				}
			}
		},
		top: function( position, data ) {
			var within = data.within,
				withinOffset = within.offset.top + within.scrollTop,
				outerHeight = within.height,
				offsetTop = within.isWindow ? within.scrollTop : within.offset.top,
				collisionPosTop = position.top - data.collisionPosition.marginTop,
				overTop = collisionPosTop - offsetTop,
				overBottom = collisionPosTop + data.collisionHeight - outerHeight - offsetTop,
				top = data.my[ 1 ] === "top",
				myOffset = top ?
					-data.elemHeight :
					data.my[ 1 ] === "bottom" ?
						data.elemHeight :
						0,
				atOffset = data.at[ 1 ] === "top" ?
					data.targetHeight :
					data.at[ 1 ] === "bottom" ?
						-data.targetHeight :
						0,
				offset = -2 * data.offset[ 1 ],
				newOverTop,
				newOverBottom;
			if ( overTop < 0 ) {
				newOverBottom = position.top + myOffset + atOffset + offset + data.collisionHeight -
					outerHeight - withinOffset;
				if ( newOverBottom < 0 || newOverBottom < abs( overTop ) ) {
					position.top += myOffset + atOffset + offset;
				}
			} else if ( overBottom > 0 ) {
				newOverTop = position.top - data.collisionPosition.marginTop + myOffset + atOffset +
					offset - offsetTop;
				if ( newOverTop > 0 || abs( newOverTop ) < overBottom ) {
					position.top += myOffset + atOffset + offset;
				}
			}
		}
	},
	flipfit: {
		left: function() {
			$.ui.position.flip.left.apply( this, arguments );
			$.ui.position.fit.left.apply( this, arguments );
		},
		top: function() {
			$.ui.position.flip.top.apply( this, arguments );
			$.ui.position.fit.top.apply( this, arguments );
		}
	}
};

} )();

var position = $.ui.position;


/*!
 * jQuery UI :data 1.12.0
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: :data Selector
//>>group: Core
//>>description: Selects elements which have data stored under the specified key.
//>>docs: http://api.jqueryui.com/data-selector/


var data = $.extend( $.expr[ ":" ], {
	data: $.expr.createPseudo ?
		$.expr.createPseudo( function( dataName ) {
			return function( elem ) {
				return !!$.data( elem, dataName );
			};
		} ) :

		// Support: jQuery <1.8
		function( elem, i, match ) {
			return !!$.data( elem, match[ 3 ] );
		}
} );

/*!
 * jQuery UI Disable Selection 1.12.0
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: disableSelection
//>>group: Core
//>>description: Disable selection of text content within the set of matched elements.
//>>docs: http://api.jqueryui.com/disableSelection/

// This file is deprecated


var disableSelection = $.fn.extend( {
	disableSelection: ( function() {
		var eventType = "onselectstart" in document.createElement( "div" ) ?
			"selectstart" :
			"mousedown";

		return function() {
			return this.on( eventType + ".ui-disableSelection", function( event ) {
				event.preventDefault();
			} );
		};
	} )(),

	enableSelection: function() {
		return this.off( ".ui-disableSelection" );
	}
} );


/*!
 * jQuery UI Effects 1.12.0
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Effects Core
//>>group: Effects
// jscs:disable maximumLineLength
//>>description: Extends the internal jQuery effects. Includes morphing and easing. Required by all other effects.
// jscs:enable maximumLineLength
//>>docs: http://api.jqueryui.com/category/effects-core/
//>>demos: http://jqueryui.com/effect/



var dataSpace = "ui-effects-",
	dataSpaceStyle = "ui-effects-style",
	dataSpaceAnimated = "ui-effects-animated",

	// Create a local jQuery because jQuery Color relies on it and the
	// global may not exist with AMD and a custom build (#10199)
	jQuery = $;

$.effects = {
	effect: {}
};

/*!
 * jQuery Color Animations v2.1.2
 * https://github.com/jquery/jquery-color
 *
 * Copyright 2014 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * Date: Wed Jan 16 08:47:09 2013 -0600
 */
( function( jQuery, undefined ) {

	var stepHooks = "backgroundColor borderBottomColor borderLeftColor borderRightColor " +
		"borderTopColor color columnRuleColor outlineColor textDecorationColor textEmphasisColor",

	// Plusequals test for += 100 -= 100
	rplusequals = /^([\-+])=\s*(\d+\.?\d*)/,

	// A set of RE's that can match strings and generate color tuples.
	stringParsers = [ {
			re: /rgba?\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
			parse: function( execResult ) {
				return [
					execResult[ 1 ],
					execResult[ 2 ],
					execResult[ 3 ],
					execResult[ 4 ]
				];
			}
		}, {
			re: /rgba?\(\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
			parse: function( execResult ) {
				return [
					execResult[ 1 ] * 2.55,
					execResult[ 2 ] * 2.55,
					execResult[ 3 ] * 2.55,
					execResult[ 4 ]
				];
			}
		}, {

			// This regex ignores A-F because it's compared against an already lowercased string
			re: /#([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})/,
			parse: function( execResult ) {
				return [
					parseInt( execResult[ 1 ], 16 ),
					parseInt( execResult[ 2 ], 16 ),
					parseInt( execResult[ 3 ], 16 )
				];
			}
		}, {

			// This regex ignores A-F because it's compared against an already lowercased string
			re: /#([a-f0-9])([a-f0-9])([a-f0-9])/,
			parse: function( execResult ) {
				return [
					parseInt( execResult[ 1 ] + execResult[ 1 ], 16 ),
					parseInt( execResult[ 2 ] + execResult[ 2 ], 16 ),
					parseInt( execResult[ 3 ] + execResult[ 3 ], 16 )
				];
			}
		}, {
			re: /hsla?\(\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
			space: "hsla",
			parse: function( execResult ) {
				return [
					execResult[ 1 ],
					execResult[ 2 ] / 100,
					execResult[ 3 ] / 100,
					execResult[ 4 ]
				];
			}
		} ],

	// JQuery.Color( )
	color = jQuery.Color = function( color, green, blue, alpha ) {
		return new jQuery.Color.fn.parse( color, green, blue, alpha );
	},
	spaces = {
		rgba: {
			props: {
				red: {
					idx: 0,
					type: "byte"
				},
				green: {
					idx: 1,
					type: "byte"
				},
				blue: {
					idx: 2,
					type: "byte"
				}
			}
		},

		hsla: {
			props: {
				hue: {
					idx: 0,
					type: "degrees"
				},
				saturation: {
					idx: 1,
					type: "percent"
				},
				lightness: {
					idx: 2,
					type: "percent"
				}
			}
		}
	},
	propTypes = {
		"byte": {
			floor: true,
			max: 255
		},
		"percent": {
			max: 1
		},
		"degrees": {
			mod: 360,
			floor: true
		}
	},
	support = color.support = {},

	// Element for support tests
	supportElem = jQuery( "<p>" )[ 0 ],

	// Colors = jQuery.Color.names
	colors,

	// Local aliases of functions called often
	each = jQuery.each;

// Determine rgba support immediately
supportElem.style.cssText = "background-color:rgba(1,1,1,.5)";
support.rgba = supportElem.style.backgroundColor.indexOf( "rgba" ) > -1;

// Define cache name and alpha properties
// for rgba and hsla spaces
each( spaces, function( spaceName, space ) {
	space.cache = "_" + spaceName;
	space.props.alpha = {
		idx: 3,
		type: "percent",
		def: 1
	};
} );

function clamp( value, prop, allowEmpty ) {
	var type = propTypes[ prop.type ] || {};

	if ( value == null ) {
		return ( allowEmpty || !prop.def ) ? null : prop.def;
	}

	// ~~ is an short way of doing floor for positive numbers
	value = type.floor ? ~~value : parseFloat( value );

	// IE will pass in empty strings as value for alpha,
	// which will hit this case
	if ( isNaN( value ) ) {
		return prop.def;
	}

	if ( type.mod ) {

		// We add mod before modding to make sure that negatives values
		// get converted properly: -10 -> 350
		return ( value + type.mod ) % type.mod;
	}

	// For now all property types without mod have min and max
	return 0 > value ? 0 : type.max < value ? type.max : value;
}

function stringParse( string ) {
	var inst = color(),
		rgba = inst._rgba = [];

	string = string.toLowerCase();

	each( stringParsers, function( i, parser ) {
		var parsed,
			match = parser.re.exec( string ),
			values = match && parser.parse( match ),
			spaceName = parser.space || "rgba";

		if ( values ) {
			parsed = inst[ spaceName ]( values );

			// If this was an rgba parse the assignment might happen twice
			// oh well....
			inst[ spaces[ spaceName ].cache ] = parsed[ spaces[ spaceName ].cache ];
			rgba = inst._rgba = parsed._rgba;

			// Exit each( stringParsers ) here because we matched
			return false;
		}
	} );

	// Found a stringParser that handled it
	if ( rgba.length ) {

		// If this came from a parsed string, force "transparent" when alpha is 0
		// chrome, (and maybe others) return "transparent" as rgba(0,0,0,0)
		if ( rgba.join() === "0,0,0,0" ) {
			jQuery.extend( rgba, colors.transparent );
		}
		return inst;
	}

	// Named colors
	return colors[ string ];
}

color.fn = jQuery.extend( color.prototype, {
	parse: function( red, green, blue, alpha ) {
		if ( red === undefined ) {
			this._rgba = [ null, null, null, null ];
			return this;
		}
		if ( red.jquery || red.nodeType ) {
			red = jQuery( red ).css( green );
			green = undefined;
		}

		var inst = this,
			type = jQuery.type( red ),
			rgba = this._rgba = [];

		// More than 1 argument specified - assume ( red, green, blue, alpha )
		if ( green !== undefined ) {
			red = [ red, green, blue, alpha ];
			type = "array";
		}

		if ( type === "string" ) {
			return this.parse( stringParse( red ) || colors._default );
		}

		if ( type === "array" ) {
			each( spaces.rgba.props, function( key, prop ) {
				rgba[ prop.idx ] = clamp( red[ prop.idx ], prop );
			} );
			return this;
		}

		if ( type === "object" ) {
			if ( red instanceof color ) {
				each( spaces, function( spaceName, space ) {
					if ( red[ space.cache ] ) {
						inst[ space.cache ] = red[ space.cache ].slice();
					}
				} );
			} else {
				each( spaces, function( spaceName, space ) {
					var cache = space.cache;
					each( space.props, function( key, prop ) {

						// If the cache doesn't exist, and we know how to convert
						if ( !inst[ cache ] && space.to ) {

							// If the value was null, we don't need to copy it
							// if the key was alpha, we don't need to copy it either
							if ( key === "alpha" || red[ key ] == null ) {
								return;
							}
							inst[ cache ] = space.to( inst._rgba );
						}

						// This is the only case where we allow nulls for ALL properties.
						// call clamp with alwaysAllowEmpty
						inst[ cache ][ prop.idx ] = clamp( red[ key ], prop, true );
					} );

					// Everything defined but alpha?
					if ( inst[ cache ] &&
							jQuery.inArray( null, inst[ cache ].slice( 0, 3 ) ) < 0 ) {

						// Use the default of 1
						inst[ cache ][ 3 ] = 1;
						if ( space.from ) {
							inst._rgba = space.from( inst[ cache ] );
						}
					}
				} );
			}
			return this;
		}
	},
	is: function( compare ) {
		var is = color( compare ),
			same = true,
			inst = this;

		each( spaces, function( _, space ) {
			var localCache,
				isCache = is[ space.cache ];
			if ( isCache ) {
				localCache = inst[ space.cache ] || space.to && space.to( inst._rgba ) || [];
				each( space.props, function( _, prop ) {
					if ( isCache[ prop.idx ] != null ) {
						same = ( isCache[ prop.idx ] === localCache[ prop.idx ] );
						return same;
					}
				} );
			}
			return same;
		} );
		return same;
	},
	_space: function() {
		var used = [],
			inst = this;
		each( spaces, function( spaceName, space ) {
			if ( inst[ space.cache ] ) {
				used.push( spaceName );
			}
		} );
		return used.pop();
	},
	transition: function( other, distance ) {
		var end = color( other ),
			spaceName = end._space(),
			space = spaces[ spaceName ],
			startColor = this.alpha() === 0 ? color( "transparent" ) : this,
			start = startColor[ space.cache ] || space.to( startColor._rgba ),
			result = start.slice();

		end = end[ space.cache ];
		each( space.props, function( key, prop ) {
			var index = prop.idx,
				startValue = start[ index ],
				endValue = end[ index ],
				type = propTypes[ prop.type ] || {};

			// If null, don't override start value
			if ( endValue === null ) {
				return;
			}

			// If null - use end
			if ( startValue === null ) {
				result[ index ] = endValue;
			} else {
				if ( type.mod ) {
					if ( endValue - startValue > type.mod / 2 ) {
						startValue += type.mod;
					} else if ( startValue - endValue > type.mod / 2 ) {
						startValue -= type.mod;
					}
				}
				result[ index ] = clamp( ( endValue - startValue ) * distance + startValue, prop );
			}
		} );
		return this[ spaceName ]( result );
	},
	blend: function( opaque ) {

		// If we are already opaque - return ourself
		if ( this._rgba[ 3 ] === 1 ) {
			return this;
		}

		var rgb = this._rgba.slice(),
			a = rgb.pop(),
			blend = color( opaque )._rgba;

		return color( jQuery.map( rgb, function( v, i ) {
			return ( 1 - a ) * blend[ i ] + a * v;
		} ) );
	},
	toRgbaString: function() {
		var prefix = "rgba(",
			rgba = jQuery.map( this._rgba, function( v, i ) {
				return v == null ? ( i > 2 ? 1 : 0 ) : v;
			} );

		if ( rgba[ 3 ] === 1 ) {
			rgba.pop();
			prefix = "rgb(";
		}

		return prefix + rgba.join() + ")";
	},
	toHslaString: function() {
		var prefix = "hsla(",
			hsla = jQuery.map( this.hsla(), function( v, i ) {
				if ( v == null ) {
					v = i > 2 ? 1 : 0;
				}

				// Catch 1 and 2
				if ( i && i < 3 ) {
					v = Math.round( v * 100 ) + "%";
				}
				return v;
			} );

		if ( hsla[ 3 ] === 1 ) {
			hsla.pop();
			prefix = "hsl(";
		}
		return prefix + hsla.join() + ")";
	},
	toHexString: function( includeAlpha ) {
		var rgba = this._rgba.slice(),
			alpha = rgba.pop();

		if ( includeAlpha ) {
			rgba.push( ~~( alpha * 255 ) );
		}

		return "#" + jQuery.map( rgba, function( v ) {

			// Default to 0 when nulls exist
			v = ( v || 0 ).toString( 16 );
			return v.length === 1 ? "0" + v : v;
		} ).join( "" );
	},
	toString: function() {
		return this._rgba[ 3 ] === 0 ? "transparent" : this.toRgbaString();
	}
} );
color.fn.parse.prototype = color.fn;

// Hsla conversions adapted from:
// https://code.google.com/p/maashaack/source/browse/packages/graphics/trunk/src/graphics/colors/HUE2RGB.as?r=5021

function hue2rgb( p, q, h ) {
	h = ( h + 1 ) % 1;
	if ( h * 6 < 1 ) {
		return p + ( q - p ) * h * 6;
	}
	if ( h * 2 < 1 ) {
		return q;
	}
	if ( h * 3 < 2 ) {
		return p + ( q - p ) * ( ( 2 / 3 ) - h ) * 6;
	}
	return p;
}

spaces.hsla.to = function( rgba ) {
	if ( rgba[ 0 ] == null || rgba[ 1 ] == null || rgba[ 2 ] == null ) {
		return [ null, null, null, rgba[ 3 ] ];
	}
	var r = rgba[ 0 ] / 255,
		g = rgba[ 1 ] / 255,
		b = rgba[ 2 ] / 255,
		a = rgba[ 3 ],
		max = Math.max( r, g, b ),
		min = Math.min( r, g, b ),
		diff = max - min,
		add = max + min,
		l = add * 0.5,
		h, s;

	if ( min === max ) {
		h = 0;
	} else if ( r === max ) {
		h = ( 60 * ( g - b ) / diff ) + 360;
	} else if ( g === max ) {
		h = ( 60 * ( b - r ) / diff ) + 120;
	} else {
		h = ( 60 * ( r - g ) / diff ) + 240;
	}

	// Chroma (diff) == 0 means greyscale which, by definition, saturation = 0%
	// otherwise, saturation is based on the ratio of chroma (diff) to lightness (add)
	if ( diff === 0 ) {
		s = 0;
	} else if ( l <= 0.5 ) {
		s = diff / add;
	} else {
		s = diff / ( 2 - add );
	}
	return [ Math.round( h ) % 360, s, l, a == null ? 1 : a ];
};

spaces.hsla.from = function( hsla ) {
	if ( hsla[ 0 ] == null || hsla[ 1 ] == null || hsla[ 2 ] == null ) {
		return [ null, null, null, hsla[ 3 ] ];
	}
	var h = hsla[ 0 ] / 360,
		s = hsla[ 1 ],
		l = hsla[ 2 ],
		a = hsla[ 3 ],
		q = l <= 0.5 ? l * ( 1 + s ) : l + s - l * s,
		p = 2 * l - q;

	return [
		Math.round( hue2rgb( p, q, h + ( 1 / 3 ) ) * 255 ),
		Math.round( hue2rgb( p, q, h ) * 255 ),
		Math.round( hue2rgb( p, q, h - ( 1 / 3 ) ) * 255 ),
		a
	];
};

each( spaces, function( spaceName, space ) {
	var props = space.props,
		cache = space.cache,
		to = space.to,
		from = space.from;

	// Makes rgba() and hsla()
	color.fn[ spaceName ] = function( value ) {

		// Generate a cache for this space if it doesn't exist
		if ( to && !this[ cache ] ) {
			this[ cache ] = to( this._rgba );
		}
		if ( value === undefined ) {
			return this[ cache ].slice();
		}

		var ret,
			type = jQuery.type( value ),
			arr = ( type === "array" || type === "object" ) ? value : arguments,
			local = this[ cache ].slice();

		each( props, function( key, prop ) {
			var val = arr[ type === "object" ? key : prop.idx ];
			if ( val == null ) {
				val = local[ prop.idx ];
			}
			local[ prop.idx ] = clamp( val, prop );
		} );

		if ( from ) {
			ret = color( from( local ) );
			ret[ cache ] = local;
			return ret;
		} else {
			return color( local );
		}
	};

	// Makes red() green() blue() alpha() hue() saturation() lightness()
	each( props, function( key, prop ) {

		// Alpha is included in more than one space
		if ( color.fn[ key ] ) {
			return;
		}
		color.fn[ key ] = function( value ) {
			var vtype = jQuery.type( value ),
				fn = ( key === "alpha" ? ( this._hsla ? "hsla" : "rgba" ) : spaceName ),
				local = this[ fn ](),
				cur = local[ prop.idx ],
				match;

			if ( vtype === "undefined" ) {
				return cur;
			}

			if ( vtype === "function" ) {
				value = value.call( this, cur );
				vtype = jQuery.type( value );
			}
			if ( value == null && prop.empty ) {
				return this;
			}
			if ( vtype === "string" ) {
				match = rplusequals.exec( value );
				if ( match ) {
					value = cur + parseFloat( match[ 2 ] ) * ( match[ 1 ] === "+" ? 1 : -1 );
				}
			}
			local[ prop.idx ] = value;
			return this[ fn ]( local );
		};
	} );
} );

// Add cssHook and .fx.step function for each named hook.
// accept a space separated string of properties
color.hook = function( hook ) {
	var hooks = hook.split( " " );
	each( hooks, function( i, hook ) {
		jQuery.cssHooks[ hook ] = {
			set: function( elem, value ) {
				var parsed, curElem,
					backgroundColor = "";

				if ( value !== "transparent" && ( jQuery.type( value ) !== "string" ||
						( parsed = stringParse( value ) ) ) ) {
					value = color( parsed || value );
					if ( !support.rgba && value._rgba[ 3 ] !== 1 ) {
						curElem = hook === "backgroundColor" ? elem.parentNode : elem;
						while (
							( backgroundColor === "" || backgroundColor === "transparent" ) &&
							curElem && curElem.style
						) {
							try {
								backgroundColor = jQuery.css( curElem, "backgroundColor" );
								curElem = curElem.parentNode;
							} catch ( e ) {
							}
						}

						value = value.blend( backgroundColor && backgroundColor !== "transparent" ?
							backgroundColor :
							"_default" );
					}

					value = value.toRgbaString();
				}
				try {
					elem.style[ hook ] = value;
				} catch ( e ) {

					// Wrapped to prevent IE from throwing errors on "invalid" values like
					// 'auto' or 'inherit'
				}
			}
		};
		jQuery.fx.step[ hook ] = function( fx ) {
			if ( !fx.colorInit ) {
				fx.start = color( fx.elem, hook );
				fx.end = color( fx.end );
				fx.colorInit = true;
			}
			jQuery.cssHooks[ hook ].set( fx.elem, fx.start.transition( fx.end, fx.pos ) );
		};
	} );

};

color.hook( stepHooks );

jQuery.cssHooks.borderColor = {
	expand: function( value ) {
		var expanded = {};

		each( [ "Top", "Right", "Bottom", "Left" ], function( i, part ) {
			expanded[ "border" + part + "Color" ] = value;
		} );
		return expanded;
	}
};

// Basic color names only.
// Usage of any of the other color names requires adding yourself or including
// jquery.color.svg-names.js.
colors = jQuery.Color.names = {

	// 4.1. Basic color keywords
	aqua: "#00ffff",
	black: "#000000",
	blue: "#0000ff",
	fuchsia: "#ff00ff",
	gray: "#808080",
	green: "#008000",
	lime: "#00ff00",
	maroon: "#800000",
	navy: "#000080",
	olive: "#808000",
	purple: "#800080",
	red: "#ff0000",
	silver: "#c0c0c0",
	teal: "#008080",
	white: "#ffffff",
	yellow: "#ffff00",

	// 4.2.3. "transparent" color keyword
	transparent: [ null, null, null, 0 ],

	_default: "#ffffff"
};

} )( jQuery );

/******************************************************************************/
/****************************** CLASS ANIMATIONS ******************************/
/******************************************************************************/
( function() {

var classAnimationActions = [ "add", "remove", "toggle" ],
	shorthandStyles = {
		border: 1,
		borderBottom: 1,
		borderColor: 1,
		borderLeft: 1,
		borderRight: 1,
		borderTop: 1,
		borderWidth: 1,
		margin: 1,
		padding: 1
	};

$.each(
	[ "borderLeftStyle", "borderRightStyle", "borderBottomStyle", "borderTopStyle" ],
	function( _, prop ) {
		$.fx.step[ prop ] = function( fx ) {
			if ( fx.end !== "none" && !fx.setAttr || fx.pos === 1 && !fx.setAttr ) {
				jQuery.style( fx.elem, prop, fx.end );
				fx.setAttr = true;
			}
		};
	}
);

function getElementStyles( elem ) {
	var key, len,
		style = elem.ownerDocument.defaultView ?
			elem.ownerDocument.defaultView.getComputedStyle( elem, null ) :
			elem.currentStyle,
		styles = {};

	if ( style && style.length && style[ 0 ] && style[ style[ 0 ] ] ) {
		len = style.length;
		while ( len-- ) {
			key = style[ len ];
			if ( typeof style[ key ] === "string" ) {
				styles[ $.camelCase( key ) ] = style[ key ];
			}
		}

	// Support: Opera, IE <9
	} else {
		for ( key in style ) {
			if ( typeof style[ key ] === "string" ) {
				styles[ key ] = style[ key ];
			}
		}
	}

	return styles;
}

function styleDifference( oldStyle, newStyle ) {
	var diff = {},
		name, value;

	for ( name in newStyle ) {
		value = newStyle[ name ];
		if ( oldStyle[ name ] !== value ) {
			if ( !shorthandStyles[ name ] ) {
				if ( $.fx.step[ name ] || !isNaN( parseFloat( value ) ) ) {
					diff[ name ] = value;
				}
			}
		}
	}

	return diff;
}

// Support: jQuery <1.8
if ( !$.fn.addBack ) {
	$.fn.addBack = function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter( selector )
		);
	};
}

$.effects.animateClass = function( value, duration, easing, callback ) {
	var o = $.speed( duration, easing, callback );

	return this.queue( function() {
		var animated = $( this ),
			baseClass = animated.attr( "class" ) || "",
			applyClassChange,
			allAnimations = o.children ? animated.find( "*" ).addBack() : animated;

		// Map the animated objects to store the original styles.
		allAnimations = allAnimations.map( function() {
			var el = $( this );
			return {
				el: el,
				start: getElementStyles( this )
			};
		} );

		// Apply class change
		applyClassChange = function() {
			$.each( classAnimationActions, function( i, action ) {
				if ( value[ action ] ) {
					animated[ action + "Class" ]( value[ action ] );
				}
			} );
		};
		applyClassChange();

		// Map all animated objects again - calculate new styles and diff
		allAnimations = allAnimations.map( function() {
			this.end = getElementStyles( this.el[ 0 ] );
			this.diff = styleDifference( this.start, this.end );
			return this;
		} );

		// Apply original class
		animated.attr( "class", baseClass );

		// Map all animated objects again - this time collecting a promise
		allAnimations = allAnimations.map( function() {
			var styleInfo = this,
				dfd = $.Deferred(),
				opts = $.extend( {}, o, {
					queue: false,
					complete: function() {
						dfd.resolve( styleInfo );
					}
				} );

			this.el.animate( this.diff, opts );
			return dfd.promise();
		} );

		// Once all animations have completed:
		$.when.apply( $, allAnimations.get() ).done( function() {

			// Set the final class
			applyClassChange();

			// For each animated element,
			// clear all css properties that were animated
			$.each( arguments, function() {
				var el = this.el;
				$.each( this.diff, function( key ) {
					el.css( key, "" );
				} );
			} );

			// This is guarnteed to be there if you use jQuery.speed()
			// it also handles dequeuing the next anim...
			o.complete.call( animated[ 0 ] );
		} );
	} );
};

$.fn.extend( {
	addClass: ( function( orig ) {
		return function( classNames, speed, easing, callback ) {
			return speed ?
				$.effects.animateClass.call( this,
					{ add: classNames }, speed, easing, callback ) :
				orig.apply( this, arguments );
		};
	} )( $.fn.addClass ),

	removeClass: ( function( orig ) {
		return function( classNames, speed, easing, callback ) {
			return arguments.length > 1 ?
				$.effects.animateClass.call( this,
					{ remove: classNames }, speed, easing, callback ) :
				orig.apply( this, arguments );
		};
	} )( $.fn.removeClass ),

	toggleClass: ( function( orig ) {
		return function( classNames, force, speed, easing, callback ) {
			if ( typeof force === "boolean" || force === undefined ) {
				if ( !speed ) {

					// Without speed parameter
					return orig.apply( this, arguments );
				} else {
					return $.effects.animateClass.call( this,
						( force ? { add: classNames } : { remove: classNames } ),
						speed, easing, callback );
				}
			} else {

				// Without force parameter
				return $.effects.animateClass.call( this,
					{ toggle: classNames }, force, speed, easing );
			}
		};
	} )( $.fn.toggleClass ),

	switchClass: function( remove, add, speed, easing, callback ) {
		return $.effects.animateClass.call( this, {
			add: add,
			remove: remove
		}, speed, easing, callback );
	}
} );

} )();

/******************************************************************************/
/*********************************** EFFECTS **********************************/
/******************************************************************************/

( function() {

if ( $.expr && $.expr.filters && $.expr.filters.animated ) {
	$.expr.filters.animated = ( function( orig ) {
		return function( elem ) {
			return !!$( elem ).data( dataSpaceAnimated ) || orig( elem );
		};
	} )( $.expr.filters.animated );
}

if ( $.uiBackCompat !== false ) {
	$.extend( $.effects, {

		// Saves a set of properties in a data storage
		save: function( element, set ) {
			var i = 0, length = set.length;
			for ( ; i < length; i++ ) {
				if ( set[ i ] !== null ) {
					element.data( dataSpace + set[ i ], element[ 0 ].style[ set[ i ] ] );
				}
			}
		},

		// Restores a set of previously saved properties from a data storage
		restore: function( element, set ) {
			var val, i = 0, length = set.length;
			for ( ; i < length; i++ ) {
				if ( set[ i ] !== null ) {
					val = element.data( dataSpace + set[ i ] );
					element.css( set[ i ], val );
				}
			}
		},

		setMode: function( el, mode ) {
			if ( mode === "toggle" ) {
				mode = el.is( ":hidden" ) ? "show" : "hide";
			}
			return mode;
		},

		// Wraps the element around a wrapper that copies position properties
		createWrapper: function( element ) {

			// If the element is already wrapped, return it
			if ( element.parent().is( ".ui-effects-wrapper" ) ) {
				return element.parent();
			}

			// Wrap the element
			var props = {
					width: element.outerWidth( true ),
					height: element.outerHeight( true ),
					"float": element.css( "float" )
				},
				wrapper = $( "<div></div>" )
					.addClass( "ui-effects-wrapper" )
					.css( {
						fontSize: "100%",
						background: "transparent",
						border: "none",
						margin: 0,
						padding: 0
					} ),

				// Store the size in case width/height are defined in % - Fixes #5245
				size = {
					width: element.width(),
					height: element.height()
				},
				active = document.activeElement;

			// Support: Firefox
			// Firefox incorrectly exposes anonymous content
			// https://bugzilla.mozilla.org/show_bug.cgi?id=561664
			try {
				active.id;
			} catch ( e ) {
				active = document.body;
			}

			element.wrap( wrapper );

			// Fixes #7595 - Elements lose focus when wrapped.
			if ( element[ 0 ] === active || $.contains( element[ 0 ], active ) ) {
				$( active ).trigger( "focus" );
			}

			// Hotfix for jQuery 1.4 since some change in wrap() seems to actually
			// lose the reference to the wrapped element
			wrapper = element.parent();

			// Transfer positioning properties to the wrapper
			if ( element.css( "position" ) === "static" ) {
				wrapper.css( { position: "relative" } );
				element.css( { position: "relative" } );
			} else {
				$.extend( props, {
					position: element.css( "position" ),
					zIndex: element.css( "z-index" )
				} );
				$.each( [ "top", "left", "bottom", "right" ], function( i, pos ) {
					props[ pos ] = element.css( pos );
					if ( isNaN( parseInt( props[ pos ], 10 ) ) ) {
						props[ pos ] = "auto";
					}
				} );
				element.css( {
					position: "relative",
					top: 0,
					left: 0,
					right: "auto",
					bottom: "auto"
				} );
			}
			element.css( size );

			return wrapper.css( props ).show();
		},

		removeWrapper: function( element ) {
			var active = document.activeElement;

			if ( element.parent().is( ".ui-effects-wrapper" ) ) {
				element.parent().replaceWith( element );

				// Fixes #7595 - Elements lose focus when wrapped.
				if ( element[ 0 ] === active || $.contains( element[ 0 ], active ) ) {
					$( active ).trigger( "focus" );
				}
			}

			return element;
		}
	} );
}

$.extend( $.effects, {
	version: "1.12.0",

	define: function( name, mode, effect ) {
		if ( !effect ) {
			effect = mode;
			mode = "effect";
		}

		$.effects.effect[ name ] = effect;
		$.effects.effect[ name ].mode = mode;

		return effect;
	},

	scaledDimensions: function( element, percent, direction ) {
		if ( percent === 0 ) {
			return {
				height: 0,
				width: 0,
				outerHeight: 0,
				outerWidth: 0
			};
		}

		var x = direction !== "horizontal" ? ( ( percent || 100 ) / 100 ) : 1,
			y = direction !== "vertical" ? ( ( percent || 100 ) / 100 ) : 1;

		return {
			height: element.height() * y,
			width: element.width() * x,
			outerHeight: element.outerHeight() * y,
			outerWidth: element.outerWidth() * x
		};

	},

	clipToBox: function( animation ) {
		return {
			width: animation.clip.right - animation.clip.left,
			height: animation.clip.bottom - animation.clip.top,
			left: animation.clip.left,
			top: animation.clip.top
		};
	},

	// Injects recently queued functions to be first in line (after "inprogress")
	unshift: function( element, queueLength, count ) {
		var queue = element.queue();

		if ( queueLength > 1 ) {
			queue.splice.apply( queue,
				[ 1, 0 ].concat( queue.splice( queueLength, count ) ) );
		}
		element.dequeue();
	},

	saveStyle: function( element ) {
		element.data( dataSpaceStyle, element[ 0 ].style.cssText );
	},

	restoreStyle: function( element ) {
		element[ 0 ].style.cssText = element.data( dataSpaceStyle ) || "";
		element.removeData( dataSpaceStyle );
	},

	mode: function( element, mode ) {
		var hidden = element.is( ":hidden" );

		if ( mode === "toggle" ) {
			mode = hidden ? "show" : "hide";
		}
		if ( hidden ? mode === "hide" : mode === "show" ) {
			mode = "none";
		}
		return mode;
	},

	// Translates a [top,left] array into a baseline value
	getBaseline: function( origin, original ) {
		var y, x;

		switch ( origin[ 0 ] ) {
		case "top":
			y = 0;
			break;
		case "middle":
			y = 0.5;
			break;
		case "bottom":
			y = 1;
			break;
		default:
			y = origin[ 0 ] / original.height;
		}

		switch ( origin[ 1 ] ) {
		case "left":
			x = 0;
			break;
		case "center":
			x = 0.5;
			break;
		case "right":
			x = 1;
			break;
		default:
			x = origin[ 1 ] / original.width;
		}

		return {
			x: x,
			y: y
		};
	},

	// Creates a placeholder element so that the original element can be made absolute
	createPlaceholder: function( element ) {
		var placeholder,
			cssPosition = element.css( "position" ),
			position = element.position();

		// Lock in margins first to account for form elements, which
		// will change margin if you explicitly set height
		// see: http://jsfiddle.net/JZSMt/3/ https://bugs.webkit.org/show_bug.cgi?id=107380
		// Support: Safari
		element.css( {
			marginTop: element.css( "marginTop" ),
			marginBottom: element.css( "marginBottom" ),
			marginLeft: element.css( "marginLeft" ),
			marginRight: element.css( "marginRight" )
		} )
		.outerWidth( element.outerWidth() )
		.outerHeight( element.outerHeight() );

		if ( /^(static|relative)/.test( cssPosition ) ) {
			cssPosition = "absolute";

			placeholder = $( "<" + element[ 0 ].nodeName + ">" ).insertAfter( element ).css( {

				// Convert inline to inline block to account for inline elements
				// that turn to inline block based on content (like img)
				display: /^(inline|ruby)/.test( element.css( "display" ) ) ?
					"inline-block" :
					"block",
				visibility: "hidden",

				// Margins need to be set to account for margin collapse
				marginTop: element.css( "marginTop" ),
				marginBottom: element.css( "marginBottom" ),
				marginLeft: element.css( "marginLeft" ),
				marginRight: element.css( "marginRight" ),
				"float": element.css( "float" )
			} )
			.outerWidth( element.outerWidth() )
			.outerHeight( element.outerHeight() )
			.addClass( "ui-effects-placeholder" );

			element.data( dataSpace + "placeholder", placeholder );
		}

		element.css( {
			position: cssPosition,
			left: position.left,
			top: position.top
		} );

		return placeholder;
	},

	removePlaceholder: function( element ) {
		var dataKey = dataSpace + "placeholder",
				placeholder = element.data( dataKey );

		if ( placeholder ) {
			placeholder.remove();
			element.removeData( dataKey );
		}
	},

	// Removes a placeholder if it exists and restores
	// properties that were modified during placeholder creation
	cleanUp: function( element ) {
		$.effects.restoreStyle( element );
		$.effects.removePlaceholder( element );
	},

	setTransition: function( element, list, factor, value ) {
		value = value || {};
		$.each( list, function( i, x ) {
			var unit = element.cssUnit( x );
			if ( unit[ 0 ] > 0 ) {
				value[ x ] = unit[ 0 ] * factor + unit[ 1 ];
			}
		} );
		return value;
	}
} );

// Return an effect options object for the given parameters:
function _normalizeArguments( effect, options, speed, callback ) {

	// Allow passing all options as the first parameter
	if ( $.isPlainObject( effect ) ) {
		options = effect;
		effect = effect.effect;
	}

	// Convert to an object
	effect = { effect: effect };

	// Catch (effect, null, ...)
	if ( options == null ) {
		options = {};
	}

	// Catch (effect, callback)
	if ( $.isFunction( options ) ) {
		callback = options;
		speed = null;
		options = {};
	}

	// Catch (effect, speed, ?)
	if ( typeof options === "number" || $.fx.speeds[ options ] ) {
		callback = speed;
		speed = options;
		options = {};
	}

	// Catch (effect, options, callback)
	if ( $.isFunction( speed ) ) {
		callback = speed;
		speed = null;
	}

	// Add options to effect
	if ( options ) {
		$.extend( effect, options );
	}

	speed = speed || options.duration;
	effect.duration = $.fx.off ? 0 :
		typeof speed === "number" ? speed :
		speed in $.fx.speeds ? $.fx.speeds[ speed ] :
		$.fx.speeds._default;

	effect.complete = callback || options.complete;

	return effect;
}

function standardAnimationOption( option ) {

	// Valid standard speeds (nothing, number, named speed)
	if ( !option || typeof option === "number" || $.fx.speeds[ option ] ) {
		return true;
	}

	// Invalid strings - treat as "normal" speed
	if ( typeof option === "string" && !$.effects.effect[ option ] ) {
		return true;
	}

	// Complete callback
	if ( $.isFunction( option ) ) {
		return true;
	}

	// Options hash (but not naming an effect)
	if ( typeof option === "object" && !option.effect ) {
		return true;
	}

	// Didn't match any standard API
	return false;
}

$.fn.extend( {
	effect: function( /* effect, options, speed, callback */ ) {
		var args = _normalizeArguments.apply( this, arguments ),
			effectMethod = $.effects.effect[ args.effect ],
			defaultMode = effectMethod.mode,
			queue = args.queue,
			queueName = queue || "fx",
			complete = args.complete,
			mode = args.mode,
			modes = [],
			prefilter = function( next ) {
				var el = $( this ),
					normalizedMode = $.effects.mode( el, mode ) || defaultMode;

				// Sentinel for duck-punching the :animated psuedo-selector
				el.data( dataSpaceAnimated, true );

				// Save effect mode for later use,
				// we can't just call $.effects.mode again later,
				// as the .show() below destroys the initial state
				modes.push( normalizedMode );

				// See $.uiBackCompat inside of run() for removal of defaultMode in 1.13
				if ( defaultMode && ( normalizedMode === "show" ||
						( normalizedMode === defaultMode && normalizedMode === "hide" ) ) ) {
					el.show();
				}

				if ( !defaultMode || normalizedMode !== "none" ) {
					$.effects.saveStyle( el );
				}

				if ( $.isFunction( next ) ) {
					next();
				}
			};

		if ( $.fx.off || !effectMethod ) {

			// Delegate to the original method (e.g., .show()) if possible
			if ( mode ) {
				return this[ mode ]( args.duration, complete );
			} else {
				return this.each( function() {
					if ( complete ) {
						complete.call( this );
					}
				} );
			}
		}

		function run( next ) {
			var elem = $( this );

			function cleanup() {
				elem.removeData( dataSpaceAnimated );

				$.effects.cleanUp( elem );

				if ( args.mode === "hide" ) {
					elem.hide();
				}

				done();
			}

			function done() {
				if ( $.isFunction( complete ) ) {
					complete.call( elem[ 0 ] );
				}

				if ( $.isFunction( next ) ) {
					next();
				}
			}

			// Override mode option on a per element basis,
			// as toggle can be either show or hide depending on element state
			args.mode = modes.shift();

			if ( $.uiBackCompat !== false && !defaultMode ) {
				if ( elem.is( ":hidden" ) ? mode === "hide" : mode === "show" ) {

					// Call the core method to track "olddisplay" properly
					elem[ mode ]();
					done();
				} else {
					effectMethod.call( elem[ 0 ], args, done );
				}
			} else {
				if ( args.mode === "none" ) {

					// Call the core method to track "olddisplay" properly
					elem[ mode ]();
					done();
				} else {
					effectMethod.call( elem[ 0 ], args, cleanup );
				}
			}
		}

		// Run prefilter on all elements first to ensure that
		// any showing or hiding happens before placeholder creation,
		// which ensures that any layout changes are correctly captured.
		return queue === false ?
			this.each( prefilter ).each( run ) :
			this.queue( queueName, prefilter ).queue( queueName, run );
	},

	show: ( function( orig ) {
		return function( option ) {
			if ( standardAnimationOption( option ) ) {
				return orig.apply( this, arguments );
			} else {
				var args = _normalizeArguments.apply( this, arguments );
				args.mode = "show";
				return this.effect.call( this, args );
			}
		};
	} )( $.fn.show ),

	hide: ( function( orig ) {
		return function( option ) {
			if ( standardAnimationOption( option ) ) {
				return orig.apply( this, arguments );
			} else {
				var args = _normalizeArguments.apply( this, arguments );
				args.mode = "hide";
				return this.effect.call( this, args );
			}
		};
	} )( $.fn.hide ),

	toggle: ( function( orig ) {
		return function( option ) {
			if ( standardAnimationOption( option ) || typeof option === "boolean" ) {
				return orig.apply( this, arguments );
			} else {
				var args = _normalizeArguments.apply( this, arguments );
				args.mode = "toggle";
				return this.effect.call( this, args );
			}
		};
	} )( $.fn.toggle ),

	cssUnit: function( key ) {
		var style = this.css( key ),
			val = [];

		$.each( [ "em", "px", "%", "pt" ], function( i, unit ) {
			if ( style.indexOf( unit ) > 0 ) {
				val = [ parseFloat( style ), unit ];
			}
		} );
		return val;
	},

	cssClip: function( clipObj ) {
		if ( clipObj ) {
			return this.css( "clip", "rect(" + clipObj.top + "px " + clipObj.right + "px " +
				clipObj.bottom + "px " + clipObj.left + "px)" );
		}
		return parseClip( this.css( "clip" ), this );
	},

	transfer: function( options, done ) {
		var element = $( this ),
			target = $( options.to ),
			targetFixed = target.css( "position" ) === "fixed",
			body = $( "body" ),
			fixTop = targetFixed ? body.scrollTop() : 0,
			fixLeft = targetFixed ? body.scrollLeft() : 0,
			endPosition = target.offset(),
			animation = {
				top: endPosition.top - fixTop,
				left: endPosition.left - fixLeft,
				height: target.innerHeight(),
				width: target.innerWidth()
			},
			startPosition = element.offset(),
			transfer = $( "<div class='ui-effects-transfer'></div>" )
				.appendTo( "body" )
				.addClass( options.className )
				.css( {
					top: startPosition.top - fixTop,
					left: startPosition.left - fixLeft,
					height: element.innerHeight(),
					width: element.innerWidth(),
					position: targetFixed ? "fixed" : "absolute"
				} )
				.animate( animation, options.duration, options.easing, function() {
					transfer.remove();
					if ( $.isFunction( done ) ) {
						done();
					}
				} );
	}
} );

function parseClip( str, element ) {
		var outerWidth = element.outerWidth(),
			outerHeight = element.outerHeight(),
			clipRegex = /^rect\((-?\d*\.?\d*px|-?\d+%|auto),?\s*(-?\d*\.?\d*px|-?\d+%|auto),?\s*(-?\d*\.?\d*px|-?\d+%|auto),?\s*(-?\d*\.?\d*px|-?\d+%|auto)\)$/,
			values = clipRegex.exec( str ) || [ "", 0, outerWidth, outerHeight, 0 ];

		return {
			top: parseFloat( values[ 1 ] ) || 0,
			right: values[ 2 ] === "auto" ? outerWidth : parseFloat( values[ 2 ] ),
			bottom: values[ 3 ] === "auto" ? outerHeight : parseFloat( values[ 3 ] ),
			left: parseFloat( values[ 4 ] ) || 0
		};
}

$.fx.step.clip = function( fx ) {
	if ( !fx.clipInit ) {
		fx.start = $( fx.elem ).cssClip();
		if ( typeof fx.end === "string" ) {
			fx.end = parseClip( fx.end, fx.elem );
		}
		fx.clipInit = true;
	}

	$( fx.elem ).cssClip( {
		top: fx.pos * ( fx.end.top - fx.start.top ) + fx.start.top,
		right: fx.pos * ( fx.end.right - fx.start.right ) + fx.start.right,
		bottom: fx.pos * ( fx.end.bottom - fx.start.bottom ) + fx.start.bottom,
		left: fx.pos * ( fx.end.left - fx.start.left ) + fx.start.left
	} );
};

} )();

/******************************************************************************/
/*********************************** EASING ***********************************/
/******************************************************************************/

( function() {

// Based on easing equations from Robert Penner (http://www.robertpenner.com/easing)

var baseEasings = {};

$.each( [ "Quad", "Cubic", "Quart", "Quint", "Expo" ], function( i, name ) {
	baseEasings[ name ] = function( p ) {
		return Math.pow( p, i + 2 );
	};
} );

$.extend( baseEasings, {
	Sine: function( p ) {
		return 1 - Math.cos( p * Math.PI / 2 );
	},
	Circ: function( p ) {
		return 1 - Math.sqrt( 1 - p * p );
	},
	Elastic: function( p ) {
		return p === 0 || p === 1 ? p :
			-Math.pow( 2, 8 * ( p - 1 ) ) * Math.sin( ( ( p - 1 ) * 80 - 7.5 ) * Math.PI / 15 );
	},
	Back: function( p ) {
		return p * p * ( 3 * p - 2 );
	},
	Bounce: function( p ) {
		var pow2,
			bounce = 4;

		while ( p < ( ( pow2 = Math.pow( 2, --bounce ) ) - 1 ) / 11 ) {}
		return 1 / Math.pow( 4, 3 - bounce ) - 7.5625 * Math.pow( ( pow2 * 3 - 2 ) / 22 - p, 2 );
	}
} );

$.each( baseEasings, function( name, easeIn ) {
	$.easing[ "easeIn" + name ] = easeIn;
	$.easing[ "easeOut" + name ] = function( p ) {
		return 1 - easeIn( 1 - p );
	};
	$.easing[ "easeInOut" + name ] = function( p ) {
		return p < 0.5 ?
			easeIn( p * 2 ) / 2 :
			1 - easeIn( p * -2 + 2 ) / 2;
	};
} );

} )();

var effect = $.effects;


/*!
 * jQuery UI Effects Blind 1.12.0
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Blind Effect
//>>group: Effects
//>>description: Blinds the element.
//>>docs: http://api.jqueryui.com/blind-effect/
//>>demos: http://jqueryui.com/effect/



var effectsEffectBlind = $.effects.define( "blind", "hide", function( options, done ) {
	var map = {
			up: [ "bottom", "top" ],
			vertical: [ "bottom", "top" ],
			down: [ "top", "bottom" ],
			left: [ "right", "left" ],
			horizontal: [ "right", "left" ],
			right: [ "left", "right" ]
		},
		element = $( this ),
		direction = options.direction || "up",
		start = element.cssClip(),
		animate = { clip: $.extend( {}, start ) },
		placeholder = $.effects.createPlaceholder( element );

	animate.clip[ map[ direction ][ 0 ] ] = animate.clip[ map[ direction ][ 1 ] ];

	if ( options.mode === "show" ) {
		element.cssClip( animate.clip );
		if ( placeholder ) {
			placeholder.css( $.effects.clipToBox( animate ) );
		}

		animate.clip = start;
	}

	if ( placeholder ) {
		placeholder.animate( $.effects.clipToBox( animate ), options.duration, options.easing );
	}

	element.animate( animate, {
		queue: false,
		duration: options.duration,
		easing: options.easing,
		complete: done
	} );
} );


/*!
 * jQuery UI Effects Bounce 1.12.0
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Bounce Effect
//>>group: Effects
//>>description: Bounces an element horizontally or vertically n times.
//>>docs: http://api.jqueryui.com/bounce-effect/
//>>demos: http://jqueryui.com/effect/



var effectsEffectBounce = $.effects.define( "bounce", function( options, done ) {
	var upAnim, downAnim, refValue,
		element = $( this ),

		// Defaults:
		mode = options.mode,
		hide = mode === "hide",
		show = mode === "show",
		direction = options.direction || "up",
		distance = options.distance,
		times = options.times || 5,

		// Number of internal animations
		anims = times * 2 + ( show || hide ? 1 : 0 ),
		speed = options.duration / anims,
		easing = options.easing,

		// Utility:
		ref = ( direction === "up" || direction === "down" ) ? "top" : "left",
		motion = ( direction === "up" || direction === "left" ),
		i = 0,

		queuelen = element.queue().length;

	$.effects.createPlaceholder( element );

	refValue = element.css( ref );

	// Default distance for the BIGGEST bounce is the outer Distance / 3
	if ( !distance ) {
		distance = element[ ref === "top" ? "outerHeight" : "outerWidth" ]() / 3;
	}

	if ( show ) {
		downAnim = { opacity: 1 };
		downAnim[ ref ] = refValue;

		// If we are showing, force opacity 0 and set the initial position
		// then do the "first" animation
		element
			.css( "opacity", 0 )
			.css( ref, motion ? -distance * 2 : distance * 2 )
			.animate( downAnim, speed, easing );
	}

	// Start at the smallest distance if we are hiding
	if ( hide ) {
		distance = distance / Math.pow( 2, times - 1 );
	}

	downAnim = {};
	downAnim[ ref ] = refValue;

	// Bounces up/down/left/right then back to 0 -- times * 2 animations happen here
	for ( ; i < times; i++ ) {
		upAnim = {};
		upAnim[ ref ] = ( motion ? "-=" : "+=" ) + distance;

		element
			.animate( upAnim, speed, easing )
			.animate( downAnim, speed, easing );

		distance = hide ? distance * 2 : distance / 2;
	}

	// Last Bounce when Hiding
	if ( hide ) {
		upAnim = { opacity: 0 };
		upAnim[ ref ] = ( motion ? "-=" : "+=" ) + distance;

		element.animate( upAnim, speed, easing );
	}

	element.queue( done );

	$.effects.unshift( element, queuelen, anims + 1 );
} );


/*!
 * jQuery UI Effects Clip 1.12.0
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Clip Effect
//>>group: Effects
//>>description: Clips the element on and off like an old TV.
//>>docs: http://api.jqueryui.com/clip-effect/
//>>demos: http://jqueryui.com/effect/



var effectsEffectClip = $.effects.define( "clip", "hide", function( options, done ) {
	var start,
		animate = {},
		element = $( this ),
		direction = options.direction || "vertical",
		both = direction === "both",
		horizontal = both || direction === "horizontal",
		vertical = both || direction === "vertical";

	start = element.cssClip();
	animate.clip = {
		top: vertical ? ( start.bottom - start.top ) / 2 : start.top,
		right: horizontal ? ( start.right - start.left ) / 2 : start.right,
		bottom: vertical ? ( start.bottom - start.top ) / 2 : start.bottom,
		left: horizontal ? ( start.right - start.left ) / 2 : start.left
	};

	$.effects.createPlaceholder( element );

	if ( options.mode === "show" ) {
		element.cssClip( animate.clip );
		animate.clip = start;
	}

	element.animate( animate, {
		queue: false,
		duration: options.duration,
		easing: options.easing,
		complete: done
	} );

} );


/*!
 * jQuery UI Effects Drop 1.12.0
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Drop Effect
//>>group: Effects
//>>description: Moves an element in one direction and hides it at the same time.
//>>docs: http://api.jqueryui.com/drop-effect/
//>>demos: http://jqueryui.com/effect/



var effectsEffectDrop = $.effects.define( "drop", "hide", function( options, done ) {

	var distance,
		element = $( this ),
		mode = options.mode,
		show = mode === "show",
		direction = options.direction || "left",
		ref = ( direction === "up" || direction === "down" ) ? "top" : "left",
		motion = ( direction === "up" || direction === "left" ) ? "-=" : "+=",
		oppositeMotion = ( motion === "+=" ) ? "-=" : "+=",
		animation = {
			opacity: 0
		};

	$.effects.createPlaceholder( element );

	distance = options.distance ||
		element[ ref === "top" ? "outerHeight" : "outerWidth" ]( true ) / 2;

	animation[ ref ] = motion + distance;

	if ( show ) {
		element.css( animation );

		animation[ ref ] = oppositeMotion + distance;
		animation.opacity = 1;
	}

	// Animate
	element.animate( animation, {
		queue: false,
		duration: options.duration,
		easing: options.easing,
		complete: done
	} );
} );


/*!
 * jQuery UI Effects Explode 1.12.0
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Explode Effect
//>>group: Effects
// jscs:disable maximumLineLength
//>>description: Explodes an element in all directions into n pieces. Implodes an element to its original wholeness.
// jscs:enable maximumLineLength
//>>docs: http://api.jqueryui.com/explode-effect/
//>>demos: http://jqueryui.com/effect/



var effectsEffectExplode = $.effects.define( "explode", "hide", function( options, done ) {

	var i, j, left, top, mx, my,
		rows = options.pieces ? Math.round( Math.sqrt( options.pieces ) ) : 3,
		cells = rows,
		element = $( this ),
		mode = options.mode,
		show = mode === "show",

		// Show and then visibility:hidden the element before calculating offset
		offset = element.show().css( "visibility", "hidden" ).offset(),

		// Width and height of a piece
		width = Math.ceil( element.outerWidth() / cells ),
		height = Math.ceil( element.outerHeight() / rows ),
		pieces = [];

	// Children animate complete:
	function childComplete() {
		pieces.push( this );
		if ( pieces.length === rows * cells ) {
			animComplete();
		}
	}

	// Clone the element for each row and cell.
	for ( i = 0; i < rows; i++ ) { // ===>
		top = offset.top + i * height;
		my = i - ( rows - 1 ) / 2;

		for ( j = 0; j < cells; j++ ) { // |||
			left = offset.left + j * width;
			mx = j - ( cells - 1 ) / 2;

			// Create a clone of the now hidden main element that will be absolute positioned
			// within a wrapper div off the -left and -top equal to size of our pieces
			element
				.clone()
				.appendTo( "body" )
				.wrap( "<div></div>" )
				.css( {
					position: "absolute",
					visibility: "visible",
					left: -j * width,
					top: -i * height
				} )

				// Select the wrapper - make it overflow: hidden and absolute positioned based on
				// where the original was located +left and +top equal to the size of pieces
				.parent()
					.addClass( "ui-effects-explode" )
					.css( {
						position: "absolute",
						overflow: "hidden",
						width: width,
						height: height,
						left: left + ( show ? mx * width : 0 ),
						top: top + ( show ? my * height : 0 ),
						opacity: show ? 0 : 1
					} )
					.animate( {
						left: left + ( show ? 0 : mx * width ),
						top: top + ( show ? 0 : my * height ),
						opacity: show ? 1 : 0
					}, options.duration || 500, options.easing, childComplete );
		}
	}

	function animComplete() {
		element.css( {
			visibility: "visible"
		} );
		$( pieces ).remove();
		done();
	}
} );


/*!
 * jQuery UI Effects Fade 1.12.0
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Fade Effect
//>>group: Effects
//>>description: Fades the element.
//>>docs: http://api.jqueryui.com/fade-effect/
//>>demos: http://jqueryui.com/effect/



var effectsEffectFade = $.effects.define( "fade", "toggle", function( options, done ) {
	var show = options.mode === "show";

	$( this )
		.css( "opacity", show ? 0 : 1 )
		.animate( {
			opacity: show ? 1 : 0
		}, {
			queue: false,
			duration: options.duration,
			easing: options.easing,
			complete: done
		} );
} );


/*!
 * jQuery UI Effects Fold 1.12.0
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Fold Effect
//>>group: Effects
//>>description: Folds an element first horizontally and then vertically.
//>>docs: http://api.jqueryui.com/fold-effect/
//>>demos: http://jqueryui.com/effect/



var effectsEffectFold = $.effects.define( "fold", "hide", function( options, done ) {

	// Create element
	var element = $( this ),
		mode = options.mode,
		show = mode === "show",
		hide = mode === "hide",
		size = options.size || 15,
		percent = /([0-9]+)%/.exec( size ),
		horizFirst = !!options.horizFirst,
		ref = horizFirst ? [ "right", "bottom" ] : [ "bottom", "right" ],
		duration = options.duration / 2,

		placeholder = $.effects.createPlaceholder( element ),

		start = element.cssClip(),
		animation1 = { clip: $.extend( {}, start ) },
		animation2 = { clip: $.extend( {}, start ) },

		distance = [ start[ ref[ 0 ] ], start[ ref[ 1 ] ] ],

		queuelen = element.queue().length;

	if ( percent ) {
		size = parseInt( percent[ 1 ], 10 ) / 100 * distance[ hide ? 0 : 1 ];
	}
	animation1.clip[ ref[ 0 ] ] = size;
	animation2.clip[ ref[ 0 ] ] = size;
	animation2.clip[ ref[ 1 ] ] = 0;

	if ( show ) {
		element.cssClip( animation2.clip );
		if ( placeholder ) {
			placeholder.css( $.effects.clipToBox( animation2 ) );
		}

		animation2.clip = start;
	}

	// Animate
	element
		.queue( function( next ) {
			if ( placeholder ) {
				placeholder
					.animate( $.effects.clipToBox( animation1 ), duration, options.easing )
					.animate( $.effects.clipToBox( animation2 ), duration, options.easing );
			}

			next();
		} )
		.animate( animation1, duration, options.easing )
		.animate( animation2, duration, options.easing )
		.queue( done );

	$.effects.unshift( element, queuelen, 4 );
} );


/*!
 * jQuery UI Effects Highlight 1.12.0
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Highlight Effect
//>>group: Effects
//>>description: Highlights the background of an element in a defined color for a custom duration.
//>>docs: http://api.jqueryui.com/highlight-effect/
//>>demos: http://jqueryui.com/effect/



var effectsEffectHighlight = $.effects.define( "highlight", "show", function( options, done ) {
	var element = $( this ),
		animation = {
			backgroundColor: element.css( "backgroundColor" )
		};

	if ( options.mode === "hide" ) {
		animation.opacity = 0;
	}

	$.effects.saveStyle( element );

	element
		.css( {
			backgroundImage: "none",
			backgroundColor: options.color || "#ffff99"
		} )
		.animate( animation, {
			queue: false,
			duration: options.duration,
			easing: options.easing,
			complete: done
		} );
} );


/*!
 * jQuery UI Effects Size 1.12.0
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Size Effect
//>>group: Effects
//>>description: Resize an element to a specified width and height.
//>>docs: http://api.jqueryui.com/size-effect/
//>>demos: http://jqueryui.com/effect/



var effectsEffectSize = $.effects.define( "size", function( options, done ) {

	// Create element
	var baseline, factor, temp,
		element = $( this ),

		// Copy for children
		cProps = [ "fontSize" ],
		vProps = [ "borderTopWidth", "borderBottomWidth", "paddingTop", "paddingBottom" ],
		hProps = [ "borderLeftWidth", "borderRightWidth", "paddingLeft", "paddingRight" ],

		// Set options
		mode = options.mode,
		restore = mode !== "effect",
		scale = options.scale || "both",
		origin = options.origin || [ "middle", "center" ],
		position = element.css( "position" ),
		pos = element.position(),
		original = $.effects.scaledDimensions( element ),
		from = options.from || original,
		to = options.to || $.effects.scaledDimensions( element, 0 );

	$.effects.createPlaceholder( element );

	if ( mode === "show" ) {
		temp = from;
		from = to;
		to = temp;
	}

	// Set scaling factor
	factor = {
		from: {
			y: from.height / original.height,
			x: from.width / original.width
		},
		to: {
			y: to.height / original.height,
			x: to.width / original.width
		}
	};

	// Scale the css box
	if ( scale === "box" || scale === "both" ) {

		// Vertical props scaling
		if ( factor.from.y !== factor.to.y ) {
			from = $.effects.setTransition( element, vProps, factor.from.y, from );
			to = $.effects.setTransition( element, vProps, factor.to.y, to );
		}

		// Horizontal props scaling
		if ( factor.from.x !== factor.to.x ) {
			from = $.effects.setTransition( element, hProps, factor.from.x, from );
			to = $.effects.setTransition( element, hProps, factor.to.x, to );
		}
	}

	// Scale the content
	if ( scale === "content" || scale === "both" ) {

		// Vertical props scaling
		if ( factor.from.y !== factor.to.y ) {
			from = $.effects.setTransition( element, cProps, factor.from.y, from );
			to = $.effects.setTransition( element, cProps, factor.to.y, to );
		}
	}

	// Adjust the position properties based on the provided origin points
	if ( origin ) {
		baseline = $.effects.getBaseline( origin, original );
		from.top = ( original.outerHeight - from.outerHeight ) * baseline.y + pos.top;
		from.left = ( original.outerWidth - from.outerWidth ) * baseline.x + pos.left;
		to.top = ( original.outerHeight - to.outerHeight ) * baseline.y + pos.top;
		to.left = ( original.outerWidth - to.outerWidth ) * baseline.x + pos.left;
	}
	element.css( from );

	// Animate the children if desired
	if ( scale === "content" || scale === "both" ) {

		vProps = vProps.concat( [ "marginTop", "marginBottom" ] ).concat( cProps );
		hProps = hProps.concat( [ "marginLeft", "marginRight" ] );

		// Only animate children with width attributes specified
		// TODO: is this right? should we include anything with css width specified as well
		element.find( "*[width]" ).each( function() {
			var child = $( this ),
				childOriginal = $.effects.scaledDimensions( child ),
				childFrom = {
					height: childOriginal.height * factor.from.y,
					width: childOriginal.width * factor.from.x,
					outerHeight: childOriginal.outerHeight * factor.from.y,
					outerWidth: childOriginal.outerWidth * factor.from.x
				},
				childTo = {
					height: childOriginal.height * factor.to.y,
					width: childOriginal.width * factor.to.x,
					outerHeight: childOriginal.height * factor.to.y,
					outerWidth: childOriginal.width * factor.to.x
				};

			// Vertical props scaling
			if ( factor.from.y !== factor.to.y ) {
				childFrom = $.effects.setTransition( child, vProps, factor.from.y, childFrom );
				childTo = $.effects.setTransition( child, vProps, factor.to.y, childTo );
			}

			// Horizontal props scaling
			if ( factor.from.x !== factor.to.x ) {
				childFrom = $.effects.setTransition( child, hProps, factor.from.x, childFrom );
				childTo = $.effects.setTransition( child, hProps, factor.to.x, childTo );
			}

			if ( restore ) {
				$.effects.saveStyle( child );
			}

			// Animate children
			child.css( childFrom );
			child.animate( childTo, options.duration, options.easing, function() {

				// Restore children
				if ( restore ) {
					$.effects.restoreStyle( child );
				}
			} );
		} );
	}

	// Animate
	element.animate( to, {
		queue: false,
		duration: options.duration,
		easing: options.easing,
		complete: function() {

			var offset = element.offset();

			if ( to.opacity === 0 ) {
				element.css( "opacity", from.opacity );
			}

			if ( !restore ) {
				element
					.css( "position", position === "static" ? "relative" : position )
					.offset( offset );

				// Need to save style here so that automatic style restoration
				// doesn't restore to the original styles from before the animation.
				$.effects.saveStyle( element );
			}

			done();
		}
	} );

} );


/*!
 * jQuery UI Effects Scale 1.12.0
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Scale Effect
//>>group: Effects
//>>description: Grows or shrinks an element and its content.
//>>docs: http://api.jqueryui.com/scale-effect/
//>>demos: http://jqueryui.com/effect/



var effectsEffectScale = $.effects.define( "scale", function( options, done ) {

	// Create element
	var el = $( this ),
		mode = options.mode,
		percent = parseInt( options.percent, 10 ) ||
			( parseInt( options.percent, 10 ) === 0 ? 0 : ( mode !== "effect" ? 0 : 100 ) ),

		newOptions = $.extend( true, {
			from: $.effects.scaledDimensions( el ),
			to: $.effects.scaledDimensions( el, percent, options.direction || "both" ),
			origin: options.origin || [ "middle", "center" ]
		}, options );

	// Fade option to support puff
	if ( options.fade ) {
		newOptions.from.opacity = 1;
		newOptions.to.opacity = 0;
	}

	$.effects.effect.size.call( this, newOptions, done );
} );


/*!
 * jQuery UI Effects Puff 1.12.0
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Puff Effect
//>>group: Effects
//>>description: Creates a puff effect by scaling the element up and hiding it at the same time.
//>>docs: http://api.jqueryui.com/puff-effect/
//>>demos: http://jqueryui.com/effect/



var effectsEffectPuff = $.effects.define( "puff", "hide", function( options, done ) {
	var newOptions = $.extend( true, {}, options, {
		fade: true,
		percent: parseInt( options.percent, 10 ) || 150
	} );

	$.effects.effect.scale.call( this, newOptions, done );
} );


/*!
 * jQuery UI Effects Pulsate 1.12.0
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Pulsate Effect
//>>group: Effects
//>>description: Pulsates an element n times by changing the opacity to zero and back.
//>>docs: http://api.jqueryui.com/pulsate-effect/
//>>demos: http://jqueryui.com/effect/



var effectsEffectPulsate = $.effects.define( "pulsate", "show", function( options, done ) {
	var element = $( this ),
		mode = options.mode,
		show = mode === "show",
		hide = mode === "hide",
		showhide = show || hide,

		// Showing or hiding leaves off the "last" animation
		anims = ( ( options.times || 5 ) * 2 ) + ( showhide ? 1 : 0 ),
		duration = options.duration / anims,
		animateTo = 0,
		i = 1,
		queuelen = element.queue().length;

	if ( show || !element.is( ":visible" ) ) {
		element.css( "opacity", 0 ).show();
		animateTo = 1;
	}

	// Anims - 1 opacity "toggles"
	for ( ; i < anims; i++ ) {
		element.animate( { opacity: animateTo }, duration, options.easing );
		animateTo = 1 - animateTo;
	}

	element.animate( { opacity: animateTo }, duration, options.easing );

	element.queue( done );

	$.effects.unshift( element, queuelen, anims + 1 );
} );


/*!
 * jQuery UI Effects Shake 1.12.0
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Shake Effect
//>>group: Effects
//>>description: Shakes an element horizontally or vertically n times.
//>>docs: http://api.jqueryui.com/shake-effect/
//>>demos: http://jqueryui.com/effect/



var effectsEffectShake = $.effects.define( "shake", function( options, done ) {

	var i = 1,
		element = $( this ),
		direction = options.direction || "left",
		distance = options.distance || 20,
		times = options.times || 3,
		anims = times * 2 + 1,
		speed = Math.round( options.duration / anims ),
		ref = ( direction === "up" || direction === "down" ) ? "top" : "left",
		positiveMotion = ( direction === "up" || direction === "left" ),
		animation = {},
		animation1 = {},
		animation2 = {},

		queuelen = element.queue().length;

	$.effects.createPlaceholder( element );

	// Animation
	animation[ ref ] = ( positiveMotion ? "-=" : "+=" ) + distance;
	animation1[ ref ] = ( positiveMotion ? "+=" : "-=" ) + distance * 2;
	animation2[ ref ] = ( positiveMotion ? "-=" : "+=" ) + distance * 2;

	// Animate
	element.animate( animation, speed, options.easing );

	// Shakes
	for ( ; i < times; i++ ) {
		element
			.animate( animation1, speed, options.easing )
			.animate( animation2, speed, options.easing );
	}

	element
		.animate( animation1, speed, options.easing )
		.animate( animation, speed / 2, options.easing )
		.queue( done );

	$.effects.unshift( element, queuelen, anims + 1 );
} );


/*!
 * jQuery UI Effects Slide 1.12.0
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Slide Effect
//>>group: Effects
//>>description: Slides an element in and out of the viewport.
//>>docs: http://api.jqueryui.com/slide-effect/
//>>demos: http://jqueryui.com/effect/



var effectsEffectSlide = $.effects.define( "slide", "show", function( options, done ) {
	var startClip, startRef,
		element = $( this ),
		map = {
			up: [ "bottom", "top" ],
			down: [ "top", "bottom" ],
			left: [ "right", "left" ],
			right: [ "left", "right" ]
		},
		mode = options.mode,
		direction = options.direction || "left",
		ref = ( direction === "up" || direction === "down" ) ? "top" : "left",
		positiveMotion = ( direction === "up" || direction === "left" ),
		distance = options.distance ||
			element[ ref === "top" ? "outerHeight" : "outerWidth" ]( true ),
		animation = {};

	$.effects.createPlaceholder( element );

	startClip = element.cssClip();
	startRef = element.position()[ ref ];

	// Define hide animation
	animation[ ref ] = ( positiveMotion ? -1 : 1 ) * distance + startRef;
	animation.clip = element.cssClip();
	animation.clip[ map[ direction ][ 1 ] ] = animation.clip[ map[ direction ][ 0 ] ];

	// Reverse the animation if we're showing
	if ( mode === "show" ) {
		element.cssClip( animation.clip );
		element.css( ref, animation[ ref ] );
		animation.clip = startClip;
		animation[ ref ] = startRef;
	}

	// Actually animate
	element.animate( animation, {
		queue: false,
		duration: options.duration,
		easing: options.easing,
		complete: done
	} );
} );


/*!
 * jQuery UI Effects Transfer 1.12.0
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Transfer Effect
//>>group: Effects
//>>description: Displays a transfer effect from one element to another.
//>>docs: http://api.jqueryui.com/transfer-effect/
//>>demos: http://jqueryui.com/effect/



var effect;
if ( $.uiBackCompat !== false ) {
	effect = $.effects.define( "transfer", function( options, done ) {
		$( this ).transfer( options, done );
	} );
}
var effectsEffectTransfer = effect;


/*!
 * jQuery UI Focusable 1.12.0
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: :focusable Selector
//>>group: Core
//>>description: Selects elements which can be focused.
//>>docs: http://api.jqueryui.com/focusable-selector/



// Selectors
$.ui.focusable = function( element, hasTabindex ) {
	var map, mapName, img, focusableIfVisible, fieldset,
		nodeName = element.nodeName.toLowerCase();

	if ( "area" === nodeName ) {
		map = element.parentNode;
		mapName = map.name;
		if ( !element.href || !mapName || map.nodeName.toLowerCase() !== "map" ) {
			return false;
		}
		img = $( "img[usemap='#" + mapName + "']" );
		return img.length > 0 && img.is( ":visible" );
	}

	if ( /^(input|select|textarea|button|object)$/.test( nodeName ) ) {
		focusableIfVisible = !element.disabled;

		if ( focusableIfVisible ) {

			// Form controls within a disabled fieldset are disabled.
			// However, controls within the fieldset's legend do not get disabled.
			// Since controls generally aren't placed inside legends, we skip
			// this portion of the check.
			fieldset = $( element ).closest( "fieldset" )[ 0 ];
			if ( fieldset ) {
				focusableIfVisible = !fieldset.disabled;
			}
		}
	} else if ( "a" === nodeName ) {
		focusableIfVisible = element.href || hasTabindex;
	} else {
		focusableIfVisible = hasTabindex;
	}

	return focusableIfVisible && $( element ).is( ":visible" ) && visible( $( element ) );
};

// Support: IE 8 only
// IE 8 doesn't resolve inherit to visible/hidden for computed values
function visible( element ) {
	var visibility = element.css( "visibility" );
	while ( visibility === "inherit" ) {
		element = element.parent();
		visibility = element.css( "visibility" );
	}
	return visibility !== "hidden";
}

$.extend( $.expr[ ":" ], {
	focusable: function( element ) {
		return $.ui.focusable( element, $.attr( element, "tabindex" ) != null );
	}
} );

var focusable = $.ui.focusable;




// Support: IE8 Only
// IE8 does not support the form attribute and when it is supplied. It overwrites the form prop
// with a string, so we need to find the proper form.
var form = $.fn.form = function() {
	return typeof this[ 0 ].form === "string" ? this.closest( "form" ) : $( this[ 0 ].form );
};


/*!
 * jQuery UI Form Reset Mixin 1.12.0
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Form Reset Mixin
//>>group: Core
//>>description: Refresh input widgets when their form is reset
//>>docs: http://api.jqueryui.com/form-reset-mixin/



var formResetMixin = $.ui.formResetMixin = {
	_formResetHandler: function() {
		var form = $( this );

		// Wait for the form reset to actually happen before refreshing
		setTimeout( function() {
			var instances = form.data( "ui-form-reset-instances" );
			$.each( instances, function() {
				this.refresh();
			} );
		} );
	},

	_bindFormResetHandler: function() {
		this.form = this.element.form();
		if ( !this.form.length ) {
			return;
		}

		var instances = this.form.data( "ui-form-reset-instances" ) || [];
		if ( !instances.length ) {

			// We don't use _on() here because we use a single event handler per form
			this.form.on( "reset.ui-form-reset", this._formResetHandler );
		}
		instances.push( this );
		this.form.data( "ui-form-reset-instances", instances );
	},

	_unbindFormResetHandler: function() {
		if ( !this.form.length ) {
			return;
		}

		var instances = this.form.data( "ui-form-reset-instances" );
		instances.splice( $.inArray( this, instances ), 1 );
		if ( instances.length ) {
			this.form.data( "ui-form-reset-instances", instances );
		} else {
			this.form
				.removeData( "ui-form-reset-instances" )
				.off( "reset.ui-form-reset" );
		}
	}
};


/*!
 * jQuery UI Support for jQuery core 1.7.x 1.12.0
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 */

//>>label: jQuery 1.7 Support
//>>group: Core
//>>description: Support version 1.7.x of jQuery core



// Support: jQuery 1.7 only
// Not a great way to check versions, but since we only support 1.7+ and only
// need to detect <1.8, this is a simple check that should suffice. Checking
// for "1.7." would be a bit safer, but the version string is 1.7, not 1.7.0
// and we'll never reach 1.70.0 (if we do, we certainly won't be supporting
// 1.7 anymore). See #11197 for why we're not using feature detection.
if ( $.fn.jquery.substring( 0, 3 ) === "1.7" ) {

	// Setters for .innerWidth(), .innerHeight(), .outerWidth(), .outerHeight()
	// Unlike jQuery Core 1.8+, these only support numeric values to set the
	// dimensions in pixels
	$.each( [ "Width", "Height" ], function( i, name ) {
		var side = name === "Width" ? [ "Left", "Right" ] : [ "Top", "Bottom" ],
			type = name.toLowerCase(),
			orig = {
				innerWidth: $.fn.innerWidth,
				innerHeight: $.fn.innerHeight,
				outerWidth: $.fn.outerWidth,
				outerHeight: $.fn.outerHeight
			};

		function reduce( elem, size, border, margin ) {
			$.each( side, function() {
				size -= parseFloat( $.css( elem, "padding" + this ) ) || 0;
				if ( border ) {
					size -= parseFloat( $.css( elem, "border" + this + "Width" ) ) || 0;
				}
				if ( margin ) {
					size -= parseFloat( $.css( elem, "margin" + this ) ) || 0;
				}
			} );
			return size;
		}

		$.fn[ "inner" + name ] = function( size ) {
			if ( size === undefined ) {
				return orig[ "inner" + name ].call( this );
			}

			return this.each( function() {
				$( this ).css( type, reduce( this, size ) + "px" );
			} );
		};

		$.fn[ "outer" + name ] = function( size, margin ) {
			if ( typeof size !== "number" ) {
				return orig[ "outer" + name ].call( this, size );
			}

			return this.each( function() {
				$( this ).css( type, reduce( this, size, true, margin ) + "px" );
			} );
		};
	} );

	$.fn.addBack = function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter( selector )
		);
	};
}

;
/*!
 * jQuery UI Keycode 1.12.0
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Keycode
//>>group: Core
//>>description: Provide keycodes as keynames
//>>docs: http://api.jqueryui.com/jQuery.ui.keyCode/


var keycode = $.ui.keyCode = {
	BACKSPACE: 8,
	COMMA: 188,
	DELETE: 46,
	DOWN: 40,
	END: 35,
	ENTER: 13,
	ESCAPE: 27,
	HOME: 36,
	LEFT: 37,
	PAGE_DOWN: 34,
	PAGE_UP: 33,
	PERIOD: 190,
	RIGHT: 39,
	SPACE: 32,
	TAB: 9,
	UP: 38
};




// Internal use only
var escapeSelector = $.ui.escapeSelector = ( function() {
	var selectorEscape = /([!"#$%&'()*+,./:;<=>?@[\]^`{|}~])/g;
	return function( selector ) {
		return selector.replace( selectorEscape, "\\$1" );
	};
} )();


/*!
 * jQuery UI Labels 1.12.0
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: labels
//>>group: Core
//>>description: Find all the labels associated with a given input
//>>docs: http://api.jqueryui.com/labels/



var labels = $.fn.labels = function() {
	var ancestor, selector, id, labels, ancestors;

	// Check control.labels first
	if ( this[ 0 ].labels && this[ 0 ].labels.length ) {
		return this.pushStack( this[ 0 ].labels );
	}

	// Support: IE <= 11, FF <= 37, Android <= 2.3 only
	// Above browsers do not support control.labels. Everything below is to support them
	// as well as document fragments. control.labels does not work on document fragments
	labels = this.eq( 0 ).parents( "label" );

	// Look for the label based on the id
	id = this.attr( "id" );
	if ( id ) {

		// We don't search against the document in case the element
		// is disconnected from the DOM
		ancestor = this.eq( 0 ).parents().last();

		// Get a full set of top level ancestors
		ancestors = ancestor.add( ancestor.length ? ancestor.siblings() : this.siblings() );

		// Create a selector for the label based on the id
		selector = "label[for='" + $.ui.escapeSelector( id ) + "']";

		labels = labels.add( ancestors.find( selector ).addBack( selector ) );

	}

	// Return whatever we have found for labels
	return this.pushStack( labels );
};


/*!
 * jQuery UI Scroll Parent 1.12.0
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: scrollParent
//>>group: Core
//>>description: Get the closest ancestor element that is scrollable.
//>>docs: http://api.jqueryui.com/scrollParent/



var scrollParent = $.fn.scrollParent = function( includeHidden ) {
	var position = this.css( "position" ),
		excludeStaticParent = position === "absolute",
		overflowRegex = includeHidden ? /(auto|scroll|hidden)/ : /(auto|scroll)/,
		scrollParent = this.parents().filter( function() {
			var parent = $( this );
			if ( excludeStaticParent && parent.css( "position" ) === "static" ) {
				return false;
			}
			return overflowRegex.test( parent.css( "overflow" ) + parent.css( "overflow-y" ) +
				parent.css( "overflow-x" ) );
		} ).eq( 0 );

	return position === "fixed" || !scrollParent.length ?
		$( this[ 0 ].ownerDocument || document ) :
		scrollParent;
};


/*!
 * jQuery UI Tabbable 1.12.0
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: :tabbable Selector
//>>group: Core
//>>description: Selects elements which can be tabbed to.
//>>docs: http://api.jqueryui.com/tabbable-selector/



var tabbable = $.extend( $.expr[ ":" ], {
	tabbable: function( element ) {
		var tabIndex = $.attr( element, "tabindex" ),
			hasTabindex = tabIndex != null;
		return ( !hasTabindex || tabIndex >= 0 ) && $.ui.focusable( element, hasTabindex );
	}
} );


/*!
 * jQuery UI Unique ID 1.12.0
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: uniqueId
//>>group: Core
//>>description: Functions to generate and remove uniqueId's
//>>docs: http://api.jqueryui.com/uniqueId/



var uniqueId = $.fn.extend( {
	uniqueId: ( function() {
		var uuid = 0;

		return function() {
			return this.each( function() {
				if ( !this.id ) {
					this.id = "ui-id-" + ( ++uuid );
				}
			} );
		};
	} )(),

	removeUniqueId: function() {
		return this.each( function() {
			if ( /^ui-id-\d+$/.test( this.id ) ) {
				$( this ).removeAttr( "id" );
			}
		} );
	}
} );


/*!
 * jQuery UI Accordion 1.12.0
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Accordion
//>>group: Widgets
// jscs:disable maximumLineLength
//>>description: Displays collapsible content panels for presenting information in a limited amount of space.
// jscs:enable maximumLineLength
//>>docs: http://api.jqueryui.com/accordion/
//>>demos: http://jqueryui.com/accordion/
//>>css.structure: ../../themes/base/core.css
//>>css.structure: ../../themes/base/accordion.css
//>>css.theme: ../../themes/base/theme.css



var widgetsAccordion = $.widget( "ui.accordion", {
	version: "1.12.0",
	options: {
		active: 0,
		animate: {},
		classes: {
			"ui-accordion-header": "ui-corner-top",
			"ui-accordion-header-collapsed": "ui-corner-all",
			"ui-accordion-content": "ui-corner-bottom"
		},
		collapsible: false,
		event: "click",
		header: "> li > :first-child, > :not(li):even",
		heightStyle: "auto",
		icons: {
			activeHeader: "ui-icon-triangle-1-s",
			header: "ui-icon-triangle-1-e"
		},

		// Callbacks
		activate: null,
		beforeActivate: null
	},

	hideProps: {
		borderTopWidth: "hide",
		borderBottomWidth: "hide",
		paddingTop: "hide",
		paddingBottom: "hide",
		height: "hide"
	},

	showProps: {
		borderTopWidth: "show",
		borderBottomWidth: "show",
		paddingTop: "show",
		paddingBottom: "show",
		height: "show"
	},

	_create: function() {
		var options = this.options;

		this.prevShow = this.prevHide = $();
		this._addClass( "ui-accordion", "ui-widget ui-helper-reset" );
		this.element.attr( "role", "tablist" );

		// Don't allow collapsible: false and active: false / null
		if ( !options.collapsible && ( options.active === false || options.active == null ) ) {
			options.active = 0;
		}

		this._processPanels();

		// handle negative values
		if ( options.active < 0 ) {
			options.active += this.headers.length;
		}
		this._refresh();
	},

	_getCreateEventData: function() {
		return {
			header: this.active,
			panel: !this.active.length ? $() : this.active.next()
		};
	},

	_createIcons: function() {
		var icon, children,
			icons = this.options.icons;

		if ( icons ) {
			icon = $( "<span>" );
			this._addClass( icon, "ui-accordion-header-icon", "ui-icon " + icons.header );
			icon.prependTo( this.headers );
			children = this.active.children( ".ui-accordion-header-icon" );
			this._removeClass( children, icons.header )
				._addClass( children, null, icons.activeHeader )
				._addClass( this.headers, "ui-accordion-icons" );
		}
	},

	_destroyIcons: function() {
		this._removeClass( this.headers, "ui-accordion-icons" );
		this.headers.children( ".ui-accordion-header-icon" ).remove();
	},

	_destroy: function() {
		var contents;

		// Clean up main element
		this.element.removeAttr( "role" );

		// Clean up headers
		this.headers
			.removeAttr( "role aria-expanded aria-selected aria-controls tabIndex" )
			.removeUniqueId();

		this._destroyIcons();

		// Clean up content panels
		contents = this.headers.next()
			.css( "display", "" )
			.removeAttr( "role aria-hidden aria-labelledby" )
			.removeUniqueId();

		if ( this.options.heightStyle !== "content" ) {
			contents.css( "height", "" );
		}
	},

	_setOption: function( key, value ) {
		if ( key === "active" ) {

			// _activate() will handle invalid values and update this.options
			this._activate( value );
			return;
		}

		if ( key === "event" ) {
			if ( this.options.event ) {
				this._off( this.headers, this.options.event );
			}
			this._setupEvents( value );
		}

		this._super( key, value );

		// Setting collapsible: false while collapsed; open first panel
		if ( key === "collapsible" && !value && this.options.active === false ) {
			this._activate( 0 );
		}

		if ( key === "icons" ) {
			this._destroyIcons();
			if ( value ) {
				this._createIcons();
			}
		}
	},

	_setOptionDisabled: function( value ) {
		this._super( value );

		this.element.attr( "aria-disabled", value );

		// Support: IE8 Only
		// #5332 / #6059 - opacity doesn't cascade to positioned elements in IE
		// so we need to add the disabled class to the headers and panels
		this._toggleClass( null, "ui-state-disabled", !!value );
		this._toggleClass( this.headers.add( this.headers.next() ), null, "ui-state-disabled",
			!!value );
	},

	_keydown: function( event ) {
		if ( event.altKey || event.ctrlKey ) {
			return;
		}

		var keyCode = $.ui.keyCode,
			length = this.headers.length,
			currentIndex = this.headers.index( event.target ),
			toFocus = false;

		switch ( event.keyCode ) {
		case keyCode.RIGHT:
		case keyCode.DOWN:
			toFocus = this.headers[ ( currentIndex + 1 ) % length ];
			break;
		case keyCode.LEFT:
		case keyCode.UP:
			toFocus = this.headers[ ( currentIndex - 1 + length ) % length ];
			break;
		case keyCode.SPACE:
		case keyCode.ENTER:
			this._eventHandler( event );
			break;
		case keyCode.HOME:
			toFocus = this.headers[ 0 ];
			break;
		case keyCode.END:
			toFocus = this.headers[ length - 1 ];
			break;
		}

		if ( toFocus ) {
			$( event.target ).attr( "tabIndex", -1 );
			$( toFocus ).attr( "tabIndex", 0 );
			$( toFocus ).trigger( "focus" );
			event.preventDefault();
		}
	},

	_panelKeyDown: function( event ) {
		if ( event.keyCode === $.ui.keyCode.UP && event.ctrlKey ) {
			$( event.currentTarget ).prev().trigger( "focus" );
		}
	},

	refresh: function() {
		var options = this.options;
		this._processPanels();

		// Was collapsed or no panel
		if ( ( options.active === false && options.collapsible === true ) ||
				!this.headers.length ) {
			options.active = false;
			this.active = $();

		// active false only when collapsible is true
		} else if ( options.active === false ) {
			this._activate( 0 );

		// was active, but active panel is gone
		} else if ( this.active.length && !$.contains( this.element[ 0 ], this.active[ 0 ] ) ) {

			// all remaining panel are disabled
			if ( this.headers.length === this.headers.find( ".ui-state-disabled" ).length ) {
				options.active = false;
				this.active = $();

			// activate previous panel
			} else {
				this._activate( Math.max( 0, options.active - 1 ) );
			}

		// was active, active panel still exists
		} else {

			// make sure active index is correct
			options.active = this.headers.index( this.active );
		}

		this._destroyIcons();

		this._refresh();
	},

	_processPanels: function() {
		var prevHeaders = this.headers,
			prevPanels = this.panels;

		this.headers = this.element.find( this.options.header );
		this._addClass( this.headers, "ui-accordion-header ui-accordion-header-collapsed",
			"ui-state-default" );

		this.panels = this.headers.next().filter( ":not(.ui-accordion-content-active)" ).hide();
		this._addClass( this.panels, "ui-accordion-content", "ui-helper-reset ui-widget-content" );

		// Avoid memory leaks (#10056)
		if ( prevPanels ) {
			this._off( prevHeaders.not( this.headers ) );
			this._off( prevPanels.not( this.panels ) );
		}
	},

	_refresh: function() {
		var maxHeight,
			options = this.options,
			heightStyle = options.heightStyle,
			parent = this.element.parent();

		this.active = this._findActive( options.active );
		this._addClass( this.active, "ui-accordion-header-active", "ui-state-active" )
			._removeClass( this.active, "ui-accordion-header-collapsed" );
		this._addClass( this.active.next(), "ui-accordion-content-active" );
		this.active.next().show();

		this.headers
			.attr( "role", "tab" )
			.each( function() {
				var header = $( this ),
					headerId = header.uniqueId().attr( "id" ),
					panel = header.next(),
					panelId = panel.uniqueId().attr( "id" );
				header.attr( "aria-controls", panelId );
				panel.attr( "aria-labelledby", headerId );
			} )
			.next()
				.attr( "role", "tabpanel" );

		this.headers
			.not( this.active )
				.attr( {
					"aria-selected": "false",
					"aria-expanded": "false",
					tabIndex: -1
				} )
				.next()
					.attr( {
						"aria-hidden": "true"
					} )
					.hide();

		// Make sure at least one header is in the tab order
		if ( !this.active.length ) {
			this.headers.eq( 0 ).attr( "tabIndex", 0 );
		} else {
			this.active.attr( {
				"aria-selected": "true",
				"aria-expanded": "true",
				tabIndex: 0
			} )
				.next()
					.attr( {
						"aria-hidden": "false"
					} );
		}

		this._createIcons();

		this._setupEvents( options.event );

		if ( heightStyle === "fill" ) {
			maxHeight = parent.height();
			this.element.siblings( ":visible" ).each( function() {
				var elem = $( this ),
					position = elem.css( "position" );

				if ( position === "absolute" || position === "fixed" ) {
					return;
				}
				maxHeight -= elem.outerHeight( true );
			} );

			this.headers.each( function() {
				maxHeight -= $( this ).outerHeight( true );
			} );

			this.headers.next()
				.each( function() {
					$( this ).height( Math.max( 0, maxHeight -
						$( this ).innerHeight() + $( this ).height() ) );
				} )
				.css( "overflow", "auto" );
		} else if ( heightStyle === "auto" ) {
			maxHeight = 0;
			this.headers.next()
				.each( function() {
					var isVisible = $( this ).is( ":visible" );
					if ( !isVisible ) {
						$( this ).show();
					}
					maxHeight = Math.max( maxHeight, $( this ).css( "height", "" ).height() );
					if ( !isVisible ) {
						$( this ).hide();
					}
				} )
				.height( maxHeight );
		}
	},

	_activate: function( index ) {
		var active = this._findActive( index )[ 0 ];

		// Trying to activate the already active panel
		if ( active === this.active[ 0 ] ) {
			return;
		}

		// Trying to collapse, simulate a click on the currently active header
		active = active || this.active[ 0 ];

		this._eventHandler( {
			target: active,
			currentTarget: active,
			preventDefault: $.noop
		} );
	},

	_findActive: function( selector ) {
		return typeof selector === "number" ? this.headers.eq( selector ) : $();
	},

	_setupEvents: function( event ) {
		var events = {
			keydown: "_keydown"
		};
		if ( event ) {
			$.each( event.split( " " ), function( index, eventName ) {
				events[ eventName ] = "_eventHandler";
			} );
		}

		this._off( this.headers.add( this.headers.next() ) );
		this._on( this.headers, events );
		this._on( this.headers.next(), { keydown: "_panelKeyDown" } );
		this._hoverable( this.headers );
		this._focusable( this.headers );
	},

	_eventHandler: function( event ) {
		var activeChildren, clickedChildren,
			options = this.options,
			active = this.active,
			clicked = $( event.currentTarget ),
			clickedIsActive = clicked[ 0 ] === active[ 0 ],
			collapsing = clickedIsActive && options.collapsible,
			toShow = collapsing ? $() : clicked.next(),
			toHide = active.next(),
			eventData = {
				oldHeader: active,
				oldPanel: toHide,
				newHeader: collapsing ? $() : clicked,
				newPanel: toShow
			};

		event.preventDefault();

		if (

				// click on active header, but not collapsible
				( clickedIsActive && !options.collapsible ) ||

				// allow canceling activation
				( this._trigger( "beforeActivate", event, eventData ) === false ) ) {
			return;
		}

		options.active = collapsing ? false : this.headers.index( clicked );

		// When the call to ._toggle() comes after the class changes
		// it causes a very odd bug in IE 8 (see #6720)
		this.active = clickedIsActive ? $() : clicked;
		this._toggle( eventData );

		// Switch classes
		// corner classes on the previously active header stay after the animation
		this._removeClass( active, "ui-accordion-header-active", "ui-state-active" );
		if ( options.icons ) {
			activeChildren = active.children( ".ui-accordion-header-icon" );
			this._removeClass( activeChildren, null, options.icons.activeHeader )
				._addClass( activeChildren, null, options.icons.header );
		}

		if ( !clickedIsActive ) {
			this._removeClass( clicked, "ui-accordion-header-collapsed" )
				._addClass( clicked, "ui-accordion-header-active", "ui-state-active" );
			if ( options.icons ) {
				clickedChildren = clicked.children( ".ui-accordion-header-icon" );
				this._removeClass( clickedChildren, null, options.icons.header )
					._addClass( clickedChildren, null, options.icons.activeHeader );
			}

			this._addClass( clicked.next(), "ui-accordion-content-active" );
		}
	},

	_toggle: function( data ) {
		var toShow = data.newPanel,
			toHide = this.prevShow.length ? this.prevShow : data.oldPanel;

		// Handle activating a panel during the animation for another activation
		this.prevShow.add( this.prevHide ).stop( true, true );
		this.prevShow = toShow;
		this.prevHide = toHide;

		if ( this.options.animate ) {
			this._animate( toShow, toHide, data );
		} else {
			toHide.hide();
			toShow.show();
			this._toggleComplete( data );
		}

		toHide.attr( {
			"aria-hidden": "true"
		} );
		toHide.prev().attr( {
			"aria-selected": "false",
			"aria-expanded": "false"
		} );

		// if we're switching panels, remove the old header from the tab order
		// if we're opening from collapsed state, remove the previous header from the tab order
		// if we're collapsing, then keep the collapsing header in the tab order
		if ( toShow.length && toHide.length ) {
			toHide.prev().attr( {
				"tabIndex": -1,
				"aria-expanded": "false"
			} );
		} else if ( toShow.length ) {
			this.headers.filter( function() {
				return parseInt( $( this ).attr( "tabIndex" ), 10 ) === 0;
			} )
				.attr( "tabIndex", -1 );
		}

		toShow
			.attr( "aria-hidden", "false" )
			.prev()
				.attr( {
					"aria-selected": "true",
					"aria-expanded": "true",
					tabIndex: 0
				} );
	},

	_animate: function( toShow, toHide, data ) {
		var total, easing, duration,
			that = this,
			adjust = 0,
			boxSizing = toShow.css( "box-sizing" ),
			down = toShow.length &&
				( !toHide.length || ( toShow.index() < toHide.index() ) ),
			animate = this.options.animate || {},
			options = down && animate.down || animate,
			complete = function() {
				that._toggleComplete( data );
			};

		if ( typeof options === "number" ) {
			duration = options;
		}
		if ( typeof options === "string" ) {
			easing = options;
		}

		// fall back from options to animation in case of partial down settings
		easing = easing || options.easing || animate.easing;
		duration = duration || options.duration || animate.duration;

		if ( !toHide.length ) {
			return toShow.animate( this.showProps, duration, easing, complete );
		}
		if ( !toShow.length ) {
			return toHide.animate( this.hideProps, duration, easing, complete );
		}

		total = toShow.show().outerHeight();
		toHide.animate( this.hideProps, {
			duration: duration,
			easing: easing,
			step: function( now, fx ) {
				fx.now = Math.round( now );
			}
		} );
		toShow
			.hide()
			.animate( this.showProps, {
				duration: duration,
				easing: easing,
				complete: complete,
				step: function( now, fx ) {
					fx.now = Math.round( now );
					if ( fx.prop !== "height" ) {
						if ( boxSizing === "content-box" ) {
							adjust += fx.now;
						}
					} else if ( that.options.heightStyle !== "content" ) {
						fx.now = Math.round( total - toHide.outerHeight() - adjust );
						adjust = 0;
					}
				}
			} );
	},

	_toggleComplete: function( data ) {
		var toHide = data.oldPanel,
			prev = toHide.prev();

		this._removeClass( toHide, "ui-accordion-content-active" );
		this._removeClass( prev, "ui-accordion-header-active" )
			._addClass( prev, "ui-accordion-header-collapsed" );

		// Work around for rendering bug in IE (#5421)
		if ( toHide.length ) {
			toHide.parent()[ 0 ].className = toHide.parent()[ 0 ].className;
		}
		this._trigger( "activate", null, data );
	}
} );



var safeActiveElement = $.ui.safeActiveElement = function( document ) {
	var activeElement;

	// Support: IE 9 only
	// IE9 throws an "Unspecified error" accessing document.activeElement from an <iframe>
	try {
		activeElement = document.activeElement;
	} catch ( error ) {
		activeElement = document.body;
	}

	// Support: IE 9 - 11 only
	// IE may return null instead of an element
	// Interestingly, this only seems to occur when NOT in an iframe
	if ( !activeElement ) {
		activeElement = document.body;
	}

	// Support: IE 11 only
	// IE11 returns a seemingly empty object in some cases when accessing
	// document.activeElement from an <iframe>
	if ( !activeElement.nodeName ) {
		activeElement = document.body;
	}

	return activeElement;
};


/*!
 * jQuery UI Menu 1.12.0
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Menu
//>>group: Widgets
//>>description: Creates nestable menus.
//>>docs: http://api.jqueryui.com/menu/
//>>demos: http://jqueryui.com/menu/
//>>css.structure: ../../themes/base/core.css
//>>css.structure: ../../themes/base/menu.css
//>>css.theme: ../../themes/base/theme.css



var widgetsMenu = $.widget( "ui.menu", {
	version: "1.12.0",
	defaultElement: "<ul>",
	delay: 300,
	options: {
		icons: {
			submenu: "ui-icon-caret-1-e"
		},
		items: "> *",
		menus: "ul",
		position: {
			my: "left top",
			at: "right top"
		},
		role: "menu",

		// Callbacks
		blur: null,
		focus: null,
		select: null
	},

	_create: function() {
		this.activeMenu = this.element;

		// Flag used to prevent firing of the click handler
		// as the event bubbles up through nested menus
		this.mouseHandled = false;
		this.element
			.uniqueId()
			.attr( {
				role: this.options.role,
				tabIndex: 0
			} );

		this._addClass( "ui-menu", "ui-widget ui-widget-content" );
		this._on( {

			// Prevent focus from sticking to links inside menu after clicking
			// them (focus should always stay on UL during navigation).
			"mousedown .ui-menu-item": function( event ) {
				event.preventDefault();
			},
			"click .ui-menu-item": function( event ) {
				var target = $( event.target );
				var active = $( $.ui.safeActiveElement( this.document[ 0 ] ) );
				if ( !this.mouseHandled && target.not( ".ui-state-disabled" ).length ) {
					this.select( event );

					// Only set the mouseHandled flag if the event will bubble, see #9469.
					if ( !event.isPropagationStopped() ) {
						this.mouseHandled = true;
					}

					// Open submenu on click
					if ( target.has( ".ui-menu" ).length ) {
						this.expand( event );
					} else if ( !this.element.is( ":focus" ) &&
							active.closest( ".ui-menu" ).length ) {

						// Redirect focus to the menu
						this.element.trigger( "focus", [ true ] );

						// If the active item is on the top level, let it stay active.
						// Otherwise, blur the active item since it is no longer visible.
						if ( this.active && this.active.parents( ".ui-menu" ).length === 1 ) {
							clearTimeout( this.timer );
						}
					}
				}
			},
			"mouseenter .ui-menu-item": function( event ) {

				// Ignore mouse events while typeahead is active, see #10458.
				// Prevents focusing the wrong item when typeahead causes a scroll while the mouse
				// is over an item in the menu
				if ( this.previousFilter ) {
					return;
				}

				var actualTarget = $( event.target ).closest( ".ui-menu-item" ),
					target = $( event.currentTarget );

				// Ignore bubbled events on parent items, see #11641
				if ( actualTarget[ 0 ] !== target[ 0 ] ) {
					return;
				}

				// Remove ui-state-active class from siblings of the newly focused menu item
				// to avoid a jump caused by adjacent elements both having a class with a border
				this._removeClass( target.siblings().children( ".ui-state-active" ),
					null, "ui-state-active" );
				this.focus( event, target );
			},
			mouseleave: "collapseAll",
			"mouseleave .ui-menu": "collapseAll",
			focus: function( event, keepActiveItem ) {

				// If there's already an active item, keep it active
				// If not, activate the first item
				var item = this.active || this.element.find( this.options.items ).eq( 0 );

				if ( !keepActiveItem ) {
					this.focus( event, item );
				}
			},
			blur: function( event ) {
				this._delay( function() {
					var notContained = !$.contains(
						this.element[ 0 ],
						$.ui.safeActiveElement( this.document[ 0 ] )
					);
					if ( notContained ) {
						this.collapseAll( event );
					}
				} );
			},
			keydown: "_keydown"
		} );

		this.refresh();

		// Clicks outside of a menu collapse any open menus
		this._on( this.document, {
			click: function( event ) {
				if ( this._closeOnDocumentClick( event ) ) {
					this.collapseAll( event );
				}

				// Reset the mouseHandled flag
				this.mouseHandled = false;
			}
		} );
	},

	_destroy: function() {
		var items = this.element.find( ".ui-menu-item" )
				.removeAttr( "role aria-disabled" ),
			submenus = items.children( ".ui-menu-item-wrapper" )
				.removeUniqueId()
				.removeAttr( "tabIndex role aria-haspopup" );

		// Destroy (sub)menus
		this.element
			.removeAttr( "aria-activedescendant" )
			.find( ".ui-menu" ).addBack()
				.removeAttr( "role aria-labelledby aria-expanded aria-hidden aria-disabled " +
					"tabIndex" )
				.removeUniqueId()
				.show();

		submenus.children().each( function() {
			var elem = $( this );
			if ( elem.data( "ui-menu-submenu-caret" ) ) {
				elem.remove();
			}
		} );
	},

	_keydown: function( event ) {
		var match, prev, character, skip,
			preventDefault = true;

		switch ( event.keyCode ) {
		case $.ui.keyCode.PAGE_UP:
			this.previousPage( event );
			break;
		case $.ui.keyCode.PAGE_DOWN:
			this.nextPage( event );
			break;
		case $.ui.keyCode.HOME:
			this._move( "first", "first", event );
			break;
		case $.ui.keyCode.END:
			this._move( "last", "last", event );
			break;
		case $.ui.keyCode.UP:
			this.previous( event );
			break;
		case $.ui.keyCode.DOWN:
			this.next( event );
			break;
		case $.ui.keyCode.LEFT:
			this.collapse( event );
			break;
		case $.ui.keyCode.RIGHT:
			if ( this.active && !this.active.is( ".ui-state-disabled" ) ) {
				this.expand( event );
			}
			break;
		case $.ui.keyCode.ENTER:
		case $.ui.keyCode.SPACE:
			this._activate( event );
			break;
		case $.ui.keyCode.ESCAPE:
			this.collapse( event );
			break;
		default:
			preventDefault = false;
			prev = this.previousFilter || "";
			character = String.fromCharCode( event.keyCode );
			skip = false;

			clearTimeout( this.filterTimer );

			if ( character === prev ) {
				skip = true;
			} else {
				character = prev + character;
			}

			match = this._filterMenuItems( character );
			match = skip && match.index( this.active.next() ) !== -1 ?
				this.active.nextAll( ".ui-menu-item" ) :
				match;

			// If no matches on the current filter, reset to the last character pressed
			// to move down the menu to the first item that starts with that character
			if ( !match.length ) {
				character = String.fromCharCode( event.keyCode );
				match = this._filterMenuItems( character );
			}

			if ( match.length ) {
				this.focus( event, match );
				this.previousFilter = character;
				this.filterTimer = this._delay( function() {
					delete this.previousFilter;
				}, 1000 );
			} else {
				delete this.previousFilter;
			}
		}

		if ( preventDefault ) {
			event.preventDefault();
		}
	},

	_activate: function( event ) {
		if ( this.active && !this.active.is( ".ui-state-disabled" ) ) {
			if ( this.active.children( "[aria-haspopup='true']" ).length ) {
				this.expand( event );
			} else {
				this.select( event );
			}
		}
	},

	refresh: function() {
		var menus, items, newSubmenus, newItems, newWrappers,
			that = this,
			icon = this.options.icons.submenu,
			submenus = this.element.find( this.options.menus );

		this._toggleClass( "ui-menu-icons", null, !!this.element.find( ".ui-icon" ).length );

		// Initialize nested menus
		newSubmenus = submenus.filter( ":not(.ui-menu)" )
			.hide()
			.attr( {
				role: this.options.role,
				"aria-hidden": "true",
				"aria-expanded": "false"
			} )
			.each( function() {
				var menu = $( this ),
					item = menu.prev(),
					submenuCaret = $( "<span>" ).data( "ui-menu-submenu-caret", true );

				that._addClass( submenuCaret, "ui-menu-icon", "ui-icon " + icon );
				item
					.attr( "aria-haspopup", "true" )
					.prepend( submenuCaret );
				menu.attr( "aria-labelledby", item.attr( "id" ) );
			} );

		this._addClass( newSubmenus, "ui-menu", "ui-widget ui-widget-content ui-front" );

		menus = submenus.add( this.element );
		items = menus.find( this.options.items );

		// Initialize menu-items containing spaces and/or dashes only as dividers
		items.not( ".ui-menu-item" ).each( function() {
			var item = $( this );
			if ( that._isDivider( item ) ) {
				that._addClass( item, "ui-menu-divider", "ui-widget-content" );
			}
		} );

		// Don't refresh list items that are already adapted
		newItems = items.not( ".ui-menu-item, .ui-menu-divider" );
		newWrappers = newItems.children()
			.not( ".ui-menu" )
				.uniqueId()
				.attr( {
					tabIndex: -1,
					role: this._itemRole()
				} );
		this._addClass( newItems, "ui-menu-item" )
			._addClass( newWrappers, "ui-menu-item-wrapper" );

		// Add aria-disabled attribute to any disabled menu item
		items.filter( ".ui-state-disabled" ).attr( "aria-disabled", "true" );

		// If the active item has been removed, blur the menu
		if ( this.active && !$.contains( this.element[ 0 ], this.active[ 0 ] ) ) {
			this.blur();
		}
	},

	_itemRole: function() {
		return {
			menu: "menuitem",
			listbox: "option"
		}[ this.options.role ];
	},

	_setOption: function( key, value ) {
		if ( key === "icons" ) {
			var icons = this.element.find( ".ui-menu-icon" );
			this._removeClass( icons, null, this.options.icons.submenu )
				._addClass( icons, null, value.submenu );
		}
		this._super( key, value );
	},

	_setOptionDisabled: function( value ) {
		this._super( value );

		this.element.attr( "aria-disabled", String( value ) );
		this._toggleClass( null, "ui-state-disabled", !!value );
	},

	focus: function( event, item ) {
		var nested, focused, activeParent;
		this.blur( event, event && event.type === "focus" );

		this._scrollIntoView( item );

		this.active = item.first();

		focused = this.active.children( ".ui-menu-item-wrapper" );
		this._addClass( focused, null, "ui-state-active" );

		// Only update aria-activedescendant if there's a role
		// otherwise we assume focus is managed elsewhere
		if ( this.options.role ) {
			this.element.attr( "aria-activedescendant", focused.attr( "id" ) );
		}

		// Highlight active parent menu item, if any
		activeParent = this.active
			.parent()
				.closest( ".ui-menu-item" )
					.children( ".ui-menu-item-wrapper" );
		this._addClass( activeParent, null, "ui-state-active" );

		if ( event && event.type === "keydown" ) {
			this._close();
		} else {
			this.timer = this._delay( function() {
				this._close();
			}, this.delay );
		}

		nested = item.children( ".ui-menu" );
		if ( nested.length && event && ( /^mouse/.test( event.type ) ) ) {
			this._startOpening( nested );
		}
		this.activeMenu = item.parent();

		this._trigger( "focus", event, { item: item } );
	},

	_scrollIntoView: function( item ) {
		var borderTop, paddingTop, offset, scroll, elementHeight, itemHeight;
		if ( this._hasScroll() ) {
			borderTop = parseFloat( $.css( this.activeMenu[ 0 ], "borderTopWidth" ) ) || 0;
			paddingTop = parseFloat( $.css( this.activeMenu[ 0 ], "paddingTop" ) ) || 0;
			offset = item.offset().top - this.activeMenu.offset().top - borderTop - paddingTop;
			scroll = this.activeMenu.scrollTop();
			elementHeight = this.activeMenu.height();
			itemHeight = item.outerHeight();

			if ( offset < 0 ) {
				this.activeMenu.scrollTop( scroll + offset );
			} else if ( offset + itemHeight > elementHeight ) {
				this.activeMenu.scrollTop( scroll + offset - elementHeight + itemHeight );
			}
		}
	},

	blur: function( event, fromFocus ) {
		if ( !fromFocus ) {
			clearTimeout( this.timer );
		}

		if ( !this.active ) {
			return;
		}

		this._removeClass( this.active.children( ".ui-menu-item-wrapper" ),
			null, "ui-state-active" );

		this._trigger( "blur", event, { item: this.active } );
		this.active = null;
	},

	_startOpening: function( submenu ) {
		clearTimeout( this.timer );

		// Don't open if already open fixes a Firefox bug that caused a .5 pixel
		// shift in the submenu position when mousing over the caret icon
		if ( submenu.attr( "aria-hidden" ) !== "true" ) {
			return;
		}

		this.timer = this._delay( function() {
			this._close();
			this._open( submenu );
		}, this.delay );
	},

	_open: function( submenu ) {
		var position = $.extend( {
			of: this.active
		}, this.options.position );

		clearTimeout( this.timer );
		this.element.find( ".ui-menu" ).not( submenu.parents( ".ui-menu" ) )
			.hide()
			.attr( "aria-hidden", "true" );

		submenu
			.show()
			.removeAttr( "aria-hidden" )
			.attr( "aria-expanded", "true" )
			.position( position );
	},

	collapseAll: function( event, all ) {
		clearTimeout( this.timer );
		this.timer = this._delay( function() {

			// If we were passed an event, look for the submenu that contains the event
			var currentMenu = all ? this.element :
				$( event && event.target ).closest( this.element.find( ".ui-menu" ) );

			// If we found no valid submenu ancestor, use the main menu to close all
			// sub menus anyway
			if ( !currentMenu.length ) {
				currentMenu = this.element;
			}

			this._close( currentMenu );

			this.blur( event );

			// Work around active item staying active after menu is blurred
			this._removeClass( currentMenu.find( ".ui-state-active" ), null, "ui-state-active" );

			this.activeMenu = currentMenu;
		}, this.delay );
	},

	// With no arguments, closes the currently active menu - if nothing is active
	// it closes all menus.  If passed an argument, it will search for menus BELOW
	_close: function( startMenu ) {
		if ( !startMenu ) {
			startMenu = this.active ? this.active.parent() : this.element;
		}

		startMenu.find( ".ui-menu" )
			.hide()
			.attr( "aria-hidden", "true" )
			.attr( "aria-expanded", "false" );
	},

	_closeOnDocumentClick: function( event ) {
		return !$( event.target ).closest( ".ui-menu" ).length;
	},

	_isDivider: function( item ) {

		// Match hyphen, em dash, en dash
		return !/[^\-\u2014\u2013\s]/.test( item.text() );
	},

	collapse: function( event ) {
		var newItem = this.active &&
			this.active.parent().closest( ".ui-menu-item", this.element );
		if ( newItem && newItem.length ) {
			this._close();
			this.focus( event, newItem );
		}
	},

	expand: function( event ) {
		var newItem = this.active &&
			this.active
				.children( ".ui-menu " )
					.find( this.options.items )
						.first();

		if ( newItem && newItem.length ) {
			this._open( newItem.parent() );

			// Delay so Firefox will not hide activedescendant change in expanding submenu from AT
			this._delay( function() {
				this.focus( event, newItem );
			} );
		}
	},

	next: function( event ) {
		this._move( "next", "first", event );
	},

	previous: function( event ) {
		this._move( "prev", "last", event );
	},

	isFirstItem: function() {
		return this.active && !this.active.prevAll( ".ui-menu-item" ).length;
	},

	isLastItem: function() {
		return this.active && !this.active.nextAll( ".ui-menu-item" ).length;
	},

	_move: function( direction, filter, event ) {
		var next;
		if ( this.active ) {
			if ( direction === "first" || direction === "last" ) {
				next = this.active
					[ direction === "first" ? "prevAll" : "nextAll" ]( ".ui-menu-item" )
					.eq( -1 );
			} else {
				next = this.active
					[ direction + "All" ]( ".ui-menu-item" )
					.eq( 0 );
			}
		}
		if ( !next || !next.length || !this.active ) {
			next = this.activeMenu.find( this.options.items )[ filter ]();
		}

		this.focus( event, next );
	},

	nextPage: function( event ) {
		var item, base, height;

		if ( !this.active ) {
			this.next( event );
			return;
		}
		if ( this.isLastItem() ) {
			return;
		}
		if ( this._hasScroll() ) {
			base = this.active.offset().top;
			height = this.element.height();
			this.active.nextAll( ".ui-menu-item" ).each( function() {
				item = $( this );
				return item.offset().top - base - height < 0;
			} );

			this.focus( event, item );
		} else {
			this.focus( event, this.activeMenu.find( this.options.items )
				[ !this.active ? "first" : "last" ]() );
		}
	},

	previousPage: function( event ) {
		var item, base, height;
		if ( !this.active ) {
			this.next( event );
			return;
		}
		if ( this.isFirstItem() ) {
			return;
		}
		if ( this._hasScroll() ) {
			base = this.active.offset().top;
			height = this.element.height();
			this.active.prevAll( ".ui-menu-item" ).each( function() {
				item = $( this );
				return item.offset().top - base + height > 0;
			} );

			this.focus( event, item );
		} else {
			this.focus( event, this.activeMenu.find( this.options.items ).first() );
		}
	},

	_hasScroll: function() {
		return this.element.outerHeight() < this.element.prop( "scrollHeight" );
	},

	select: function( event ) {

		// TODO: It should never be possible to not have an active item at this
		// point, but the tests don't trigger mouseenter before click.
		this.active = this.active || $( event.target ).closest( ".ui-menu-item" );
		var ui = { item: this.active };
		if ( !this.active.has( ".ui-menu" ).length ) {
			this.collapseAll( event, true );
		}
		this._trigger( "select", event, ui );
	},

	_filterMenuItems: function( character ) {
		var escapedCharacter = character.replace( /[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&" ),
			regex = new RegExp( "^" + escapedCharacter, "i" );

		return this.activeMenu
			.find( this.options.items )

				// Only match on items, not dividers or other content (#10571)
				.filter( ".ui-menu-item" )
					.filter( function() {
						return regex.test(
							$.trim( $( this ).children( ".ui-menu-item-wrapper" ).text() ) );
					} );
	}
} );


/*!
 * jQuery UI Autocomplete 1.12.0
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Autocomplete
//>>group: Widgets
//>>description: Lists suggested words as the user is typing.
//>>docs: http://api.jqueryui.com/autocomplete/
//>>demos: http://jqueryui.com/autocomplete/
//>>css.structure: ../../themes/base/core.css
//>>css.structure: ../../themes/base/autocomplete.css
//>>css.theme: ../../themes/base/theme.css



$.widget( "ui.autocomplete", {
	version: "1.12.0",
	defaultElement: "<input>",
	options: {
		appendTo: null,
		autoFocus: false,
		delay: 300,
		minLength: 1,
		position: {
			my: "left top",
			at: "left bottom",
			collision: "none"
		},
		source: null,

		// Callbacks
		change: null,
		close: null,
		focus: null,
		open: null,
		response: null,
		search: null,
		select: null
	},

	requestIndex: 0,
	pending: 0,

	_create: function() {

		// Some browsers only repeat keydown events, not keypress events,
		// so we use the suppressKeyPress flag to determine if we've already
		// handled the keydown event. #7269
		// Unfortunately the code for & in keypress is the same as the up arrow,
		// so we use the suppressKeyPressRepeat flag to avoid handling keypress
		// events when we know the keydown event was used to modify the
		// search term. #7799
		var suppressKeyPress, suppressKeyPressRepeat, suppressInput,
			nodeName = this.element[ 0 ].nodeName.toLowerCase(),
			isTextarea = nodeName === "textarea",
			isInput = nodeName === "input";

		// Textareas are always multi-line
		// Inputs are always single-line, even if inside a contentEditable element
		// IE also treats inputs as contentEditable
		// All other element types are determined by whether or not they're contentEditable
		this.isMultiLine = isTextarea || !isInput && this._isContentEditable( this.element );

		this.valueMethod = this.element[ isTextarea || isInput ? "val" : "text" ];
		this.isNewMenu = true;

		this._addClass( "ui-autocomplete-input" );
		this.element.attr( "autocomplete", "off" );

		this._on( this.element, {
			keydown: function( event ) {
				if ( this.element.prop( "readOnly" ) ) {
					suppressKeyPress = true;
					suppressInput = true;
					suppressKeyPressRepeat = true;
					return;
				}

				suppressKeyPress = false;
				suppressInput = false;
				suppressKeyPressRepeat = false;
				var keyCode = $.ui.keyCode;
				switch ( event.keyCode ) {
				case keyCode.PAGE_UP:
					suppressKeyPress = true;
					this._move( "previousPage", event );
					break;
				case keyCode.PAGE_DOWN:
					suppressKeyPress = true;
					this._move( "nextPage", event );
					break;
				case keyCode.UP:
					suppressKeyPress = true;
					this._keyEvent( "previous", event );
					break;
				case keyCode.DOWN:
					suppressKeyPress = true;
					this._keyEvent( "next", event );
					break;
				case keyCode.ENTER:

					// when menu is open and has focus
					if ( this.menu.active ) {

						// #6055 - Opera still allows the keypress to occur
						// which causes forms to submit
						suppressKeyPress = true;
						event.preventDefault();
						this.menu.select( event );
					}
					break;
				case keyCode.TAB:
					if ( this.menu.active ) {
						this.menu.select( event );
					}
					break;
				case keyCode.ESCAPE:
					if ( this.menu.element.is( ":visible" ) ) {
						if ( !this.isMultiLine ) {
							this._value( this.term );
						}
						this.close( event );

						// Different browsers have different default behavior for escape
						// Single press can mean undo or clear
						// Double press in IE means clear the whole form
						event.preventDefault();
					}
					break;
				default:
					suppressKeyPressRepeat = true;

					// search timeout should be triggered before the input value is changed
					this._searchTimeout( event );
					break;
				}
			},
			keypress: function( event ) {
				if ( suppressKeyPress ) {
					suppressKeyPress = false;
					if ( !this.isMultiLine || this.menu.element.is( ":visible" ) ) {
						event.preventDefault();
					}
					return;
				}
				if ( suppressKeyPressRepeat ) {
					return;
				}

				// Replicate some key handlers to allow them to repeat in Firefox and Opera
				var keyCode = $.ui.keyCode;
				switch ( event.keyCode ) {
				case keyCode.PAGE_UP:
					this._move( "previousPage", event );
					break;
				case keyCode.PAGE_DOWN:
					this._move( "nextPage", event );
					break;
				case keyCode.UP:
					this._keyEvent( "previous", event );
					break;
				case keyCode.DOWN:
					this._keyEvent( "next", event );
					break;
				}
			},
			input: function( event ) {
				if ( suppressInput ) {
					suppressInput = false;
					event.preventDefault();
					return;
				}
				this._searchTimeout( event );
			},
			focus: function() {
				this.selectedItem = null;
				this.previous = this._value();
			},
			blur: function( event ) {
				if ( this.cancelBlur ) {
					delete this.cancelBlur;
					return;
				}

				clearTimeout( this.searching );
				this.close( event );
				this._change( event );
			}
		} );

		this._initSource();
		this.menu = $( "<ul>" )
			.appendTo( this._appendTo() )
			.menu( {

				// disable ARIA support, the live region takes care of that
				role: null
			} )
			.hide()
			.menu( "instance" );

		this._addClass( this.menu.element, "ui-autocomplete", "ui-front" );
		this._on( this.menu.element, {
			mousedown: function( event ) {

				// prevent moving focus out of the text field
				event.preventDefault();

				// IE doesn't prevent moving focus even with event.preventDefault()
				// so we set a flag to know when we should ignore the blur event
				this.cancelBlur = true;
				this._delay( function() {
					delete this.cancelBlur;

					// Support: IE 8 only
					// Right clicking a menu item or selecting text from the menu items will
					// result in focus moving out of the input. However, we've already received
					// and ignored the blur event because of the cancelBlur flag set above. So
					// we restore focus to ensure that the menu closes properly based on the user's
					// next actions.
					if ( this.element[ 0 ] !== $.ui.safeActiveElement( this.document[ 0 ] ) ) {
						this.element.trigger( "focus" );
					}
				} );
			},
			menufocus: function( event, ui ) {
				var label, item;

				// support: Firefox
				// Prevent accidental activation of menu items in Firefox (#7024 #9118)
				if ( this.isNewMenu ) {
					this.isNewMenu = false;
					if ( event.originalEvent && /^mouse/.test( event.originalEvent.type ) ) {
						this.menu.blur();

						this.document.one( "mousemove", function() {
							$( event.target ).trigger( event.originalEvent );
						} );

						return;
					}
				}

				item = ui.item.data( "ui-autocomplete-item" );
				if ( false !== this._trigger( "focus", event, { item: item } ) ) {

					// use value to match what will end up in the input, if it was a key event
					if ( event.originalEvent && /^key/.test( event.originalEvent.type ) ) {
						this._value( item.value );
					}
				}

				// Announce the value in the liveRegion
				label = ui.item.attr( "aria-label" ) || item.value;
				if ( label && $.trim( label ).length ) {
					this.liveRegion.children().hide();
					$( "<div>" ).text( label ).appendTo( this.liveRegion );
				}
			},
			menuselect: function( event, ui ) {
				var item = ui.item.data( "ui-autocomplete-item" ),
					previous = this.previous;

				// Only trigger when focus was lost (click on menu)
				if ( this.element[ 0 ] !== $.ui.safeActiveElement( this.document[ 0 ] ) ) {
					this.element.trigger( "focus" );
					this.previous = previous;

					// #6109 - IE triggers two focus events and the second
					// is asynchronous, so we need to reset the previous
					// term synchronously and asynchronously :-(
					this._delay( function() {
						this.previous = previous;
						this.selectedItem = item;
					} );
				}

				if ( false !== this._trigger( "select", event, { item: item } ) ) {
					this._value( item.value );
				}

				// reset the term after the select event
				// this allows custom select handling to work properly
				this.term = this._value();

				this.close( event );
				this.selectedItem = item;
			}
		} );

		this.liveRegion = $( "<div>", {
			role: "status",
			"aria-live": "assertive",
			"aria-relevant": "additions"
		} )
			.appendTo( this.document[ 0 ].body );

		this._addClass( this.liveRegion, null, "ui-helper-hidden-accessible" );

		// Turning off autocomplete prevents the browser from remembering the
		// value when navigating through history, so we re-enable autocomplete
		// if the page is unloaded before the widget is destroyed. #7790
		this._on( this.window, {
			beforeunload: function() {
				this.element.removeAttr( "autocomplete" );
			}
		} );
	},

	_destroy: function() {
		clearTimeout( this.searching );
		this.element.removeAttr( "autocomplete" );
		this.menu.element.remove();
		this.liveRegion.remove();
	},

	_setOption: function( key, value ) {
		this._super( key, value );
		if ( key === "source" ) {
			this._initSource();
		}
		if ( key === "appendTo" ) {
			this.menu.element.appendTo( this._appendTo() );
		}
		if ( key === "disabled" && value && this.xhr ) {
			this.xhr.abort();
		}
	},

	_isEventTargetInWidget: function( event ) {
		var menuElement = this.menu.element[ 0 ];

		return event.target === this.element[ 0 ] ||
			event.target === menuElement ||
			$.contains( menuElement, event.target );
	},

	_closeOnClickOutside: function( event ) {
		if ( !this._isEventTargetInWidget( event ) ) {
			this.close();
		}
	},

	_appendTo: function() {
		var element = this.options.appendTo;

		if ( element ) {
			element = element.jquery || element.nodeType ?
				$( element ) :
				this.document.find( element ).eq( 0 );
		}

		if ( !element || !element[ 0 ] ) {
			element = this.element.closest( ".ui-front, dialog" );
		}

		if ( !element.length ) {
			element = this.document[ 0 ].body;
		}

		return element;
	},

	_initSource: function() {
		var array, url,
			that = this;
		if ( $.isArray( this.options.source ) ) {
			array = this.options.source;
			this.source = function( request, response ) {
				response( $.ui.autocomplete.filter( array, request.term ) );
			};
		} else if ( typeof this.options.source === "string" ) {
			url = this.options.source;
			this.source = function( request, response ) {
				if ( that.xhr ) {
					that.xhr.abort();
				}
				that.xhr = $.ajax( {
					url: url,
					data: request,
					dataType: "json",
					success: function( data ) {
						response( data );
					},
					error: function() {
						response( [] );
					}
				} );
			};
		} else {
			this.source = this.options.source;
		}
	},

	_searchTimeout: function( event ) {
		clearTimeout( this.searching );
		this.searching = this._delay( function() {

			// Search if the value has changed, or if the user retypes the same value (see #7434)
			var equalValues = this.term === this._value(),
				menuVisible = this.menu.element.is( ":visible" ),
				modifierKey = event.altKey || event.ctrlKey || event.metaKey || event.shiftKey;

			if ( !equalValues || ( equalValues && !menuVisible && !modifierKey ) ) {
				this.selectedItem = null;
				this.search( null, event );
			}
		}, this.options.delay );
	},

	search: function( value, event ) {
		value = value != null ? value : this._value();

		// Always save the actual value, not the one passed as an argument
		this.term = this._value();

		if ( value.length < this.options.minLength ) {
			return this.close( event );
		}

		if ( this._trigger( "search", event ) === false ) {
			return;
		}

		return this._search( value );
	},

	_search: function( value ) {
		this.pending++;
		this._addClass( "ui-autocomplete-loading" );
		this.cancelSearch = false;

		this.source( { term: value }, this._response() );
	},

	_response: function() {
		var index = ++this.requestIndex;

		return $.proxy( function( content ) {
			if ( index === this.requestIndex ) {
				this.__response( content );
			}

			this.pending--;
			if ( !this.pending ) {
				this._removeClass( "ui-autocomplete-loading" );
			}
		}, this );
	},

	__response: function( content ) {
		if ( content ) {
			content = this._normalize( content );
		}
		this._trigger( "response", null, { content: content } );
		if ( !this.options.disabled && content && content.length && !this.cancelSearch ) {
			this._suggest( content );
			this._trigger( "open" );
		} else {

			// use ._close() instead of .close() so we don't cancel future searches
			this._close();
		}
	},

	close: function( event ) {
		this.cancelSearch = true;
		this._close( event );
	},

	_close: function( event ) {

		// Remove the handler that closes the menu on outside clicks
		this._off( this.document, "mousedown" );

		if ( this.menu.element.is( ":visible" ) ) {
			this.menu.element.hide();
			this.menu.blur();
			this.isNewMenu = true;
			this._trigger( "close", event );
		}
	},

	_change: function( event ) {
		if ( this.previous !== this._value() ) {
			this._trigger( "change", event, { item: this.selectedItem } );
		}
	},

	_normalize: function( items ) {

		// assume all items have the right format when the first item is complete
		if ( items.length && items[ 0 ].label && items[ 0 ].value ) {
			return items;
		}
		return $.map( items, function( item ) {
			if ( typeof item === "string" ) {
				return {
					label: item,
					value: item
				};
			}
			return $.extend( {}, item, {
				label: item.label || item.value,
				value: item.value || item.label
			} );
		} );
	},

	_suggest: function( items ) {
		var ul = this.menu.element.empty();
		this._renderMenu( ul, items );
		this.isNewMenu = true;
		this.menu.refresh();

		// Size and position menu
		ul.show();
		this._resizeMenu();
		ul.position( $.extend( {
			of: this.element
		}, this.options.position ) );

		if ( this.options.autoFocus ) {
			this.menu.next();
		}

		// Listen for interactions outside of the widget (#6642)
		this._on( this.document, {
			mousedown: "_closeOnClickOutside"
		} );
	},

	_resizeMenu: function() {
		var ul = this.menu.element;
		ul.outerWidth( Math.max(

			// Firefox wraps long text (possibly a rounding bug)
			// so we add 1px to avoid the wrapping (#7513)
			ul.width( "" ).outerWidth() + 1,
			this.element.outerWidth()
		) );
	},

	_renderMenu: function( ul, items ) {
		var that = this;
		$.each( items, function( index, item ) {
			that._renderItemData( ul, item );
		} );
	},

	_renderItemData: function( ul, item ) {
		return this._renderItem( ul, item ).data( "ui-autocomplete-item", item );
	},

	_renderItem: function( ul, item ) {
		return $( "<li>" )
			.append( $( "<div>" ).text( item.label ) )
			.appendTo( ul );
	},

	_move: function( direction, event ) {
		if ( !this.menu.element.is( ":visible" ) ) {
			this.search( null, event );
			return;
		}
		if ( this.menu.isFirstItem() && /^previous/.test( direction ) ||
				this.menu.isLastItem() && /^next/.test( direction ) ) {

			if ( !this.isMultiLine ) {
				this._value( this.term );
			}

			this.menu.blur();
			return;
		}
		this.menu[ direction ]( event );
	},

	widget: function() {
		return this.menu.element;
	},

	_value: function() {
		return this.valueMethod.apply( this.element, arguments );
	},

	_keyEvent: function( keyEvent, event ) {
		if ( !this.isMultiLine || this.menu.element.is( ":visible" ) ) {
			this._move( keyEvent, event );

			// Prevents moving cursor to beginning/end of the text field in some browsers
			event.preventDefault();
		}
	},

	// Support: Chrome <=50
	// We should be able to just use this.element.prop( "isContentEditable" )
	// but hidden elements always report false in Chrome.
	// https://code.google.com/p/chromium/issues/detail?id=313082
	_isContentEditable: function( element ) {
		if ( !element.length ) {
			return false;
		}

		var editable = element.prop( "contentEditable" );

		if ( editable === "inherit" ) {
		  return this._isContentEditable( element.parent() );
		}

		return editable === "true";
	}
} );

$.extend( $.ui.autocomplete, {
	escapeRegex: function( value ) {
		return value.replace( /[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&" );
	},
	filter: function( array, term ) {
		var matcher = new RegExp( $.ui.autocomplete.escapeRegex( term ), "i" );
		return $.grep( array, function( value ) {
			return matcher.test( value.label || value.value || value );
		} );
	}
} );

// Live region extension, adding a `messages` option
// NOTE: This is an experimental API. We are still investigating
// a full solution for string manipulation and internationalization.
$.widget( "ui.autocomplete", $.ui.autocomplete, {
	options: {
		messages: {
			noResults: "No search results.",
			results: function( amount ) {
				return amount + ( amount > 1 ? " results are" : " result is" ) +
					" available, use up and down arrow keys to navigate.";
			}
		}
	},

	__response: function( content ) {
		var message;
		this._superApply( arguments );
		if ( this.options.disabled || this.cancelSearch ) {
			return;
		}
		if ( content && content.length ) {
			message = this.options.messages.results( content.length );
		} else {
			message = this.options.messages.noResults;
		}
		this.liveRegion.children().hide();
		$( "<div>" ).text( message ).appendTo( this.liveRegion );
	}
} );

var widgetsAutocomplete = $.ui.autocomplete;


/*!
 * jQuery UI Controlgroup 1.12.0
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Controlgroup
//>>group: Widgets
//>>description: Visually groups form control widgets
//>>docs: http://api.jqueryui.com/controlgroup/
//>>demos: http://jqueryui.com/controlgroup/
//>>css.structure: ../../themes/base/core.css
//>>css.structure: ../../themes/base/controlgroup.css
//>>css.theme: ../../themes/base/theme.css


var controlgroupCornerRegex = /ui-corner-([a-z]){2,6}/g;

var widgetsControlgroup = $.widget( "ui.controlgroup", {
	version: "1.12.0",
	defaultElement: "<div>",
	options: {
		direction: "horizontal",
		disabled: null,
		onlyVisible: true,
		items: {
			"button": "input[type=button], input[type=submit], input[type=reset], button, a",
			"controlgroupLabel": ".ui-controlgroup-label",
			"checkboxradio": "input[type='checkbox'], input[type='radio']",
			"selectmenu": "select",
			"spinner": ".ui-spinner-input"
		}
	},

	_create: function() {
		this._enhance();
	},

	// To support the enhanced option in jQuery Mobile, we isolate DOM manipulation
	_enhance: function() {
		this.element.attr( "role", "toolbar" );
		this.refresh();
	},

	_destroy: function() {
		this._callChildMethod( "destroy" );
		this.childWidgets.removeData( "ui-controlgroup-data" );
		this.element.removeAttr( "role" );
		if ( this.options.items.controlgroupLabel ) {
			this.element
				.find( this.options.items.controlgroupLabel )
				.find( ".ui-controlgroup-label-contents" )
				.contents().unwrap();
		}
	},

	_initWidgets: function() {
		var that = this,
			childWidgets = [];

		// First we iterate over each of the items options
		$.each( this.options.items, function( widget, selector ) {
			var labels;
			var options = {};

			// Make sure the widget has a selector set
			if ( !selector ) {
				return;
			}

			if ( widget === "controlgroupLabel" ) {
				labels = that.element.find( selector );
				labels.each( function() {
					var element = $( this );

					if ( element.children( ".ui-controlgroup-label-contents" ).length ) {
						return;
					}
					element.contents()
						.wrapAll( "<span class='ui-controlgroup-label-contents'></span>" );
				} );
				that._addClass( labels, null, "ui-widget ui-widget-content ui-state-default" );
				childWidgets = childWidgets.concat( labels.get() );
				return;
			}

			// Make sure the widget actually exists
			if ( !$.fn[ widget ] ) {
				return;
			}

			// We assume everything is in the middle to start because we can't determine
			// first / last elements until all enhancments are done.
			if ( that[ "_" + widget + "Options" ] ) {
				options = that[ "_" + widget + "Options" ]( "middle" );
			}

			// Find instances of this widget inside controlgroup and init them
			that.element
				.find( selector )
				.each( function() {
					var element = $( this );
					var instance = element[ widget ]( "instance" );

					// We need to clone the default options for this type of widget to avoid
					// polluting the variable options which has a wider scope than a single widget.
					var instanceOptions = $.widget.extend( {}, options );

					// If the button is the child of a spinner ignore it
					// TODO: Find a more generic solution
					if ( widget === "button" && element.parent( ".ui-spinner" ).length ) {
						return;
					}

					// Create the widget if it doesn't exist
					if ( !instance ) {
						instance = element[ widget ]()[ widget ]( "instance" );
					}
					if ( instance ) {
						instanceOptions.classes =
							that._resolveClassesValues( instanceOptions.classes, instance );
					}
					element[ widget ]( instanceOptions );

					// Store an instance of the controlgroup to be able to reference
					// from the outermost element for changing options and refresh
					var widgetElement = element[ widget ]( "widget" );
					$.data( widgetElement[ 0 ], "ui-controlgroup-data",
						instance ? instance : element[ widget ]( "instance" ) );

					childWidgets.push( widgetElement[ 0 ] );
				} );
		} );

		this.childWidgets = $( $.unique( childWidgets ) );
		this._addClass( this.childWidgets, "ui-controlgroup-item" );
	},

	_callChildMethod: function( method ) {
		this.childWidgets.each( function() {
			var element = $( this ),
				data = element.data( "ui-controlgroup-data" );
			if ( data && data[ method ] ) {
				data[ method ]();
			}
		} );
	},

	_updateCornerClass: function( element, position ) {
		var remove = "ui-corner-top ui-corner-bottom ui-corner-left ui-corner-right ui-corner-all";
		var add = this._buildSimpleOptions( position, "label" ).classes.label;

		this._removeClass( element, null, remove );
		this._addClass( element, null, add );
	},

	_buildSimpleOptions: function( position, key ) {
		var direction = this.options.direction === "vertical";
		var result = {
			classes: {}
		};
		result.classes[ key ] = {
			"middle": "",
			"first": "ui-corner-" + ( direction ? "top" : "left" ),
			"last": "ui-corner-" + ( direction ? "bottom" : "right" ),
			"only": "ui-corner-all"
		}[ position ];

		return result;
	},

	_spinnerOptions: function( position ) {
		var options = this._buildSimpleOptions( position, "ui-spinner" );

		options.classes[ "ui-spinner-up" ] = "";
		options.classes[ "ui-spinner-down" ] = "";

		return options;
	},

	_buttonOptions: function( position ) {
		return this._buildSimpleOptions( position, "ui-button" );
	},

	_checkboxradioOptions: function( position ) {
		return this._buildSimpleOptions( position, "ui-checkboxradio-label" );
	},

	_selectmenuOptions: function( position ) {
		var direction = this.options.direction === "vertical";
		return {
			width: direction ? "auto" : false,
			classes: {
				middle: {
					"ui-selectmenu-button-open": "",
					"ui-selectmenu-button-closed": ""
				},
				first: {
					"ui-selectmenu-button-open": "ui-corner-" + ( direction ? "top" : "tl" ),
					"ui-selectmenu-button-closed": "ui-corner-" + ( direction ? "top" : "left" )
				},
				last: {
					"ui-selectmenu-button-open": direction ? "" : "ui-corner-tr",
					"ui-selectmenu-button-closed": "ui-corner-" + ( direction ? "bottom" : "right" )
				},
				only: {
					"ui-selectmenu-button-open": "ui-corner-top",
					"ui-selectmenu-button-closed": "ui-corner-all"
				}

			}[ position ]
		};
	},

	_resolveClassesValues: function( classes, instance ) {
		var result = {};
		$.each( classes, function( key ) {
			var current = instance.options.classes[ key ] || "";
			current = current.replace( controlgroupCornerRegex, "" ).trim();
			result[ key ] = ( current + " " + classes[ key ] ).replace( /\s+/g, " " );
		} );
		return result;
	},

	_setOption: function( key, value ) {
		if ( key === "direction" ) {
			this._removeClass( "ui-controlgroup-" + this.options.direction );
		}

		this._super( key, value );
		if ( key === "disabled" ) {
			this._callChildMethod( value ? "disable" : "enable" );
			return;
		}

		this.refresh();
	},

	refresh: function() {
		var children,
			that = this;

		this._addClass( "ui-controlgroup ui-controlgroup-" + this.options.direction );

		if ( this.options.direction === "horizontal" ) {
			this._addClass( null, "ui-helper-clearfix" );
		}
		this._initWidgets();

		children = this.childWidgets;

		// We filter here because we need to track all childWidgets not just the visible ones
		if ( this.options.onlyVisible ) {
			children = children.filter( ":visible" );
		}

		if ( children.length ) {

			// We do this last because we need to make sure all enhancment is done
			// before determining first and last
			$.each( [ "first", "last" ], function( index, value ) {
				var instance = children[ value ]().data( "ui-controlgroup-data" );

				if ( instance && that[ "_" + instance.widgetName + "Options" ] ) {
					var options = that[ "_" + instance.widgetName + "Options" ](
						children.length === 1 ? "only" : value
					);
					options.classes = that._resolveClassesValues( options.classes, instance );
					instance.element[ instance.widgetName ]( options );
				} else {
					that._updateCornerClass( children[ value ](), value );
				}
			} );

			// Finally call the refresh method on each of the child widgets.
			this._callChildMethod( "refresh" );
		}
	}
} );

/*!
 * jQuery UI Checkboxradio 1.12.0
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Checkboxradio
//>>group: Widgets
//>>description: Enhances a form with multiple themeable checkboxes or radio buttons.
//>>docs: http://api.jqueryui.com/checkboxradio/
//>>demos: http://jqueryui.com/checkboxradio/
//>>css.structure: ../../themes/base/core.css
//>>css.structure: ../../themes/base/button.css
//>>css.structure: ../../themes/base/checkboxradio.css
//>>css.theme: ../../themes/base/theme.css



$.widget( "ui.checkboxradio", [ $.ui.formResetMixin, {
	version: "1.12.0",
	options: {
		disabled: null,
		label: null,
		icon: true,
		classes: {
			"ui-checkboxradio-label": "ui-corner-all",
			"ui-checkboxradio-icon": "ui-corner-all"
		}
	},

	_getCreateOptions: function() {
		var disabled, labels;
		var that = this;
		var options = this._super() || {};

		// We read the type here, because it makes more sense to throw a element type error first,
		// rather then the error for lack of a label. Often if its the wrong type, it
		// won't have a label (e.g. calling on a div, btn, etc)
		this._readType();

		labels = this.element.labels();

		// If there are multiple labels, use the last one
		this.label = $( labels[ labels.length - 1 ] );
		if ( !this.label.length ) {
			$.error( "No label found for checkboxradio widget" );
		}

		this.originalLabel = "";

		// We need to get the label text but this may also need to make sure it does not contain the
		// input itself.
		this.label.contents().not( this.element ).each( function() {

			// The label contents could be text, html, or a mix. We concat each element to get a
			// string representation of the label, without the input as part of it.
			that.originalLabel += this.nodeType === 3 ? $( this ).text() : this.outerHTML;
		} );

		// Set the label option if we found label text
		if ( this.originalLabel ) {
			options.label = this.originalLabel;
		}

		disabled = this.element[ 0 ].disabled;
		if ( disabled != null ) {
			options.disabled = disabled;
		}
		return options;
	},

	_create: function() {
		var checked = this.element[ 0 ].checked;

		this._bindFormResetHandler();

		if ( this.options.disabled == null ) {
			this.options.disabled = this.element[ 0 ].disabled;
		}

		this._setOption( "disabled", this.options.disabled );
		this._addClass( "ui-checkboxradio", "ui-helper-hidden-accessible" );
		this._addClass( this.label, "ui-checkboxradio-label", "ui-button ui-widget" );

		if ( this.type === "radio" ) {
			this._addClass( this.label, "ui-checkboxradio-radio-label" );
		}

		if ( this.options.label && this.options.label !== this.originalLabel ) {
			this._updateLabel();
		} else if ( this.originalLabel ) {
			this.options.label = this.originalLabel;
		}

		this._enhance();

		if ( checked ) {
			this._addClass( this.label, "ui-checkboxradio-checked", "ui-state-active" );
			if ( this.icon ) {
				this._addClass( this.icon, null, "ui-state-hover" );
			}
		}

		this._on( {
			change: "_toggleClasses",
			focus: function() {
				this._addClass( this.label, null, "ui-state-focus ui-visual-focus" );
			},
			blur: function() {
				this._removeClass( this.label, null, "ui-state-focus ui-visual-focus" );
			}
		} );
	},

	_readType: function() {
		var nodeName = this.element[ 0 ].nodeName.toLowerCase();
		this.type = this.element[ 0 ].type;
		if ( nodeName !== "input" || !/radio|checkbox/.test( this.type ) ) {
			$.error( "Can't create checkboxradio on element.nodeName=" + nodeName +
				" and element.type=" + this.type );
		}
	},

	// Support jQuery Mobile enhanced option
	_enhance: function() {
		this._updateIcon( this.element[ 0 ].checked );
	},

	widget: function() {
		return this.label;
	},

	_getRadioGroup: function() {
		var group;
		var name = this.element[ 0 ].name;
		var nameSelector = "input[name='" + $.ui.escapeSelector( name ) + "']";

		if ( !name ) {
			return $( [] );
		}

		if ( this.form.length ) {
			group = $( this.form[ 0 ].elements ).filter( nameSelector );
		} else {

			// Not inside a form, check all inputs that also are not inside a form
			group = $( nameSelector ).filter( function() {
				return $( this ).form().length === 0;
			} );
		}

		return group.not( this.element );
	},

	_toggleClasses: function() {
		var checked = this.element[ 0 ].checked;
		this._toggleClass( this.label, "ui-checkboxradio-checked", "ui-state-active", checked );

		if ( this.options.icon && this.type === "checkbox" ) {
			this._toggleClass( this.icon, null, "ui-icon-check ui-state-checked", checked )
				._toggleClass( this.icon, null, "ui-icon-blank", !checked );
		}

		if ( this.type === "radio" ) {
			this._getRadioGroup()
				.each( function() {
					var instance = $( this ).checkboxradio( "instance" );

					if ( instance ) {
						instance._removeClass( instance.label,
							"ui-checkboxradio-checked", "ui-state-active" );
					}
				} );
		}
	},

	_destroy: function() {
		this._unbindFormResetHandler();

		if ( this.icon ) {
			this.icon.remove();
			this.iconSpace.remove();
		}
	},

	_setOption: function( key, value ) {

		// We don't allow the value to be set to nothing
		if ( key === "label" && !value ) {
			return;
		}

		this._super( key, value );

		if ( key === "disabled" ) {
			this._toggleClass( this.label, null, "ui-state-disabled", value );
			this.element[ 0 ].disabled = value;

			// Don't refresh when setting disabled
			return;
		}
		this.refresh();
	},

	_updateIcon: function( checked ) {
		var toAdd = "ui-icon ui-icon-background ";

		if ( this.options.icon ) {
			if ( !this.icon ) {
				this.icon = $( "<span>" );
				this.iconSpace = $( "<span> </span>" );
				this._addClass( this.iconSpace, "ui-checkboxradio-icon-space" );
			}

			if ( this.type === "checkbox" ) {
				toAdd += checked ? "ui-icon-check ui-state-checked" : "ui-icon-blank";
				this._removeClass( this.icon, null, checked ? "ui-icon-blank" : "ui-icon-check" );
			} else {
				toAdd += "ui-icon-blank";
			}
			this._addClass( this.icon, "ui-checkboxradio-icon", toAdd );
			if ( !checked ) {
				this._removeClass( this.icon, null, "ui-icon-check ui-state-checked" );
			}
			this.icon.prependTo( this.label ).after( this.iconSpace );
		} else if ( this.icon !== undefined ) {
			this.icon.remove();
			this.iconSpace.remove();
			delete this.icon;
		}
	},

	_updateLabel: function() {

		// Remove the contents of the label ( minus the icon, icon space, and input )
		this.label.contents().not( this.element.add( this.icon ).add( this.iconSpace ) ).remove();
		this.label.append( this.options.label );
	},

	refresh: function() {
		var checked = this.element[ 0 ].checked,
			isDisabled = this.element[ 0 ].disabled;

		this._updateIcon( checked );
		this._toggleClass( this.label, "ui-checkboxradio-checked", "ui-state-active", checked );
		if ( this.options.label !== null ) {
			this._updateLabel();
		}

		if ( isDisabled !== this.options.disabled ) {
			this._setOptions( { "disabled": isDisabled } );
		}
	}

} ] );

var widgetsCheckboxradio = $.ui.checkboxradio;


/*!
 * jQuery UI Button 1.12.0
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Button
//>>group: Widgets
//>>description: Enhances a form with themeable buttons.
//>>docs: http://api.jqueryui.com/button/
//>>demos: http://jqueryui.com/button/
//>>css.structure: ../../themes/base/core.css
//>>css.structure: ../../themes/base/button.css
//>>css.theme: ../../themes/base/theme.css



$.widget( "ui.button", {
	version: "1.12.0",
	defaultElement: "<button>",
	options: {
		classes: {
			"ui-button": "ui-corner-all"
		},
		disabled: null,
		icon: null,
		iconPosition: "beginning",
		label: null,
		showLabel: true
	},

	_getCreateOptions: function() {
		var disabled,

			// This is to support cases like in jQuery Mobile where the base widget does have
			// an implementation of _getCreateOptions
			options = this._super() || {};

		this.isInput = this.element.is( "input" );

		disabled = this.element[ 0 ].disabled;
		if ( disabled != null ) {
			options.disabled = disabled;
		}

		this.originalLabel = this.isInput ? this.element.val() : this.element.html();
		if ( this.originalLabel ) {
			options.label = this.originalLabel;
		}

		return options;
	},

	_create: function() {
		if ( !this.option.showLabel & !this.options.icon ) {
			this.options.showLabel = true;
		}

		// We have to check the option again here even though we did in _getCreateOptions,
		// because null may have been passed on init which would override what was set in
		// _getCreateOptions
		if ( this.options.disabled == null ) {
			this.options.disabled = this.element[ 0 ].disabled || false;
		}

		this.hasTitle = !!this.element.attr( "title" );

		// Check to see if the label needs to be set or if its already correct
		if ( this.options.label && this.options.label !== this.originalLabel ) {
			if ( this.isInput ) {
				this.element.val( this.options.label );
			} else {
				this.element.html( this.options.label );
			}
		}
		this._addClass( "ui-button", "ui-widget" );
		this._setOption( "disabled", this.options.disabled );
		this._enhance();

		if ( this.element.is( "a" ) ) {
			this._on( {
				"keyup": function( event ) {
					if ( event.keyCode === $.ui.keyCode.SPACE ) {
						event.preventDefault();

						// Support: PhantomJS <= 1.9, IE 8 Only
						// If a native click is available use it so we actually cause navigation
						// otherwise just trigger a click event
						if ( this.element[ 0 ].click ) {
							this.element[ 0 ].click();
						} else {
							this.element.trigger( "click" );
						}
					}
				}
			} );
		}
	},

	_enhance: function() {
		if ( !this.element.is( "button" ) ) {
			this.element.attr( "role", "button" );
		}

		if ( this.options.icon ) {
			this._updateIcon( "icon", this.options.icon );
			this._updateTooltip();
		}
	},

	_updateTooltip: function() {
		this.title = this.element.attr( "title" );

		if ( !this.options.showLabel && !this.title ) {
			this.element.attr( "title", this.options.label );
		}
	},

	_updateIcon: function( option, value ) {
		var icon = option !== "iconPosition",
			position = icon ? this.options.iconPosition : value,
			displayBlock = position === "top" || position === "bottom";

		// Create icon
		if ( !this.icon ) {
			this.icon = $( "<span>" );

			this._addClass( this.icon, "ui-button-icon", "ui-icon" );

			if ( !this.options.showLabel ) {
				this._addClass( "ui-button-icon-only" );
			}
		} else if ( icon ) {

			// If we are updating the icon remove the old icon class
			this._removeClass( this.icon, null, this.options.icon );
		}

		// If we are updating the icon add the new icon class
		if ( icon ) {
			this._addClass( this.icon, null, value );
		}

		this._attachIcon( position );

		// If the icon is on top or bottom we need to add the ui-widget-icon-block class and remove
		// the iconSpace if there is one.
		if ( displayBlock ) {
			this._addClass( this.icon, null, "ui-widget-icon-block" );
			if ( this.iconSpace ) {
				this.iconSpace.remove();
			}
		} else {

			// Position is beginning or end so remove the ui-widget-icon-block class and add the
			// space if it does not exist
			if ( !this.iconSpace ) {
				this.iconSpace = $( "<span> </span>" );
				this._addClass( this.iconSpace, "ui-button-icon-space" );
			}
			this._removeClass( this.icon, null, "ui-wiget-icon-block" );
			this._attachIconSpace( position );
		}
	},

	_destroy: function() {
		this.element.removeAttr( "role" );

		if ( this.icon ) {
			this.icon.remove();
		}
		if ( this.iconSpace ) {
			this.iconSpace.remove();
		}
		if ( !this.hasTitle ) {
			this.element.removeAttr( "title" );
		}
	},

	_attachIconSpace: function( iconPosition ) {
		this.icon[ /^(?:end|bottom)/.test( iconPosition ) ? "before" : "after" ]( this.iconSpace );
	},

	_attachIcon: function( iconPosition ) {
		this.element[ /^(?:end|bottom)/.test( iconPosition ) ? "append" : "prepend" ]( this.icon );
	},

	_setOptions: function( options ) {
		var newShowLabel = options.showLabel === undefined ?
				this.options.showLabel :
				options.showLabel,
			newIcon = options.icon === undefined ? this.options.icon : options.icon;

		if ( !newShowLabel && !newIcon ) {
			options.showLabel = true;
		}
		this._super( options );
	},

	_setOption: function( key, value ) {
		if ( key === "icon" ) {
			if ( value ) {
				this._updateIcon( key, value );
			} else if ( this.icon ) {
				this.icon.remove();
				if ( this.iconSpace ) {
					this.iconSpace.remove();
				}
			}
		}

		if ( key === "iconPosition" ) {
			this._updateIcon( key, value );
		}

		// Make sure we can't end up with a button that has neither text nor icon
		if ( key === "showLabel" ) {
				this._toggleClass( "ui-button-icon-only", null, !value );
				this._updateTooltip();
		}

		if ( key === "label" ) {
			if ( this.isInput ) {
				this.element.val( value );
			} else {

				// If there is an icon, append it, else nothing then append the value
				// this avoids removal of the icon when setting label text
				this.element.html( value );
				if ( this.icon ) {
					this._attachIcon( this.options.iconPosition );
					this._attachIconSpace( this.options.iconPosition );
				}
			}
		}

		this._super( key, value );

		if ( key === "disabled" ) {
			this._toggleClass( null, "ui-state-disabled", value );
			this.element[ 0 ].disabled = value;
			if ( value ) {
				this.element.blur();
			}
		}
	},

	refresh: function() {

		// Make sure to only check disabled if its an element that supports this otherwise
		// check for the disabled class to determine state
		var isDisabled = this.element.is( "input, button" ) ?
			this.element[ 0 ].disabled : this.element.hasClass( "ui-button-disabled" );

		if ( isDisabled !== this.options.disabled ) {
			this._setOptions( { disabled: isDisabled } );
		}

		this._updateTooltip();
	}
} );

// DEPRECATED
if ( $.uiBackCompat !== false ) {

	// Text and Icons options
	$.widget( "ui.button", $.ui.button, {
		options: {
			text: true,
			icons: {
				primary: null,
				secondary: null
			}
		},

		_create: function() {
			if ( this.options.showLabel && !this.options.text ) {
				this.options.showLabel = this.options.text;
			}
			if ( !this.options.showLabel && this.options.text ) {
				this.options.text = this.options.showLabel;
			}
			if ( !this.options.icon && ( this.options.icons.primary ||
					this.options.icons.secondary ) ) {
				if ( this.options.icons.primary ) {
					this.options.icon = this.options.icons.primary;
				} else {
					this.options.icon = this.options.icons.secondary;
					this.options.iconPosition = "end";
				}
			} else if ( this.options.icon ) {
				this.options.icons.primary = this.options.icon;
			}
			this._super();
		},

		_setOption: function( key, value ) {
			if ( key === "text" ) {
				this._super( "showLabel", value );
				return;
			}
			if ( key === "showLabel" ) {
				this.options.text = value;
			}
			if ( key === "icon" ) {
				this.options.icons.primary = value;
			}
			if ( key === "icons" ) {
				if ( value.primary ) {
					this._super( "icon", value.primary );
					this._super( "iconPosition", "beginning" );
				} else if ( value.secondary ) {
					this._super( "icon", value.secondary );
					this._super( "iconPosition", "end" );
				}
			}
			this._superApply( arguments );
		}
	} );

	$.fn.button = ( function( orig ) {
		return function() {
			if ( !this.length || ( this.length && this[ 0 ].tagName !== "INPUT" ) ||
					( this.length && this[ 0 ].tagName === "INPUT" && (
						this.attr( "type" ) !== "checkbox" && this.attr( "type" ) !== "radio"
					) ) ) {
				return orig.apply( this, arguments );
			}
			if ( !$.ui.checkboxradio ) {
				$.error( "Checkboxradio widget missing" );
			}
			if ( arguments.length === 0 ) {
				return this.checkboxradio( {
					"icon": false
				} );
			}
			return this.checkboxradio.apply( this, arguments );
		};
	} )( $.fn.button );

	$.fn.buttonset = function() {
		if ( !$.ui.controlgroup ) {
			$.error( "Controlgroup widget missing" );
		}
		if ( arguments[ 0 ] === "option" && arguments[ 1 ] === "items" && arguments[ 2 ] ) {
			return this.controlgroup.apply( this,
				[ arguments[ 0 ], "items.button", arguments[ 2 ] ] );
		}
		if ( arguments[ 0 ] === "option" && arguments[ 1 ] === "items" ) {
			return this.controlgroup.apply( this, [ arguments[ 0 ], "items.button" ] );
		}
		if ( typeof arguments[ 0 ] === "object" && arguments[ 0 ].items ) {
			arguments[ 0 ].items = {
				button: arguments[ 0 ].items
			};
		}
		return this.controlgroup.apply( this, arguments );
	};
}

var widgetsButton = $.ui.button;


// jscs:disable maximumLineLength
/* jscs:disable requireCamelCaseOrUpperCaseIdentifiers */
/*!
 * jQuery UI Datepicker 1.12.0
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Datepicker
//>>group: Widgets
//>>description: Displays a calendar from an input or inline for selecting dates.
//>>docs: http://api.jqueryui.com/datepicker/
//>>demos: http://jqueryui.com/datepicker/
//>>css.structure: ../../themes/base/core.css
//>>css.structure: ../../themes/base/datepicker.css
//>>css.theme: ../../themes/base/theme.css



$.extend( $.ui, { datepicker: { version: "1.12.0" } } );

var datepicker_instActive;

function datepicker_getZindex( elem ) {
	var position, value;
	while ( elem.length && elem[ 0 ] !== document ) {

		// Ignore z-index if position is set to a value where z-index is ignored by the browser
		// This makes behavior of this function consistent across browsers
		// WebKit always returns auto if the element is positioned
		position = elem.css( "position" );
		if ( position === "absolute" || position === "relative" || position === "fixed" ) {

			// IE returns 0 when zIndex is not specified
			// other browsers return a string
			// we ignore the case of nested elements with an explicit value of 0
			// <div style="z-index: -10;"><div style="z-index: 0;"></div></div>
			value = parseInt( elem.css( "zIndex" ), 10 );
			if ( !isNaN( value ) && value !== 0 ) {
				return value;
			}
		}
		elem = elem.parent();
	}

	return 0;
}
/* Date picker manager.
   Use the singleton instance of this class, $.datepicker, to interact with the date picker.
   Settings for (groups of) date pickers are maintained in an instance object,
   allowing multiple different settings on the same page. */

function Datepicker() {
	this._curInst = null; // The current instance in use
	this._keyEvent = false; // If the last event was a key event
	this._disabledInputs = []; // List of date picker inputs that have been disabled
	this._datepickerShowing = false; // True if the popup picker is showing , false if not
	this._inDialog = false; // True if showing within a "dialog", false if not
	this._mainDivId = "ui-datepicker-div"; // The ID of the main datepicker division
	this._inlineClass = "ui-datepicker-inline"; // The name of the inline marker class
	this._appendClass = "ui-datepicker-append"; // The name of the append marker class
	this._triggerClass = "ui-datepicker-trigger"; // The name of the trigger marker class
	this._dialogClass = "ui-datepicker-dialog"; // The name of the dialog marker class
	this._disableClass = "ui-datepicker-disabled"; // The name of the disabled covering marker class
	this._unselectableClass = "ui-datepicker-unselectable"; // The name of the unselectable cell marker class
	this._currentClass = "ui-datepicker-current-day"; // The name of the current day marker class
	this._dayOverClass = "ui-datepicker-days-cell-over"; // The name of the day hover marker class
	this.regional = []; // Available regional settings, indexed by language code
	this.regional[ "" ] = { // Default regional settings
		closeText: "Done", // Display text for close link
		prevText: "Prev", // Display text for previous month link
		nextText: "Next", // Display text for next month link
		currentText: "Today", // Display text for current month link
		monthNames: [ "January","February","March","April","May","June",
			"July","August","September","October","November","December" ], // Names of months for drop-down and formatting
		monthNamesShort: [ "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" ], // For formatting
		dayNames: [ "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" ], // For formatting
		dayNamesShort: [ "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" ], // For formatting
		dayNamesMin: [ "Su","Mo","Tu","We","Th","Fr","Sa" ], // Column headings for days starting at Sunday
		weekHeader: "Wk", // Column header for week of the year
		dateFormat: "mm/dd/yy", // See format options on parseDate
		firstDay: 0, // The first day of the week, Sun = 0, Mon = 1, ...
		isRTL: false, // True if right-to-left language, false if left-to-right
		showMonthAfterYear: false, // True if the year select precedes month, false for month then year
		yearSuffix: "" // Additional text to append to the year in the month headers
	};
	this._defaults = { // Global defaults for all the date picker instances
		showOn: "focus", // "focus" for popup on focus,
			// "button" for trigger button, or "both" for either
		showAnim: "fadeIn", // Name of jQuery animation for popup
		showOptions: {}, // Options for enhanced animations
		defaultDate: null, // Used when field is blank: actual date,
			// +/-number for offset from today, null for today
		appendText: "", // Display text following the input box, e.g. showing the format
		buttonText: "...", // Text for trigger button
		buttonImage: "", // URL for trigger button image
		buttonImageOnly: false, // True if the image appears alone, false if it appears on a button
		hideIfNoPrevNext: false, // True to hide next/previous month links
			// if not applicable, false to just disable them
		navigationAsDateFormat: false, // True if date formatting applied to prev/today/next links
		gotoCurrent: false, // True if today link goes back to current selection instead
		changeMonth: false, // True if month can be selected directly, false if only prev/next
		changeYear: false, // True if year can be selected directly, false if only prev/next
		yearRange: "c-10:c+10", // Range of years to display in drop-down,
			// either relative to today's year (-nn:+nn), relative to currently displayed year
			// (c-nn:c+nn), absolute (nnnn:nnnn), or a combination of the above (nnnn:-n)
		showOtherMonths: false, // True to show dates in other months, false to leave blank
		selectOtherMonths: false, // True to allow selection of dates in other months, false for unselectable
		showWeek: false, // True to show week of the year, false to not show it
		calculateWeek: this.iso8601Week, // How to calculate the week of the year,
			// takes a Date and returns the number of the week for it
		shortYearCutoff: "+10", // Short year values < this are in the current century,
			// > this are in the previous century,
			// string value starting with "+" for current year + value
		minDate: null, // The earliest selectable date, or null for no limit
		maxDate: null, // The latest selectable date, or null for no limit
		duration: "fast", // Duration of display/closure
		beforeShowDay: null, // Function that takes a date and returns an array with
			// [0] = true if selectable, false if not, [1] = custom CSS class name(s) or "",
			// [2] = cell title (optional), e.g. $.datepicker.noWeekends
		beforeShow: null, // Function that takes an input field and
			// returns a set of custom settings for the date picker
		onSelect: null, // Define a callback function when a date is selected
		onChangeMonthYear: null, // Define a callback function when the month or year is changed
		onClose: null, // Define a callback function when the datepicker is closed
		numberOfMonths: 1, // Number of months to show at a time
		showCurrentAtPos: 0, // The position in multipe months at which to show the current month (starting at 0)
		stepMonths: 1, // Number of months to step back/forward
		stepBigMonths: 12, // Number of months to step back/forward for the big links
		altField: "", // Selector for an alternate field to store selected dates into
		altFormat: "", // The date format to use for the alternate field
		constrainInput: true, // The input is constrained by the current date format
		showButtonPanel: false, // True to show button panel, false to not show it
		autoSize: false, // True to size the input for the date format, false to leave as is
		disabled: false // The initial disabled state
	};
	$.extend( this._defaults, this.regional[ "" ] );
	this.regional.en = $.extend( true, {}, this.regional[ "" ] );
	this.regional[ "en-US" ] = $.extend( true, {}, this.regional.en );
	this.dpDiv = datepicker_bindHover( $( "<div id='" + this._mainDivId + "' class='ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>" ) );
}

$.extend( Datepicker.prototype, {
	/* Class name added to elements to indicate already configured with a date picker. */
	markerClassName: "hasDatepicker",

	//Keep track of the maximum number of rows displayed (see #7043)
	maxRows: 4,

	// TODO rename to "widget" when switching to widget factory
	_widgetDatepicker: function() {
		return this.dpDiv;
	},

	/* Override the default settings for all instances of the date picker.
	 * @param  settings  object - the new settings to use as defaults (anonymous object)
	 * @return the manager object
	 */
	setDefaults: function( settings ) {
		datepicker_extendRemove( this._defaults, settings || {} );
		return this;
	},

	/* Attach the date picker to a jQuery selection.
	 * @param  target	element - the target input field or division or span
	 * @param  settings  object - the new settings to use for this date picker instance (anonymous)
	 */
	_attachDatepicker: function( target, settings ) {
		var nodeName, inline, inst;
		nodeName = target.nodeName.toLowerCase();
		inline = ( nodeName === "div" || nodeName === "span" );
		if ( !target.id ) {
			this.uuid += 1;
			target.id = "dp" + this.uuid;
		}
		inst = this._newInst( $( target ), inline );
		inst.settings = $.extend( {}, settings || {} );
		if ( nodeName === "input" ) {
			this._connectDatepicker( target, inst );
		} else if ( inline ) {
			this._inlineDatepicker( target, inst );
		}
	},

	/* Create a new instance object. */
	_newInst: function( target, inline ) {
		var id = target[ 0 ].id.replace( /([^A-Za-z0-9_\-])/g, "\\\\$1" ); // escape jQuery meta chars
		return { id: id, input: target, // associated target
			selectedDay: 0, selectedMonth: 0, selectedYear: 0, // current selection
			drawMonth: 0, drawYear: 0, // month being drawn
			inline: inline, // is datepicker inline or not
			dpDiv: ( !inline ? this.dpDiv : // presentation div
			datepicker_bindHover( $( "<div class='" + this._inlineClass + " ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>" ) ) ) };
	},

	/* Attach the date picker to an input field. */
	_connectDatepicker: function( target, inst ) {
		var input = $( target );
		inst.append = $( [] );
		inst.trigger = $( [] );
		if ( input.hasClass( this.markerClassName ) ) {
			return;
		}
		this._attachments( input, inst );
		input.addClass( this.markerClassName ).on( "keydown", this._doKeyDown ).
			on( "keypress", this._doKeyPress ).on( "keyup", this._doKeyUp );
		this._autoSize( inst );
		$.data( target, "datepicker", inst );

		//If disabled option is true, disable the datepicker once it has been attached to the input (see ticket #5665)
		if ( inst.settings.disabled ) {
			this._disableDatepicker( target );
		}
	},

	/* Make attachments based on settings. */
	_attachments: function( input, inst ) {
		var showOn, buttonText, buttonImage,
			appendText = this._get( inst, "appendText" ),
			isRTL = this._get( inst, "isRTL" );

		if ( inst.append ) {
			inst.append.remove();
		}
		if ( appendText ) {
			inst.append = $( "<span class='" + this._appendClass + "'>" + appendText + "</span>" );
			input[ isRTL ? "before" : "after" ]( inst.append );
		}

		input.off( "focus", this._showDatepicker );

		if ( inst.trigger ) {
			inst.trigger.remove();
		}

		showOn = this._get( inst, "showOn" );
		if ( showOn === "focus" || showOn === "both" ) { // pop-up date picker when in the marked field
			input.on( "focus", this._showDatepicker );
		}
		if ( showOn === "button" || showOn === "both" ) { // pop-up date picker when button clicked
			buttonText = this._get( inst, "buttonText" );
			buttonImage = this._get( inst, "buttonImage" );
			inst.trigger = $( this._get( inst, "buttonImageOnly" ) ?
				$( "<img/>" ).addClass( this._triggerClass ).
					attr( { src: buttonImage, alt: buttonText, title: buttonText } ) :
				$( "<button type='button'></button>" ).addClass( this._triggerClass ).
					html( !buttonImage ? buttonText : $( "<img/>" ).attr(
					{ src:buttonImage, alt:buttonText, title:buttonText } ) ) );
			input[ isRTL ? "before" : "after" ]( inst.trigger );
			inst.trigger.on( "click", function() {
				if ( $.datepicker._datepickerShowing && $.datepicker._lastInput === input[ 0 ] ) {
					$.datepicker._hideDatepicker();
				} else if ( $.datepicker._datepickerShowing && $.datepicker._lastInput !== input[ 0 ] ) {
					$.datepicker._hideDatepicker();
					$.datepicker._showDatepicker( input[ 0 ] );
				} else {
					$.datepicker._showDatepicker( input[ 0 ] );
				}
				return false;
			} );
		}
	},

	/* Apply the maximum length for the date format. */
	_autoSize: function( inst ) {
		if ( this._get( inst, "autoSize" ) && !inst.inline ) {
			var findMax, max, maxI, i,
				date = new Date( 2009, 12 - 1, 20 ), // Ensure double digits
				dateFormat = this._get( inst, "dateFormat" );

			if ( dateFormat.match( /[DM]/ ) ) {
				findMax = function( names ) {
					max = 0;
					maxI = 0;
					for ( i = 0; i < names.length; i++ ) {
						if ( names[ i ].length > max ) {
							max = names[ i ].length;
							maxI = i;
						}
					}
					return maxI;
				};
				date.setMonth( findMax( this._get( inst, ( dateFormat.match( /MM/ ) ?
					"monthNames" : "monthNamesShort" ) ) ) );
				date.setDate( findMax( this._get( inst, ( dateFormat.match( /DD/ ) ?
					"dayNames" : "dayNamesShort" ) ) ) + 20 - date.getDay() );
			}
			inst.input.attr( "size", this._formatDate( inst, date ).length );
		}
	},

	/* Attach an inline date picker to a div. */
	_inlineDatepicker: function( target, inst ) {
		var divSpan = $( target );
		if ( divSpan.hasClass( this.markerClassName ) ) {
			return;
		}
		divSpan.addClass( this.markerClassName ).append( inst.dpDiv );
		$.data( target, "datepicker", inst );
		this._setDate( inst, this._getDefaultDate( inst ), true );
		this._updateDatepicker( inst );
		this._updateAlternate( inst );

		//If disabled option is true, disable the datepicker before showing it (see ticket #5665)
		if ( inst.settings.disabled ) {
			this._disableDatepicker( target );
		}

		// Set display:block in place of inst.dpDiv.show() which won't work on disconnected elements
		// http://bugs.jqueryui.com/ticket/7552 - A Datepicker created on a detached div has zero height
		inst.dpDiv.css( "display", "block" );
	},

	/* Pop-up the date picker in a "dialog" box.
	 * @param  input element - ignored
	 * @param  date	string or Date - the initial date to display
	 * @param  onSelect  function - the function to call when a date is selected
	 * @param  settings  object - update the dialog date picker instance's settings (anonymous object)
	 * @param  pos int[2] - coordinates for the dialog's position within the screen or
	 *					event - with x/y coordinates or
	 *					leave empty for default (screen centre)
	 * @return the manager object
	 */
	_dialogDatepicker: function( input, date, onSelect, settings, pos ) {
		var id, browserWidth, browserHeight, scrollX, scrollY,
			inst = this._dialogInst; // internal instance

		if ( !inst ) {
			this.uuid += 1;
			id = "dp" + this.uuid;
			this._dialogInput = $( "<input type='text' id='" + id +
				"' style='position: absolute; top: -100px; width: 0px;'/>" );
			this._dialogInput.on( "keydown", this._doKeyDown );
			$( "body" ).append( this._dialogInput );
			inst = this._dialogInst = this._newInst( this._dialogInput, false );
			inst.settings = {};
			$.data( this._dialogInput[ 0 ], "datepicker", inst );
		}
		datepicker_extendRemove( inst.settings, settings || {} );
		date = ( date && date.constructor === Date ? this._formatDate( inst, date ) : date );
		this._dialogInput.val( date );

		this._pos = ( pos ? ( pos.length ? pos : [ pos.pageX, pos.pageY ] ) : null );
		if ( !this._pos ) {
			browserWidth = document.documentElement.clientWidth;
			browserHeight = document.documentElement.clientHeight;
			scrollX = document.documentElement.scrollLeft || document.body.scrollLeft;
			scrollY = document.documentElement.scrollTop || document.body.scrollTop;
			this._pos = // should use actual width/height below
				[ ( browserWidth / 2 ) - 100 + scrollX, ( browserHeight / 2 ) - 150 + scrollY ];
		}

		// Move input on screen for focus, but hidden behind dialog
		this._dialogInput.css( "left", ( this._pos[ 0 ] + 20 ) + "px" ).css( "top", this._pos[ 1 ] + "px" );
		inst.settings.onSelect = onSelect;
		this._inDialog = true;
		this.dpDiv.addClass( this._dialogClass );
		this._showDatepicker( this._dialogInput[ 0 ] );
		if ( $.blockUI ) {
			$.blockUI( this.dpDiv );
		}
		$.data( this._dialogInput[ 0 ], "datepicker", inst );
		return this;
	},

	/* Detach a datepicker from its control.
	 * @param  target	element - the target input field or division or span
	 */
	_destroyDatepicker: function( target ) {
		var nodeName,
			$target = $( target ),
			inst = $.data( target, "datepicker" );

		if ( !$target.hasClass( this.markerClassName ) ) {
			return;
		}

		nodeName = target.nodeName.toLowerCase();
		$.removeData( target, "datepicker" );
		if ( nodeName === "input" ) {
			inst.append.remove();
			inst.trigger.remove();
			$target.removeClass( this.markerClassName ).
				off( "focus", this._showDatepicker ).
				off( "keydown", this._doKeyDown ).
				off( "keypress", this._doKeyPress ).
				off( "keyup", this._doKeyUp );
		} else if ( nodeName === "div" || nodeName === "span" ) {
			$target.removeClass( this.markerClassName ).empty();
		}

		if ( datepicker_instActive === inst ) {
			datepicker_instActive = null;
		}
	},

	/* Enable the date picker to a jQuery selection.
	 * @param  target	element - the target input field or division or span
	 */
	_enableDatepicker: function( target ) {
		var nodeName, inline,
			$target = $( target ),
			inst = $.data( target, "datepicker" );

		if ( !$target.hasClass( this.markerClassName ) ) {
			return;
		}

		nodeName = target.nodeName.toLowerCase();
		if ( nodeName === "input" ) {
			target.disabled = false;
			inst.trigger.filter( "button" ).
				each( function() { this.disabled = false; } ).end().
				filter( "img" ).css( { opacity: "1.0", cursor: "" } );
		} else if ( nodeName === "div" || nodeName === "span" ) {
			inline = $target.children( "." + this._inlineClass );
			inline.children().removeClass( "ui-state-disabled" );
			inline.find( "select.ui-datepicker-month, select.ui-datepicker-year" ).
				prop( "disabled", false );
		}
		this._disabledInputs = $.map( this._disabledInputs,
			function( value ) { return ( value === target ? null : value ); } ); // delete entry
	},

	/* Disable the date picker to a jQuery selection.
	 * @param  target	element - the target input field or division or span
	 */
	_disableDatepicker: function( target ) {
		var nodeName, inline,
			$target = $( target ),
			inst = $.data( target, "datepicker" );

		if ( !$target.hasClass( this.markerClassName ) ) {
			return;
		}

		nodeName = target.nodeName.toLowerCase();
		if ( nodeName === "input" ) {
			target.disabled = true;
			inst.trigger.filter( "button" ).
				each( function() { this.disabled = true; } ).end().
				filter( "img" ).css( { opacity: "0.5", cursor: "default" } );
		} else if ( nodeName === "div" || nodeName === "span" ) {
			inline = $target.children( "." + this._inlineClass );
			inline.children().addClass( "ui-state-disabled" );
			inline.find( "select.ui-datepicker-month, select.ui-datepicker-year" ).
				prop( "disabled", true );
		}
		this._disabledInputs = $.map( this._disabledInputs,
			function( value ) { return ( value === target ? null : value ); } ); // delete entry
		this._disabledInputs[ this._disabledInputs.length ] = target;
	},

	/* Is the first field in a jQuery collection disabled as a datepicker?
	 * @param  target	element - the target input field or division or span
	 * @return boolean - true if disabled, false if enabled
	 */
	_isDisabledDatepicker: function( target ) {
		if ( !target ) {
			return false;
		}
		for ( var i = 0; i < this._disabledInputs.length; i++ ) {
			if ( this._disabledInputs[ i ] === target ) {
				return true;
			}
		}
		return false;
	},

	/* Retrieve the instance data for the target control.
	 * @param  target  element - the target input field or division or span
	 * @return  object - the associated instance data
	 * @throws  error if a jQuery problem getting data
	 */
	_getInst: function( target ) {
		try {
			return $.data( target, "datepicker" );
		}
		catch ( err ) {
			throw "Missing instance data for this datepicker";
		}
	},

	/* Update or retrieve the settings for a date picker attached to an input field or division.
	 * @param  target  element - the target input field or division or span
	 * @param  name	object - the new settings to update or
	 *				string - the name of the setting to change or retrieve,
	 *				when retrieving also "all" for all instance settings or
	 *				"defaults" for all global defaults
	 * @param  value   any - the new value for the setting
	 *				(omit if above is an object or to retrieve a value)
	 */
	_optionDatepicker: function( target, name, value ) {
		var settings, date, minDate, maxDate,
			inst = this._getInst( target );

		if ( arguments.length === 2 && typeof name === "string" ) {
			return ( name === "defaults" ? $.extend( {}, $.datepicker._defaults ) :
				( inst ? ( name === "all" ? $.extend( {}, inst.settings ) :
				this._get( inst, name ) ) : null ) );
		}

		settings = name || {};
		if ( typeof name === "string" ) {
			settings = {};
			settings[ name ] = value;
		}

		if ( inst ) {
			if ( this._curInst === inst ) {
				this._hideDatepicker();
			}

			date = this._getDateDatepicker( target, true );
			minDate = this._getMinMaxDate( inst, "min" );
			maxDate = this._getMinMaxDate( inst, "max" );
			datepicker_extendRemove( inst.settings, settings );

			// reformat the old minDate/maxDate values if dateFormat changes and a new minDate/maxDate isn't provided
			if ( minDate !== null && settings.dateFormat !== undefined && settings.minDate === undefined ) {
				inst.settings.minDate = this._formatDate( inst, minDate );
			}
			if ( maxDate !== null && settings.dateFormat !== undefined && settings.maxDate === undefined ) {
				inst.settings.maxDate = this._formatDate( inst, maxDate );
			}
			if ( "disabled" in settings ) {
				if ( settings.disabled ) {
					this._disableDatepicker( target );
				} else {
					this._enableDatepicker( target );
				}
			}
			this._attachments( $( target ), inst );
			this._autoSize( inst );
			this._setDate( inst, date );
			this._updateAlternate( inst );
			this._updateDatepicker( inst );
		}
	},

	// Change method deprecated
	_changeDatepicker: function( target, name, value ) {
		this._optionDatepicker( target, name, value );
	},

	/* Redraw the date picker attached to an input field or division.
	 * @param  target  element - the target input field or division or span
	 */
	_refreshDatepicker: function( target ) {
		var inst = this._getInst( target );
		if ( inst ) {
			this._updateDatepicker( inst );
		}
	},

	/* Set the dates for a jQuery selection.
	 * @param  target element - the target input field or division or span
	 * @param  date	Date - the new date
	 */
	_setDateDatepicker: function( target, date ) {
		var inst = this._getInst( target );
		if ( inst ) {
			this._setDate( inst, date );
			this._updateDatepicker( inst );
			this._updateAlternate( inst );
		}
	},

	/* Get the date(s) for the first entry in a jQuery selection.
	 * @param  target element - the target input field or division or span
	 * @param  noDefault boolean - true if no default date is to be used
	 * @return Date - the current date
	 */
	_getDateDatepicker: function( target, noDefault ) {
		var inst = this._getInst( target );
		if ( inst && !inst.inline ) {
			this._setDateFromField( inst, noDefault );
		}
		return ( inst ? this._getDate( inst ) : null );
	},

	/* Handle keystrokes. */
	_doKeyDown: function( event ) {
		var onSelect, dateStr, sel,
			inst = $.datepicker._getInst( event.target ),
			handled = true,
			isRTL = inst.dpDiv.is( ".ui-datepicker-rtl" );

		inst._keyEvent = true;
		if ( $.datepicker._datepickerShowing ) {
			switch ( event.keyCode ) {
				case 9: $.datepicker._hideDatepicker();
						handled = false;
						break; // hide on tab out
				case 13: sel = $( "td." + $.datepicker._dayOverClass + ":not(." +
									$.datepicker._currentClass + ")", inst.dpDiv );
						if ( sel[ 0 ] ) {
							$.datepicker._selectDay( event.target, inst.selectedMonth, inst.selectedYear, sel[ 0 ] );
						}

						onSelect = $.datepicker._get( inst, "onSelect" );
						if ( onSelect ) {
							dateStr = $.datepicker._formatDate( inst );

							// Trigger custom callback
							onSelect.apply( ( inst.input ? inst.input[ 0 ] : null ), [ dateStr, inst ] );
						} else {
							$.datepicker._hideDatepicker();
						}

						return false; // don't submit the form
				case 27: $.datepicker._hideDatepicker();
						break; // hide on escape
				case 33: $.datepicker._adjustDate( event.target, ( event.ctrlKey ?
							-$.datepicker._get( inst, "stepBigMonths" ) :
							-$.datepicker._get( inst, "stepMonths" ) ), "M" );
						break; // previous month/year on page up/+ ctrl
				case 34: $.datepicker._adjustDate( event.target, ( event.ctrlKey ?
							+$.datepicker._get( inst, "stepBigMonths" ) :
							+$.datepicker._get( inst, "stepMonths" ) ), "M" );
						break; // next month/year on page down/+ ctrl
				case 35: if ( event.ctrlKey || event.metaKey ) {
							$.datepicker._clearDate( event.target );
						}
						handled = event.ctrlKey || event.metaKey;
						break; // clear on ctrl or command +end
				case 36: if ( event.ctrlKey || event.metaKey ) {
							$.datepicker._gotoToday( event.target );
						}
						handled = event.ctrlKey || event.metaKey;
						break; // current on ctrl or command +home
				case 37: if ( event.ctrlKey || event.metaKey ) {
							$.datepicker._adjustDate( event.target, ( isRTL ? +1 : -1 ), "D" );
						}
						handled = event.ctrlKey || event.metaKey;

						// -1 day on ctrl or command +left
						if ( event.originalEvent.altKey ) {
							$.datepicker._adjustDate( event.target, ( event.ctrlKey ?
								-$.datepicker._get( inst, "stepBigMonths" ) :
								-$.datepicker._get( inst, "stepMonths" ) ), "M" );
						}

						// next month/year on alt +left on Mac
						break;
				case 38: if ( event.ctrlKey || event.metaKey ) {
							$.datepicker._adjustDate( event.target, -7, "D" );
						}
						handled = event.ctrlKey || event.metaKey;
						break; // -1 week on ctrl or command +up
				case 39: if ( event.ctrlKey || event.metaKey ) {
							$.datepicker._adjustDate( event.target, ( isRTL ? -1 : +1 ), "D" );
						}
						handled = event.ctrlKey || event.metaKey;

						// +1 day on ctrl or command +right
						if ( event.originalEvent.altKey ) {
							$.datepicker._adjustDate( event.target, ( event.ctrlKey ?
								+$.datepicker._get( inst, "stepBigMonths" ) :
								+$.datepicker._get( inst, "stepMonths" ) ), "M" );
						}

						// next month/year on alt +right
						break;
				case 40: if ( event.ctrlKey || event.metaKey ) {
							$.datepicker._adjustDate( event.target, +7, "D" );
						}
						handled = event.ctrlKey || event.metaKey;
						break; // +1 week on ctrl or command +down
				default: handled = false;
			}
		} else if ( event.keyCode === 36 && event.ctrlKey ) { // display the date picker on ctrl+home
			$.datepicker._showDatepicker( this );
		} else {
			handled = false;
		}

		if ( handled ) {
			event.preventDefault();
			event.stopPropagation();
		}
	},

	/* Filter entered characters - based on date format. */
	_doKeyPress: function( event ) {
		var chars, chr,
			inst = $.datepicker._getInst( event.target );

		if ( $.datepicker._get( inst, "constrainInput" ) ) {
			chars = $.datepicker._possibleChars( $.datepicker._get( inst, "dateFormat" ) );
			chr = String.fromCharCode( event.charCode == null ? event.keyCode : event.charCode );
			return event.ctrlKey || event.metaKey || ( chr < " " || !chars || chars.indexOf( chr ) > -1 );
		}
	},

	/* Synchronise manual entry and field/alternate field. */
	_doKeyUp: function( event ) {
		var date,
			inst = $.datepicker._getInst( event.target );

		if ( inst.input.val() !== inst.lastVal ) {
			try {
				date = $.datepicker.parseDate( $.datepicker._get( inst, "dateFormat" ),
					( inst.input ? inst.input.val() : null ),
					$.datepicker._getFormatConfig( inst ) );

				if ( date ) { // only if valid
					$.datepicker._setDateFromField( inst );
					$.datepicker._updateAlternate( inst );
					$.datepicker._updateDatepicker( inst );
				}
			}
			catch ( err ) {
			}
		}
		return true;
	},

	/* Pop-up the date picker for a given input field.
	 * If false returned from beforeShow event handler do not show.
	 * @param  input  element - the input field attached to the date picker or
	 *					event - if triggered by focus
	 */
	_showDatepicker: function( input ) {
		input = input.target || input;
		if ( input.nodeName.toLowerCase() !== "input" ) { // find from button/image trigger
			input = $( "input", input.parentNode )[ 0 ];
		}

		if ( $.datepicker._isDisabledDatepicker( input ) || $.datepicker._lastInput === input ) { // already here
			return;
		}

		var inst, beforeShow, beforeShowSettings, isFixed,
			offset, showAnim, duration;

		inst = $.datepicker._getInst( input );
		if ( $.datepicker._curInst && $.datepicker._curInst !== inst ) {
			$.datepicker._curInst.dpDiv.stop( true, true );
			if ( inst && $.datepicker._datepickerShowing ) {
				$.datepicker._hideDatepicker( $.datepicker._curInst.input[ 0 ] );
			}
		}

		beforeShow = $.datepicker._get( inst, "beforeShow" );
		beforeShowSettings = beforeShow ? beforeShow.apply( input, [ input, inst ] ) : {};
		if ( beforeShowSettings === false ) {
			return;
		}
		datepicker_extendRemove( inst.settings, beforeShowSettings );

		inst.lastVal = null;
		$.datepicker._lastInput = input;
		$.datepicker._setDateFromField( inst );

		if ( $.datepicker._inDialog ) { // hide cursor
			input.value = "";
		}
		if ( !$.datepicker._pos ) { // position below input
			$.datepicker._pos = $.datepicker._findPos( input );
			$.datepicker._pos[ 1 ] += input.offsetHeight; // add the height
		}

		isFixed = false;
		$( input ).parents().each( function() {
			isFixed |= $( this ).css( "position" ) === "fixed";
			return !isFixed;
		} );

		offset = { left: $.datepicker._pos[ 0 ], top: $.datepicker._pos[ 1 ] };
		$.datepicker._pos = null;

		//to avoid flashes on Firefox
		inst.dpDiv.empty();

		// determine sizing offscreen
		inst.dpDiv.css( { position: "absolute", display: "block", top: "-1000px" } );
		$.datepicker._updateDatepicker( inst );

		// fix width for dynamic number of date pickers
		// and adjust position before showing
		offset = $.datepicker._checkOffset( inst, offset, isFixed );
		inst.dpDiv.css( { position: ( $.datepicker._inDialog && $.blockUI ?
			"static" : ( isFixed ? "fixed" : "absolute" ) ), display: "none",
			left: offset.left + "px", top: offset.top + "px" } );

		if ( !inst.inline ) {
			showAnim = $.datepicker._get( inst, "showAnim" );
			duration = $.datepicker._get( inst, "duration" );
			inst.dpDiv.css( "z-index", datepicker_getZindex( $( input ) ) + 1 );
			$.datepicker._datepickerShowing = true;

			if ( $.effects && $.effects.effect[ showAnim ] ) {
				inst.dpDiv.show( showAnim, $.datepicker._get( inst, "showOptions" ), duration );
			} else {
				inst.dpDiv[ showAnim || "show" ]( showAnim ? duration : null );
			}

			if ( $.datepicker._shouldFocusInput( inst ) ) {
				inst.input.trigger( "focus" );
			}

			$.datepicker._curInst = inst;
		}
	},

	/* Generate the date picker content. */
	_updateDatepicker: function( inst ) {
		this.maxRows = 4; //Reset the max number of rows being displayed (see #7043)
		datepicker_instActive = inst; // for delegate hover events
		inst.dpDiv.empty().append( this._generateHTML( inst ) );
		this._attachHandlers( inst );

		var origyearshtml,
			numMonths = this._getNumberOfMonths( inst ),
			cols = numMonths[ 1 ],
			width = 17,
			activeCell = inst.dpDiv.find( "." + this._dayOverClass + " a" );

		if ( activeCell.length > 0 ) {
			datepicker_handleMouseover.apply( activeCell.get( 0 ) );
		}

		inst.dpDiv.removeClass( "ui-datepicker-multi-2 ui-datepicker-multi-3 ui-datepicker-multi-4" ).width( "" );
		if ( cols > 1 ) {
			inst.dpDiv.addClass( "ui-datepicker-multi-" + cols ).css( "width", ( width * cols ) + "em" );
		}
		inst.dpDiv[ ( numMonths[ 0 ] !== 1 || numMonths[ 1 ] !== 1 ? "add" : "remove" ) +
			"Class" ]( "ui-datepicker-multi" );
		inst.dpDiv[ ( this._get( inst, "isRTL" ) ? "add" : "remove" ) +
			"Class" ]( "ui-datepicker-rtl" );

		if ( inst === $.datepicker._curInst && $.datepicker._datepickerShowing && $.datepicker._shouldFocusInput( inst ) ) {
			inst.input.trigger( "focus" );
		}

		// Deffered render of the years select (to avoid flashes on Firefox)
		if ( inst.yearshtml ) {
			origyearshtml = inst.yearshtml;
			setTimeout( function() {

				//assure that inst.yearshtml didn't change.
				if ( origyearshtml === inst.yearshtml && inst.yearshtml ) {
					inst.dpDiv.find( "select.ui-datepicker-year:first" ).replaceWith( inst.yearshtml );
				}
				origyearshtml = inst.yearshtml = null;
			}, 0 );
		}
	},

	// #6694 - don't focus the input if it's already focused
	// this breaks the change event in IE
	// Support: IE and jQuery <1.9
	_shouldFocusInput: function( inst ) {
		return inst.input && inst.input.is( ":visible" ) && !inst.input.is( ":disabled" ) && !inst.input.is( ":focus" );
	},

	/* Check positioning to remain on screen. */
	_checkOffset: function( inst, offset, isFixed ) {
		var dpWidth = inst.dpDiv.outerWidth(),
			dpHeight = inst.dpDiv.outerHeight(),
			inputWidth = inst.input ? inst.input.outerWidth() : 0,
			inputHeight = inst.input ? inst.input.outerHeight() : 0,
			viewWidth = document.documentElement.clientWidth + ( isFixed ? 0 : $( document ).scrollLeft() ),
			viewHeight = document.documentElement.clientHeight + ( isFixed ? 0 : $( document ).scrollTop() );

		offset.left -= ( this._get( inst, "isRTL" ) ? ( dpWidth - inputWidth ) : 0 );
		offset.left -= ( isFixed && offset.left === inst.input.offset().left ) ? $( document ).scrollLeft() : 0;
		offset.top -= ( isFixed && offset.top === ( inst.input.offset().top + inputHeight ) ) ? $( document ).scrollTop() : 0;

		// Now check if datepicker is showing outside window viewport - move to a better place if so.
		offset.left -= Math.min( offset.left, ( offset.left + dpWidth > viewWidth && viewWidth > dpWidth ) ?
			Math.abs( offset.left + dpWidth - viewWidth ) : 0 );
		offset.top -= Math.min( offset.top, ( offset.top + dpHeight > viewHeight && viewHeight > dpHeight ) ?
			Math.abs( dpHeight + inputHeight ) : 0 );

		return offset;
	},

	/* Find an object's position on the screen. */
	_findPos: function( obj ) {
		var position,
			inst = this._getInst( obj ),
			isRTL = this._get( inst, "isRTL" );

		while ( obj && ( obj.type === "hidden" || obj.nodeType !== 1 || $.expr.filters.hidden( obj ) ) ) {
			obj = obj[ isRTL ? "previousSibling" : "nextSibling" ];
		}

		position = $( obj ).offset();
		return [ position.left, position.top ];
	},

	/* Hide the date picker from view.
	 * @param  input  element - the input field attached to the date picker
	 */
	_hideDatepicker: function( input ) {
		var showAnim, duration, postProcess, onClose,
			inst = this._curInst;

		if ( !inst || ( input && inst !== $.data( input, "datepicker" ) ) ) {
			return;
		}

		if ( this._datepickerShowing ) {
			showAnim = this._get( inst, "showAnim" );
			duration = this._get( inst, "duration" );
			postProcess = function() {
				$.datepicker._tidyDialog( inst );
			};

			// DEPRECATED: after BC for 1.8.x $.effects[ showAnim ] is not needed
			if ( $.effects && ( $.effects.effect[ showAnim ] || $.effects[ showAnim ] ) ) {
				inst.dpDiv.hide( showAnim, $.datepicker._get( inst, "showOptions" ), duration, postProcess );
			} else {
				inst.dpDiv[ ( showAnim === "slideDown" ? "slideUp" :
					( showAnim === "fadeIn" ? "fadeOut" : "hide" ) ) ]( ( showAnim ? duration : null ), postProcess );
			}

			if ( !showAnim ) {
				postProcess();
			}
			this._datepickerShowing = false;

			onClose = this._get( inst, "onClose" );
			if ( onClose ) {
				onClose.apply( ( inst.input ? inst.input[ 0 ] : null ), [ ( inst.input ? inst.input.val() : "" ), inst ] );
			}

			this._lastInput = null;
			if ( this._inDialog ) {
				this._dialogInput.css( { position: "absolute", left: "0", top: "-100px" } );
				if ( $.blockUI ) {
					$.unblockUI();
					$( "body" ).append( this.dpDiv );
				}
			}
			this._inDialog = false;
		}
	},

	/* Tidy up after a dialog display. */
	_tidyDialog: function( inst ) {
		inst.dpDiv.removeClass( this._dialogClass ).off( ".ui-datepicker-calendar" );
	},

	/* Close date picker if clicked elsewhere. */
	_checkExternalClick: function( event ) {
		if ( !$.datepicker._curInst ) {
			return;
		}

		var $target = $( event.target ),
			inst = $.datepicker._getInst( $target[ 0 ] );

		if ( ( ( $target[ 0 ].id !== $.datepicker._mainDivId &&
				$target.parents( "#" + $.datepicker._mainDivId ).length === 0 &&
				!$target.hasClass( $.datepicker.markerClassName ) &&
				!$target.closest( "." + $.datepicker._triggerClass ).length &&
				$.datepicker._datepickerShowing && !( $.datepicker._inDialog && $.blockUI ) ) ) ||
			( $target.hasClass( $.datepicker.markerClassName ) && $.datepicker._curInst !== inst ) ) {
				$.datepicker._hideDatepicker();
		}
	},

	/* Adjust one of the date sub-fields. */
	_adjustDate: function( id, offset, period ) {
		var target = $( id ),
			inst = this._getInst( target[ 0 ] );

		if ( this._isDisabledDatepicker( target[ 0 ] ) ) {
			return;
		}
		this._adjustInstDate( inst, offset +
			( period === "M" ? this._get( inst, "showCurrentAtPos" ) : 0 ), // undo positioning
			period );
		this._updateDatepicker( inst );
	},

	/* Action for current link. */
	_gotoToday: function( id ) {
		var date,
			target = $( id ),
			inst = this._getInst( target[ 0 ] );

		if ( this._get( inst, "gotoCurrent" ) && inst.currentDay ) {
			inst.selectedDay = inst.currentDay;
			inst.drawMonth = inst.selectedMonth = inst.currentMonth;
			inst.drawYear = inst.selectedYear = inst.currentYear;
		} else {
			date = new Date();
			inst.selectedDay = date.getDate();
			inst.drawMonth = inst.selectedMonth = date.getMonth();
			inst.drawYear = inst.selectedYear = date.getFullYear();
		}
		this._notifyChange( inst );
		this._adjustDate( target );
	},

	/* Action for selecting a new month/year. */
	_selectMonthYear: function( id, select, period ) {
		var target = $( id ),
			inst = this._getInst( target[ 0 ] );

		inst[ "selected" + ( period === "M" ? "Month" : "Year" ) ] =
		inst[ "draw" + ( period === "M" ? "Month" : "Year" ) ] =
			parseInt( select.options[ select.selectedIndex ].value, 10 );

		this._notifyChange( inst );
		this._adjustDate( target );
	},

	/* Action for selecting a day. */
	_selectDay: function( id, month, year, td ) {
		var inst,
			target = $( id );

		if ( $( td ).hasClass( this._unselectableClass ) || this._isDisabledDatepicker( target[ 0 ] ) ) {
			return;
		}

		inst = this._getInst( target[ 0 ] );
		inst.selectedDay = inst.currentDay = $( "a", td ).html();
		inst.selectedMonth = inst.currentMonth = month;
		inst.selectedYear = inst.currentYear = year;
		this._selectDate( id, this._formatDate( inst,
			inst.currentDay, inst.currentMonth, inst.currentYear ) );
	},

	/* Erase the input field and hide the date picker. */
	_clearDate: function( id ) {
		var target = $( id );
		this._selectDate( target, "" );
	},

	/* Update the input field with the selected date. */
	_selectDate: function( id, dateStr ) {
		var onSelect,
			target = $( id ),
			inst = this._getInst( target[ 0 ] );

		dateStr = ( dateStr != null ? dateStr : this._formatDate( inst ) );
		if ( inst.input ) {
			inst.input.val( dateStr );
		}
		this._updateAlternate( inst );

		onSelect = this._get( inst, "onSelect" );
		if ( onSelect ) {
			onSelect.apply( ( inst.input ? inst.input[ 0 ] : null ), [ dateStr, inst ] );  // trigger custom callback
		} else if ( inst.input ) {
			inst.input.trigger( "change" ); // fire the change event
		}

		if ( inst.inline ) {
			this._updateDatepicker( inst );
		} else {
			this._hideDatepicker();
			this._lastInput = inst.input[ 0 ];
			if ( typeof( inst.input[ 0 ] ) !== "object" ) {
				inst.input.trigger( "focus" ); // restore focus
			}
			this._lastInput = null;
		}
	},

	/* Update any alternate field to synchronise with the main field. */
	_updateAlternate: function( inst ) {
		var altFormat, date, dateStr,
			altField = this._get( inst, "altField" );

		if ( altField ) { // update alternate field too
			altFormat = this._get( inst, "altFormat" ) || this._get( inst, "dateFormat" );
			date = this._getDate( inst );
			dateStr = this.formatDate( altFormat, date, this._getFormatConfig( inst ) );
			$( altField ).val( dateStr );
		}
	},

	/* Set as beforeShowDay function to prevent selection of weekends.
	 * @param  date  Date - the date to customise
	 * @return [boolean, string] - is this date selectable?, what is its CSS class?
	 */
	noWeekends: function( date ) {
		var day = date.getDay();
		return [ ( day > 0 && day < 6 ), "" ];
	},

	/* Set as calculateWeek to determine the week of the year based on the ISO 8601 definition.
	 * @param  date  Date - the date to get the week for
	 * @return  number - the number of the week within the year that contains this date
	 */
	iso8601Week: function( date ) {
		var time,
			checkDate = new Date( date.getTime() );

		// Find Thursday of this week starting on Monday
		checkDate.setDate( checkDate.getDate() + 4 - ( checkDate.getDay() || 7 ) );

		time = checkDate.getTime();
		checkDate.setMonth( 0 ); // Compare with Jan 1
		checkDate.setDate( 1 );
		return Math.floor( Math.round( ( time - checkDate ) / 86400000 ) / 7 ) + 1;
	},

	/* Parse a string value into a date object.
	 * See formatDate below for the possible formats.
	 *
	 * @param  format string - the expected format of the date
	 * @param  value string - the date in the above format
	 * @param  settings Object - attributes include:
	 *					shortYearCutoff  number - the cutoff year for determining the century (optional)
	 *					dayNamesShort	string[7] - abbreviated names of the days from Sunday (optional)
	 *					dayNames		string[7] - names of the days from Sunday (optional)
	 *					monthNamesShort string[12] - abbreviated names of the months (optional)
	 *					monthNames		string[12] - names of the months (optional)
	 * @return  Date - the extracted date value or null if value is blank
	 */
	parseDate: function( format, value, settings ) {
		if ( format == null || value == null ) {
			throw "Invalid arguments";
		}

		value = ( typeof value === "object" ? value.toString() : value + "" );
		if ( value === "" ) {
			return null;
		}

		var iFormat, dim, extra,
			iValue = 0,
			shortYearCutoffTemp = ( settings ? settings.shortYearCutoff : null ) || this._defaults.shortYearCutoff,
			shortYearCutoff = ( typeof shortYearCutoffTemp !== "string" ? shortYearCutoffTemp :
				new Date().getFullYear() % 100 + parseInt( shortYearCutoffTemp, 10 ) ),
			dayNamesShort = ( settings ? settings.dayNamesShort : null ) || this._defaults.dayNamesShort,
			dayNames = ( settings ? settings.dayNames : null ) || this._defaults.dayNames,
			monthNamesShort = ( settings ? settings.monthNamesShort : null ) || this._defaults.monthNamesShort,
			monthNames = ( settings ? settings.monthNames : null ) || this._defaults.monthNames,
			year = -1,
			month = -1,
			day = -1,
			doy = -1,
			literal = false,
			date,

			// Check whether a format character is doubled
			lookAhead = function( match ) {
				var matches = ( iFormat + 1 < format.length && format.charAt( iFormat + 1 ) === match );
				if ( matches ) {
					iFormat++;
				}
				return matches;
			},

			// Extract a number from the string value
			getNumber = function( match ) {
				var isDoubled = lookAhead( match ),
					size = ( match === "@" ? 14 : ( match === "!" ? 20 :
					( match === "y" && isDoubled ? 4 : ( match === "o" ? 3 : 2 ) ) ) ),
					minSize = ( match === "y" ? size : 1 ),
					digits = new RegExp( "^\\d{" + minSize + "," + size + "}" ),
					num = value.substring( iValue ).match( digits );
				if ( !num ) {
					throw "Missing number at position " + iValue;
				}
				iValue += num[ 0 ].length;
				return parseInt( num[ 0 ], 10 );
			},

			// Extract a name from the string value and convert to an index
			getName = function( match, shortNames, longNames ) {
				var index = -1,
					names = $.map( lookAhead( match ) ? longNames : shortNames, function( v, k ) {
						return [ [ k, v ] ];
					} ).sort( function( a, b ) {
						return -( a[ 1 ].length - b[ 1 ].length );
					} );

				$.each( names, function( i, pair ) {
					var name = pair[ 1 ];
					if ( value.substr( iValue, name.length ).toLowerCase() === name.toLowerCase() ) {
						index = pair[ 0 ];
						iValue += name.length;
						return false;
					}
				} );
				if ( index !== -1 ) {
					return index + 1;
				} else {
					throw "Unknown name at position " + iValue;
				}
			},

			// Confirm that a literal character matches the string value
			checkLiteral = function() {
				if ( value.charAt( iValue ) !== format.charAt( iFormat ) ) {
					throw "Unexpected literal at position " + iValue;
				}
				iValue++;
			};

		for ( iFormat = 0; iFormat < format.length; iFormat++ ) {
			if ( literal ) {
				if ( format.charAt( iFormat ) === "'" && !lookAhead( "'" ) ) {
					literal = false;
				} else {
					checkLiteral();
				}
			} else {
				switch ( format.charAt( iFormat ) ) {
					case "d":
						day = getNumber( "d" );
						break;
					case "D":
						getName( "D", dayNamesShort, dayNames );
						break;
					case "o":
						doy = getNumber( "o" );
						break;
					case "m":
						month = getNumber( "m" );
						break;
					case "M":
						month = getName( "M", monthNamesShort, monthNames );
						break;
					case "y":
						year = getNumber( "y" );
						break;
					case "@":
						date = new Date( getNumber( "@" ) );
						year = date.getFullYear();
						month = date.getMonth() + 1;
						day = date.getDate();
						break;
					case "!":
						date = new Date( ( getNumber( "!" ) - this._ticksTo1970 ) / 10000 );
						year = date.getFullYear();
						month = date.getMonth() + 1;
						day = date.getDate();
						break;
					case "'":
						if ( lookAhead( "'" ) ) {
							checkLiteral();
						} else {
							literal = true;
						}
						break;
					default:
						checkLiteral();
				}
			}
		}

		if ( iValue < value.length ) {
			extra = value.substr( iValue );
			if ( !/^\s+/.test( extra ) ) {
				throw "Extra/unparsed characters found in date: " + extra;
			}
		}

		if ( year === -1 ) {
			year = new Date().getFullYear();
		} else if ( year < 100 ) {
			year += new Date().getFullYear() - new Date().getFullYear() % 100 +
				( year <= shortYearCutoff ? 0 : -100 );
		}

		if ( doy > -1 ) {
			month = 1;
			day = doy;
			do {
				dim = this._getDaysInMonth( year, month - 1 );
				if ( day <= dim ) {
					break;
				}
				month++;
				day -= dim;
			} while ( true );
		}

		date = this._daylightSavingAdjust( new Date( year, month - 1, day ) );
		if ( date.getFullYear() !== year || date.getMonth() + 1 !== month || date.getDate() !== day ) {
			throw "Invalid date"; // E.g. 31/02/00
		}
		return date;
	},

	/* Standard date formats. */
	ATOM: "yy-mm-dd", // RFC 3339 (ISO 8601)
	COOKIE: "D, dd M yy",
	ISO_8601: "yy-mm-dd",
	RFC_822: "D, d M y",
	RFC_850: "DD, dd-M-y",
	RFC_1036: "D, d M y",
	RFC_1123: "D, d M yy",
	RFC_2822: "D, d M yy",
	RSS: "D, d M y", // RFC 822
	TICKS: "!",
	TIMESTAMP: "@",
	W3C: "yy-mm-dd", // ISO 8601

	_ticksTo1970: ( ( ( 1970 - 1 ) * 365 + Math.floor( 1970 / 4 ) - Math.floor( 1970 / 100 ) +
		Math.floor( 1970 / 400 ) ) * 24 * 60 * 60 * 10000000 ),

	/* Format a date object into a string value.
	 * The format can be combinations of the following:
	 * d  - day of month (no leading zero)
	 * dd - day of month (two digit)
	 * o  - day of year (no leading zeros)
	 * oo - day of year (three digit)
	 * D  - day name short
	 * DD - day name long
	 * m  - month of year (no leading zero)
	 * mm - month of year (two digit)
	 * M  - month name short
	 * MM - month name long
	 * y  - year (two digit)
	 * yy - year (four digit)
	 * @ - Unix timestamp (ms since 01/01/1970)
	 * ! - Windows ticks (100ns since 01/01/0001)
	 * "..." - literal text
	 * '' - single quote
	 *
	 * @param  format string - the desired format of the date
	 * @param  date Date - the date value to format
	 * @param  settings Object - attributes include:
	 *					dayNamesShort	string[7] - abbreviated names of the days from Sunday (optional)
	 *					dayNames		string[7] - names of the days from Sunday (optional)
	 *					monthNamesShort string[12] - abbreviated names of the months (optional)
	 *					monthNames		string[12] - names of the months (optional)
	 * @return  string - the date in the above format
	 */
	formatDate: function( format, date, settings ) {
		if ( !date ) {
			return "";
		}

		var iFormat,
			dayNamesShort = ( settings ? settings.dayNamesShort : null ) || this._defaults.dayNamesShort,
			dayNames = ( settings ? settings.dayNames : null ) || this._defaults.dayNames,
			monthNamesShort = ( settings ? settings.monthNamesShort : null ) || this._defaults.monthNamesShort,
			monthNames = ( settings ? settings.monthNames : null ) || this._defaults.monthNames,

			// Check whether a format character is doubled
			lookAhead = function( match ) {
				var matches = ( iFormat + 1 < format.length && format.charAt( iFormat + 1 ) === match );
				if ( matches ) {
					iFormat++;
				}
				return matches;
			},

			// Format a number, with leading zero if necessary
			formatNumber = function( match, value, len ) {
				var num = "" + value;
				if ( lookAhead( match ) ) {
					while ( num.length < len ) {
						num = "0" + num;
					}
				}
				return num;
			},

			// Format a name, short or long as requested
			formatName = function( match, value, shortNames, longNames ) {
				return ( lookAhead( match ) ? longNames[ value ] : shortNames[ value ] );
			},
			output = "",
			literal = false;

		if ( date ) {
			for ( iFormat = 0; iFormat < format.length; iFormat++ ) {
				if ( literal ) {
					if ( format.charAt( iFormat ) === "'" && !lookAhead( "'" ) ) {
						literal = false;
					} else {
						output += format.charAt( iFormat );
					}
				} else {
					switch ( format.charAt( iFormat ) ) {
						case "d":
							output += formatNumber( "d", date.getDate(), 2 );
							break;
						case "D":
							output += formatName( "D", date.getDay(), dayNamesShort, dayNames );
							break;
						case "o":
							output += formatNumber( "o",
								Math.round( ( new Date( date.getFullYear(), date.getMonth(), date.getDate() ).getTime() - new Date( date.getFullYear(), 0, 0 ).getTime() ) / 86400000 ), 3 );
							break;
						case "m":
							output += formatNumber( "m", date.getMonth() + 1, 2 );
							break;
						case "M":
							output += formatName( "M", date.getMonth(), monthNamesShort, monthNames );
							break;
						case "y":
							output += ( lookAhead( "y" ) ? date.getFullYear() :
								( date.getFullYear() % 100 < 10 ? "0" : "" ) + date.getFullYear() % 100 );
							break;
						case "@":
							output += date.getTime();
							break;
						case "!":
							output += date.getTime() * 10000 + this._ticksTo1970;
							break;
						case "'":
							if ( lookAhead( "'" ) ) {
								output += "'";
							} else {
								literal = true;
							}
							break;
						default:
							output += format.charAt( iFormat );
					}
				}
			}
		}
		return output;
	},

	/* Extract all possible characters from the date format. */
	_possibleChars: function( format ) {
		var iFormat,
			chars = "",
			literal = false,

			// Check whether a format character is doubled
			lookAhead = function( match ) {
				var matches = ( iFormat + 1 < format.length && format.charAt( iFormat + 1 ) === match );
				if ( matches ) {
					iFormat++;
				}
				return matches;
			};

		for ( iFormat = 0; iFormat < format.length; iFormat++ ) {
			if ( literal ) {
				if ( format.charAt( iFormat ) === "'" && !lookAhead( "'" ) ) {
					literal = false;
				} else {
					chars += format.charAt( iFormat );
				}
			} else {
				switch ( format.charAt( iFormat ) ) {
					case "d": case "m": case "y": case "@":
						chars += "0123456789";
						break;
					case "D": case "M":
						return null; // Accept anything
					case "'":
						if ( lookAhead( "'" ) ) {
							chars += "'";
						} else {
							literal = true;
						}
						break;
					default:
						chars += format.charAt( iFormat );
				}
			}
		}
		return chars;
	},

	/* Get a setting value, defaulting if necessary. */
	_get: function( inst, name ) {
		return inst.settings[ name ] !== undefined ?
			inst.settings[ name ] : this._defaults[ name ];
	},

	/* Parse existing date and initialise date picker. */
	_setDateFromField: function( inst, noDefault ) {
		if ( inst.input.val() === inst.lastVal ) {
			return;
		}

		var dateFormat = this._get( inst, "dateFormat" ),
			dates = inst.lastVal = inst.input ? inst.input.val() : null,
			defaultDate = this._getDefaultDate( inst ),
			date = defaultDate,
			settings = this._getFormatConfig( inst );

		try {
			date = this.parseDate( dateFormat, dates, settings ) || defaultDate;
		} catch ( event ) {
			dates = ( noDefault ? "" : dates );
		}
		inst.selectedDay = date.getDate();
		inst.drawMonth = inst.selectedMonth = date.getMonth();
		inst.drawYear = inst.selectedYear = date.getFullYear();
		inst.currentDay = ( dates ? date.getDate() : 0 );
		inst.currentMonth = ( dates ? date.getMonth() : 0 );
		inst.currentYear = ( dates ? date.getFullYear() : 0 );
		this._adjustInstDate( inst );
	},

	/* Retrieve the default date shown on opening. */
	_getDefaultDate: function( inst ) {
		return this._restrictMinMax( inst,
			this._determineDate( inst, this._get( inst, "defaultDate" ), new Date() ) );
	},

	/* A date may be specified as an exact value or a relative one. */
	_determineDate: function( inst, date, defaultDate ) {
		var offsetNumeric = function( offset ) {
				var date = new Date();
				date.setDate( date.getDate() + offset );
				return date;
			},
			offsetString = function( offset ) {
				try {
					return $.datepicker.parseDate( $.datepicker._get( inst, "dateFormat" ),
						offset, $.datepicker._getFormatConfig( inst ) );
				}
				catch ( e ) {

					// Ignore
				}

				var date = ( offset.toLowerCase().match( /^c/ ) ?
					$.datepicker._getDate( inst ) : null ) || new Date(),
					year = date.getFullYear(),
					month = date.getMonth(),
					day = date.getDate(),
					pattern = /([+\-]?[0-9]+)\s*(d|D|w|W|m|M|y|Y)?/g,
					matches = pattern.exec( offset );

				while ( matches ) {
					switch ( matches[ 2 ] || "d" ) {
						case "d" : case "D" :
							day += parseInt( matches[ 1 ], 10 ); break;
						case "w" : case "W" :
							day += parseInt( matches[ 1 ], 10 ) * 7; break;
						case "m" : case "M" :
							month += parseInt( matches[ 1 ], 10 );
							day = Math.min( day, $.datepicker._getDaysInMonth( year, month ) );
							break;
						case "y": case "Y" :
							year += parseInt( matches[ 1 ], 10 );
							day = Math.min( day, $.datepicker._getDaysInMonth( year, month ) );
							break;
					}
					matches = pattern.exec( offset );
				}
				return new Date( year, month, day );
			},
			newDate = ( date == null || date === "" ? defaultDate : ( typeof date === "string" ? offsetString( date ) :
				( typeof date === "number" ? ( isNaN( date ) ? defaultDate : offsetNumeric( date ) ) : new Date( date.getTime() ) ) ) );

		newDate = ( newDate && newDate.toString() === "Invalid Date" ? defaultDate : newDate );
		if ( newDate ) {
			newDate.setHours( 0 );
			newDate.setMinutes( 0 );
			newDate.setSeconds( 0 );
			newDate.setMilliseconds( 0 );
		}
		return this._daylightSavingAdjust( newDate );
	},

	/* Handle switch to/from daylight saving.
	 * Hours may be non-zero on daylight saving cut-over:
	 * > 12 when midnight changeover, but then cannot generate
	 * midnight datetime, so jump to 1AM, otherwise reset.
	 * @param  date  (Date) the date to check
	 * @return  (Date) the corrected date
	 */
	_daylightSavingAdjust: function( date ) {
		if ( !date ) {
			return null;
		}
		date.setHours( date.getHours() > 12 ? date.getHours() + 2 : 0 );
		return date;
	},

	/* Set the date(s) directly. */
	_setDate: function( inst, date, noChange ) {
		var clear = !date,
			origMonth = inst.selectedMonth,
			origYear = inst.selectedYear,
			newDate = this._restrictMinMax( inst, this._determineDate( inst, date, new Date() ) );

		inst.selectedDay = inst.currentDay = newDate.getDate();
		inst.drawMonth = inst.selectedMonth = inst.currentMonth = newDate.getMonth();
		inst.drawYear = inst.selectedYear = inst.currentYear = newDate.getFullYear();
		if ( ( origMonth !== inst.selectedMonth || origYear !== inst.selectedYear ) && !noChange ) {
			this._notifyChange( inst );
		}
		this._adjustInstDate( inst );
		if ( inst.input ) {
			inst.input.val( clear ? "" : this._formatDate( inst ) );
		}
	},

	/* Retrieve the date(s) directly. */
	_getDate: function( inst ) {
		var startDate = ( !inst.currentYear || ( inst.input && inst.input.val() === "" ) ? null :
			this._daylightSavingAdjust( new Date(
			inst.currentYear, inst.currentMonth, inst.currentDay ) ) );
			return startDate;
	},

	/* Attach the onxxx handlers.  These are declared statically so
	 * they work with static code transformers like Caja.
	 */
	_attachHandlers: function( inst ) {
		var stepMonths = this._get( inst, "stepMonths" ),
			id = "#" + inst.id.replace( /\\\\/g, "\\" );
		inst.dpDiv.find( "[data-handler]" ).map( function() {
			var handler = {
				prev: function() {
					$.datepicker._adjustDate( id, -stepMonths, "M" );
				},
				next: function() {
					$.datepicker._adjustDate( id, +stepMonths, "M" );
				},
				hide: function() {
					$.datepicker._hideDatepicker();
				},
				today: function() {
					$.datepicker._gotoToday( id );
				},
				selectDay: function() {
					$.datepicker._selectDay( id, +this.getAttribute( "data-month" ), +this.getAttribute( "data-year" ), this );
					return false;
				},
				selectMonth: function() {
					$.datepicker._selectMonthYear( id, this, "M" );
					return false;
				},
				selectYear: function() {
					$.datepicker._selectMonthYear( id, this, "Y" );
					return false;
				}
			};
			$( this ).on( this.getAttribute( "data-event" ), handler[ this.getAttribute( "data-handler" ) ] );
		} );
	},

	/* Generate the HTML for the current state of the date picker. */
	_generateHTML: function( inst ) {
		var maxDraw, prevText, prev, nextText, next, currentText, gotoDate,
			controls, buttonPanel, firstDay, showWeek, dayNames, dayNamesMin,
			monthNames, monthNamesShort, beforeShowDay, showOtherMonths,
			selectOtherMonths, defaultDate, html, dow, row, group, col, selectedDate,
			cornerClass, calender, thead, day, daysInMonth, leadDays, curRows, numRows,
			printDate, dRow, tbody, daySettings, otherMonth, unselectable,
			tempDate = new Date(),
			today = this._daylightSavingAdjust(
				new Date( tempDate.getFullYear(), tempDate.getMonth(), tempDate.getDate() ) ), // clear time
			isRTL = this._get( inst, "isRTL" ),
			showButtonPanel = this._get( inst, "showButtonPanel" ),
			hideIfNoPrevNext = this._get( inst, "hideIfNoPrevNext" ),
			navigationAsDateFormat = this._get( inst, "navigationAsDateFormat" ),
			numMonths = this._getNumberOfMonths( inst ),
			showCurrentAtPos = this._get( inst, "showCurrentAtPos" ),
			stepMonths = this._get( inst, "stepMonths" ),
			isMultiMonth = ( numMonths[ 0 ] !== 1 || numMonths[ 1 ] !== 1 ),
			currentDate = this._daylightSavingAdjust( ( !inst.currentDay ? new Date( 9999, 9, 9 ) :
				new Date( inst.currentYear, inst.currentMonth, inst.currentDay ) ) ),
			minDate = this._getMinMaxDate( inst, "min" ),
			maxDate = this._getMinMaxDate( inst, "max" ),
			drawMonth = inst.drawMonth - showCurrentAtPos,
			drawYear = inst.drawYear;

		if ( drawMonth < 0 ) {
			drawMonth += 12;
			drawYear--;
		}
		if ( maxDate ) {
			maxDraw = this._daylightSavingAdjust( new Date( maxDate.getFullYear(),
				maxDate.getMonth() - ( numMonths[ 0 ] * numMonths[ 1 ] ) + 1, maxDate.getDate() ) );
			maxDraw = ( minDate && maxDraw < minDate ? minDate : maxDraw );
			while ( this._daylightSavingAdjust( new Date( drawYear, drawMonth, 1 ) ) > maxDraw ) {
				drawMonth--;
				if ( drawMonth < 0 ) {
					drawMonth = 11;
					drawYear--;
				}
			}
		}
		inst.drawMonth = drawMonth;
		inst.drawYear = drawYear;

		prevText = this._get( inst, "prevText" );
		prevText = ( !navigationAsDateFormat ? prevText : this.formatDate( prevText,
			this._daylightSavingAdjust( new Date( drawYear, drawMonth - stepMonths, 1 ) ),
			this._getFormatConfig( inst ) ) );

		prev = ( this._canAdjustMonth( inst, -1, drawYear, drawMonth ) ?
			"<a class='ui-datepicker-prev ui-corner-all' data-handler='prev' data-event='click'" +
			" title='" + prevText + "'><span class='ui-icon ui-icon-circle-triangle-" + ( isRTL ? "e" : "w" ) + "'>" + prevText + "</span></a>" :
			( hideIfNoPrevNext ? "" : "<a class='ui-datepicker-prev ui-corner-all ui-state-disabled' title='" + prevText + "'><span class='ui-icon ui-icon-circle-triangle-" + ( isRTL ? "e" : "w" ) + "'>" + prevText + "</span></a>" ) );

		nextText = this._get( inst, "nextText" );
		nextText = ( !navigationAsDateFormat ? nextText : this.formatDate( nextText,
			this._daylightSavingAdjust( new Date( drawYear, drawMonth + stepMonths, 1 ) ),
			this._getFormatConfig( inst ) ) );

		next = ( this._canAdjustMonth( inst, +1, drawYear, drawMonth ) ?
			"<a class='ui-datepicker-next ui-corner-all' data-handler='next' data-event='click'" +
			" title='" + nextText + "'><span class='ui-icon ui-icon-circle-triangle-" + ( isRTL ? "w" : "e" ) + "'>" + nextText + "</span></a>" :
			( hideIfNoPrevNext ? "" : "<a class='ui-datepicker-next ui-corner-all ui-state-disabled' title='" + nextText + "'><span class='ui-icon ui-icon-circle-triangle-" + ( isRTL ? "w" : "e" ) + "'>" + nextText + "</span></a>" ) );

		currentText = this._get( inst, "currentText" );
		gotoDate = ( this._get( inst, "gotoCurrent" ) && inst.currentDay ? currentDate : today );
		currentText = ( !navigationAsDateFormat ? currentText :
			this.formatDate( currentText, gotoDate, this._getFormatConfig( inst ) ) );

		controls = ( !inst.inline ? "<button type='button' class='ui-datepicker-close ui-state-default ui-priority-primary ui-corner-all' data-handler='hide' data-event='click'>" +
			this._get( inst, "closeText" ) + "</button>" : "" );

		buttonPanel = ( showButtonPanel ) ? "<div class='ui-datepicker-buttonpane ui-widget-content'>" + ( isRTL ? controls : "" ) +
			( this._isInRange( inst, gotoDate ) ? "<button type='button' class='ui-datepicker-current ui-state-default ui-priority-secondary ui-corner-all' data-handler='today' data-event='click'" +
			">" + currentText + "</button>" : "" ) + ( isRTL ? "" : controls ) + "</div>" : "";

		firstDay = parseInt( this._get( inst, "firstDay" ), 10 );
		firstDay = ( isNaN( firstDay ) ? 0 : firstDay );

		showWeek = this._get( inst, "showWeek" );
		dayNames = this._get( inst, "dayNames" );
		dayNamesMin = this._get( inst, "dayNamesMin" );
		monthNames = this._get( inst, "monthNames" );
		monthNamesShort = this._get( inst, "monthNamesShort" );
		beforeShowDay = this._get( inst, "beforeShowDay" );
		showOtherMonths = this._get( inst, "showOtherMonths" );
		selectOtherMonths = this._get( inst, "selectOtherMonths" );
		defaultDate = this._getDefaultDate( inst );
		html = "";

		for ( row = 0; row < numMonths[ 0 ]; row++ ) {
			group = "";
			this.maxRows = 4;
			for ( col = 0; col < numMonths[ 1 ]; col++ ) {
				selectedDate = this._daylightSavingAdjust( new Date( drawYear, drawMonth, inst.selectedDay ) );
				cornerClass = " ui-corner-all";
				calender = "";
				if ( isMultiMonth ) {
					calender += "<div class='ui-datepicker-group";
					if ( numMonths[ 1 ] > 1 ) {
						switch ( col ) {
							case 0: calender += " ui-datepicker-group-first";
								cornerClass = " ui-corner-" + ( isRTL ? "right" : "left" ); break;
							case numMonths[ 1 ] - 1: calender += " ui-datepicker-group-last";
								cornerClass = " ui-corner-" + ( isRTL ? "left" : "right" ); break;
							default: calender += " ui-datepicker-group-middle"; cornerClass = ""; break;
						}
					}
					calender += "'>";
				}
				calender += "<div class='ui-datepicker-header ui-widget-header ui-helper-clearfix" + cornerClass + "'>" +
					( /all|left/.test( cornerClass ) && row === 0 ? ( isRTL ? next : prev ) : "" ) +
					( /all|right/.test( cornerClass ) && row === 0 ? ( isRTL ? prev : next ) : "" ) +
					this._generateMonthYearHeader( inst, drawMonth, drawYear, minDate, maxDate,
					row > 0 || col > 0, monthNames, monthNamesShort ) + // draw month headers
					"</div><table class='ui-datepicker-calendar'><thead>" +
					"<tr>";
				thead = ( showWeek ? "<th class='ui-datepicker-week-col'>" + this._get( inst, "weekHeader" ) + "</th>" : "" );
				for ( dow = 0; dow < 7; dow++ ) { // days of the week
					day = ( dow + firstDay ) % 7;
					thead += "<th scope='col'" + ( ( dow + firstDay + 6 ) % 7 >= 5 ? " class='ui-datepicker-week-end'" : "" ) + ">" +
						"<span title='" + dayNames[ day ] + "'>" + dayNamesMin[ day ] + "</span></th>";
				}
				calender += thead + "</tr></thead><tbody>";
				daysInMonth = this._getDaysInMonth( drawYear, drawMonth );
				if ( drawYear === inst.selectedYear && drawMonth === inst.selectedMonth ) {
					inst.selectedDay = Math.min( inst.selectedDay, daysInMonth );
				}
				leadDays = ( this._getFirstDayOfMonth( drawYear, drawMonth ) - firstDay + 7 ) % 7;
				curRows = Math.ceil( ( leadDays + daysInMonth ) / 7 ); // calculate the number of rows to generate
				numRows = ( isMultiMonth ? this.maxRows > curRows ? this.maxRows : curRows : curRows ); //If multiple months, use the higher number of rows (see #7043)
				this.maxRows = numRows;
				printDate = this._daylightSavingAdjust( new Date( drawYear, drawMonth, 1 - leadDays ) );
				for ( dRow = 0; dRow < numRows; dRow++ ) { // create date picker rows
					calender += "<tr>";
					tbody = ( !showWeek ? "" : "<td class='ui-datepicker-week-col'>" +
						this._get( inst, "calculateWeek" )( printDate ) + "</td>" );
					for ( dow = 0; dow < 7; dow++ ) { // create date picker days
						daySettings = ( beforeShowDay ?
							beforeShowDay.apply( ( inst.input ? inst.input[ 0 ] : null ), [ printDate ] ) : [ true, "" ] );
						otherMonth = ( printDate.getMonth() !== drawMonth );
						unselectable = ( otherMonth && !selectOtherMonths ) || !daySettings[ 0 ] ||
							( minDate && printDate < minDate ) || ( maxDate && printDate > maxDate );
						tbody += "<td class='" +
							( ( dow + firstDay + 6 ) % 7 >= 5 ? " ui-datepicker-week-end" : "" ) + // highlight weekends
							( otherMonth ? " ui-datepicker-other-month" : "" ) + // highlight days from other months
							( ( printDate.getTime() === selectedDate.getTime() && drawMonth === inst.selectedMonth && inst._keyEvent ) || // user pressed key
							( defaultDate.getTime() === printDate.getTime() && defaultDate.getTime() === selectedDate.getTime() ) ?

							// or defaultDate is current printedDate and defaultDate is selectedDate
							" " + this._dayOverClass : "" ) + // highlight selected day
							( unselectable ? " " + this._unselectableClass + " ui-state-disabled" : "" ) +  // highlight unselectable days
							( otherMonth && !showOtherMonths ? "" : " " + daySettings[ 1 ] + // highlight custom dates
							( printDate.getTime() === currentDate.getTime() ? " " + this._currentClass : "" ) + // highlight selected day
							( printDate.getTime() === today.getTime() ? " ui-datepicker-today" : "" ) ) + "'" + // highlight today (if different)
							( ( !otherMonth || showOtherMonths ) && daySettings[ 2 ] ? " title='" + daySettings[ 2 ].replace( /'/g, "&#39;" ) + "'" : "" ) + // cell title
							( unselectable ? "" : " data-handler='selectDay' data-event='click' data-month='" + printDate.getMonth() + "' data-year='" + printDate.getFullYear() + "'" ) + ">" + // actions
							( otherMonth && !showOtherMonths ? "&#xa0;" : // display for other months
							( unselectable ? "<span class='ui-state-default'>" + printDate.getDate() + "</span>" : "<a class='ui-state-default" +
							( printDate.getTime() === today.getTime() ? " ui-state-highlight" : "" ) +
							( printDate.getTime() === currentDate.getTime() ? " ui-state-active" : "" ) + // highlight selected day
							( otherMonth ? " ui-priority-secondary" : "" ) + // distinguish dates from other months
							"' href='#'>" + printDate.getDate() + "</a>" ) ) + "</td>"; // display selectable date
						printDate.setDate( printDate.getDate() + 1 );
						printDate = this._daylightSavingAdjust( printDate );
					}
					calender += tbody + "</tr>";
				}
				drawMonth++;
				if ( drawMonth > 11 ) {
					drawMonth = 0;
					drawYear++;
				}
				calender += "</tbody></table>" + ( isMultiMonth ? "</div>" +
							( ( numMonths[ 0 ] > 0 && col === numMonths[ 1 ] - 1 ) ? "<div class='ui-datepicker-row-break'></div>" : "" ) : "" );
				group += calender;
			}
			html += group;
		}
		html += buttonPanel;
		inst._keyEvent = false;
		return html;
	},

	/* Generate the month and year header. */
	_generateMonthYearHeader: function( inst, drawMonth, drawYear, minDate, maxDate,
			secondary, monthNames, monthNamesShort ) {

		var inMinYear, inMaxYear, month, years, thisYear, determineYear, year, endYear,
			changeMonth = this._get( inst, "changeMonth" ),
			changeYear = this._get( inst, "changeYear" ),
			showMonthAfterYear = this._get( inst, "showMonthAfterYear" ),
			html = "<div class='ui-datepicker-title'>",
			monthHtml = "";

		// Month selection
		if ( secondary || !changeMonth ) {
			monthHtml += "<span class='ui-datepicker-month'>" + monthNames[ drawMonth ] + "</span>";
		} else {
			inMinYear = ( minDate && minDate.getFullYear() === drawYear );
			inMaxYear = ( maxDate && maxDate.getFullYear() === drawYear );
			monthHtml += "<select class='ui-datepicker-month' data-handler='selectMonth' data-event='change'>";
			for ( month = 0; month < 12; month++ ) {
				if ( ( !inMinYear || month >= minDate.getMonth() ) && ( !inMaxYear || month <= maxDate.getMonth() ) ) {
					monthHtml += "<option value='" + month + "'" +
						( month === drawMonth ? " selected='selected'" : "" ) +
						">" + monthNamesShort[ month ] + "</option>";
				}
			}
			monthHtml += "</select>";
		}

		if ( !showMonthAfterYear ) {
			html += monthHtml + ( secondary || !( changeMonth && changeYear ) ? "&#xa0;" : "" );
		}

		// Year selection
		if ( !inst.yearshtml ) {
			inst.yearshtml = "";
			if ( secondary || !changeYear ) {
				html += "<span class='ui-datepicker-year'>" + drawYear + "</span>";
			} else {

				// determine range of years to display
				years = this._get( inst, "yearRange" ).split( ":" );
				thisYear = new Date().getFullYear();
				determineYear = function( value ) {
					var year = ( value.match( /c[+\-].*/ ) ? drawYear + parseInt( value.substring( 1 ), 10 ) :
						( value.match( /[+\-].*/ ) ? thisYear + parseInt( value, 10 ) :
						parseInt( value, 10 ) ) );
					return ( isNaN( year ) ? thisYear : year );
				};
				year = determineYear( years[ 0 ] );
				endYear = Math.max( year, determineYear( years[ 1 ] || "" ) );
				year = ( minDate ? Math.max( year, minDate.getFullYear() ) : year );
				endYear = ( maxDate ? Math.min( endYear, maxDate.getFullYear() ) : endYear );
				inst.yearshtml += "<select class='ui-datepicker-year' data-handler='selectYear' data-event='change'>";
				for ( ; year <= endYear; year++ ) {
					inst.yearshtml += "<option value='" + year + "'" +
						( year === drawYear ? " selected='selected'" : "" ) +
						">" + year + "</option>";
				}
				inst.yearshtml += "</select>";

				html += inst.yearshtml;
				inst.yearshtml = null;
			}
		}

		html += this._get( inst, "yearSuffix" );
		if ( showMonthAfterYear ) {
			html += ( secondary || !( changeMonth && changeYear ) ? "&#xa0;" : "" ) + monthHtml;
		}
		html += "</div>"; // Close datepicker_header
		return html;
	},

	/* Adjust one of the date sub-fields. */
	_adjustInstDate: function( inst, offset, period ) {
		var year = inst.selectedYear + ( period === "Y" ? offset : 0 ),
			month = inst.selectedMonth + ( period === "M" ? offset : 0 ),
			day = Math.min( inst.selectedDay, this._getDaysInMonth( year, month ) ) + ( period === "D" ? offset : 0 ),
			date = this._restrictMinMax( inst, this._daylightSavingAdjust( new Date( year, month, day ) ) );

		inst.selectedDay = date.getDate();
		inst.drawMonth = inst.selectedMonth = date.getMonth();
		inst.drawYear = inst.selectedYear = date.getFullYear();
		if ( period === "M" || period === "Y" ) {
			this._notifyChange( inst );
		}
	},

	/* Ensure a date is within any min/max bounds. */
	_restrictMinMax: function( inst, date ) {
		var minDate = this._getMinMaxDate( inst, "min" ),
			maxDate = this._getMinMaxDate( inst, "max" ),
			newDate = ( minDate && date < minDate ? minDate : date );
		return ( maxDate && newDate > maxDate ? maxDate : newDate );
	},

	/* Notify change of month/year. */
	_notifyChange: function( inst ) {
		var onChange = this._get( inst, "onChangeMonthYear" );
		if ( onChange ) {
			onChange.apply( ( inst.input ? inst.input[ 0 ] : null ),
				[ inst.selectedYear, inst.selectedMonth + 1, inst ] );
		}
	},

	/* Determine the number of months to show. */
	_getNumberOfMonths: function( inst ) {
		var numMonths = this._get( inst, "numberOfMonths" );
		return ( numMonths == null ? [ 1, 1 ] : ( typeof numMonths === "number" ? [ 1, numMonths ] : numMonths ) );
	},

	/* Determine the current maximum date - ensure no time components are set. */
	_getMinMaxDate: function( inst, minMax ) {
		return this._determineDate( inst, this._get( inst, minMax + "Date" ), null );
	},

	/* Find the number of days in a given month. */
	_getDaysInMonth: function( year, month ) {
		return 32 - this._daylightSavingAdjust( new Date( year, month, 32 ) ).getDate();
	},

	/* Find the day of the week of the first of a month. */
	_getFirstDayOfMonth: function( year, month ) {
		return new Date( year, month, 1 ).getDay();
	},

	/* Determines if we should allow a "next/prev" month display change. */
	_canAdjustMonth: function( inst, offset, curYear, curMonth ) {
		var numMonths = this._getNumberOfMonths( inst ),
			date = this._daylightSavingAdjust( new Date( curYear,
			curMonth + ( offset < 0 ? offset : numMonths[ 0 ] * numMonths[ 1 ] ), 1 ) );

		if ( offset < 0 ) {
			date.setDate( this._getDaysInMonth( date.getFullYear(), date.getMonth() ) );
		}
		return this._isInRange( inst, date );
	},

	/* Is the given date in the accepted range? */
	_isInRange: function( inst, date ) {
		var yearSplit, currentYear,
			minDate = this._getMinMaxDate( inst, "min" ),
			maxDate = this._getMinMaxDate( inst, "max" ),
			minYear = null,
			maxYear = null,
			years = this._get( inst, "yearRange" );
			if ( years ) {
				yearSplit = years.split( ":" );
				currentYear = new Date().getFullYear();
				minYear = parseInt( yearSplit[ 0 ], 10 );
				maxYear = parseInt( yearSplit[ 1 ], 10 );
				if ( yearSplit[ 0 ].match( /[+\-].*/ ) ) {
					minYear += currentYear;
				}
				if ( yearSplit[ 1 ].match( /[+\-].*/ ) ) {
					maxYear += currentYear;
				}
			}

		return ( ( !minDate || date.getTime() >= minDate.getTime() ) &&
			( !maxDate || date.getTime() <= maxDate.getTime() ) &&
			( !minYear || date.getFullYear() >= minYear ) &&
			( !maxYear || date.getFullYear() <= maxYear ) );
	},

	/* Provide the configuration settings for formatting/parsing. */
	_getFormatConfig: function( inst ) {
		var shortYearCutoff = this._get( inst, "shortYearCutoff" );
		shortYearCutoff = ( typeof shortYearCutoff !== "string" ? shortYearCutoff :
			new Date().getFullYear() % 100 + parseInt( shortYearCutoff, 10 ) );
		return { shortYearCutoff: shortYearCutoff,
			dayNamesShort: this._get( inst, "dayNamesShort" ), dayNames: this._get( inst, "dayNames" ),
			monthNamesShort: this._get( inst, "monthNamesShort" ), monthNames: this._get( inst, "monthNames" ) };
	},

	/* Format the given date for display. */
	_formatDate: function( inst, day, month, year ) {
		if ( !day ) {
			inst.currentDay = inst.selectedDay;
			inst.currentMonth = inst.selectedMonth;
			inst.currentYear = inst.selectedYear;
		}
		var date = ( day ? ( typeof day === "object" ? day :
			this._daylightSavingAdjust( new Date( year, month, day ) ) ) :
			this._daylightSavingAdjust( new Date( inst.currentYear, inst.currentMonth, inst.currentDay ) ) );
		return this.formatDate( this._get( inst, "dateFormat" ), date, this._getFormatConfig( inst ) );
	}
} );

/*
 * Bind hover events for datepicker elements.
 * Done via delegate so the binding only occurs once in the lifetime of the parent div.
 * Global datepicker_instActive, set by _updateDatepicker allows the handlers to find their way back to the active picker.
 */
function datepicker_bindHover( dpDiv ) {
	var selector = "button, .ui-datepicker-prev, .ui-datepicker-next, .ui-datepicker-calendar td a";
	return dpDiv.on( "mouseout", selector, function() {
			$( this ).removeClass( "ui-state-hover" );
			if ( this.className.indexOf( "ui-datepicker-prev" ) !== -1 ) {
				$( this ).removeClass( "ui-datepicker-prev-hover" );
			}
			if ( this.className.indexOf( "ui-datepicker-next" ) !== -1 ) {
				$( this ).removeClass( "ui-datepicker-next-hover" );
			}
		} )
		.on( "mouseover", selector, datepicker_handleMouseover );
}

function datepicker_handleMouseover() {
	if ( !$.datepicker._isDisabledDatepicker( datepicker_instActive.inline ? datepicker_instActive.dpDiv.parent()[ 0 ] : datepicker_instActive.input[ 0 ] ) ) {
		$( this ).parents( ".ui-datepicker-calendar" ).find( "a" ).removeClass( "ui-state-hover" );
		$( this ).addClass( "ui-state-hover" );
		if ( this.className.indexOf( "ui-datepicker-prev" ) !== -1 ) {
			$( this ).addClass( "ui-datepicker-prev-hover" );
		}
		if ( this.className.indexOf( "ui-datepicker-next" ) !== -1 ) {
			$( this ).addClass( "ui-datepicker-next-hover" );
		}
	}
}

/* jQuery extend now ignores nulls! */
function datepicker_extendRemove( target, props ) {
	$.extend( target, props );
	for ( var name in props ) {
		if ( props[ name ] == null ) {
			target[ name ] = props[ name ];
		}
	}
	return target;
}

/* Invoke the datepicker functionality.
   @param  options  string - a command, optionally followed by additional parameters or
					Object - settings for attaching new datepicker functionality
   @return  jQuery object */
$.fn.datepicker = function( options ) {

	/* Verify an empty collection wasn't passed - Fixes #6976 */
	if ( !this.length ) {
		return this;
	}

	/* Initialise the date picker. */
	if ( !$.datepicker.initialized ) {
		$( document ).on( "mousedown", $.datepicker._checkExternalClick );
		$.datepicker.initialized = true;
	}

	/* Append datepicker main container to body if not exist. */
	if ( $( "#" + $.datepicker._mainDivId ).length === 0 ) {
		$( "body" ).append( $.datepicker.dpDiv );
	}

	var otherArgs = Array.prototype.slice.call( arguments, 1 );
	if ( typeof options === "string" && ( options === "isDisabled" || options === "getDate" || options === "widget" ) ) {
		return $.datepicker[ "_" + options + "Datepicker" ].
			apply( $.datepicker, [ this[ 0 ] ].concat( otherArgs ) );
	}
	if ( options === "option" && arguments.length === 2 && typeof arguments[ 1 ] === "string" ) {
		return $.datepicker[ "_" + options + "Datepicker" ].
			apply( $.datepicker, [ this[ 0 ] ].concat( otherArgs ) );
	}
	return this.each( function() {
		typeof options === "string" ?
			$.datepicker[ "_" + options + "Datepicker" ].
				apply( $.datepicker, [ this ].concat( otherArgs ) ) :
			$.datepicker._attachDatepicker( this, options );
	} );
};

$.datepicker = new Datepicker(); // singleton instance
$.datepicker.initialized = false;
$.datepicker.uuid = new Date().getTime();
$.datepicker.version = "1.12.0";

var widgetsDatepicker = $.datepicker;




// This file is deprecated
var ie = $.ui.ie = !!/msie [\w.]+/.exec( navigator.userAgent.toLowerCase() );

/*!
 * jQuery UI Mouse 1.12.0
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Mouse
//>>group: Widgets
//>>description: Abstracts mouse-based interactions to assist in creating certain widgets.
//>>docs: http://api.jqueryui.com/mouse/



var mouseHandled = false;
$( document ).on( "mouseup", function() {
	mouseHandled = false;
} );

var widgetsMouse = $.widget( "ui.mouse", {
	version: "1.12.0",
	options: {
		cancel: "input, textarea, button, select, option",
		distance: 1,
		delay: 0
	},
	_mouseInit: function() {
		var that = this;

		this.element
			.on( "mousedown." + this.widgetName, function( event ) {
				return that._mouseDown( event );
			} )
			.on( "click." + this.widgetName, function( event ) {
				if ( true === $.data( event.target, that.widgetName + ".preventClickEvent" ) ) {
					$.removeData( event.target, that.widgetName + ".preventClickEvent" );
					event.stopImmediatePropagation();
					return false;
				}
			} );

		this.started = false;
	},

	// TODO: make sure destroying one instance of mouse doesn't mess with
	// other instances of mouse
	_mouseDestroy: function() {
		this.element.off( "." + this.widgetName );
		if ( this._mouseMoveDelegate ) {
			this.document
				.off( "mousemove." + this.widgetName, this._mouseMoveDelegate )
				.off( "mouseup." + this.widgetName, this._mouseUpDelegate );
		}
	},

	_mouseDown: function( event ) {

		// don't let more than one widget handle mouseStart
		if ( mouseHandled ) {
			return;
		}

		this._mouseMoved = false;

		// We may have missed mouseup (out of window)
		( this._mouseStarted && this._mouseUp( event ) );

		this._mouseDownEvent = event;

		var that = this,
			btnIsLeft = ( event.which === 1 ),

			// event.target.nodeName works around a bug in IE 8 with
			// disabled inputs (#7620)
			elIsCancel = ( typeof this.options.cancel === "string" && event.target.nodeName ?
				$( event.target ).closest( this.options.cancel ).length : false );
		if ( !btnIsLeft || elIsCancel || !this._mouseCapture( event ) ) {
			return true;
		}

		this.mouseDelayMet = !this.options.delay;
		if ( !this.mouseDelayMet ) {
			this._mouseDelayTimer = setTimeout( function() {
				that.mouseDelayMet = true;
			}, this.options.delay );
		}

		if ( this._mouseDistanceMet( event ) && this._mouseDelayMet( event ) ) {
			this._mouseStarted = ( this._mouseStart( event ) !== false );
			if ( !this._mouseStarted ) {
				event.preventDefault();
				return true;
			}
		}

		// Click event may never have fired (Gecko & Opera)
		if ( true === $.data( event.target, this.widgetName + ".preventClickEvent" ) ) {
			$.removeData( event.target, this.widgetName + ".preventClickEvent" );
		}

		// These delegates are required to keep context
		this._mouseMoveDelegate = function( event ) {
			return that._mouseMove( event );
		};
		this._mouseUpDelegate = function( event ) {
			return that._mouseUp( event );
		};

		this.document
			.on( "mousemove." + this.widgetName, this._mouseMoveDelegate )
			.on( "mouseup." + this.widgetName, this._mouseUpDelegate );

		event.preventDefault();

		mouseHandled = true;
		return true;
	},

	_mouseMove: function( event ) {

		// Only check for mouseups outside the document if you've moved inside the document
		// at least once. This prevents the firing of mouseup in the case of IE<9, which will
		// fire a mousemove event if content is placed under the cursor. See #7778
		// Support: IE <9
		if ( this._mouseMoved ) {

			// IE mouseup check - mouseup happened when mouse was out of window
			if ( $.ui.ie && ( !document.documentMode || document.documentMode < 9 ) &&
					!event.button ) {
				return this._mouseUp( event );

			// Iframe mouseup check - mouseup occurred in another document
			} else if ( !event.which ) {

				// Support: Safari <=8 - 9
				// Safari sets which to 0 if you press any of the following keys
				// during a drag (#14461)
				if ( event.originalEvent.altKey || event.originalEvent.ctrlKey ||
						event.originalEvent.metaKey || event.originalEvent.shiftKey ) {
					this.ignoreMissingWhich = true;
				} else if ( !this.ignoreMissingWhich ) {
					return this._mouseUp( event );
				}
			}
		}

		if ( event.which || event.button ) {
			this._mouseMoved = true;
		}

		if ( this._mouseStarted ) {
			this._mouseDrag( event );
			return event.preventDefault();
		}

		if ( this._mouseDistanceMet( event ) && this._mouseDelayMet( event ) ) {
			this._mouseStarted =
				( this._mouseStart( this._mouseDownEvent, event ) !== false );
			( this._mouseStarted ? this._mouseDrag( event ) : this._mouseUp( event ) );
		}

		return !this._mouseStarted;
	},

	_mouseUp: function( event ) {
		this.document
			.off( "mousemove." + this.widgetName, this._mouseMoveDelegate )
			.off( "mouseup." + this.widgetName, this._mouseUpDelegate );

		if ( this._mouseStarted ) {
			this._mouseStarted = false;

			if ( event.target === this._mouseDownEvent.target ) {
				$.data( event.target, this.widgetName + ".preventClickEvent", true );
			}

			this._mouseStop( event );
		}

		if ( this._mouseDelayTimer ) {
			clearTimeout( this._mouseDelayTimer );
			delete this._mouseDelayTimer;
		}

		this.ignoreMissingWhich = false;
		mouseHandled = false;
		event.preventDefault();
	},

	_mouseDistanceMet: function( event ) {
		return ( Math.max(
				Math.abs( this._mouseDownEvent.pageX - event.pageX ),
				Math.abs( this._mouseDownEvent.pageY - event.pageY )
			) >= this.options.distance
		);
	},

	_mouseDelayMet: function( /* event */ ) {
		return this.mouseDelayMet;
	},

	// These are placeholder methods, to be overriden by extending plugin
	_mouseStart: function( /* event */ ) {},
	_mouseDrag: function( /* event */ ) {},
	_mouseStop: function( /* event */ ) {},
	_mouseCapture: function( /* event */ ) { return true; }
} );




// $.ui.plugin is deprecated. Use $.widget() extensions instead.
var plugin = $.ui.plugin = {
	add: function( module, option, set ) {
		var i,
			proto = $.ui[ module ].prototype;
		for ( i in set ) {
			proto.plugins[ i ] = proto.plugins[ i ] || [];
			proto.plugins[ i ].push( [ option, set[ i ] ] );
		}
	},
	call: function( instance, name, args, allowDisconnected ) {
		var i,
			set = instance.plugins[ name ];

		if ( !set ) {
			return;
		}

		if ( !allowDisconnected && ( !instance.element[ 0 ].parentNode ||
				instance.element[ 0 ].parentNode.nodeType === 11 ) ) {
			return;
		}

		for ( i = 0; i < set.length; i++ ) {
			if ( instance.options[ set[ i ][ 0 ] ] ) {
				set[ i ][ 1 ].apply( instance.element, args );
			}
		}
	}
};



var safeBlur = $.ui.safeBlur = function( element ) {

	// Support: IE9 - 10 only
	// If the <body> is blurred, IE will switch windows, see #9420
	if ( element && element.nodeName.toLowerCase() !== "body" ) {
		$( element ).trigger( "blur" );
	}
};


/*!
 * jQuery UI Draggable 1.12.0
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Draggable
//>>group: Interactions
//>>description: Enables dragging functionality for any element.
//>>docs: http://api.jqueryui.com/draggable/
//>>demos: http://jqueryui.com/draggable/
//>>css.structure: ../../themes/base/draggable.css



$.widget( "ui.draggable", $.ui.mouse, {
	version: "1.12.0",
	widgetEventPrefix: "drag",
	options: {
		addClasses: true,
		appendTo: "parent",
		axis: false,
		connectToSortable: false,
		containment: false,
		cursor: "auto",
		cursorAt: false,
		grid: false,
		handle: false,
		helper: "original",
		iframeFix: false,
		opacity: false,
		refreshPositions: false,
		revert: false,
		revertDuration: 500,
		scope: "default",
		scroll: true,
		scrollSensitivity: 20,
		scrollSpeed: 20,
		snap: false,
		snapMode: "both",
		snapTolerance: 20,
		stack: false,
		zIndex: false,

		// Callbacks
		drag: null,
		start: null,
		stop: null
	},
	_create: function() {

		if ( this.options.helper === "original" ) {
			this._setPositionRelative();
		}
		if ( this.options.addClasses ) {
			this._addClass( "ui-draggable" );
		}
		this._setHandleClassName();

		this._mouseInit();
	},

	_setOption: function( key, value ) {
		this._super( key, value );
		if ( key === "handle" ) {
			this._removeHandleClassName();
			this._setHandleClassName();
		}
	},

	_destroy: function() {
		if ( ( this.helper || this.element ).is( ".ui-draggable-dragging" ) ) {
			this.destroyOnClear = true;
			return;
		}
		this._removeHandleClassName();
		this._mouseDestroy();
	},

	_mouseCapture: function( event ) {
		var o = this.options;

		this._blurActiveElement( event );

		// Among others, prevent a drag on a resizable-handle
		if ( this.helper || o.disabled ||
				$( event.target ).closest( ".ui-resizable-handle" ).length > 0 ) {
			return false;
		}

		//Quit if we're not on a valid handle
		this.handle = this._getHandle( event );
		if ( !this.handle ) {
			return false;
		}

		this._blockFrames( o.iframeFix === true ? "iframe" : o.iframeFix );

		return true;

	},

	_blockFrames: function( selector ) {
		this.iframeBlocks = this.document.find( selector ).map( function() {
			var iframe = $( this );

			return $( "<div>" )
				.css( "position", "absolute" )
				.appendTo( iframe.parent() )
				.outerWidth( iframe.outerWidth() )
				.outerHeight( iframe.outerHeight() )
				.offset( iframe.offset() )[ 0 ];
		} );
	},

	_unblockFrames: function() {
		if ( this.iframeBlocks ) {
			this.iframeBlocks.remove();
			delete this.iframeBlocks;
		}
	},

	_blurActiveElement: function( event ) {
		var activeElement = $.ui.safeActiveElement( this.document[ 0 ] ),
			target = $( event.target );

		// Only blur if the event occurred on an element that is:
		// 1) within the draggable handle
		// 2) but not within the currently focused element
		// See #10527, #12472
		if ( this._getHandle( event ) && target.closest( activeElement ).length ) {
			return;
		}

		// Blur any element that currently has focus, see #4261
		$.ui.safeBlur( activeElement );
	},

	_mouseStart: function( event ) {

		var o = this.options;

		//Create and append the visible helper
		this.helper = this._createHelper( event );

		this._addClass( this.helper, "ui-draggable-dragging" );

		//Cache the helper size
		this._cacheHelperProportions();

		//If ddmanager is used for droppables, set the global draggable
		if ( $.ui.ddmanager ) {
			$.ui.ddmanager.current = this;
		}

		/*
		 * - Position generation -
		 * This block generates everything position related - it's the core of draggables.
		 */

		//Cache the margins of the original element
		this._cacheMargins();

		//Store the helper's css position
		this.cssPosition = this.helper.css( "position" );
		this.scrollParent = this.helper.scrollParent( true );
		this.offsetParent = this.helper.offsetParent();
		this.hasFixedAncestor = this.helper.parents().filter( function() {
				return $( this ).css( "position" ) === "fixed";
			} ).length > 0;

		//The element's absolute position on the page minus margins
		this.positionAbs = this.element.offset();
		this._refreshOffsets( event );

		//Generate the original position
		this.originalPosition = this.position = this._generatePosition( event, false );
		this.originalPageX = event.pageX;
		this.originalPageY = event.pageY;

		//Adjust the mouse offset relative to the helper if "cursorAt" is supplied
		( o.cursorAt && this._adjustOffsetFromHelper( o.cursorAt ) );

		//Set a containment if given in the options
		this._setContainment();

		//Trigger event + callbacks
		if ( this._trigger( "start", event ) === false ) {
			this._clear();
			return false;
		}

		//Recache the helper size
		this._cacheHelperProportions();

		//Prepare the droppable offsets
		if ( $.ui.ddmanager && !o.dropBehaviour ) {
			$.ui.ddmanager.prepareOffsets( this, event );
		}

		// Execute the drag once - this causes the helper not to be visible before getting its
		// correct position
		this._mouseDrag( event, true );

		// If the ddmanager is used for droppables, inform the manager that dragging has started
		// (see #5003)
		if ( $.ui.ddmanager ) {
			$.ui.ddmanager.dragStart( this, event );
		}

		return true;
	},

	_refreshOffsets: function( event ) {
		this.offset = {
			top: this.positionAbs.top - this.margins.top,
			left: this.positionAbs.left - this.margins.left,
			scroll: false,
			parent: this._getParentOffset(),
			relative: this._getRelativeOffset()
		};

		this.offset.click = {
			left: event.pageX - this.offset.left,
			top: event.pageY - this.offset.top
		};
	},

	_mouseDrag: function( event, noPropagation ) {

		// reset any necessary cached properties (see #5009)
		if ( this.hasFixedAncestor ) {
			this.offset.parent = this._getParentOffset();
		}

		//Compute the helpers position
		this.position = this._generatePosition( event, true );
		this.positionAbs = this._convertPositionTo( "absolute" );

		//Call plugins and callbacks and use the resulting position if something is returned
		if ( !noPropagation ) {
			var ui = this._uiHash();
			if ( this._trigger( "drag", event, ui ) === false ) {
				this._mouseUp( new $.Event( "mouseup", event ) );
				return false;
			}
			this.position = ui.position;
		}

		this.helper[ 0 ].style.left = this.position.left + "px";
		this.helper[ 0 ].style.top = this.position.top + "px";

		if ( $.ui.ddmanager ) {
			$.ui.ddmanager.drag( this, event );
		}

		return false;
	},

	_mouseStop: function( event ) {

		//If we are using droppables, inform the manager about the drop
		var that = this,
			dropped = false;
		if ( $.ui.ddmanager && !this.options.dropBehaviour ) {
			dropped = $.ui.ddmanager.drop( this, event );
		}

		//if a drop comes from outside (a sortable)
		if ( this.dropped ) {
			dropped = this.dropped;
			this.dropped = false;
		}

		if ( ( this.options.revert === "invalid" && !dropped ) ||
				( this.options.revert === "valid" && dropped ) ||
				this.options.revert === true || ( $.isFunction( this.options.revert ) &&
				this.options.revert.call( this.element, dropped ) )
		) {
			$( this.helper ).animate(
				this.originalPosition,
				parseInt( this.options.revertDuration, 10 ),
				function() {
					if ( that._trigger( "stop", event ) !== false ) {
						that._clear();
					}
				}
			);
		} else {
			if ( this._trigger( "stop", event ) !== false ) {
				this._clear();
			}
		}

		return false;
	},

	_mouseUp: function( event ) {
		this._unblockFrames();

		// If the ddmanager is used for droppables, inform the manager that dragging has stopped
		// (see #5003)
		if ( $.ui.ddmanager ) {
			$.ui.ddmanager.dragStop( this, event );
		}

		// Only need to focus if the event occurred on the draggable itself, see #10527
		if ( this.handleElement.is( event.target ) ) {

			// The interaction is over; whether or not the click resulted in a drag,
			// focus the element
			this.element.trigger( "focus" );
		}

		return $.ui.mouse.prototype._mouseUp.call( this, event );
	},

	cancel: function() {

		if ( this.helper.is( ".ui-draggable-dragging" ) ) {
			this._mouseUp( new $.Event( "mouseup", { target: this.element[ 0 ] } ) );
		} else {
			this._clear();
		}

		return this;

	},

	_getHandle: function( event ) {
		return this.options.handle ?
			!!$( event.target ).closest( this.element.find( this.options.handle ) ).length :
			true;
	},

	_setHandleClassName: function() {
		this.handleElement = this.options.handle ?
			this.element.find( this.options.handle ) : this.element;
		this._addClass( this.handleElement, "ui-draggable-handle" );
	},

	_removeHandleClassName: function() {
		this._removeClass( this.handleElement, "ui-draggable-handle" );
	},

	_createHelper: function( event ) {

		var o = this.options,
			helperIsFunction = $.isFunction( o.helper ),
			helper = helperIsFunction ?
				$( o.helper.apply( this.element[ 0 ], [ event ] ) ) :
				( o.helper === "clone" ?
					this.element.clone().removeAttr( "id" ) :
					this.element );

		if ( !helper.parents( "body" ).length ) {
			helper.appendTo( ( o.appendTo === "parent" ?
				this.element[ 0 ].parentNode :
				o.appendTo ) );
		}

		// Http://bugs.jqueryui.com/ticket/9446
		// a helper function can return the original element
		// which wouldn't have been set to relative in _create
		if ( helperIsFunction && helper[ 0 ] === this.element[ 0 ] ) {
			this._setPositionRelative();
		}

		if ( helper[ 0 ] !== this.element[ 0 ] &&
				!( /(fixed|absolute)/ ).test( helper.css( "position" ) ) ) {
			helper.css( "position", "absolute" );
		}

		return helper;

	},

	_setPositionRelative: function() {
		if ( !( /^(?:r|a|f)/ ).test( this.element.css( "position" ) ) ) {
			this.element[ 0 ].style.position = "relative";
		}
	},

	_adjustOffsetFromHelper: function( obj ) {
		if ( typeof obj === "string" ) {
			obj = obj.split( " " );
		}
		if ( $.isArray( obj ) ) {
			obj = { left: +obj[ 0 ], top: +obj[ 1 ] || 0 };
		}
		if ( "left" in obj ) {
			this.offset.click.left = obj.left + this.margins.left;
		}
		if ( "right" in obj ) {
			this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;
		}
		if ( "top" in obj ) {
			this.offset.click.top = obj.top + this.margins.top;
		}
		if ( "bottom" in obj ) {
			this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;
		}
	},

	_isRootNode: function( element ) {
		return ( /(html|body)/i ).test( element.tagName ) || element === this.document[ 0 ];
	},

	_getParentOffset: function() {

		//Get the offsetParent and cache its position
		var po = this.offsetParent.offset(),
			document = this.document[ 0 ];

		// This is a special case where we need to modify a offset calculated on start, since the
		// following happened:
		// 1. The position of the helper is absolute, so it's position is calculated based on the
		// next positioned parent
		// 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn't
		// the document, which means that the scroll is included in the initial calculation of the
		// offset of the parent, and never recalculated upon drag
		if ( this.cssPosition === "absolute" && this.scrollParent[ 0 ] !== document &&
				$.contains( this.scrollParent[ 0 ], this.offsetParent[ 0 ] ) ) {
			po.left += this.scrollParent.scrollLeft();
			po.top += this.scrollParent.scrollTop();
		}

		if ( this._isRootNode( this.offsetParent[ 0 ] ) ) {
			po = { top: 0, left: 0 };
		}

		return {
			top: po.top + ( parseInt( this.offsetParent.css( "borderTopWidth" ), 10 ) || 0 ),
			left: po.left + ( parseInt( this.offsetParent.css( "borderLeftWidth" ), 10 ) || 0 )
		};

	},

	_getRelativeOffset: function() {
		if ( this.cssPosition !== "relative" ) {
			return { top: 0, left: 0 };
		}

		var p = this.element.position(),
			scrollIsRootNode = this._isRootNode( this.scrollParent[ 0 ] );

		return {
			top: p.top - ( parseInt( this.helper.css( "top" ), 10 ) || 0 ) +
				( !scrollIsRootNode ? this.scrollParent.scrollTop() : 0 ),
			left: p.left - ( parseInt( this.helper.css( "left" ), 10 ) || 0 ) +
				( !scrollIsRootNode ? this.scrollParent.scrollLeft() : 0 )
		};

	},

	_cacheMargins: function() {
		this.margins = {
			left: ( parseInt( this.element.css( "marginLeft" ), 10 ) || 0 ),
			top: ( parseInt( this.element.css( "marginTop" ), 10 ) || 0 ),
			right: ( parseInt( this.element.css( "marginRight" ), 10 ) || 0 ),
			bottom: ( parseInt( this.element.css( "marginBottom" ), 10 ) || 0 )
		};
	},

	_cacheHelperProportions: function() {
		this.helperProportions = {
			width: this.helper.outerWidth(),
			height: this.helper.outerHeight()
		};
	},

	_setContainment: function() {

		var isUserScrollable, c, ce,
			o = this.options,
			document = this.document[ 0 ];

		this.relativeContainer = null;

		if ( !o.containment ) {
			this.containment = null;
			return;
		}

		if ( o.containment === "window" ) {
			this.containment = [
				$( window ).scrollLeft() - this.offset.relative.left - this.offset.parent.left,
				$( window ).scrollTop() - this.offset.relative.top - this.offset.parent.top,
				$( window ).scrollLeft() + $( window ).width() -
					this.helperProportions.width - this.margins.left,
				$( window ).scrollTop() +
					( $( window ).height() || document.body.parentNode.scrollHeight ) -
					this.helperProportions.height - this.margins.top
			];
			return;
		}

		if ( o.containment === "document" ) {
			this.containment = [
				0,
				0,
				$( document ).width() - this.helperProportions.width - this.margins.left,
				( $( document ).height() || document.body.parentNode.scrollHeight ) -
					this.helperProportions.height - this.margins.top
			];
			return;
		}

		if ( o.containment.constructor === Array ) {
			this.containment = o.containment;
			return;
		}

		if ( o.containment === "parent" ) {
			o.containment = this.helper[ 0 ].parentNode;
		}

		c = $( o.containment );
		ce = c[ 0 ];

		if ( !ce ) {
			return;
		}

		isUserScrollable = /(scroll|auto)/.test( c.css( "overflow" ) );

		this.containment = [
			( parseInt( c.css( "borderLeftWidth" ), 10 ) || 0 ) +
				( parseInt( c.css( "paddingLeft" ), 10 ) || 0 ),
			( parseInt( c.css( "borderTopWidth" ), 10 ) || 0 ) +
				( parseInt( c.css( "paddingTop" ), 10 ) || 0 ),
			( isUserScrollable ? Math.max( ce.scrollWidth, ce.offsetWidth ) : ce.offsetWidth ) -
				( parseInt( c.css( "borderRightWidth" ), 10 ) || 0 ) -
				( parseInt( c.css( "paddingRight" ), 10 ) || 0 ) -
				this.helperProportions.width -
				this.margins.left -
				this.margins.right,
			( isUserScrollable ? Math.max( ce.scrollHeight, ce.offsetHeight ) : ce.offsetHeight ) -
				( parseInt( c.css( "borderBottomWidth" ), 10 ) || 0 ) -
				( parseInt( c.css( "paddingBottom" ), 10 ) || 0 ) -
				this.helperProportions.height -
				this.margins.top -
				this.margins.bottom
		];
		this.relativeContainer = c;
	},

	_convertPositionTo: function( d, pos ) {

		if ( !pos ) {
			pos = this.position;
		}

		var mod = d === "absolute" ? 1 : -1,
			scrollIsRootNode = this._isRootNode( this.scrollParent[ 0 ] );

		return {
			top: (

				// The absolute mouse position
				pos.top	+

				// Only for relative positioned nodes: Relative offset from element to offset parent
				this.offset.relative.top * mod +

				// The offsetParent's offset without borders (offset + border)
				this.offset.parent.top * mod -
				( ( this.cssPosition === "fixed" ?
					-this.offset.scroll.top :
					( scrollIsRootNode ? 0 : this.offset.scroll.top ) ) * mod )
			),
			left: (

				// The absolute mouse position
				pos.left +

				// Only for relative positioned nodes: Relative offset from element to offset parent
				this.offset.relative.left * mod +

				// The offsetParent's offset without borders (offset + border)
				this.offset.parent.left * mod	-
				( ( this.cssPosition === "fixed" ?
					-this.offset.scroll.left :
					( scrollIsRootNode ? 0 : this.offset.scroll.left ) ) * mod )
			)
		};

	},

	_generatePosition: function( event, constrainPosition ) {

		var containment, co, top, left,
			o = this.options,
			scrollIsRootNode = this._isRootNode( this.scrollParent[ 0 ] ),
			pageX = event.pageX,
			pageY = event.pageY;

		// Cache the scroll
		if ( !scrollIsRootNode || !this.offset.scroll ) {
			this.offset.scroll = {
				top: this.scrollParent.scrollTop(),
				left: this.scrollParent.scrollLeft()
			};
		}

		/*
		 * - Position constraining -
		 * Constrain the position to a mix of grid, containment.
		 */

		// If we are not dragging yet, we won't check for options
		if ( constrainPosition ) {
			if ( this.containment ) {
				if ( this.relativeContainer ) {
					co = this.relativeContainer.offset();
					containment = [
						this.containment[ 0 ] + co.left,
						this.containment[ 1 ] + co.top,
						this.containment[ 2 ] + co.left,
						this.containment[ 3 ] + co.top
					];
				} else {
					containment = this.containment;
				}

				if ( event.pageX - this.offset.click.left < containment[ 0 ] ) {
					pageX = containment[ 0 ] + this.offset.click.left;
				}
				if ( event.pageY - this.offset.click.top < containment[ 1 ] ) {
					pageY = containment[ 1 ] + this.offset.click.top;
				}
				if ( event.pageX - this.offset.click.left > containment[ 2 ] ) {
					pageX = containment[ 2 ] + this.offset.click.left;
				}
				if ( event.pageY - this.offset.click.top > containment[ 3 ] ) {
					pageY = containment[ 3 ] + this.offset.click.top;
				}
			}

			if ( o.grid ) {

				//Check for grid elements set to 0 to prevent divide by 0 error causing invalid
				// argument errors in IE (see ticket #6950)
				top = o.grid[ 1 ] ? this.originalPageY + Math.round( ( pageY -
					this.originalPageY ) / o.grid[ 1 ] ) * o.grid[ 1 ] : this.originalPageY;
				pageY = containment ? ( ( top - this.offset.click.top >= containment[ 1 ] ||
					top - this.offset.click.top > containment[ 3 ] ) ?
						top :
						( ( top - this.offset.click.top >= containment[ 1 ] ) ?
							top - o.grid[ 1 ] : top + o.grid[ 1 ] ) ) : top;

				left = o.grid[ 0 ] ? this.originalPageX +
					Math.round( ( pageX - this.originalPageX ) / o.grid[ 0 ] ) * o.grid[ 0 ] :
					this.originalPageX;
				pageX = containment ? ( ( left - this.offset.click.left >= containment[ 0 ] ||
					left - this.offset.click.left > containment[ 2 ] ) ?
						left :
						( ( left - this.offset.click.left >= containment[ 0 ] ) ?
							left - o.grid[ 0 ] : left + o.grid[ 0 ] ) ) : left;
			}

			if ( o.axis === "y" ) {
				pageX = this.originalPageX;
			}

			if ( o.axis === "x" ) {
				pageY = this.originalPageY;
			}
		}

		return {
			top: (

				// The absolute mouse position
				pageY -

				// Click offset (relative to the element)
				this.offset.click.top -

				// Only for relative positioned nodes: Relative offset from element to offset parent
				this.offset.relative.top -

				// The offsetParent's offset without borders (offset + border)
				this.offset.parent.top +
				( this.cssPosition === "fixed" ?
					-this.offset.scroll.top :
					( scrollIsRootNode ? 0 : this.offset.scroll.top ) )
			),
			left: (

				// The absolute mouse position
				pageX -

				// Click offset (relative to the element)
				this.offset.click.left -

				// Only for relative positioned nodes: Relative offset from element to offset parent
				this.offset.relative.left -

				// The offsetParent's offset without borders (offset + border)
				this.offset.parent.left +
				( this.cssPosition === "fixed" ?
					-this.offset.scroll.left :
					( scrollIsRootNode ? 0 : this.offset.scroll.left ) )
			)
		};

	},

	_clear: function() {
		this._removeClass( this.helper, "ui-draggable-dragging" );
		if ( this.helper[ 0 ] !== this.element[ 0 ] && !this.cancelHelperRemoval ) {
			this.helper.remove();
		}
		this.helper = null;
		this.cancelHelperRemoval = false;
		if ( this.destroyOnClear ) {
			this.destroy();
		}
	},

	// From now on bulk stuff - mainly helpers

	_trigger: function( type, event, ui ) {
		ui = ui || this._uiHash();
		$.ui.plugin.call( this, type, [ event, ui, this ], true );

		// Absolute position and offset (see #6884 ) have to be recalculated after plugins
		if ( /^(drag|start|stop)/.test( type ) ) {
			this.positionAbs = this._convertPositionTo( "absolute" );
			ui.offset = this.positionAbs;
		}
		return $.Widget.prototype._trigger.call( this, type, event, ui );
	},

	plugins: {},

	_uiHash: function() {
		return {
			helper: this.helper,
			position: this.position,
			originalPosition: this.originalPosition,
			offset: this.positionAbs
		};
	}

} );

$.ui.plugin.add( "draggable", "connectToSortable", {
	start: function( event, ui, draggable ) {
		var uiSortable = $.extend( {}, ui, {
			item: draggable.element
		} );

		draggable.sortables = [];
		$( draggable.options.connectToSortable ).each( function() {
			var sortable = $( this ).sortable( "instance" );

			if ( sortable && !sortable.options.disabled ) {
				draggable.sortables.push( sortable );

				// RefreshPositions is called at drag start to refresh the containerCache
				// which is used in drag. This ensures it's initialized and synchronized
				// with any changes that might have happened on the page since initialization.
				sortable.refreshPositions();
				sortable._trigger( "activate", event, uiSortable );
			}
		} );
	},
	stop: function( event, ui, draggable ) {
		var uiSortable = $.extend( {}, ui, {
			item: draggable.element
		} );

		draggable.cancelHelperRemoval = false;

		$.each( draggable.sortables, function() {
			var sortable = this;

			if ( sortable.isOver ) {
				sortable.isOver = 0;

				// Allow this sortable to handle removing the helper
				draggable.cancelHelperRemoval = true;
				sortable.cancelHelperRemoval = false;

				// Use _storedCSS To restore properties in the sortable,
				// as this also handles revert (#9675) since the draggable
				// may have modified them in unexpected ways (#8809)
				sortable._storedCSS = {
					position: sortable.placeholder.css( "position" ),
					top: sortable.placeholder.css( "top" ),
					left: sortable.placeholder.css( "left" )
				};

				sortable._mouseStop( event );

				// Once drag has ended, the sortable should return to using
				// its original helper, not the shared helper from draggable
				sortable.options.helper = sortable.options._helper;
			} else {

				// Prevent this Sortable from removing the helper.
				// However, don't set the draggable to remove the helper
				// either as another connected Sortable may yet handle the removal.
				sortable.cancelHelperRemoval = true;

				sortable._trigger( "deactivate", event, uiSortable );
			}
		} );
	},
	drag: function( event, ui, draggable ) {
		$.each( draggable.sortables, function() {
			var innermostIntersecting = false,
				sortable = this;

			// Copy over variables that sortable's _intersectsWith uses
			sortable.positionAbs = draggable.positionAbs;
			sortable.helperProportions = draggable.helperProportions;
			sortable.offset.click = draggable.offset.click;

			if ( sortable._intersectsWith( sortable.containerCache ) ) {
				innermostIntersecting = true;

				$.each( draggable.sortables, function() {

					// Copy over variables that sortable's _intersectsWith uses
					this.positionAbs = draggable.positionAbs;
					this.helperProportions = draggable.helperProportions;
					this.offset.click = draggable.offset.click;

					if ( this !== sortable &&
							this._intersectsWith( this.containerCache ) &&
							$.contains( sortable.element[ 0 ], this.element[ 0 ] ) ) {
						innermostIntersecting = false;
					}

					return innermostIntersecting;
				} );
			}

			if ( innermostIntersecting ) {

				// If it intersects, we use a little isOver variable and set it once,
				// so that the move-in stuff gets fired only once.
				if ( !sortable.isOver ) {
					sortable.isOver = 1;

					// Store draggable's parent in case we need to reappend to it later.
					draggable._parent = ui.helper.parent();

					sortable.currentItem = ui.helper
						.appendTo( sortable.element )
						.data( "ui-sortable-item", true );

					// Store helper option to later restore it
					sortable.options._helper = sortable.options.helper;

					sortable.options.helper = function() {
						return ui.helper[ 0 ];
					};

					// Fire the start events of the sortable with our passed browser event,
					// and our own helper (so it doesn't create a new one)
					event.target = sortable.currentItem[ 0 ];
					sortable._mouseCapture( event, true );
					sortable._mouseStart( event, true, true );

					// Because the browser event is way off the new appended portlet,
					// modify necessary variables to reflect the changes
					sortable.offset.click.top = draggable.offset.click.top;
					sortable.offset.click.left = draggable.offset.click.left;
					sortable.offset.parent.left -= draggable.offset.parent.left -
						sortable.offset.parent.left;
					sortable.offset.parent.top -= draggable.offset.parent.top -
						sortable.offset.parent.top;

					draggable._trigger( "toSortable", event );

					// Inform draggable that the helper is in a valid drop zone,
					// used solely in the revert option to handle "valid/invalid".
					draggable.dropped = sortable.element;

					// Need to refreshPositions of all sortables in the case that
					// adding to one sortable changes the location of the other sortables (#9675)
					$.each( draggable.sortables, function() {
						this.refreshPositions();
					} );

					// Hack so receive/update callbacks work (mostly)
					draggable.currentItem = draggable.element;
					sortable.fromOutside = draggable;
				}

				if ( sortable.currentItem ) {
					sortable._mouseDrag( event );

					// Copy the sortable's position because the draggable's can potentially reflect
					// a relative position, while sortable is always absolute, which the dragged
					// element has now become. (#8809)
					ui.position = sortable.position;
				}
			} else {

				// If it doesn't intersect with the sortable, and it intersected before,
				// we fake the drag stop of the sortable, but make sure it doesn't remove
				// the helper by using cancelHelperRemoval.
				if ( sortable.isOver ) {

					sortable.isOver = 0;
					sortable.cancelHelperRemoval = true;

					// Calling sortable's mouseStop would trigger a revert,
					// so revert must be temporarily false until after mouseStop is called.
					sortable.options._revert = sortable.options.revert;
					sortable.options.revert = false;

					sortable._trigger( "out", event, sortable._uiHash( sortable ) );
					sortable._mouseStop( event, true );

					// Restore sortable behaviors that were modfied
					// when the draggable entered the sortable area (#9481)
					sortable.options.revert = sortable.options._revert;
					sortable.options.helper = sortable.options._helper;

					if ( sortable.placeholder ) {
						sortable.placeholder.remove();
					}

					// Restore and recalculate the draggable's offset considering the sortable
					// may have modified them in unexpected ways. (#8809, #10669)
					ui.helper.appendTo( draggable._parent );
					draggable._refreshOffsets( event );
					ui.position = draggable._generatePosition( event, true );

					draggable._trigger( "fromSortable", event );

					// Inform draggable that the helper is no longer in a valid drop zone
					draggable.dropped = false;

					// Need to refreshPositions of all sortables just in case removing
					// from one sortable changes the location of other sortables (#9675)
					$.each( draggable.sortables, function() {
						this.refreshPositions();
					} );
				}
			}
		} );
	}
} );

$.ui.plugin.add( "draggable", "cursor", {
	start: function( event, ui, instance ) {
		var t = $( "body" ),
			o = instance.options;

		if ( t.css( "cursor" ) ) {
			o._cursor = t.css( "cursor" );
		}
		t.css( "cursor", o.cursor );
	},
	stop: function( event, ui, instance ) {
		var o = instance.options;
		if ( o._cursor ) {
			$( "body" ).css( "cursor", o._cursor );
		}
	}
} );

$.ui.plugin.add( "draggable", "opacity", {
	start: function( event, ui, instance ) {
		var t = $( ui.helper ),
			o = instance.options;
		if ( t.css( "opacity" ) ) {
			o._opacity = t.css( "opacity" );
		}
		t.css( "opacity", o.opacity );
	},
	stop: function( event, ui, instance ) {
		var o = instance.options;
		if ( o._opacity ) {
			$( ui.helper ).css( "opacity", o._opacity );
		}
	}
} );

$.ui.plugin.add( "draggable", "scroll", {
	start: function( event, ui, i ) {
		if ( !i.scrollParentNotHidden ) {
			i.scrollParentNotHidden = i.helper.scrollParent( false );
		}

		if ( i.scrollParentNotHidden[ 0 ] !== i.document[ 0 ] &&
				i.scrollParentNotHidden[ 0 ].tagName !== "HTML" ) {
			i.overflowOffset = i.scrollParentNotHidden.offset();
		}
	},
	drag: function( event, ui, i  ) {

		var o = i.options,
			scrolled = false,
			scrollParent = i.scrollParentNotHidden[ 0 ],
			document = i.document[ 0 ];

		if ( scrollParent !== document && scrollParent.tagName !== "HTML" ) {
			if ( !o.axis || o.axis !== "x" ) {
				if ( ( i.overflowOffset.top + scrollParent.offsetHeight ) - event.pageY <
						o.scrollSensitivity ) {
					scrollParent.scrollTop = scrolled = scrollParent.scrollTop + o.scrollSpeed;
				} else if ( event.pageY - i.overflowOffset.top < o.scrollSensitivity ) {
					scrollParent.scrollTop = scrolled = scrollParent.scrollTop - o.scrollSpeed;
				}
			}

			if ( !o.axis || o.axis !== "y" ) {
				if ( ( i.overflowOffset.left + scrollParent.offsetWidth ) - event.pageX <
						o.scrollSensitivity ) {
					scrollParent.scrollLeft = scrolled = scrollParent.scrollLeft + o.scrollSpeed;
				} else if ( event.pageX - i.overflowOffset.left < o.scrollSensitivity ) {
					scrollParent.scrollLeft = scrolled = scrollParent.scrollLeft - o.scrollSpeed;
				}
			}

		} else {

			if ( !o.axis || o.axis !== "x" ) {
				if ( event.pageY - $( document ).scrollTop() < o.scrollSensitivity ) {
					scrolled = $( document ).scrollTop( $( document ).scrollTop() - o.scrollSpeed );
				} else if ( $( window ).height() - ( event.pageY - $( document ).scrollTop() ) <
						o.scrollSensitivity ) {
					scrolled = $( document ).scrollTop( $( document ).scrollTop() + o.scrollSpeed );
				}
			}

			if ( !o.axis || o.axis !== "y" ) {
				if ( event.pageX - $( document ).scrollLeft() < o.scrollSensitivity ) {
					scrolled = $( document ).scrollLeft(
						$( document ).scrollLeft() - o.scrollSpeed
					);
				} else if ( $( window ).width() - ( event.pageX - $( document ).scrollLeft() ) <
						o.scrollSensitivity ) {
					scrolled = $( document ).scrollLeft(
						$( document ).scrollLeft() + o.scrollSpeed
					);
				}
			}

		}

		if ( scrolled !== false && $.ui.ddmanager && !o.dropBehaviour ) {
			$.ui.ddmanager.prepareOffsets( i, event );
		}

	}
} );

$.ui.plugin.add( "draggable", "snap", {
	start: function( event, ui, i ) {

		var o = i.options;

		i.snapElements = [];

		$( o.snap.constructor !== String ? ( o.snap.items || ":data(ui-draggable)" ) : o.snap )
			.each( function() {
				var $t = $( this ),
					$o = $t.offset();
				if ( this !== i.element[ 0 ] ) {
					i.snapElements.push( {
						item: this,
						width: $t.outerWidth(), height: $t.outerHeight(),
						top: $o.top, left: $o.left
					} );
				}
			} );

	},
	drag: function( event, ui, inst ) {

		var ts, bs, ls, rs, l, r, t, b, i, first,
			o = inst.options,
			d = o.snapTolerance,
			x1 = ui.offset.left, x2 = x1 + inst.helperProportions.width,
			y1 = ui.offset.top, y2 = y1 + inst.helperProportions.height;

		for ( i = inst.snapElements.length - 1; i >= 0; i-- ) {

			l = inst.snapElements[ i ].left - inst.margins.left;
			r = l + inst.snapElements[ i ].width;
			t = inst.snapElements[ i ].top - inst.margins.top;
			b = t + inst.snapElements[ i ].height;

			if ( x2 < l - d || x1 > r + d || y2 < t - d || y1 > b + d ||
					!$.contains( inst.snapElements[ i ].item.ownerDocument,
					inst.snapElements[ i ].item ) ) {
				if ( inst.snapElements[ i ].snapping ) {
					( inst.options.snap.release &&
						inst.options.snap.release.call(
							inst.element,
							event,
							$.extend( inst._uiHash(), { snapItem: inst.snapElements[ i ].item } )
						) );
				}
				inst.snapElements[ i ].snapping = false;
				continue;
			}

			if ( o.snapMode !== "inner" ) {
				ts = Math.abs( t - y2 ) <= d;
				bs = Math.abs( b - y1 ) <= d;
				ls = Math.abs( l - x2 ) <= d;
				rs = Math.abs( r - x1 ) <= d;
				if ( ts ) {
					ui.position.top = inst._convertPositionTo( "relative", {
						top: t - inst.helperProportions.height,
						left: 0
					} ).top;
				}
				if ( bs ) {
					ui.position.top = inst._convertPositionTo( "relative", {
						top: b,
						left: 0
					} ).top;
				}
				if ( ls ) {
					ui.position.left = inst._convertPositionTo( "relative", {
						top: 0,
						left: l - inst.helperProportions.width
					} ).left;
				}
				if ( rs ) {
					ui.position.left = inst._convertPositionTo( "relative", {
						top: 0,
						left: r
					} ).left;
				}
			}

			first = ( ts || bs || ls || rs );

			if ( o.snapMode !== "outer" ) {
				ts = Math.abs( t - y1 ) <= d;
				bs = Math.abs( b - y2 ) <= d;
				ls = Math.abs( l - x1 ) <= d;
				rs = Math.abs( r - x2 ) <= d;
				if ( ts ) {
					ui.position.top = inst._convertPositionTo( "relative", {
						top: t,
						left: 0
					} ).top;
				}
				if ( bs ) {
					ui.position.top = inst._convertPositionTo( "relative", {
						top: b - inst.helperProportions.height,
						left: 0
					} ).top;
				}
				if ( ls ) {
					ui.position.left = inst._convertPositionTo( "relative", {
						top: 0,
						left: l
					} ).left;
				}
				if ( rs ) {
					ui.position.left = inst._convertPositionTo( "relative", {
						top: 0,
						left: r - inst.helperProportions.width
					} ).left;
				}
			}

			if ( !inst.snapElements[ i ].snapping && ( ts || bs || ls || rs || first ) ) {
				( inst.options.snap.snap &&
					inst.options.snap.snap.call(
						inst.element,
						event,
						$.extend( inst._uiHash(), {
							snapItem: inst.snapElements[ i ].item
						} ) ) );
			}
			inst.snapElements[ i ].snapping = ( ts || bs || ls || rs || first );

		}

	}
} );

$.ui.plugin.add( "draggable", "stack", {
	start: function( event, ui, instance ) {
		var min,
			o = instance.options,
			group = $.makeArray( $( o.stack ) ).sort( function( a, b ) {
				return ( parseInt( $( a ).css( "zIndex" ), 10 ) || 0 ) -
					( parseInt( $( b ).css( "zIndex" ), 10 ) || 0 );
			} );

		if ( !group.length ) { return; }

		min = parseInt( $( group[ 0 ] ).css( "zIndex" ), 10 ) || 0;
		$( group ).each( function( i ) {
			$( this ).css( "zIndex", min + i );
		} );
		this.css( "zIndex", ( min + group.length ) );
	}
} );

$.ui.plugin.add( "draggable", "zIndex", {
	start: function( event, ui, instance ) {
		var t = $( ui.helper ),
			o = instance.options;

		if ( t.css( "zIndex" ) ) {
			o._zIndex = t.css( "zIndex" );
		}
		t.css( "zIndex", o.zIndex );
	},
	stop: function( event, ui, instance ) {
		var o = instance.options;

		if ( o._zIndex ) {
			$( ui.helper ).css( "zIndex", o._zIndex );
		}
	}
} );

var widgetsDraggable = $.ui.draggable;


/*!
 * jQuery UI Resizable 1.12.0
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Resizable
//>>group: Interactions
//>>description: Enables resize functionality for any element.
//>>docs: http://api.jqueryui.com/resizable/
//>>demos: http://jqueryui.com/resizable/
//>>css.structure: ../../themes/base/core.css
//>>css.structure: ../../themes/base/resizable.css
//>>css.theme: ../../themes/base/theme.css



$.widget( "ui.resizable", $.ui.mouse, {
	version: "1.12.0",
	widgetEventPrefix: "resize",
	options: {
		alsoResize: false,
		animate: false,
		animateDuration: "slow",
		animateEasing: "swing",
		aspectRatio: false,
		autoHide: false,
		classes: {
			"ui-resizable-se": "ui-icon ui-icon-gripsmall-diagonal-se"
		},
		containment: false,
		ghost: false,
		grid: false,
		handles: "e,s,se",
		helper: false,
		maxHeight: null,
		maxWidth: null,
		minHeight: 10,
		minWidth: 10,

		// See #7960
		zIndex: 90,

		// Callbacks
		resize: null,
		start: null,
		stop: null
	},

	_num: function( value ) {
		return parseFloat( value ) || 0;
	},

	_isNumber: function( value ) {
		return !isNaN( parseFloat( value ) );
	},

	_hasScroll: function( el, a ) {

		if ( $( el ).css( "overflow" ) === "hidden" ) {
			return false;
		}

		var scroll = ( a && a === "left" ) ? "scrollLeft" : "scrollTop",
			has = false;

		if ( el[ scroll ] > 0 ) {
			return true;
		}

		// TODO: determine which cases actually cause this to happen
		// if the element doesn't have the scroll set, see if it's possible to
		// set the scroll
		el[ scroll ] = 1;
		has = ( el[ scroll ] > 0 );
		el[ scroll ] = 0;
		return has;
	},

	_create: function() {

		var margins,
			o = this.options,
			that = this;
		this._addClass( "ui-resizable" );

		$.extend( this, {
			_aspectRatio: !!( o.aspectRatio ),
			aspectRatio: o.aspectRatio,
			originalElement: this.element,
			_proportionallyResizeElements: [],
			_helper: o.helper || o.ghost || o.animate ? o.helper || "ui-resizable-helper" : null
		} );

		// Wrap the element if it cannot hold child nodes
		if ( this.element[ 0 ].nodeName.match( /^(canvas|textarea|input|select|button|img)$/i ) ) {

			this.element.wrap(
				$( "<div class='ui-wrapper' style='overflow: hidden;'></div>" ).css( {
					position: this.element.css( "position" ),
					width: this.element.outerWidth(),
					height: this.element.outerHeight(),
					top: this.element.css( "top" ),
					left: this.element.css( "left" )
				} )
			);

			this.element = this.element.parent().data(
				"ui-resizable", this.element.resizable( "instance" )
			);

			this.elementIsWrapper = true;

			margins = {
				marginTop: this.originalElement.css( "marginTop" ),
				marginRight: this.originalElement.css( "marginRight" ),
				marginBottom: this.originalElement.css( "marginBottom" ),
				marginLeft: this.originalElement.css( "marginLeft" )
			};

			this.element.css( margins );
			this.originalElement.css( "margin", 0 );

			// support: Safari
			// Prevent Safari textarea resize
			this.originalResizeStyle = this.originalElement.css( "resize" );
			this.originalElement.css( "resize", "none" );

			this._proportionallyResizeElements.push( this.originalElement.css( {
				position: "static",
				zoom: 1,
				display: "block"
			} ) );

			// Support: IE9
			// avoid IE jump (hard set the margin)
			this.originalElement.css( margins );

			this._proportionallyResize();
		}

		this._setupHandles();

		if ( o.autoHide ) {
			$( this.element )
				.on( "mouseenter", function() {
					if ( o.disabled ) {
						return;
					}
					that._removeClass( "ui-resizable-autohide" );
					that._handles.show();
				} )
				.on( "mouseleave", function() {
					if ( o.disabled ) {
						return;
					}
					if ( !that.resizing ) {
						that._addClass( "ui-resizable-autohide" );
						that._handles.hide();
					}
				} );
		}

		this._mouseInit();
	},

	_destroy: function() {

		this._mouseDestroy();

		var wrapper,
			_destroy = function( exp ) {
				$( exp )
					.removeData( "resizable" )
					.removeData( "ui-resizable" )
					.off( ".resizable" )
					.find( ".ui-resizable-handle" )
						.remove();
			};

		// TODO: Unwrap at same DOM position
		if ( this.elementIsWrapper ) {
			_destroy( this.element );
			wrapper = this.element;
			this.originalElement.css( {
				position: wrapper.css( "position" ),
				width: wrapper.outerWidth(),
				height: wrapper.outerHeight(),
				top: wrapper.css( "top" ),
				left: wrapper.css( "left" )
			} ).insertAfter( wrapper );
			wrapper.remove();
		}

		this.originalElement.css( "resize", this.originalResizeStyle );
		_destroy( this.originalElement );

		return this;
	},

	_setOption: function( key, value ) {
		this._super( key, value );

		switch ( key ) {
		case "handles":
			this._removeHandles();
			this._setupHandles();
			break;
		default:
			break;
		}
	},

	_setupHandles: function() {
		var o = this.options, handle, i, n, hname, axis, that = this;
		this.handles = o.handles ||
			( !$( ".ui-resizable-handle", this.element ).length ?
				"e,s,se" : {
					n: ".ui-resizable-n",
					e: ".ui-resizable-e",
					s: ".ui-resizable-s",
					w: ".ui-resizable-w",
					se: ".ui-resizable-se",
					sw: ".ui-resizable-sw",
					ne: ".ui-resizable-ne",
					nw: ".ui-resizable-nw"
				} );

		this._handles = $();
		if ( this.handles.constructor === String ) {

			if ( this.handles === "all" ) {
				this.handles = "n,e,s,w,se,sw,ne,nw";
			}

			n = this.handles.split( "," );
			this.handles = {};

			for ( i = 0; i < n.length; i++ ) {

				handle = $.trim( n[ i ] );
				hname = "ui-resizable-" + handle;
				axis = $( "<div>" );
				this._addClass( axis, "ui-resizable-handle " + hname );

				axis.css( { zIndex: o.zIndex } );

				this.handles[ handle ] = ".ui-resizable-" + handle;
				this.element.append( axis );
			}

		}

		this._renderAxis = function( target ) {

			var i, axis, padPos, padWrapper;

			target = target || this.element;

			for ( i in this.handles ) {

				if ( this.handles[ i ].constructor === String ) {
					this.handles[ i ] = this.element.children( this.handles[ i ] ).first().show();
				} else if ( this.handles[ i ].jquery || this.handles[ i ].nodeType ) {
					this.handles[ i ] = $( this.handles[ i ] );
					this._on( this.handles[ i ], { "mousedown": that._mouseDown } );
				}

				if ( this.elementIsWrapper &&
						this.originalElement[ 0 ]
							.nodeName
							.match( /^(textarea|input|select|button)$/i ) ) {
					axis = $( this.handles[ i ], this.element );

					padWrapper = /sw|ne|nw|se|n|s/.test( i ) ?
						axis.outerHeight() :
						axis.outerWidth();

					padPos = [ "padding",
						/ne|nw|n/.test( i ) ? "Top" :
						/se|sw|s/.test( i ) ? "Bottom" :
						/^e$/.test( i ) ? "Right" : "Left" ].join( "" );

					target.css( padPos, padWrapper );

					this._proportionallyResize();
				}

				this._handles = this._handles.add( this.handles[ i ] );
			}
		};

		// TODO: make renderAxis a prototype function
		this._renderAxis( this.element );

		this._handles = this._handles.add( this.element.find( ".ui-resizable-handle" ) );
		this._handles.disableSelection();

		this._handles.on( "mouseover", function() {
			if ( !that.resizing ) {
				if ( this.className ) {
					axis = this.className.match( /ui-resizable-(se|sw|ne|nw|n|e|s|w)/i );
				}
				that.axis = axis && axis[ 1 ] ? axis[ 1 ] : "se";
			}
		} );

		if ( o.autoHide ) {
			this._handles.hide();
			this._addClass( "ui-resizable-autohide" );
		}
	},

	_removeHandles: function() {
		this._handles.remove();
	},

	_mouseCapture: function( event ) {
		var i, handle,
			capture = false;

		for ( i in this.handles ) {
			handle = $( this.handles[ i ] )[ 0 ];
			if ( handle === event.target || $.contains( handle, event.target ) ) {
				capture = true;
			}
		}

		return !this.options.disabled && capture;
	},

	_mouseStart: function( event ) {

		var curleft, curtop, cursor,
			o = this.options,
			el = this.element;

		this.resizing = true;

		this._renderProxy();

		curleft = this._num( this.helper.css( "left" ) );
		curtop = this._num( this.helper.css( "top" ) );

		if ( o.containment ) {
			curleft += $( o.containment ).scrollLeft() || 0;
			curtop += $( o.containment ).scrollTop() || 0;
		}

		this.offset = this.helper.offset();
		this.position = { left: curleft, top: curtop };

		this.size = this._helper ? {
				width: this.helper.width(),
				height: this.helper.height()
			} : {
				width: el.width(),
				height: el.height()
			};

		this.originalSize = this._helper ? {
				width: el.outerWidth(),
				height: el.outerHeight()
			} : {
				width: el.width(),
				height: el.height()
			};

		this.sizeDiff = {
			width: el.outerWidth() - el.width(),
			height: el.outerHeight() - el.height()
		};

		this.originalPosition = { left: curleft, top: curtop };
		this.originalMousePosition = { left: event.pageX, top: event.pageY };

		this.aspectRatio = ( typeof o.aspectRatio === "number" ) ?
			o.aspectRatio :
			( ( this.originalSize.width / this.originalSize.height ) || 1 );

		cursor = $( ".ui-resizable-" + this.axis ).css( "cursor" );
		$( "body" ).css( "cursor", cursor === "auto" ? this.axis + "-resize" : cursor );

		this._addClass( "ui-resizable-resizing" );
		this._propagate( "start", event );
		return true;
	},

	_mouseDrag: function( event ) {

		var data, props,
			smp = this.originalMousePosition,
			a = this.axis,
			dx = ( event.pageX - smp.left ) || 0,
			dy = ( event.pageY - smp.top ) || 0,
			trigger = this._change[ a ];

		this._updatePrevProperties();

		if ( !trigger ) {
			return false;
		}

		data = trigger.apply( this, [ event, dx, dy ] );

		this._updateVirtualBoundaries( event.shiftKey );
		if ( this._aspectRatio || event.shiftKey ) {
			data = this._updateRatio( data, event );
		}

		data = this._respectSize( data, event );

		this._updateCache( data );

		this._propagate( "resize", event );

		props = this._applyChanges();

		if ( !this._helper && this._proportionallyResizeElements.length ) {
			this._proportionallyResize();
		}

		if ( !$.isEmptyObject( props ) ) {
			this._updatePrevProperties();
			this._trigger( "resize", event, this.ui() );
			this._applyChanges();
		}

		return false;
	},

	_mouseStop: function( event ) {

		this.resizing = false;
		var pr, ista, soffseth, soffsetw, s, left, top,
			o = this.options, that = this;

		if ( this._helper ) {

			pr = this._proportionallyResizeElements;
			ista = pr.length && ( /textarea/i ).test( pr[ 0 ].nodeName );
			soffseth = ista && this._hasScroll( pr[ 0 ], "left" ) ? 0 : that.sizeDiff.height;
			soffsetw = ista ? 0 : that.sizeDiff.width;

			s = {
				width: ( that.helper.width()  - soffsetw ),
				height: ( that.helper.height() - soffseth )
			};
			left = ( parseFloat( that.element.css( "left" ) ) +
				( that.position.left - that.originalPosition.left ) ) || null;
			top = ( parseFloat( that.element.css( "top" ) ) +
				( that.position.top - that.originalPosition.top ) ) || null;

			if ( !o.animate ) {
				this.element.css( $.extend( s, { top: top, left: left } ) );
			}

			that.helper.height( that.size.height );
			that.helper.width( that.size.width );

			if ( this._helper && !o.animate ) {
				this._proportionallyResize();
			}
		}

		$( "body" ).css( "cursor", "auto" );

		this._removeClass( "ui-resizable-resizing" );

		this._propagate( "stop", event );

		if ( this._helper ) {
			this.helper.remove();
		}

		return false;

	},

	_updatePrevProperties: function() {
		this.prevPosition = {
			top: this.position.top,
			left: this.position.left
		};
		this.prevSize = {
			width: this.size.width,
			height: this.size.height
		};
	},

	_applyChanges: function() {
		var props = {};

		if ( this.position.top !== this.prevPosition.top ) {
			props.top = this.position.top + "px";
		}
		if ( this.position.left !== this.prevPosition.left ) {
			props.left = this.position.left + "px";
		}
		if ( this.size.width !== this.prevSize.width ) {
			props.width = this.size.width + "px";
		}
		if ( this.size.height !== this.prevSize.height ) {
			props.height = this.size.height + "px";
		}

		this.helper.css( props );

		return props;
	},

	_updateVirtualBoundaries: function( forceAspectRatio ) {
		var pMinWidth, pMaxWidth, pMinHeight, pMaxHeight, b,
			o = this.options;

		b = {
			minWidth: this._isNumber( o.minWidth ) ? o.minWidth : 0,
			maxWidth: this._isNumber( o.maxWidth ) ? o.maxWidth : Infinity,
			minHeight: this._isNumber( o.minHeight ) ? o.minHeight : 0,
			maxHeight: this._isNumber( o.maxHeight ) ? o.maxHeight : Infinity
		};

		if ( this._aspectRatio || forceAspectRatio ) {
			pMinWidth = b.minHeight * this.aspectRatio;
			pMinHeight = b.minWidth / this.aspectRatio;
			pMaxWidth = b.maxHeight * this.aspectRatio;
			pMaxHeight = b.maxWidth / this.aspectRatio;

			if ( pMinWidth > b.minWidth ) {
				b.minWidth = pMinWidth;
			}
			if ( pMinHeight > b.minHeight ) {
				b.minHeight = pMinHeight;
			}
			if ( pMaxWidth < b.maxWidth ) {
				b.maxWidth = pMaxWidth;
			}
			if ( pMaxHeight < b.maxHeight ) {
				b.maxHeight = pMaxHeight;
			}
		}
		this._vBoundaries = b;
	},

	_updateCache: function( data ) {
		this.offset = this.helper.offset();
		if ( this._isNumber( data.left ) ) {
			this.position.left = data.left;
		}
		if ( this._isNumber( data.top ) ) {
			this.position.top = data.top;
		}
		if ( this._isNumber( data.height ) ) {
			this.size.height = data.height;
		}
		if ( this._isNumber( data.width ) ) {
			this.size.width = data.width;
		}
	},

	_updateRatio: function( data ) {

		var cpos = this.position,
			csize = this.size,
			a = this.axis;

		if ( this._isNumber( data.height ) ) {
			data.width = ( data.height * this.aspectRatio );
		} else if ( this._isNumber( data.width ) ) {
			data.height = ( data.width / this.aspectRatio );
		}

		if ( a === "sw" ) {
			data.left = cpos.left + ( csize.width - data.width );
			data.top = null;
		}
		if ( a === "nw" ) {
			data.top = cpos.top + ( csize.height - data.height );
			data.left = cpos.left + ( csize.width - data.width );
		}

		return data;
	},

	_respectSize: function( data ) {

		var o = this._vBoundaries,
			a = this.axis,
			ismaxw = this._isNumber( data.width ) && o.maxWidth && ( o.maxWidth < data.width ),
			ismaxh = this._isNumber( data.height ) && o.maxHeight && ( o.maxHeight < data.height ),
			isminw = this._isNumber( data.width ) && o.minWidth && ( o.minWidth > data.width ),
			isminh = this._isNumber( data.height ) && o.minHeight && ( o.minHeight > data.height ),
			dw = this.originalPosition.left + this.originalSize.width,
			dh = this.originalPosition.top + this.originalSize.height,
			cw = /sw|nw|w/.test( a ), ch = /nw|ne|n/.test( a );
		if ( isminw ) {
			data.width = o.minWidth;
		}
		if ( isminh ) {
			data.height = o.minHeight;
		}
		if ( ismaxw ) {
			data.width = o.maxWidth;
		}
		if ( ismaxh ) {
			data.height = o.maxHeight;
		}

		if ( isminw && cw ) {
			data.left = dw - o.minWidth;
		}
		if ( ismaxw && cw ) {
			data.left = dw - o.maxWidth;
		}
		if ( isminh && ch ) {
			data.top = dh - o.minHeight;
		}
		if ( ismaxh && ch ) {
			data.top = dh - o.maxHeight;
		}

		// Fixing jump error on top/left - bug #2330
		if ( !data.width && !data.height && !data.left && data.top ) {
			data.top = null;
		} else if ( !data.width && !data.height && !data.top && data.left ) {
			data.left = null;
		}

		return data;
	},

	_getPaddingPlusBorderDimensions: function( element ) {
		var i = 0,
			widths = [],
			borders = [
				element.css( "borderTopWidth" ),
				element.css( "borderRightWidth" ),
				element.css( "borderBottomWidth" ),
				element.css( "borderLeftWidth" )
			],
			paddings = [
				element.css( "paddingTop" ),
				element.css( "paddingRight" ),
				element.css( "paddingBottom" ),
				element.css( "paddingLeft" )
			];

		for ( ; i < 4; i++ ) {
			widths[ i ] = ( parseFloat( borders[ i ] ) || 0 );
			widths[ i ] += ( parseFloat( paddings[ i ] ) || 0 );
		}

		return {
			height: widths[ 0 ] + widths[ 2 ],
			width: widths[ 1 ] + widths[ 3 ]
		};
	},

	_proportionallyResize: function() {

		if ( !this._proportionallyResizeElements.length ) {
			return;
		}

		var prel,
			i = 0,
			element = this.helper || this.element;

		for ( ; i < this._proportionallyResizeElements.length; i++ ) {

			prel = this._proportionallyResizeElements[ i ];

			// TODO: Seems like a bug to cache this.outerDimensions
			// considering that we are in a loop.
			if ( !this.outerDimensions ) {
				this.outerDimensions = this._getPaddingPlusBorderDimensions( prel );
			}

			prel.css( {
				height: ( element.height() - this.outerDimensions.height ) || 0,
				width: ( element.width() - this.outerDimensions.width ) || 0
			} );

		}

	},

	_renderProxy: function() {

		var el = this.element, o = this.options;
		this.elementOffset = el.offset();

		if ( this._helper ) {

			this.helper = this.helper || $( "<div style='overflow:hidden;'></div>" );

			this._addClass( this.helper, this._helper );
			this.helper.css( {
				width: this.element.outerWidth(),
				height: this.element.outerHeight(),
				position: "absolute",
				left: this.elementOffset.left + "px",
				top: this.elementOffset.top + "px",
				zIndex: ++o.zIndex //TODO: Don't modify option
			} );

			this.helper
				.appendTo( "body" )
				.disableSelection();

		} else {
			this.helper = this.element;
		}

	},

	_change: {
		e: function( event, dx ) {
			return { width: this.originalSize.width + dx };
		},
		w: function( event, dx ) {
			var cs = this.originalSize, sp = this.originalPosition;
			return { left: sp.left + dx, width: cs.width - dx };
		},
		n: function( event, dx, dy ) {
			var cs = this.originalSize, sp = this.originalPosition;
			return { top: sp.top + dy, height: cs.height - dy };
		},
		s: function( event, dx, dy ) {
			return { height: this.originalSize.height + dy };
		},
		se: function( event, dx, dy ) {
			return $.extend( this._change.s.apply( this, arguments ),
				this._change.e.apply( this, [ event, dx, dy ] ) );
		},
		sw: function( event, dx, dy ) {
			return $.extend( this._change.s.apply( this, arguments ),
				this._change.w.apply( this, [ event, dx, dy ] ) );
		},
		ne: function( event, dx, dy ) {
			return $.extend( this._change.n.apply( this, arguments ),
				this._change.e.apply( this, [ event, dx, dy ] ) );
		},
		nw: function( event, dx, dy ) {
			return $.extend( this._change.n.apply( this, arguments ),
				this._change.w.apply( this, [ event, dx, dy ] ) );
		}
	},

	_propagate: function( n, event ) {
		$.ui.plugin.call( this, n, [ event, this.ui() ] );
		( n !== "resize" && this._trigger( n, event, this.ui() ) );
	},

	plugins: {},

	ui: function() {
		return {
			originalElement: this.originalElement,
			element: this.element,
			helper: this.helper,
			position: this.position,
			size: this.size,
			originalSize: this.originalSize,
			originalPosition: this.originalPosition
		};
	}

} );

/*
 * Resizable Extensions
 */

$.ui.plugin.add( "resizable", "animate", {

	stop: function( event ) {
		var that = $( this ).resizable( "instance" ),
			o = that.options,
			pr = that._proportionallyResizeElements,
			ista = pr.length && ( /textarea/i ).test( pr[ 0 ].nodeName ),
			soffseth = ista && that._hasScroll( pr[ 0 ], "left" ) ? 0 : that.sizeDiff.height,
			soffsetw = ista ? 0 : that.sizeDiff.width,
			style = {
				width: ( that.size.width - soffsetw ),
				height: ( that.size.height - soffseth )
			},
			left = ( parseFloat( that.element.css( "left" ) ) +
				( that.position.left - that.originalPosition.left ) ) || null,
			top = ( parseFloat( that.element.css( "top" ) ) +
				( that.position.top - that.originalPosition.top ) ) || null;

		that.element.animate(
			$.extend( style, top && left ? { top: top, left: left } : {} ), {
				duration: o.animateDuration,
				easing: o.animateEasing,
				step: function() {

					var data = {
						width: parseFloat( that.element.css( "width" ) ),
						height: parseFloat( that.element.css( "height" ) ),
						top: parseFloat( that.element.css( "top" ) ),
						left: parseFloat( that.element.css( "left" ) )
					};

					if ( pr && pr.length ) {
						$( pr[ 0 ] ).css( { width: data.width, height: data.height } );
					}

					// Propagating resize, and updating values for each animation step
					that._updateCache( data );
					that._propagate( "resize", event );

				}
			}
		);
	}

} );

$.ui.plugin.add( "resizable", "containment", {

	start: function() {
		var element, p, co, ch, cw, width, height,
			that = $( this ).resizable( "instance" ),
			o = that.options,
			el = that.element,
			oc = o.containment,
			ce = ( oc instanceof $ ) ?
				oc.get( 0 ) :
				( /parent/.test( oc ) ) ? el.parent().get( 0 ) : oc;

		if ( !ce ) {
			return;
		}

		that.containerElement = $( ce );

		if ( /document/.test( oc ) || oc === document ) {
			that.containerOffset = {
				left: 0,
				top: 0
			};
			that.containerPosition = {
				left: 0,
				top: 0
			};

			that.parentData = {
				element: $( document ),
				left: 0,
				top: 0,
				width: $( document ).width(),
				height: $( document ).height() || document.body.parentNode.scrollHeight
			};
		} else {
			element = $( ce );
			p = [];
			$( [ "Top", "Right", "Left", "Bottom" ] ).each( function( i, name ) {
				p[ i ] = that._num( element.css( "padding" + name ) );
			} );

			that.containerOffset = element.offset();
			that.containerPosition = element.position();
			that.containerSize = {
				height: ( element.innerHeight() - p[ 3 ] ),
				width: ( element.innerWidth() - p[ 1 ] )
			};

			co = that.containerOffset;
			ch = that.containerSize.height;
			cw = that.containerSize.width;
			width = ( that._hasScroll ( ce, "left" ) ? ce.scrollWidth : cw );
			height = ( that._hasScroll ( ce ) ? ce.scrollHeight : ch ) ;

			that.parentData = {
				element: ce,
				left: co.left,
				top: co.top,
				width: width,
				height: height
			};
		}
	},

	resize: function( event ) {
		var woset, hoset, isParent, isOffsetRelative,
			that = $( this ).resizable( "instance" ),
			o = that.options,
			co = that.containerOffset,
			cp = that.position,
			pRatio = that._aspectRatio || event.shiftKey,
			cop = {
				top: 0,
				left: 0
			},
			ce = that.containerElement,
			continueResize = true;

		if ( ce[ 0 ] !== document && ( /static/ ).test( ce.css( "position" ) ) ) {
			cop = co;
		}

		if ( cp.left < ( that._helper ? co.left : 0 ) ) {
			that.size.width = that.size.width +
				( that._helper ?
					( that.position.left - co.left ) :
					( that.position.left - cop.left ) );

			if ( pRatio ) {
				that.size.height = that.size.width / that.aspectRatio;
				continueResize = false;
			}
			that.position.left = o.helper ? co.left : 0;
		}

		if ( cp.top < ( that._helper ? co.top : 0 ) ) {
			that.size.height = that.size.height +
				( that._helper ?
					( that.position.top - co.top ) :
					that.position.top );

			if ( pRatio ) {
				that.size.width = that.size.height * that.aspectRatio;
				continueResize = false;
			}
			that.position.top = that._helper ? co.top : 0;
		}

		isParent = that.containerElement.get( 0 ) === that.element.parent().get( 0 );
		isOffsetRelative = /relative|absolute/.test( that.containerElement.css( "position" ) );

		if ( isParent && isOffsetRelative ) {
			that.offset.left = that.parentData.left + that.position.left;
			that.offset.top = that.parentData.top + that.position.top;
		} else {
			that.offset.left = that.element.offset().left;
			that.offset.top = that.element.offset().top;
		}

		woset = Math.abs( that.sizeDiff.width +
			( that._helper ?
				that.offset.left - cop.left :
				( that.offset.left - co.left ) ) );

		hoset = Math.abs( that.sizeDiff.height +
			( that._helper ?
				that.offset.top - cop.top :
				( that.offset.top - co.top ) ) );

		if ( woset + that.size.width >= that.parentData.width ) {
			that.size.width = that.parentData.width - woset;
			if ( pRatio ) {
				that.size.height = that.size.width / that.aspectRatio;
				continueResize = false;
			}
		}

		if ( hoset + that.size.height >= that.parentData.height ) {
			that.size.height = that.parentData.height - hoset;
			if ( pRatio ) {
				that.size.width = that.size.height * that.aspectRatio;
				continueResize = false;
			}
		}

		if ( !continueResize ) {
			that.position.left = that.prevPosition.left;
			that.position.top = that.prevPosition.top;
			that.size.width = that.prevSize.width;
			that.size.height = that.prevSize.height;
		}
	},

	stop: function() {
		var that = $( this ).resizable( "instance" ),
			o = that.options,
			co = that.containerOffset,
			cop = that.containerPosition,
			ce = that.containerElement,
			helper = $( that.helper ),
			ho = helper.offset(),
			w = helper.outerWidth() - that.sizeDiff.width,
			h = helper.outerHeight() - that.sizeDiff.height;

		if ( that._helper && !o.animate && ( /relative/ ).test( ce.css( "position" ) ) ) {
			$( this ).css( {
				left: ho.left - cop.left - co.left,
				width: w,
				height: h
			} );
		}

		if ( that._helper && !o.animate && ( /static/ ).test( ce.css( "position" ) ) ) {
			$( this ).css( {
				left: ho.left - cop.left - co.left,
				width: w,
				height: h
			} );
		}
	}
} );

$.ui.plugin.add( "resizable", "alsoResize", {

	start: function() {
		var that = $( this ).resizable( "instance" ),
			o = that.options;

		$( o.alsoResize ).each( function() {
			var el = $( this );
			el.data( "ui-resizable-alsoresize", {
				width: parseFloat( el.width() ), height: parseFloat( el.height() ),
				left: parseFloat( el.css( "left" ) ), top: parseFloat( el.css( "top" ) )
			} );
		} );
	},

	resize: function( event, ui ) {
		var that = $( this ).resizable( "instance" ),
			o = that.options,
			os = that.originalSize,
			op = that.originalPosition,
			delta = {
				height: ( that.size.height - os.height ) || 0,
				width: ( that.size.width - os.width ) || 0,
				top: ( that.position.top - op.top ) || 0,
				left: ( that.position.left - op.left ) || 0
			};

			$( o.alsoResize ).each( function() {
				var el = $( this ), start = $( this ).data( "ui-resizable-alsoresize" ), style = {},
					css = el.parents( ui.originalElement[ 0 ] ).length ?
							[ "width", "height" ] :
							[ "width", "height", "top", "left" ];

				$.each( css, function( i, prop ) {
					var sum = ( start[ prop ] || 0 ) + ( delta[ prop ] || 0 );
					if ( sum && sum >= 0 ) {
						style[ prop ] = sum || null;
					}
				} );

				el.css( style );
			} );
	},

	stop: function() {
		$( this ).removeData( "ui-resizable-alsoresize" );
	}
} );

$.ui.plugin.add( "resizable", "ghost", {

	start: function() {

		var that = $( this ).resizable( "instance" ), cs = that.size;

		that.ghost = that.originalElement.clone();
		that.ghost.css( {
			opacity: 0.25,
			display: "block",
			position: "relative",
			height: cs.height,
			width: cs.width,
			margin: 0,
			left: 0,
			top: 0
		} );

		that._addClass( that.ghost, "ui-resizable-ghost" );

		// DEPRECATED
		// TODO: remove after 1.12
		if ( $.uiBackCompat !== false && typeof that.options.ghost === "string" ) {

			// Ghost option
			that.ghost.addClass( this.options.ghost );
		}

		that.ghost.appendTo( that.helper );

	},

	resize: function() {
		var that = $( this ).resizable( "instance" );
		if ( that.ghost ) {
			that.ghost.css( {
				position: "relative",
				height: that.size.height,
				width: that.size.width
			} );
		}
	},

	stop: function() {
		var that = $( this ).resizable( "instance" );
		if ( that.ghost && that.helper ) {
			that.helper.get( 0 ).removeChild( that.ghost.get( 0 ) );
		}
	}

} );

$.ui.plugin.add( "resizable", "grid", {

	resize: function() {
		var outerDimensions,
			that = $( this ).resizable( "instance" ),
			o = that.options,
			cs = that.size,
			os = that.originalSize,
			op = that.originalPosition,
			a = that.axis,
			grid = typeof o.grid === "number" ? [ o.grid, o.grid ] : o.grid,
			gridX = ( grid[ 0 ] || 1 ),
			gridY = ( grid[ 1 ] || 1 ),
			ox = Math.round( ( cs.width - os.width ) / gridX ) * gridX,
			oy = Math.round( ( cs.height - os.height ) / gridY ) * gridY,
			newWidth = os.width + ox,
			newHeight = os.height + oy,
			isMaxWidth = o.maxWidth && ( o.maxWidth < newWidth ),
			isMaxHeight = o.maxHeight && ( o.maxHeight < newHeight ),
			isMinWidth = o.minWidth && ( o.minWidth > newWidth ),
			isMinHeight = o.minHeight && ( o.minHeight > newHeight );

		o.grid = grid;

		if ( isMinWidth ) {
			newWidth += gridX;
		}
		if ( isMinHeight ) {
			newHeight += gridY;
		}
		if ( isMaxWidth ) {
			newWidth -= gridX;
		}
		if ( isMaxHeight ) {
			newHeight -= gridY;
		}

		if ( /^(se|s|e)$/.test( a ) ) {
			that.size.width = newWidth;
			that.size.height = newHeight;
		} else if ( /^(ne)$/.test( a ) ) {
			that.size.width = newWidth;
			that.size.height = newHeight;
			that.position.top = op.top - oy;
		} else if ( /^(sw)$/.test( a ) ) {
			that.size.width = newWidth;
			that.size.height = newHeight;
			that.position.left = op.left - ox;
		} else {
			if ( newHeight - gridY <= 0 || newWidth - gridX <= 0 ) {
				outerDimensions = that._getPaddingPlusBorderDimensions( this );
			}

			if ( newHeight - gridY > 0 ) {
				that.size.height = newHeight;
				that.position.top = op.top - oy;
			} else {
				newHeight = gridY - outerDimensions.height;
				that.size.height = newHeight;
				that.position.top = op.top + os.height - newHeight;
			}
			if ( newWidth - gridX > 0 ) {
				that.size.width = newWidth;
				that.position.left = op.left - ox;
			} else {
				newWidth = gridX - outerDimensions.width;
				that.size.width = newWidth;
				that.position.left = op.left + os.width - newWidth;
			}
		}
	}

} );

var widgetsResizable = $.ui.resizable;


/*!
 * jQuery UI Dialog 1.12.0
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Dialog
//>>group: Widgets
//>>description: Displays customizable dialog windows.
//>>docs: http://api.jqueryui.com/dialog/
//>>demos: http://jqueryui.com/dialog/
//>>css.structure: ../../themes/base/core.css
//>>css.structure: ../../themes/base/dialog.css
//>>css.theme: ../../themes/base/theme.css



$.widget( "ui.dialog", {
	version: "1.12.0",
	options: {
		appendTo: "body",
		autoOpen: true,
		buttons: [],
		classes: {
			"ui-dialog": "ui-corner-all",
			"ui-dialog-titlebar": "ui-corner-all"
		},
		closeOnEscape: true,
		closeText: "Close",
		draggable: true,
		hide: null,
		height: "auto",
		maxHeight: null,
		maxWidth: null,
		minHeight: 150,
		minWidth: 150,
		modal: false,
		position: {
			my: "center",
			at: "center",
			of: window,
			collision: "fit",

			// Ensure the titlebar is always visible
			using: function( pos ) {
				var topOffset = $( this ).css( pos ).offset().top;
				if ( topOffset < 0 ) {
					$( this ).css( "top", pos.top - topOffset );
				}
			}
		},
		resizable: true,
		show: null,
		title: null,
		width: 300,

		// Callbacks
		beforeClose: null,
		close: null,
		drag: null,
		dragStart: null,
		dragStop: null,
		focus: null,
		open: null,
		resize: null,
		resizeStart: null,
		resizeStop: null
	},

	sizeRelatedOptions: {
		buttons: true,
		height: true,
		maxHeight: true,
		maxWidth: true,
		minHeight: true,
		minWidth: true,
		width: true
	},

	resizableRelatedOptions: {
		maxHeight: true,
		maxWidth: true,
		minHeight: true,
		minWidth: true
	},

	_create: function() {
		this.originalCss = {
			display: this.element[ 0 ].style.display,
			width: this.element[ 0 ].style.width,
			minHeight: this.element[ 0 ].style.minHeight,
			maxHeight: this.element[ 0 ].style.maxHeight,
			height: this.element[ 0 ].style.height
		};
		this.originalPosition = {
			parent: this.element.parent(),
			index: this.element.parent().children().index( this.element )
		};
		this.originalTitle = this.element.attr( "title" );
		if ( this.options.title == null && this.originalTitle != null ) {
			this.options.title = this.originalTitle;
		}

		// Dialogs can't be disabled
		if ( this.options.disabled ) {
			this.options.disabled = false;
		}

		this._createWrapper();

		this.element
			.show()
			.removeAttr( "title" )
			.appendTo( this.uiDialog );

		this._addClass( "ui-dialog-content", "ui-widget-content" );

		this._createTitlebar();
		this._createButtonPane();

		if ( this.options.draggable && $.fn.draggable ) {
			this._makeDraggable();
		}
		if ( this.options.resizable && $.fn.resizable ) {
			this._makeResizable();
		}

		this._isOpen = false;

		this._trackFocus();
	},

	_init: function() {
		if ( this.options.autoOpen ) {
			this.open();
		}
	},

	_appendTo: function() {
		var element = this.options.appendTo;
		if ( element && ( element.jquery || element.nodeType ) ) {
			return $( element );
		}
		return this.document.find( element || "body" ).eq( 0 );
	},

	_destroy: function() {
		var next,
			originalPosition = this.originalPosition;

		this._untrackInstance();
		this._destroyOverlay();

		this.element
			.removeUniqueId()
			.css( this.originalCss )

			// Without detaching first, the following becomes really slow
			.detach();

		this.uiDialog.remove();

		if ( this.originalTitle ) {
			this.element.attr( "title", this.originalTitle );
		}

		next = originalPosition.parent.children().eq( originalPosition.index );

		// Don't try to place the dialog next to itself (#8613)
		if ( next.length && next[ 0 ] !== this.element[ 0 ] ) {
			next.before( this.element );
		} else {
			originalPosition.parent.append( this.element );
		}
	},

	widget: function() {
		return this.uiDialog;
	},

	disable: $.noop,
	enable: $.noop,

	close: function( event ) {
		var that = this;

		if ( !this._isOpen || this._trigger( "beforeClose", event ) === false ) {
			return;
		}

		this._isOpen = false;
		this._focusedElement = null;
		this._destroyOverlay();
		this._untrackInstance();

		if ( !this.opener.filter( ":focusable" ).trigger( "focus" ).length ) {

			// Hiding a focused element doesn't trigger blur in WebKit
			// so in case we have nothing to focus on, explicitly blur the active element
			// https://bugs.webkit.org/show_bug.cgi?id=47182
			$.ui.safeBlur( $.ui.safeActiveElement( this.document[ 0 ] ) );
		}

		this._hide( this.uiDialog, this.options.hide, function() {
			that._trigger( "close", event );
		} );
	},

	isOpen: function() {
		return this._isOpen;
	},

	moveToTop: function() {
		this._moveToTop();
	},

	_moveToTop: function( event, silent ) {
		var moved = false,
			zIndices = this.uiDialog.siblings( ".ui-front:visible" ).map( function() {
				return +$( this ).css( "z-index" );
			} ).get(),
			zIndexMax = Math.max.apply( null, zIndices );

		if ( zIndexMax >= +this.uiDialog.css( "z-index" ) ) {
			this.uiDialog.css( "z-index", zIndexMax + 1 );
			moved = true;
		}

		if ( moved && !silent ) {
			this._trigger( "focus", event );
		}
		return moved;
	},

	open: function() {
		var that = this;
		if ( this._isOpen ) {
			if ( this._moveToTop() ) {
				this._focusTabbable();
			}
			return;
		}

		this._isOpen = true;
		this.opener = $( $.ui.safeActiveElement( this.document[ 0 ] ) );

		this._size();
		this._position();
		this._createOverlay();
		this._moveToTop( null, true );

		// Ensure the overlay is moved to the top with the dialog, but only when
		// opening. The overlay shouldn't move after the dialog is open so that
		// modeless dialogs opened after the modal dialog stack properly.
		if ( this.overlay ) {
			this.overlay.css( "z-index", this.uiDialog.css( "z-index" ) - 1 );
		}

		this._show( this.uiDialog, this.options.show, function() {
			that._focusTabbable();
			that._trigger( "focus" );
		} );

		// Track the dialog immediately upon openening in case a focus event
		// somehow occurs outside of the dialog before an element inside the
		// dialog is focused (#10152)
		this._makeFocusTarget();

		this._trigger( "open" );
	},

	_focusTabbable: function() {

		// Set focus to the first match:
		// 1. An element that was focused previously
		// 2. First element inside the dialog matching [autofocus]
		// 3. Tabbable element inside the content element
		// 4. Tabbable element inside the buttonpane
		// 5. The close button
		// 6. The dialog itself
		var hasFocus = this._focusedElement;
		if ( !hasFocus ) {
			hasFocus = this.element.find( "[autofocus]" );
		}
		if ( !hasFocus.length ) {
			hasFocus = this.element.find( ":tabbable" );
		}
		if ( !hasFocus.length ) {
			hasFocus = this.uiDialogButtonPane.find( ":tabbable" );
		}
		if ( !hasFocus.length ) {
			hasFocus = this.uiDialogTitlebarClose.filter( ":tabbable" );
		}
		if ( !hasFocus.length ) {
			hasFocus = this.uiDialog;
		}
		hasFocus.eq( 0 ).trigger( "focus" );
	},

	_keepFocus: function( event ) {
		function checkFocus() {
			var activeElement = $.ui.safeActiveElement( this.document[ 0 ] ),
				isActive = this.uiDialog[ 0 ] === activeElement ||
					$.contains( this.uiDialog[ 0 ], activeElement );
			if ( !isActive ) {
				this._focusTabbable();
			}
		}
		event.preventDefault();
		checkFocus.call( this );

		// support: IE
		// IE <= 8 doesn't prevent moving focus even with event.preventDefault()
		// so we check again later
		this._delay( checkFocus );
	},

	_createWrapper: function() {
		this.uiDialog = $( "<div>" )
			.hide()
			.attr( {

				// Setting tabIndex makes the div focusable
				tabIndex: -1,
				role: "dialog"
			} )
			.appendTo( this._appendTo() );

		this._addClass( this.uiDialog, "ui-dialog", "ui-widget ui-widget-content ui-front" );
		this._on( this.uiDialog, {
			keydown: function( event ) {
				if ( this.options.closeOnEscape && !event.isDefaultPrevented() && event.keyCode &&
						event.keyCode === $.ui.keyCode.ESCAPE ) {
					event.preventDefault();
					this.close( event );
					return;
				}

				// Prevent tabbing out of dialogs
				if ( event.keyCode !== $.ui.keyCode.TAB || event.isDefaultPrevented() ) {
					return;
				}
				var tabbables = this.uiDialog.find( ":tabbable" ),
					first = tabbables.filter( ":first" ),
					last = tabbables.filter( ":last" );

				if ( ( event.target === last[ 0 ] || event.target === this.uiDialog[ 0 ] ) &&
						!event.shiftKey ) {
					this._delay( function() {
						first.trigger( "focus" );
					} );
					event.preventDefault();
				} else if ( ( event.target === first[ 0 ] ||
						event.target === this.uiDialog[ 0 ] ) && event.shiftKey ) {
					this._delay( function() {
						last.trigger( "focus" );
					} );
					event.preventDefault();
				}
			},
			mousedown: function( event ) {
				if ( this._moveToTop( event ) ) {
					this._focusTabbable();
				}
			}
		} );

		// We assume that any existing aria-describedby attribute means
		// that the dialog content is marked up properly
		// otherwise we brute force the content as the description
		if ( !this.element.find( "[aria-describedby]" ).length ) {
			this.uiDialog.attr( {
				"aria-describedby": this.element.uniqueId().attr( "id" )
			} );
		}
	},

	_createTitlebar: function() {
		var uiDialogTitle;

		this.uiDialogTitlebar = $( "<div>" );
		this._addClass( this.uiDialogTitlebar,
			"ui-dialog-titlebar", "ui-widget-header ui-helper-clearfix" );
		this._on( this.uiDialogTitlebar, {
			mousedown: function( event ) {

				// Don't prevent click on close button (#8838)
				// Focusing a dialog that is partially scrolled out of view
				// causes the browser to scroll it into view, preventing the click event
				if ( !$( event.target ).closest( ".ui-dialog-titlebar-close" ) ) {

					// Dialog isn't getting focus when dragging (#8063)
					this.uiDialog.trigger( "focus" );
				}
			}
		} );

		// Support: IE
		// Use type="button" to prevent enter keypresses in textboxes from closing the
		// dialog in IE (#9312)
		this.uiDialogTitlebarClose = $( "<button type='button'></button>" )
			.button( {
				label: $( "<a>" ).text( this.options.closeText ).html(),
				icon: "ui-icon-closethick",
				showLabel: false
			} )
			.appendTo( this.uiDialogTitlebar );

		this._addClass( this.uiDialogTitlebarClose, "ui-dialog-titlebar-close" );
		this._on( this.uiDialogTitlebarClose, {
			click: function( event ) {
				event.preventDefault();
				this.close( event );
			}
		} );

		uiDialogTitle = $( "<span>" ).uniqueId().prependTo( this.uiDialogTitlebar );
		this._addClass( uiDialogTitle, "ui-dialog-title" );
		this._title( uiDialogTitle );

		this.uiDialogTitlebar.prependTo( this.uiDialog );

		this.uiDialog.attr( {
			"aria-labelledby": uiDialogTitle.attr( "id" )
		} );
	},

	_title: function( title ) {
		if ( this.options.title ) {
			title.text( this.options.title );
		} else {
			title.html( "&#160;" );
		}
	},

	_createButtonPane: function() {
		this.uiDialogButtonPane = $( "<div>" );
		this._addClass( this.uiDialogButtonPane, "ui-dialog-buttonpane",
			"ui-widget-content ui-helper-clearfix" );

		this.uiButtonSet = $( "<div>" )
			.appendTo( this.uiDialogButtonPane );
		this._addClass( this.uiButtonSet, "ui-dialog-buttonset" );

		this._createButtons();
	},

	_createButtons: function() {
		var that = this,
			buttons = this.options.buttons;

		// If we already have a button pane, remove it
		this.uiDialogButtonPane.remove();
		this.uiButtonSet.empty();

		if ( $.isEmptyObject( buttons ) || ( $.isArray( buttons ) && !buttons.length ) ) {
			this._removeClass( this.uiDialog, "ui-dialog-buttons" );
			return;
		}

		$.each( buttons, function( name, props ) {
			var click, buttonOptions;
			props = $.isFunction( props ) ?
				{ click: props, text: name } :
				props;

			// Default to a non-submitting button
			props = $.extend( { type: "button" }, props );

			// Change the context for the click callback to be the main element
			click = props.click;
			buttonOptions = {
				icon: props.icon,
				iconPosition: props.iconPosition,
				showLabel: props.showLabel
			};

			delete props.click;
			delete props.icon;
			delete props.iconPosition;
			delete props.showLabel;

			$( "<button></button>", props )
				.button( buttonOptions )
				.appendTo( that.uiButtonSet )
				.on( "click", function() {
					click.apply( that.element[ 0 ], arguments );
				} );
		} );
		this._addClass( this.uiDialog, "ui-dialog-buttons" );
		this.uiDialogButtonPane.appendTo( this.uiDialog );
	},

	_makeDraggable: function() {
		var that = this,
			options = this.options;

		function filteredUi( ui ) {
			return {
				position: ui.position,
				offset: ui.offset
			};
		}

		this.uiDialog.draggable( {
			cancel: ".ui-dialog-content, .ui-dialog-titlebar-close",
			handle: ".ui-dialog-titlebar",
			containment: "document",
			start: function( event, ui ) {
				that._addClass( $( this ), "ui-dialog-dragging" );
				that._blockFrames();
				that._trigger( "dragStart", event, filteredUi( ui ) );
			},
			drag: function( event, ui ) {
				that._trigger( "drag", event, filteredUi( ui ) );
			},
			stop: function( event, ui ) {
				var left = ui.offset.left - that.document.scrollLeft(),
					top = ui.offset.top - that.document.scrollTop();

				options.position = {
					my: "left top",
					at: "left" + ( left >= 0 ? "+" : "" ) + left + " " +
						"top" + ( top >= 0 ? "+" : "" ) + top,
					of: that.window
				};
				that._removeClass( $( this ), "ui-dialog-dragging" );
				that._unblockFrames();
				that._trigger( "dragStop", event, filteredUi( ui ) );
			}
		} );
	},

	_makeResizable: function() {
		var that = this,
			options = this.options,
			handles = options.resizable,

			// .ui-resizable has position: relative defined in the stylesheet
			// but dialogs have to use absolute or fixed positioning
			position = this.uiDialog.css( "position" ),
			resizeHandles = typeof handles === "string" ?
				handles :
				"n,e,s,w,se,sw,ne,nw";

		function filteredUi( ui ) {
			return {
				originalPosition: ui.originalPosition,
				originalSize: ui.originalSize,
				position: ui.position,
				size: ui.size
			};
		}

		this.uiDialog.resizable( {
			cancel: ".ui-dialog-content",
			containment: "document",
			alsoResize: this.element,
			maxWidth: options.maxWidth,
			maxHeight: options.maxHeight,
			minWidth: options.minWidth,
			minHeight: this._minHeight(),
			handles: resizeHandles,
			start: function( event, ui ) {
				that._addClass( $( this ), "ui-dialog-resizing" );
				that._blockFrames();
				that._trigger( "resizeStart", event, filteredUi( ui ) );
			},
			resize: function( event, ui ) {
				that._trigger( "resize", event, filteredUi( ui ) );
			},
			stop: function( event, ui ) {
				var offset = that.uiDialog.offset(),
					left = offset.left - that.document.scrollLeft(),
					top = offset.top - that.document.scrollTop();

				options.height = that.uiDialog.height();
				options.width = that.uiDialog.width();
				options.position = {
					my: "left top",
					at: "left" + ( left >= 0 ? "+" : "" ) + left + " " +
						"top" + ( top >= 0 ? "+" : "" ) + top,
					of: that.window
				};
				that._removeClass( $( this ), "ui-dialog-resizing" );
				that._unblockFrames();
				that._trigger( "resizeStop", event, filteredUi( ui ) );
			}
		} )
			.css( "position", position );
	},

	_trackFocus: function() {
		this._on( this.widget(), {
			focusin: function( event ) {
				this._makeFocusTarget();
				this._focusedElement = $( event.target );
			}
		} );
	},

	_makeFocusTarget: function() {
		this._untrackInstance();
		this._trackingInstances().unshift( this );
	},

	_untrackInstance: function() {
		var instances = this._trackingInstances(),
			exists = $.inArray( this, instances );
		if ( exists !== -1 ) {
			instances.splice( exists, 1 );
		}
	},

	_trackingInstances: function() {
		var instances = this.document.data( "ui-dialog-instances" );
		if ( !instances ) {
			instances = [];
			this.document.data( "ui-dialog-instances", instances );
		}
		return instances;
	},

	_minHeight: function() {
		var options = this.options;

		return options.height === "auto" ?
			options.minHeight :
			Math.min( options.minHeight, options.height );
	},

	_position: function() {

		// Need to show the dialog to get the actual offset in the position plugin
		var isVisible = this.uiDialog.is( ":visible" );
		if ( !isVisible ) {
			this.uiDialog.show();
		}
		this.uiDialog.position( this.options.position );
		if ( !isVisible ) {
			this.uiDialog.hide();
		}
	},

	_setOptions: function( options ) {
		var that = this,
			resize = false,
			resizableOptions = {};

		$.each( options, function( key, value ) {
			that._setOption( key, value );

			if ( key in that.sizeRelatedOptions ) {
				resize = true;
			}
			if ( key in that.resizableRelatedOptions ) {
				resizableOptions[ key ] = value;
			}
		} );

		if ( resize ) {
			this._size();
			this._position();
		}
		if ( this.uiDialog.is( ":data(ui-resizable)" ) ) {
			this.uiDialog.resizable( "option", resizableOptions );
		}
	},

	_setOption: function( key, value ) {
		var isDraggable, isResizable,
			uiDialog = this.uiDialog;

		if ( key === "disabled" ) {
			return;
		}

		this._super( key, value );

		if ( key === "appendTo" ) {
			this.uiDialog.appendTo( this._appendTo() );
		}

		if ( key === "buttons" ) {
			this._createButtons();
		}

		if ( key === "closeText" ) {
			this.uiDialogTitlebarClose.button( {

				// Ensure that we always pass a string
				label: $( "<a>" ).text( "" + this.options.closeText ).html()
			} );
		}

		if ( key === "draggable" ) {
			isDraggable = uiDialog.is( ":data(ui-draggable)" );
			if ( isDraggable && !value ) {
				uiDialog.draggable( "destroy" );
			}

			if ( !isDraggable && value ) {
				this._makeDraggable();
			}
		}

		if ( key === "position" ) {
			this._position();
		}

		if ( key === "resizable" ) {

			// currently resizable, becoming non-resizable
			isResizable = uiDialog.is( ":data(ui-resizable)" );
			if ( isResizable && !value ) {
				uiDialog.resizable( "destroy" );
			}

			// Currently resizable, changing handles
			if ( isResizable && typeof value === "string" ) {
				uiDialog.resizable( "option", "handles", value );
			}

			// Currently non-resizable, becoming resizable
			if ( !isResizable && value !== false ) {
				this._makeResizable();
			}
		}

		if ( key === "title" ) {
			this._title( this.uiDialogTitlebar.find( ".ui-dialog-title" ) );
		}
	},

	_size: function() {

		// If the user has resized the dialog, the .ui-dialog and .ui-dialog-content
		// divs will both have width and height set, so we need to reset them
		var nonContentHeight, minContentHeight, maxContentHeight,
			options = this.options;

		// Reset content sizing
		this.element.show().css( {
			width: "auto",
			minHeight: 0,
			maxHeight: "none",
			height: 0
		} );

		if ( options.minWidth > options.width ) {
			options.width = options.minWidth;
		}

		// Reset wrapper sizing
		// determine the height of all the non-content elements
		nonContentHeight = this.uiDialog.css( {
			height: "auto",
			width: options.width
		} )
			.outerHeight();
		minContentHeight = Math.max( 0, options.minHeight - nonContentHeight );
		maxContentHeight = typeof options.maxHeight === "number" ?
			Math.max( 0, options.maxHeight - nonContentHeight ) :
			"none";

		if ( options.height === "auto" ) {
			this.element.css( {
				minHeight: minContentHeight,
				maxHeight: maxContentHeight,
				height: "auto"
			} );
		} else {
			this.element.height( Math.max( 0, options.height - nonContentHeight ) );
		}

		if ( this.uiDialog.is( ":data(ui-resizable)" ) ) {
			this.uiDialog.resizable( "option", "minHeight", this._minHeight() );
		}
	},

	_blockFrames: function() {
		this.iframeBlocks = this.document.find( "iframe" ).map( function() {
			var iframe = $( this );

			return $( "<div>" )
				.css( {
					position: "absolute",
					width: iframe.outerWidth(),
					height: iframe.outerHeight()
				} )
				.appendTo( iframe.parent() )
				.offset( iframe.offset() )[ 0 ];
		} );
	},

	_unblockFrames: function() {
		if ( this.iframeBlocks ) {
			this.iframeBlocks.remove();
			delete this.iframeBlocks;
		}
	},

	_allowInteraction: function( event ) {
		if ( $( event.target ).closest( ".ui-dialog" ).length ) {
			return true;
		}

		// TODO: Remove hack when datepicker implements
		// the .ui-front logic (#8989)
		return !!$( event.target ).closest( ".ui-datepicker" ).length;
	},

	_createOverlay: function() {
		if ( !this.options.modal ) {
			return;
		}

		// We use a delay in case the overlay is created from an
		// event that we're going to be cancelling (#2804)
		var isOpening = true;
		this._delay( function() {
			isOpening = false;
		} );

		if ( !this.document.data( "ui-dialog-overlays" ) ) {

			// Prevent use of anchors and inputs
			// Using _on() for an event handler shared across many instances is
			// safe because the dialogs stack and must be closed in reverse order
			this._on( this.document, {
				focusin: function( event ) {
					if ( isOpening ) {
						return;
					}

					if ( !this._allowInteraction( event ) ) {
						event.preventDefault();
						this._trackingInstances()[ 0 ]._focusTabbable();
					}
				}
			} );
		}

		this.overlay = $( "<div>" )
			.appendTo( this._appendTo() );

		this._addClass( this.overlay, null, "ui-widget-overlay ui-front" );
		this._on( this.overlay, {
			mousedown: "_keepFocus"
		} );
		this.document.data( "ui-dialog-overlays",
			( this.document.data( "ui-dialog-overlays" ) || 0 ) + 1 );
	},

	_destroyOverlay: function() {
		if ( !this.options.modal ) {
			return;
		}

		if ( this.overlay ) {
			var overlays = this.document.data( "ui-dialog-overlays" ) - 1;

			if ( !overlays ) {
				this._off( this.document, "focusin" );
				this.document.removeData( "ui-dialog-overlays" );
			} else {
				this.document.data( "ui-dialog-overlays", overlays );
			}

			this.overlay.remove();
			this.overlay = null;
		}
	}
} );

// DEPRECATED
// TODO: switch return back to widget declaration at top of file when this is removed
if ( $.uiBackCompat !== false ) {

	// Backcompat for dialogClass option
	$.widget( "ui.dialog", $.ui.dialog, {
		options: {
			dialogClass: ""
		},
		_createWrapper: function() {
			this._super();
			this.uiDialog.addClass( this.options.dialogClass );
		},
		_setOption: function( key, value ) {
			if ( key === "dialogClass" ) {
				this.uiDialog
					.removeClass( this.options.dialogClass )
					.addClass( value );
			}
			this._superApply( arguments );
		}
	} );
}

var widgetsDialog = $.ui.dialog;


/*!
 * jQuery UI Droppable 1.12.0
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Droppable
//>>group: Interactions
//>>description: Enables drop targets for draggable elements.
//>>docs: http://api.jqueryui.com/droppable/
//>>demos: http://jqueryui.com/droppable/



$.widget( "ui.droppable", {
	version: "1.12.0",
	widgetEventPrefix: "drop",
	options: {
		accept: "*",
		addClasses: true,
		greedy: false,
		scope: "default",
		tolerance: "intersect",

		// Callbacks
		activate: null,
		deactivate: null,
		drop: null,
		out: null,
		over: null
	},
	_create: function() {

		var proportions,
			o = this.options,
			accept = o.accept;

		this.isover = false;
		this.isout = true;

		this.accept = $.isFunction( accept ) ? accept : function( d ) {
			return d.is( accept );
		};

		this.proportions = function( /* valueToWrite */ ) {
			if ( arguments.length ) {

				// Store the droppable's proportions
				proportions = arguments[ 0 ];
			} else {

				// Retrieve or derive the droppable's proportions
				return proportions ?
					proportions :
					proportions = {
						width: this.element[ 0 ].offsetWidth,
						height: this.element[ 0 ].offsetHeight
					};
			}
		};

		this._addToManager( o.scope );

		o.addClasses && this._addClass( "ui-droppable" );

	},

	_addToManager: function( scope ) {

		// Add the reference and positions to the manager
		$.ui.ddmanager.droppables[ scope ] = $.ui.ddmanager.droppables[ scope ] || [];
		$.ui.ddmanager.droppables[ scope ].push( this );
	},

	_splice: function( drop ) {
		var i = 0;
		for ( ; i < drop.length; i++ ) {
			if ( drop[ i ] === this ) {
				drop.splice( i, 1 );
			}
		}
	},

	_destroy: function() {
		var drop = $.ui.ddmanager.droppables[ this.options.scope ];

		this._splice( drop );
	},

	_setOption: function( key, value ) {

		if ( key === "accept" ) {
			this.accept = $.isFunction( value ) ? value : function( d ) {
				return d.is( value );
			};
		} else if ( key === "scope" ) {
			var drop = $.ui.ddmanager.droppables[ this.options.scope ];

			this._splice( drop );
			this._addToManager( value );
		}

		this._super( key, value );
	},

	_activate: function( event ) {
		var draggable = $.ui.ddmanager.current;

		this._addActiveClass();
		if ( draggable ) {
			this._trigger( "activate", event, this.ui( draggable ) );
		}
	},

	_deactivate: function( event ) {
		var draggable = $.ui.ddmanager.current;

		this._removeActiveClass();
		if ( draggable ) {
			this._trigger( "deactivate", event, this.ui( draggable ) );
		}
	},

	_over: function( event ) {

		var draggable = $.ui.ddmanager.current;

		// Bail if draggable and droppable are same element
		if ( !draggable || ( draggable.currentItem ||
				draggable.element )[ 0 ] === this.element[ 0 ] ) {
			return;
		}

		if ( this.accept.call( this.element[ 0 ], ( draggable.currentItem ||
				draggable.element ) ) ) {
			this._addHoverClass();
			this._trigger( "over", event, this.ui( draggable ) );
		}

	},

	_out: function( event ) {

		var draggable = $.ui.ddmanager.current;

		// Bail if draggable and droppable are same element
		if ( !draggable || ( draggable.currentItem ||
				draggable.element )[ 0 ] === this.element[ 0 ] ) {
			return;
		}

		if ( this.accept.call( this.element[ 0 ], ( draggable.currentItem ||
				draggable.element ) ) ) {
			this._removeHoverClass();
			this._trigger( "out", event, this.ui( draggable ) );
		}

	},

	_drop: function( event, custom ) {

		var draggable = custom || $.ui.ddmanager.current,
			childrenIntersection = false;

		// Bail if draggable and droppable are same element
		if ( !draggable || ( draggable.currentItem ||
				draggable.element )[ 0 ] === this.element[ 0 ] ) {
			return false;
		}

		this.element
			.find( ":data(ui-droppable)" )
			.not( ".ui-draggable-dragging" )
			.each( function() {
				var inst = $( this ).droppable( "instance" );
				if (
					inst.options.greedy &&
					!inst.options.disabled &&
					inst.options.scope === draggable.options.scope &&
					inst.accept.call(
						inst.element[ 0 ], ( draggable.currentItem || draggable.element )
					) &&
					intersect(
						draggable,
						$.extend( inst, { offset: inst.element.offset() } ),
						inst.options.tolerance, event
					)
				) {
					childrenIntersection = true;
					return false; }
			} );
		if ( childrenIntersection ) {
			return false;
		}

		if ( this.accept.call( this.element[ 0 ],
				( draggable.currentItem || draggable.element ) ) ) {
			this._removeActiveClass();
			this._removeHoverClass();

			this._trigger( "drop", event, this.ui( draggable ) );
			return this.element;
		}

		return false;

	},

	ui: function( c ) {
		return {
			draggable: ( c.currentItem || c.element ),
			helper: c.helper,
			position: c.position,
			offset: c.positionAbs
		};
	},

	// Extension points just to make backcompat sane and avoid duplicating logic
	// TODO: Remove in 1.13 along with call to it below
	_addHoverClass: function() {
		this._addClass( "ui-droppable-hover" );
	},

	_removeHoverClass: function() {
		this._removeClass( "ui-droppable-hover" );
	},

	_addActiveClass: function() {
		this._addClass( "ui-droppable-active" );
	},

	_removeActiveClass: function() {
		this._removeClass( "ui-droppable-active" );
	}
} );

var intersect = $.ui.intersect = ( function() {
	function isOverAxis( x, reference, size ) {
		return ( x >= reference ) && ( x < ( reference + size ) );
	}

	return function( draggable, droppable, toleranceMode, event ) {

		if ( !droppable.offset ) {
			return false;
		}

		var x1 = ( draggable.positionAbs ||
				draggable.position.absolute ).left + draggable.margins.left,
			y1 = ( draggable.positionAbs ||
				draggable.position.absolute ).top + draggable.margins.top,
			x2 = x1 + draggable.helperProportions.width,
			y2 = y1 + draggable.helperProportions.height,
			l = droppable.offset.left,
			t = droppable.offset.top,
			r = l + droppable.proportions().width,
			b = t + droppable.proportions().height;

		switch ( toleranceMode ) {
		case "fit":
			return ( l <= x1 && x2 <= r && t <= y1 && y2 <= b );
		case "intersect":
			return ( l < x1 + ( draggable.helperProportions.width / 2 ) && // Right Half
				x2 - ( draggable.helperProportions.width / 2 ) < r && // Left Half
				t < y1 + ( draggable.helperProportions.height / 2 ) && // Bottom Half
				y2 - ( draggable.helperProportions.height / 2 ) < b ); // Top Half
		case "pointer":
			return isOverAxis( event.pageY, t, droppable.proportions().height ) &&
				isOverAxis( event.pageX, l, droppable.proportions().width );
		case "touch":
			return (
				( y1 >= t && y1 <= b ) || // Top edge touching
				( y2 >= t && y2 <= b ) || // Bottom edge touching
				( y1 < t && y2 > b ) // Surrounded vertically
			) && (
				( x1 >= l && x1 <= r ) || // Left edge touching
				( x2 >= l && x2 <= r ) || // Right edge touching
				( x1 < l && x2 > r ) // Surrounded horizontally
			);
		default:
			return false;
		}
	};
} )();

/*
	This manager tracks offsets of draggables and droppables
*/
$.ui.ddmanager = {
	current: null,
	droppables: { "default": [] },
	prepareOffsets: function( t, event ) {

		var i, j,
			m = $.ui.ddmanager.droppables[ t.options.scope ] || [],
			type = event ? event.type : null, // workaround for #2317
			list = ( t.currentItem || t.element ).find( ":data(ui-droppable)" ).addBack();

		droppablesLoop: for ( i = 0; i < m.length; i++ ) {

			// No disabled and non-accepted
			if ( m[ i ].options.disabled || ( t && !m[ i ].accept.call( m[ i ].element[ 0 ],
					( t.currentItem || t.element ) ) ) ) {
				continue;
			}

			// Filter out elements in the current dragged item
			for ( j = 0; j < list.length; j++ ) {
				if ( list[ j ] === m[ i ].element[ 0 ] ) {
					m[ i ].proportions().height = 0;
					continue droppablesLoop;
				}
			}

			m[ i ].visible = m[ i ].element.css( "display" ) !== "none";
			if ( !m[ i ].visible ) {
				continue;
			}

			// Activate the droppable if used directly from draggables
			if ( type === "mousedown" ) {
				m[ i ]._activate.call( m[ i ], event );
			}

			m[ i ].offset = m[ i ].element.offset();
			m[ i ].proportions( {
				width: m[ i ].element[ 0 ].offsetWidth,
				height: m[ i ].element[ 0 ].offsetHeight
			} );

		}

	},
	drop: function( draggable, event ) {

		var dropped = false;

		// Create a copy of the droppables in case the list changes during the drop (#9116)
		$.each( ( $.ui.ddmanager.droppables[ draggable.options.scope ] || [] ).slice(), function() {

			if ( !this.options ) {
				return;
			}
			if ( !this.options.disabled && this.visible &&
					intersect( draggable, this, this.options.tolerance, event ) ) {
				dropped = this._drop.call( this, event ) || dropped;
			}

			if ( !this.options.disabled && this.visible && this.accept.call( this.element[ 0 ],
					( draggable.currentItem || draggable.element ) ) ) {
				this.isout = true;
				this.isover = false;
				this._deactivate.call( this, event );
			}

		} );
		return dropped;

	},
	dragStart: function( draggable, event ) {

		// Listen for scrolling so that if the dragging causes scrolling the position of the
		// droppables can be recalculated (see #5003)
		draggable.element.parentsUntil( "body" ).on( "scroll.droppable", function() {
			if ( !draggable.options.refreshPositions ) {
				$.ui.ddmanager.prepareOffsets( draggable, event );
			}
		} );
	},
	drag: function( draggable, event ) {

		// If you have a highly dynamic page, you might try this option. It renders positions
		// every time you move the mouse.
		if ( draggable.options.refreshPositions ) {
			$.ui.ddmanager.prepareOffsets( draggable, event );
		}

		// Run through all droppables and check their positions based on specific tolerance options
		$.each( $.ui.ddmanager.droppables[ draggable.options.scope ] || [], function() {

			if ( this.options.disabled || this.greedyChild || !this.visible ) {
				return;
			}

			var parentInstance, scope, parent,
				intersects = intersect( draggable, this, this.options.tolerance, event ),
				c = !intersects && this.isover ?
					"isout" :
					( intersects && !this.isover ? "isover" : null );
			if ( !c ) {
				return;
			}

			if ( this.options.greedy ) {

				// find droppable parents with same scope
				scope = this.options.scope;
				parent = this.element.parents( ":data(ui-droppable)" ).filter( function() {
					return $( this ).droppable( "instance" ).options.scope === scope;
				} );

				if ( parent.length ) {
					parentInstance = $( parent[ 0 ] ).droppable( "instance" );
					parentInstance.greedyChild = ( c === "isover" );
				}
			}

			// We just moved into a greedy child
			if ( parentInstance && c === "isover" ) {
				parentInstance.isover = false;
				parentInstance.isout = true;
				parentInstance._out.call( parentInstance, event );
			}

			this[ c ] = true;
			this[ c === "isout" ? "isover" : "isout" ] = false;
			this[ c === "isover" ? "_over" : "_out" ].call( this, event );

			// We just moved out of a greedy child
			if ( parentInstance && c === "isout" ) {
				parentInstance.isout = false;
				parentInstance.isover = true;
				parentInstance._over.call( parentInstance, event );
			}
		} );

	},
	dragStop: function( draggable, event ) {
		draggable.element.parentsUntil( "body" ).off( "scroll.droppable" );

		// Call prepareOffsets one final time since IE does not fire return scroll events when
		// overflow was caused by drag (see #5003)
		if ( !draggable.options.refreshPositions ) {
			$.ui.ddmanager.prepareOffsets( draggable, event );
		}
	}
};

// DEPRECATED
// TODO: switch return back to widget declaration at top of file when this is removed
if ( $.uiBackCompat !== false ) {

	// Backcompat for activeClass and hoverClass options
	$.widget( "ui.droppable", $.ui.droppable, {
		options: {
			hoverClass: false,
			activeClass: false
		},
		_addActiveClass: function() {
			this._super();
			if ( this.options.activeClass ) {
				this.element.addClass( this.options.activeClass );
			}
		},
		_removeActiveClass: function() {
			this._super();
			if ( this.options.activeClass ) {
				this.element.removeClass( this.options.activeClass );
			}
		},
		_addHoverClass: function() {
			this._super();
			if ( this.options.hoverClass ) {
				this.element.addClass( this.options.hoverClass );
			}
		},
		_removeHoverClass: function() {
			this._super();
			if ( this.options.hoverClass ) {
				this.element.removeClass( this.options.hoverClass );
			}
		}
	} );
}

var widgetsDroppable = $.ui.droppable;


/*!
 * jQuery UI Progressbar 1.12.0
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Progressbar
//>>group: Widgets
// jscs:disable maximumLineLength
//>>description: Displays a status indicator for loading state, standard percentage, and other progress indicators.
// jscs:enable maximumLineLength
//>>docs: http://api.jqueryui.com/progressbar/
//>>demos: http://jqueryui.com/progressbar/
//>>css.structure: ../../themes/base/core.css
//>>css.structure: ../../themes/base/progressbar.css
//>>css.theme: ../../themes/base/theme.css



var widgetsProgressbar = $.widget( "ui.progressbar", {
	version: "1.12.0",
	options: {
		classes: {
			"ui-progressbar": "ui-corner-all",
			"ui-progressbar-value": "ui-corner-left",
			"ui-progressbar-complete": "ui-corner-right"
		},
		max: 100,
		value: 0,

		change: null,
		complete: null
	},

	min: 0,

	_create: function() {

		// Constrain initial value
		this.oldValue = this.options.value = this._constrainedValue();

		this.element.attr( {

			// Only set static values; aria-valuenow and aria-valuemax are
			// set inside _refreshValue()
			role: "progressbar",
			"aria-valuemin": this.min
		} );
		this._addClass( "ui-progressbar", "ui-widget ui-widget-content" );

		this.valueDiv = $( "<div>" ).appendTo( this.element );
		this._addClass( this.valueDiv, "ui-progressbar-value", "ui-widget-header" );
		this._refreshValue();
	},

	_destroy: function() {
		this.element.removeAttr( "role aria-valuemin aria-valuemax aria-valuenow" );

		this.valueDiv.remove();
	},

	value: function( newValue ) {
		if ( newValue === undefined ) {
			return this.options.value;
		}

		this.options.value = this._constrainedValue( newValue );
		this._refreshValue();
	},

	_constrainedValue: function( newValue ) {
		if ( newValue === undefined ) {
			newValue = this.options.value;
		}

		this.indeterminate = newValue === false;

		// Sanitize value
		if ( typeof newValue !== "number" ) {
			newValue = 0;
		}

		return this.indeterminate ? false :
			Math.min( this.options.max, Math.max( this.min, newValue ) );
	},

	_setOptions: function( options ) {

		// Ensure "value" option is set after other values (like max)
		var value = options.value;
		delete options.value;

		this._super( options );

		this.options.value = this._constrainedValue( value );
		this._refreshValue();
	},

	_setOption: function( key, value ) {
		if ( key === "max" ) {

			// Don't allow a max less than min
			value = Math.max( this.min, value );
		}
		this._super( key, value );
	},

	_setOptionDisabled: function( value ) {
		this._super( value );

		this.element.attr( "aria-disabled", value );
		this._toggleClass( null, "ui-state-disabled", !!value );
	},

	_percentage: function() {
		return this.indeterminate ?
			100 :
			100 * ( this.options.value - this.min ) / ( this.options.max - this.min );
	},

	_refreshValue: function() {
		var value = this.options.value,
			percentage = this._percentage();

		this.valueDiv
			.toggle( this.indeterminate || value > this.min )
			.width( percentage.toFixed( 0 ) + "%" );

		this
			._toggleClass( this.valueDiv, "ui-progressbar-complete", null,
				value === this.options.max )
			._toggleClass( "ui-progressbar-indeterminate", null, this.indeterminate );

		if ( this.indeterminate ) {
			this.element.removeAttr( "aria-valuenow" );
			if ( !this.overlayDiv ) {
				this.overlayDiv = $( "<div>" ).appendTo( this.valueDiv );
				this._addClass( this.overlayDiv, "ui-progressbar-overlay" );
			}
		} else {
			this.element.attr( {
				"aria-valuemax": this.options.max,
				"aria-valuenow": value
			} );
			if ( this.overlayDiv ) {
				this.overlayDiv.remove();
				this.overlayDiv = null;
			}
		}

		if ( this.oldValue !== value ) {
			this.oldValue = value;
			this._trigger( "change" );
		}
		if ( value === this.options.max ) {
			this._trigger( "complete" );
		}
	}
} );


/*!
 * jQuery UI Selectable 1.12.0
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Selectable
//>>group: Interactions
//>>description: Allows groups of elements to be selected with the mouse.
//>>docs: http://api.jqueryui.com/selectable/
//>>demos: http://jqueryui.com/selectable/
//>>css.structure: ../../themes/base/selectable.css



var widgetsSelectable = $.widget( "ui.selectable", $.ui.mouse, {
	version: "1.12.0",
	options: {
		appendTo: "body",
		autoRefresh: true,
		distance: 0,
		filter: "*",
		tolerance: "touch",

		// Callbacks
		selected: null,
		selecting: null,
		start: null,
		stop: null,
		unselected: null,
		unselecting: null
	},
	_create: function() {
		var that = this;

		this._addClass( "ui-selectable" );

		this.dragged = false;

		// Cache selectee children based on filter
		this.refresh = function() {
			that.elementPos = $( that.element[ 0 ] ).offset();
			that.selectees = $( that.options.filter, that.element[ 0 ] );
			that._addClass( that.selectees, "ui-selectee" );
			that.selectees.each( function() {
				var $this = $( this ),
					selecteeOffset = $this.offset(),
					pos = {
						left: selecteeOffset.left - that.elementPos.left,
						top: selecteeOffset.top - that.elementPos.top
					};
				$.data( this, "selectable-item", {
					element: this,
					$element: $this,
					left: pos.left,
					top: pos.top,
					right: pos.left + $this.outerWidth(),
					bottom: pos.top + $this.outerHeight(),
					startselected: false,
					selected: $this.hasClass( "ui-selected" ),
					selecting: $this.hasClass( "ui-selecting" ),
					unselecting: $this.hasClass( "ui-unselecting" )
				} );
			} );
		};
		this.refresh();

		this._mouseInit();

		this.helper = $( "<div>" );
		this._addClass( this.helper, "ui-selectable-helper" );
	},

	_destroy: function() {
		this.selectees.removeData( "selectable-item" );
		this._mouseDestroy();
	},

	_mouseStart: function( event ) {
		var that = this,
			options = this.options;

		this.opos = [ event.pageX, event.pageY ];
		this.elementPos = $( this.element[ 0 ] ).offset();

		if ( this.options.disabled ) {
			return;
		}

		this.selectees = $( options.filter, this.element[ 0 ] );

		this._trigger( "start", event );

		$( options.appendTo ).append( this.helper );

		// position helper (lasso)
		this.helper.css( {
			"left": event.pageX,
			"top": event.pageY,
			"width": 0,
			"height": 0
		} );

		if ( options.autoRefresh ) {
			this.refresh();
		}

		this.selectees.filter( ".ui-selected" ).each( function() {
			var selectee = $.data( this, "selectable-item" );
			selectee.startselected = true;
			if ( !event.metaKey && !event.ctrlKey ) {
				that._removeClass( selectee.$element, "ui-selected" );
				selectee.selected = false;
				that._addClass( selectee.$element, "ui-unselecting" );
				selectee.unselecting = true;

				// selectable UNSELECTING callback
				that._trigger( "unselecting", event, {
					unselecting: selectee.element
				} );
			}
		} );

		$( event.target ).parents().addBack().each( function() {
			var doSelect,
				selectee = $.data( this, "selectable-item" );
			if ( selectee ) {
				doSelect = ( !event.metaKey && !event.ctrlKey ) ||
					!selectee.$element.hasClass( "ui-selected" );
				that._removeClass( selectee.$element, doSelect ? "ui-unselecting" : "ui-selected" )
					._addClass( selectee.$element, doSelect ? "ui-selecting" : "ui-unselecting" );
				selectee.unselecting = !doSelect;
				selectee.selecting = doSelect;
				selectee.selected = doSelect;

				// selectable (UN)SELECTING callback
				if ( doSelect ) {
					that._trigger( "selecting", event, {
						selecting: selectee.element
					} );
				} else {
					that._trigger( "unselecting", event, {
						unselecting: selectee.element
					} );
				}
				return false;
			}
		} );

	},

	_mouseDrag: function( event ) {

		this.dragged = true;

		if ( this.options.disabled ) {
			return;
		}

		var tmp,
			that = this,
			options = this.options,
			x1 = this.opos[ 0 ],
			y1 = this.opos[ 1 ],
			x2 = event.pageX,
			y2 = event.pageY;

		if ( x1 > x2 ) { tmp = x2; x2 = x1; x1 = tmp; }
		if ( y1 > y2 ) { tmp = y2; y2 = y1; y1 = tmp; }
		this.helper.css( { left: x1, top: y1, width: x2 - x1, height: y2 - y1 } );

		this.selectees.each( function() {
			var selectee = $.data( this, "selectable-item" ),
				hit = false,
				offset = {};

			//prevent helper from being selected if appendTo: selectable
			if ( !selectee || selectee.element === that.element[ 0 ] ) {
				return;
			}

			offset.left   = selectee.left   + that.elementPos.left;
			offset.right  = selectee.right  + that.elementPos.left;
			offset.top    = selectee.top    + that.elementPos.top;
			offset.bottom = selectee.bottom + that.elementPos.top;

			if ( options.tolerance === "touch" ) {
				hit = ( !( offset.left > x2 || offset.right < x1 || offset.top > y2 ||
                    offset.bottom < y1 ) );
			} else if ( options.tolerance === "fit" ) {
				hit = ( offset.left > x1 && offset.right < x2 && offset.top > y1 &&
                    offset.bottom < y2 );
			}

			if ( hit ) {

				// SELECT
				if ( selectee.selected ) {
					that._removeClass( selectee.$element, "ui-selected" );
					selectee.selected = false;
				}
				if ( selectee.unselecting ) {
					that._removeClass( selectee.$element, "ui-unselecting" );
					selectee.unselecting = false;
				}
				if ( !selectee.selecting ) {
					that._addClass( selectee.$element, "ui-selecting" );
					selectee.selecting = true;

					// selectable SELECTING callback
					that._trigger( "selecting", event, {
						selecting: selectee.element
					} );
				}
			} else {

				// UNSELECT
				if ( selectee.selecting ) {
					if ( ( event.metaKey || event.ctrlKey ) && selectee.startselected ) {
						that._removeClass( selectee.$element, "ui-selecting" );
						selectee.selecting = false;
						that._addClass( selectee.$element, "ui-selected" );
						selectee.selected = true;
					} else {
						that._removeClass( selectee.$element, "ui-selecting" );
						selectee.selecting = false;
						if ( selectee.startselected ) {
							that._addClass( selectee.$element, "ui-unselecting" );
							selectee.unselecting = true;
						}

						// selectable UNSELECTING callback
						that._trigger( "unselecting", event, {
							unselecting: selectee.element
						} );
					}
				}
				if ( selectee.selected ) {
					if ( !event.metaKey && !event.ctrlKey && !selectee.startselected ) {
						that._removeClass( selectee.$element, "ui-selected" );
						selectee.selected = false;

						that._addClass( selectee.$element, "ui-unselecting" );
						selectee.unselecting = true;

						// selectable UNSELECTING callback
						that._trigger( "unselecting", event, {
							unselecting: selectee.element
						} );
					}
				}
			}
		} );

		return false;
	},

	_mouseStop: function( event ) {
		var that = this;

		this.dragged = false;

		$( ".ui-unselecting", this.element[ 0 ] ).each( function() {
			var selectee = $.data( this, "selectable-item" );
			that._removeClass( selectee.$element, "ui-unselecting" );
			selectee.unselecting = false;
			selectee.startselected = false;
			that._trigger( "unselected", event, {
				unselected: selectee.element
			} );
		} );
		$( ".ui-selecting", this.element[ 0 ] ).each( function() {
			var selectee = $.data( this, "selectable-item" );
			that._removeClass( selectee.$element, "ui-selecting" )
				._addClass( selectee.$element, "ui-selected" );
			selectee.selecting = false;
			selectee.selected = true;
			selectee.startselected = true;
			that._trigger( "selected", event, {
				selected: selectee.element
			} );
		} );
		this._trigger( "stop", event );

		this.helper.remove();

		return false;
	}

} );


/*!
 * jQuery UI Selectmenu 1.12.0
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Selectmenu
//>>group: Widgets
// jscs:disable maximumLineLength
//>>description: Duplicates and extends the functionality of a native HTML select element, allowing it to be customizable in behavior and appearance far beyond the limitations of a native select.
// jscs:enable maximumLineLength
//>>docs: http://api.jqueryui.com/selectmenu/
//>>demos: http://jqueryui.com/selectmenu/
//>>css.structure: ../../themes/base/core.css
//>>css.structure: ../../themes/base/selectmenu.css, ../../themes/base/button.css
//>>css.theme: ../../themes/base/theme.css



var widgetsSelectmenu = $.widget( "ui.selectmenu", [ $.ui.formResetMixin, {
	version: "1.12.0",
	defaultElement: "<select>",
	options: {
		appendTo: null,
		classes: {
			"ui-selectmenu-button-open": "ui-corner-top",
			"ui-selectmenu-button-closed": "ui-corner-all"
		},
		disabled: null,
		icons: {
			button: "ui-icon-triangle-1-s"
		},
		position: {
			my: "left top",
			at: "left bottom",
			collision: "none"
		},
		width: false,

		// Callbacks
		change: null,
		close: null,
		focus: null,
		open: null,
		select: null
	},

	_create: function() {
		var selectmenuId = this.element.uniqueId().attr( "id" );
		this.ids = {
			element: selectmenuId,
			button: selectmenuId + "-button",
			menu: selectmenuId + "-menu"
		};

		this._drawButton();
		this._drawMenu();
		this._bindFormResetHandler();

		this._rendered = false;
		this.menuItems = $();
	},

	_drawButton: function() {
		var icon,
			that = this,
			item = this._parseOption(
				this.element.find( "option:selected" ),
				this.element[ 0 ].selectedIndex
			);

		// Associate existing label with the new button
		this.labels = this.element.labels().attr( "for", this.ids.button );
		this._on( this.labels, {
			click: function( event ) {
				this.button.focus();
				event.preventDefault();
			}
		} );

		// Hide original select element
		this.element.hide();

		// Create button
		this.button = $( "<span>", {
			tabindex: this.options.disabled ? -1 : 0,
			id: this.ids.button,
			role: "combobox",
			"aria-expanded": "false",
			"aria-autocomplete": "list",
			"aria-owns": this.ids.menu,
			"aria-haspopup": "true",
			title: this.element.attr( "title" )
		} )
			.insertAfter( this.element );

		this._addClass( this.button, "ui-selectmenu-button ui-selectmenu-button-closed",
			"ui-button ui-widget" );

		icon = $( "<span>" ).appendTo( this.button );
		this._addClass( icon, "ui-selectmenu-icon", "ui-icon " + this.options.icons.button );
		this.buttonItem = this._renderButtonItem( item )
			.appendTo( this.button );

		if ( this.options.width !== false ) {
			this._resizeButton();
		}

		this._on( this.button, this._buttonEvents );
		this.button.one( "focusin", function() {

			// Delay rendering the menu items until the button receives focus.
			// The menu may have already been rendered via a programmatic open.
			if ( !that._rendered ) {
				that._refreshMenu();
			}
		} );
	},

	_drawMenu: function() {
		var that = this;

		// Create menu
		this.menu = $( "<ul>", {
			"aria-hidden": "true",
			"aria-labelledby": this.ids.button,
			id: this.ids.menu
		} );

		// Wrap menu
		this.menuWrap = $( "<div>" ).append( this.menu );
		this._addClass( this.menuWrap, "ui-selectmenu-menu", "ui-front" );
		this.menuWrap.appendTo( this._appendTo() );

		// Initialize menu widget
		this.menuInstance = this.menu
			.menu( {
				classes: {
					"ui-menu": "ui-corner-bottom"
				},
				role: "listbox",
				select: function( event, ui ) {
					event.preventDefault();

					// Support: IE8
					// If the item was selected via a click, the text selection
					// will be destroyed in IE
					that._setSelection();

					that._select( ui.item.data( "ui-selectmenu-item" ), event );
				},
				focus: function( event, ui ) {
					var item = ui.item.data( "ui-selectmenu-item" );

					// Prevent inital focus from firing and check if its a newly focused item
					if ( that.focusIndex != null && item.index !== that.focusIndex ) {
						that._trigger( "focus", event, { item: item } );
						if ( !that.isOpen ) {
							that._select( item, event );
						}
					}
					that.focusIndex = item.index;

					that.button.attr( "aria-activedescendant",
						that.menuItems.eq( item.index ).attr( "id" ) );
				}
			} )
			.menu( "instance" );

		// Don't close the menu on mouseleave
		this.menuInstance._off( this.menu, "mouseleave" );

		// Cancel the menu's collapseAll on document click
		this.menuInstance._closeOnDocumentClick = function() {
			return false;
		};

		// Selects often contain empty items, but never contain dividers
		this.menuInstance._isDivider = function() {
			return false;
		};
	},

	refresh: function() {
		this._refreshMenu();
		this.buttonItem.replaceWith(
			this.buttonItem = this._renderButtonItem(

				// Fall back to an empty object in case there are no options
				this._getSelectedItem().data( "ui-selectmenu-item" ) || {}
			)
		);
		if ( this.options.width === null ) {
			this._resizeButton();
		}
	},

	_refreshMenu: function() {
		var item,
			options = this.element.find( "option" );

		this.menu.empty();

		this._parseOptions( options );
		this._renderMenu( this.menu, this.items );

		this.menuInstance.refresh();
		this.menuItems = this.menu.find( "li" )
			.not( ".ui-selectmenu-optgroup" )
				.find( ".ui-menu-item-wrapper" );

		this._rendered = true;

		if ( !options.length ) {
			return;
		}

		item = this._getSelectedItem();

		// Update the menu to have the correct item focused
		this.menuInstance.focus( null, item );
		this._setAria( item.data( "ui-selectmenu-item" ) );

		// Set disabled state
		this._setOption( "disabled", this.element.prop( "disabled" ) );
	},

	open: function( event ) {
		if ( this.options.disabled ) {
			return;
		}

		// If this is the first time the menu is being opened, render the items
		if ( !this._rendered ) {
			this._refreshMenu();
		} else {

			// Menu clears focus on close, reset focus to selected item
			this._removeClass( this.menu.find( ".ui-state-active" ), null, "ui-state-active" );
			this.menuInstance.focus( null, this._getSelectedItem() );
		}

		// If there are no options, don't open the menu
		if ( !this.menuItems.length ) {
			return;
		}

		this.isOpen = true;
		this._toggleAttr();
		this._resizeMenu();
		this._position();

		this._on( this.document, this._documentClick );

		this._trigger( "open", event );
	},

	_position: function() {
		this.menuWrap.position( $.extend( { of: this.button }, this.options.position ) );
	},

	close: function( event ) {
		if ( !this.isOpen ) {
			return;
		}

		this.isOpen = false;
		this._toggleAttr();

		this.range = null;
		this._off( this.document );

		this._trigger( "close", event );
	},

	widget: function() {
		return this.button;
	},

	menuWidget: function() {
		return this.menu;
	},

	_renderButtonItem: function( item ) {
		var buttonItem = $( "<span>" );

		this._setText( buttonItem, item.label );
		this._addClass( buttonItem, "ui-selectmenu-text" );

		return buttonItem;
	},

	_renderMenu: function( ul, items ) {
		var that = this,
			currentOptgroup = "";

		$.each( items, function( index, item ) {
			var li;

			if ( item.optgroup !== currentOptgroup ) {
				li = $( "<li>", {
					text: item.optgroup
				} );
				that._addClass( li, "ui-selectmenu-optgroup", "ui-menu-divider" +
					( item.element.parent( "optgroup" ).prop( "disabled" ) ?
						" ui-state-disabled" :
						"" ) );

				li.appendTo( ul );

				currentOptgroup = item.optgroup;
			}

			that._renderItemData( ul, item );
		} );
	},

	_renderItemData: function( ul, item ) {
		return this._renderItem( ul, item ).data( "ui-selectmenu-item", item );
	},

	_renderItem: function( ul, item ) {
		var li = $( "<li>" ),
			wrapper = $( "<div>", {
				title: item.element.attr( "title" )
			} );

		if ( item.disabled ) {
			this._addClass( li, null, "ui-state-disabled" );
		}
		this._setText( wrapper, item.label );

		return li.append( wrapper ).appendTo( ul );
	},

	_setText: function( element, value ) {
		if ( value ) {
			element.text( value );
		} else {
			element.html( "&#160;" );
		}
	},

	_move: function( direction, event ) {
		var item, next,
			filter = ".ui-menu-item";

		if ( this.isOpen ) {
			item = this.menuItems.eq( this.focusIndex ).parent( "li" );
		} else {
			item = this.menuItems.eq( this.element[ 0 ].selectedIndex ).parent( "li" );
			filter += ":not(.ui-state-disabled)";
		}

		if ( direction === "first" || direction === "last" ) {
			next = item[ direction === "first" ? "prevAll" : "nextAll" ]( filter ).eq( -1 );
		} else {
			next = item[ direction + "All" ]( filter ).eq( 0 );
		}

		if ( next.length ) {
			this.menuInstance.focus( event, next );
		}
	},

	_getSelectedItem: function() {
		return this.menuItems.eq( this.element[ 0 ].selectedIndex ).parent( "li" );
	},

	_toggle: function( event ) {
		this[ this.isOpen ? "close" : "open" ]( event );
	},

	_setSelection: function() {
		var selection;

		if ( !this.range ) {
			return;
		}

		if ( window.getSelection ) {
			selection = window.getSelection();
			selection.removeAllRanges();
			selection.addRange( this.range );

		// Support: IE8
		} else {
			this.range.select();
		}

		// Support: IE
		// Setting the text selection kills the button focus in IE, but
		// restoring the focus doesn't kill the selection.
		this.button.focus();
	},

	_documentClick: {
		mousedown: function( event ) {
			if ( !this.isOpen ) {
				return;
			}

			if ( !$( event.target ).closest( ".ui-selectmenu-menu, #" +
					$.ui.escapeSelector( this.ids.button ) ).length ) {
				this.close( event );
			}
		}
	},

	_buttonEvents: {

		// Prevent text selection from being reset when interacting with the selectmenu (#10144)
		mousedown: function() {
			var selection;

			if ( window.getSelection ) {
				selection = window.getSelection();
				if ( selection.rangeCount ) {
					this.range = selection.getRangeAt( 0 );
				}

			// Support: IE8
			} else {
				this.range = document.selection.createRange();
			}
		},

		click: function( event ) {
			this._setSelection();
			this._toggle( event );
		},

		keydown: function( event ) {
			var preventDefault = true;
			switch ( event.keyCode ) {
			case $.ui.keyCode.TAB:
			case $.ui.keyCode.ESCAPE:
				this.close( event );
				preventDefault = false;
				break;
			case $.ui.keyCode.ENTER:
				if ( this.isOpen ) {
					this._selectFocusedItem( event );
				}
				break;
			case $.ui.keyCode.UP:
				if ( event.altKey ) {
					this._toggle( event );
				} else {
					this._move( "prev", event );
				}
				break;
			case $.ui.keyCode.DOWN:
				if ( event.altKey ) {
					this._toggle( event );
				} else {
					this._move( "next", event );
				}
				break;
			case $.ui.keyCode.SPACE:
				if ( this.isOpen ) {
					this._selectFocusedItem( event );
				} else {
					this._toggle( event );
				}
				break;
			case $.ui.keyCode.LEFT:
				this._move( "prev", event );
				break;
			case $.ui.keyCode.RIGHT:
				this._move( "next", event );
				break;
			case $.ui.keyCode.HOME:
			case $.ui.keyCode.PAGE_UP:
				this._move( "first", event );
				break;
			case $.ui.keyCode.END:
			case $.ui.keyCode.PAGE_DOWN:
				this._move( "last", event );
				break;
			default:
				this.menu.trigger( event );
				preventDefault = false;
			}

			if ( preventDefault ) {
				event.preventDefault();
			}
		}
	},

	_selectFocusedItem: function( event ) {
		var item = this.menuItems.eq( this.focusIndex ).parent( "li" );
		if ( !item.hasClass( "ui-state-disabled" ) ) {
			this._select( item.data( "ui-selectmenu-item" ), event );
		}
	},

	_select: function( item, event ) {
		var oldIndex = this.element[ 0 ].selectedIndex;

		// Change native select element
		this.element[ 0 ].selectedIndex = item.index;
		this.buttonItem.replaceWith( this.buttonItem = this._renderButtonItem( item ) );
		this._setAria( item );
		this._trigger( "select", event, { item: item } );

		if ( item.index !== oldIndex ) {
			this._trigger( "change", event, { item: item } );
		}

		this.close( event );
	},

	_setAria: function( item ) {
		var id = this.menuItems.eq( item.index ).attr( "id" );

		this.button.attr( {
			"aria-labelledby": id,
			"aria-activedescendant": id
		} );
		this.menu.attr( "aria-activedescendant", id );
	},

	_setOption: function( key, value ) {
		if ( key === "icons" ) {
			var icon = this.button.find( "span.ui-icon" );
			this._removeClass( icon, null, this.options.icons.button )
				._addClass( icon, null, value.button );
		}

		this._super( key, value );

		if ( key === "appendTo" ) {
			this.menuWrap.appendTo( this._appendTo() );
		}

		if ( key === "width" ) {
			this._resizeButton();
		}
	},

	_setOptionDisabled: function( value ) {
		this._super( value );

		this.menuInstance.option( "disabled", value );
		this.button.attr( "aria-disabled", value );
		this._toggleClass( this.button, null, "ui-state-disabled", value );

		this.element.prop( "disabled", value );
		if ( value ) {
			this.button.attr( "tabindex", -1 );
			this.close();
		} else {
			this.button.attr( "tabindex", 0 );
		}
	},

	_appendTo: function() {
		var element = this.options.appendTo;

		if ( element ) {
			element = element.jquery || element.nodeType ?
				$( element ) :
				this.document.find( element ).eq( 0 );
		}

		if ( !element || !element[ 0 ] ) {
			element = this.element.closest( ".ui-front, dialog" );
		}

		if ( !element.length ) {
			element = this.document[ 0 ].body;
		}

		return element;
	},

	_toggleAttr: function() {
		this.button.attr( "aria-expanded", this.isOpen );

		// We can't use two _toggleClass() calls here, because we need to make sure
		// we always remove classes first and add them second, otherwise if both classes have the
		// same theme class, it will be removed after we add it.
		this._removeClass( this.button, "ui-selectmenu-button-" +
			( this.isOpen ? "closed" : "open" ) )
			._addClass( this.button, "ui-selectmenu-button-" +
				( this.isOpen ? "open" : "closed" ) )
			._toggleClass( this.menuWrap, "ui-selectmenu-open", null, this.isOpen );

		this.menu.attr( "aria-hidden", !this.isOpen );
	},

	_resizeButton: function() {
		var width = this.options.width;

		// For `width: false`, just remove inline style and stop
		if ( width === false ) {
			this.button.css( "width", "" );
			return;
		}

		// For `width: null`, match the width of the original element
		if ( width === null ) {
			width = this.element.show().outerWidth();
			this.element.hide();
		}

		this.button.outerWidth( width );
	},

	_resizeMenu: function() {
		this.menu.outerWidth( Math.max(
			this.button.outerWidth(),

			// Support: IE10
			// IE10 wraps long text (possibly a rounding bug)
			// so we add 1px to avoid the wrapping
			this.menu.width( "" ).outerWidth() + 1
		) );
	},

	_getCreateOptions: function() {
		var options = this._super();

		options.disabled = this.element.prop( "disabled" );

		return options;
	},

	_parseOptions: function( options ) {
		var that = this,
			data = [];
		options.each( function( index, item ) {
			data.push( that._parseOption( $( item ), index ) );
		} );
		this.items = data;
	},

	_parseOption: function( option, index ) {
		var optgroup = option.parent( "optgroup" );

		return {
			element: option,
			index: index,
			value: option.val(),
			label: option.text(),
			optgroup: optgroup.attr( "label" ) || "",
			disabled: optgroup.prop( "disabled" ) || option.prop( "disabled" )
		};
	},

	_destroy: function() {
		this._unbindFormResetHandler();
		this.menuWrap.remove();
		this.button.remove();
		this.element.show();
		this.element.removeUniqueId();
		this.labels.attr( "for", this.ids.element );
	}
} ] );


/*!
 * jQuery UI Slider 1.12.0
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Slider
//>>group: Widgets
//>>description: Displays a flexible slider with ranges and accessibility via keyboard.
//>>docs: http://api.jqueryui.com/slider/
//>>demos: http://jqueryui.com/slider/
//>>css.structure: ../../themes/base/core.css
//>>css.structure: ../../themes/base/slider.css
//>>css.theme: ../../themes/base/theme.css



var widgetsSlider = $.widget( "ui.slider", $.ui.mouse, {
	version: "1.12.0",
	widgetEventPrefix: "slide",

	options: {
		animate: false,
		classes: {
			"ui-slider": "ui-corner-all",
			"ui-slider-handle": "ui-corner-all",

			// Note: ui-widget-header isn't the most fittingly semantic framework class for this
			// element, but worked best visually with a variety of themes
			"ui-slider-range": "ui-corner-all ui-widget-header"
		},
		distance: 0,
		max: 100,
		min: 0,
		orientation: "horizontal",
		range: false,
		step: 1,
		value: 0,
		values: null,

		// Callbacks
		change: null,
		slide: null,
		start: null,
		stop: null
	},

	// Number of pages in a slider
	// (how many times can you page up/down to go through the whole range)
	numPages: 5,

	_create: function() {
		this._keySliding = false;
		this._mouseSliding = false;
		this._animateOff = true;
		this._handleIndex = null;
		this._detectOrientation();
		this._mouseInit();
		this._calculateNewMax();

		this._addClass( "ui-slider ui-slider-" + this.orientation,
			"ui-widget ui-widget-content" );

		this._refresh();

		this._animateOff = false;
	},

	_refresh: function() {
		this._createRange();
		this._createHandles();
		this._setupEvents();
		this._refreshValue();
	},

	_createHandles: function() {
		var i, handleCount,
			options = this.options,
			existingHandles = this.element.find( ".ui-slider-handle" ),
			handle = "<span tabindex='0'></span>",
			handles = [];

		handleCount = ( options.values && options.values.length ) || 1;

		if ( existingHandles.length > handleCount ) {
			existingHandles.slice( handleCount ).remove();
			existingHandles = existingHandles.slice( 0, handleCount );
		}

		for ( i = existingHandles.length; i < handleCount; i++ ) {
			handles.push( handle );
		}

		this.handles = existingHandles.add( $( handles.join( "" ) ).appendTo( this.element ) );

		this._addClass( this.handles, "ui-slider-handle", "ui-state-default" );

		this.handle = this.handles.eq( 0 );

		this.handles.each( function( i ) {
			$( this ).data( "ui-slider-handle-index", i );
		} );
	},

	_createRange: function() {
		var options = this.options;

		if ( options.range ) {
			if ( options.range === true ) {
				if ( !options.values ) {
					options.values = [ this._valueMin(), this._valueMin() ];
				} else if ( options.values.length && options.values.length !== 2 ) {
					options.values = [ options.values[ 0 ], options.values[ 0 ] ];
				} else if ( $.isArray( options.values ) ) {
					options.values = options.values.slice( 0 );
				}
			}

			if ( !this.range || !this.range.length ) {
				this.range = $( "<div>" )
					.appendTo( this.element );

				this._addClass( this.range, "ui-slider-range" );
			} else {
				this._removeClass( this.range, "ui-slider-range-min ui-slider-range-max" );

				// Handle range switching from true to min/max
				this.range.css( {
					"left": "",
					"bottom": ""
				} );
			}
			if ( options.range === "min" || options.range === "max" ) {
				this._addClass( this.range, "ui-slider-range-" + options.range );
			}
		} else {
			if ( this.range ) {
				this.range.remove();
			}
			this.range = null;
		}
	},

	_setupEvents: function() {
		this._off( this.handles );
		this._on( this.handles, this._handleEvents );
		this._hoverable( this.handles );
		this._focusable( this.handles );
	},

	_destroy: function() {
		this.handles.remove();
		if ( this.range ) {
			this.range.remove();
		}

		this._mouseDestroy();
	},

	_mouseCapture: function( event ) {
		var position, normValue, distance, closestHandle, index, allowed, offset, mouseOverHandle,
			that = this,
			o = this.options;

		if ( o.disabled ) {
			return false;
		}

		this.elementSize = {
			width: this.element.outerWidth(),
			height: this.element.outerHeight()
		};
		this.elementOffset = this.element.offset();

		position = { x: event.pageX, y: event.pageY };
		normValue = this._normValueFromMouse( position );
		distance = this._valueMax() - this._valueMin() + 1;
		this.handles.each( function( i ) {
			var thisDistance = Math.abs( normValue - that.values( i ) );
			if ( ( distance > thisDistance ) ||
				( distance === thisDistance &&
					( i === that._lastChangedValue || that.values( i ) === o.min ) ) ) {
				distance = thisDistance;
				closestHandle = $( this );
				index = i;
			}
		} );

		allowed = this._start( event, index );
		if ( allowed === false ) {
			return false;
		}
		this._mouseSliding = true;

		this._handleIndex = index;

		this._addClass( closestHandle, null, "ui-state-active" );
		closestHandle.trigger( "focus" );

		offset = closestHandle.offset();
		mouseOverHandle = !$( event.target ).parents().addBack().is( ".ui-slider-handle" );
		this._clickOffset = mouseOverHandle ? { left: 0, top: 0 } : {
			left: event.pageX - offset.left - ( closestHandle.width() / 2 ),
			top: event.pageY - offset.top -
				( closestHandle.height() / 2 ) -
				( parseInt( closestHandle.css( "borderTopWidth" ), 10 ) || 0 ) -
				( parseInt( closestHandle.css( "borderBottomWidth" ), 10 ) || 0 ) +
				( parseInt( closestHandle.css( "marginTop" ), 10 ) || 0 )
		};

		if ( !this.handles.hasClass( "ui-state-hover" ) ) {
			this._slide( event, index, normValue );
		}
		this._animateOff = true;
		return true;
	},

	_mouseStart: function() {
		return true;
	},

	_mouseDrag: function( event ) {
		var position = { x: event.pageX, y: event.pageY },
			normValue = this._normValueFromMouse( position );

		this._slide( event, this._handleIndex, normValue );

		return false;
	},

	_mouseStop: function( event ) {
		this._removeClass( this.handles, null, "ui-state-active" );
		this._mouseSliding = false;

		this._stop( event, this._handleIndex );
		this._change( event, this._handleIndex );

		this._handleIndex = null;
		this._clickOffset = null;
		this._animateOff = false;

		return false;
	},

	_detectOrientation: function() {
		this.orientation = ( this.options.orientation === "vertical" ) ? "vertical" : "horizontal";
	},

	_normValueFromMouse: function( position ) {
		var pixelTotal,
			pixelMouse,
			percentMouse,
			valueTotal,
			valueMouse;

		if ( this.orientation === "horizontal" ) {
			pixelTotal = this.elementSize.width;
			pixelMouse = position.x - this.elementOffset.left -
				( this._clickOffset ? this._clickOffset.left : 0 );
		} else {
			pixelTotal = this.elementSize.height;
			pixelMouse = position.y - this.elementOffset.top -
				( this._clickOffset ? this._clickOffset.top : 0 );
		}

		percentMouse = ( pixelMouse / pixelTotal );
		if ( percentMouse > 1 ) {
			percentMouse = 1;
		}
		if ( percentMouse < 0 ) {
			percentMouse = 0;
		}
		if ( this.orientation === "vertical" ) {
			percentMouse = 1 - percentMouse;
		}

		valueTotal = this._valueMax() - this._valueMin();
		valueMouse = this._valueMin() + percentMouse * valueTotal;

		return this._trimAlignValue( valueMouse );
	},

	_uiHash: function( index, value, values ) {
		var uiHash = {
			handle: this.handles[ index ],
			handleIndex: index,
			value: value !== undefined ? value : this.value()
		};

		if ( this._hasMultipleValues() ) {
			uiHash.value = value !== undefined ? value : this.values( index );
			uiHash.values = values || this.values();
		}

		return uiHash;
	},

	_hasMultipleValues: function() {
		return this.options.values && this.options.values.length;
	},

	_start: function( event, index ) {
		return this._trigger( "start", event, this._uiHash( index ) );
	},

	_slide: function( event, index, newVal ) {
		var allowed, otherVal,
			currentValue = this.value(),
			newValues = this.values();

		if ( this._hasMultipleValues() ) {
			otherVal = this.values( index ? 0 : 1 );
			currentValue = this.values( index );

			if ( this.options.values.length === 2 && this.options.range === true ) {
				newVal =  index === 0 ? Math.min( otherVal, newVal ) : Math.max( otherVal, newVal );
			}

			newValues[ index ] = newVal;
		}

		if ( newVal === currentValue ) {
			return;
		}

		allowed = this._trigger( "slide", event, this._uiHash( index, newVal, newValues ) );

		// A slide can be canceled by returning false from the slide callback
		if ( allowed === false ) {
			return;
		}

		if ( this._hasMultipleValues() ) {
			this.values( index, newVal );
		} else {
			this.value( newVal );
		}
	},

	_stop: function( event, index ) {
		this._trigger( "stop", event, this._uiHash( index ) );
	},

	_change: function( event, index ) {
		if ( !this._keySliding && !this._mouseSliding ) {

			//store the last changed value index for reference when handles overlap
			this._lastChangedValue = index;
			this._trigger( "change", event, this._uiHash( index ) );
		}
	},

	value: function( newValue ) {
		if ( arguments.length ) {
			this.options.value = this._trimAlignValue( newValue );
			this._refreshValue();
			this._change( null, 0 );
			return;
		}

		return this._value();
	},

	values: function( index, newValue ) {
		var vals,
			newValues,
			i;

		if ( arguments.length > 1 ) {
			this.options.values[ index ] = this._trimAlignValue( newValue );
			this._refreshValue();
			this._change( null, index );
			return;
		}

		if ( arguments.length ) {
			if ( $.isArray( arguments[ 0 ] ) ) {
				vals = this.options.values;
				newValues = arguments[ 0 ];
				for ( i = 0; i < vals.length; i += 1 ) {
					vals[ i ] = this._trimAlignValue( newValues[ i ] );
					this._change( null, i );
				}
				this._refreshValue();
			} else {
				if ( this._hasMultipleValues() ) {
					return this._values( index );
				} else {
					return this.value();
				}
			}
		} else {
			return this._values();
		}
	},

	_setOption: function( key, value ) {
		var i,
			valsLength = 0;

		if ( key === "range" && this.options.range === true ) {
			if ( value === "min" ) {
				this.options.value = this._values( 0 );
				this.options.values = null;
			} else if ( value === "max" ) {
				this.options.value = this._values( this.options.values.length - 1 );
				this.options.values = null;
			}
		}

		if ( $.isArray( this.options.values ) ) {
			valsLength = this.options.values.length;
		}

		this._super( key, value );

		switch ( key ) {
			case "orientation":
				this._detectOrientation();
				this._removeClass( "ui-slider-horizontal ui-slider-vertical" )
					._addClass( "ui-slider-" + this.orientation );
				this._refreshValue();
				if ( this.options.range ) {
					this._refreshRange( value );
				}

				// Reset positioning from previous orientation
				this.handles.css( value === "horizontal" ? "bottom" : "left", "" );
				break;
			case "value":
				this._animateOff = true;
				this._refreshValue();
				this._change( null, 0 );
				this._animateOff = false;
				break;
			case "values":
				this._animateOff = true;
				this._refreshValue();

				// Start from the last handle to prevent unreachable handles (#9046)
				for ( i = valsLength - 1; i >= 0; i-- ) {
					this._change( null, i );
				}
				this._animateOff = false;
				break;
			case "step":
			case "min":
			case "max":
				this._animateOff = true;
				this._calculateNewMax();
				this._refreshValue();
				this._animateOff = false;
				break;
			case "range":
				this._animateOff = true;
				this._refresh();
				this._animateOff = false;
				break;
		}
	},

	_setOptionDisabled: function( value ) {
		this._super( value );

		this._toggleClass( null, "ui-state-disabled", !!value );
	},

	//internal value getter
	// _value() returns value trimmed by min and max, aligned by step
	_value: function() {
		var val = this.options.value;
		val = this._trimAlignValue( val );

		return val;
	},

	//internal values getter
	// _values() returns array of values trimmed by min and max, aligned by step
	// _values( index ) returns single value trimmed by min and max, aligned by step
	_values: function( index ) {
		var val,
			vals,
			i;

		if ( arguments.length ) {
			val = this.options.values[ index ];
			val = this._trimAlignValue( val );

			return val;
		} else if ( this._hasMultipleValues() ) {

			// .slice() creates a copy of the array
			// this copy gets trimmed by min and max and then returned
			vals = this.options.values.slice();
			for ( i = 0; i < vals.length; i += 1 ) {
				vals[ i ] = this._trimAlignValue( vals[ i ] );
			}

			return vals;
		} else {
			return [];
		}
	},

	// Returns the step-aligned value that val is closest to, between (inclusive) min and max
	_trimAlignValue: function( val ) {
		if ( val <= this._valueMin() ) {
			return this._valueMin();
		}
		if ( val >= this._valueMax() ) {
			return this._valueMax();
		}
		var step = ( this.options.step > 0 ) ? this.options.step : 1,
			valModStep = ( val - this._valueMin() ) % step,
			alignValue = val - valModStep;

		if ( Math.abs( valModStep ) * 2 >= step ) {
			alignValue += ( valModStep > 0 ) ? step : ( -step );
		}

		// Since JavaScript has problems with large floats, round
		// the final value to 5 digits after the decimal point (see #4124)
		return parseFloat( alignValue.toFixed( 5 ) );
	},

	_calculateNewMax: function() {
		var max = this.options.max,
			min = this._valueMin(),
			step = this.options.step,
			aboveMin = Math.round( ( max - min ) / step ) * step;
		max = aboveMin + min;
		if ( max > this.options.max ) {

			//If max is not divisible by step, rounding off may increase its value
			max -= step;
		}
		this.max = parseFloat( max.toFixed( this._precision() ) );
	},

	_precision: function() {
		var precision = this._precisionOf( this.options.step );
		if ( this.options.min !== null ) {
			precision = Math.max( precision, this._precisionOf( this.options.min ) );
		}
		return precision;
	},

	_precisionOf: function( num ) {
		var str = num.toString(),
			decimal = str.indexOf( "." );
		return decimal === -1 ? 0 : str.length - decimal - 1;
	},

	_valueMin: function() {
		return this.options.min;
	},

	_valueMax: function() {
		return this.max;
	},

	_refreshRange: function( orientation ) {
		if ( orientation === "vertical" ) {
			this.range.css( { "width": "", "left": "" } );
		}
		if ( orientation === "horizontal" ) {
			this.range.css( { "height": "", "bottom": "" } );
		}
	},

	_refreshValue: function() {
		var lastValPercent, valPercent, value, valueMin, valueMax,
			oRange = this.options.range,
			o = this.options,
			that = this,
			animate = ( !this._animateOff ) ? o.animate : false,
			_set = {};

		if ( this._hasMultipleValues() ) {
			this.handles.each( function( i ) {
				valPercent = ( that.values( i ) - that._valueMin() ) / ( that._valueMax() -
					that._valueMin() ) * 100;
				_set[ that.orientation === "horizontal" ? "left" : "bottom" ] = valPercent + "%";
				$( this ).stop( 1, 1 )[ animate ? "animate" : "css" ]( _set, o.animate );
				if ( that.options.range === true ) {
					if ( that.orientation === "horizontal" ) {
						if ( i === 0 ) {
							that.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( {
								left: valPercent + "%"
							}, o.animate );
						}
						if ( i === 1 ) {
							that.range[ animate ? "animate" : "css" ]( {
								width: ( valPercent - lastValPercent ) + "%"
							}, {
								queue: false,
								duration: o.animate
							} );
						}
					} else {
						if ( i === 0 ) {
							that.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( {
								bottom: ( valPercent ) + "%"
							}, o.animate );
						}
						if ( i === 1 ) {
							that.range[ animate ? "animate" : "css" ]( {
								height: ( valPercent - lastValPercent ) + "%"
							}, {
								queue: false,
								duration: o.animate
							} );
						}
					}
				}
				lastValPercent = valPercent;
			} );
		} else {
			value = this.value();
			valueMin = this._valueMin();
			valueMax = this._valueMax();
			valPercent = ( valueMax !== valueMin ) ?
					( value - valueMin ) / ( valueMax - valueMin ) * 100 :
					0;
			_set[ this.orientation === "horizontal" ? "left" : "bottom" ] = valPercent + "%";
			this.handle.stop( 1, 1 )[ animate ? "animate" : "css" ]( _set, o.animate );

			if ( oRange === "min" && this.orientation === "horizontal" ) {
				this.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( {
					width: valPercent + "%"
				}, o.animate );
			}
			if ( oRange === "max" && this.orientation === "horizontal" ) {
				this.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( {
					width: ( 100 - valPercent ) + "%"
				}, o.animate );
			}
			if ( oRange === "min" && this.orientation === "vertical" ) {
				this.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( {
					height: valPercent + "%"
				}, o.animate );
			}
			if ( oRange === "max" && this.orientation === "vertical" ) {
				this.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( {
					height: ( 100 - valPercent ) + "%"
				}, o.animate );
			}
		}
	},

	_handleEvents: {
		keydown: function( event ) {
			var allowed, curVal, newVal, step,
				index = $( event.target ).data( "ui-slider-handle-index" );

			switch ( event.keyCode ) {
				case $.ui.keyCode.HOME:
				case $.ui.keyCode.END:
				case $.ui.keyCode.PAGE_UP:
				case $.ui.keyCode.PAGE_DOWN:
				case $.ui.keyCode.UP:
				case $.ui.keyCode.RIGHT:
				case $.ui.keyCode.DOWN:
				case $.ui.keyCode.LEFT:
					event.preventDefault();
					if ( !this._keySliding ) {
						this._keySliding = true;
						this._addClass( $( event.target ), null, "ui-state-active" );
						allowed = this._start( event, index );
						if ( allowed === false ) {
							return;
						}
					}
					break;
			}

			step = this.options.step;
			if ( this._hasMultipleValues() ) {
				curVal = newVal = this.values( index );
			} else {
				curVal = newVal = this.value();
			}

			switch ( event.keyCode ) {
				case $.ui.keyCode.HOME:
					newVal = this._valueMin();
					break;
				case $.ui.keyCode.END:
					newVal = this._valueMax();
					break;
				case $.ui.keyCode.PAGE_UP:
					newVal = this._trimAlignValue(
						curVal + ( ( this._valueMax() - this._valueMin() ) / this.numPages )
					);
					break;
				case $.ui.keyCode.PAGE_DOWN:
					newVal = this._trimAlignValue(
						curVal - ( ( this._valueMax() - this._valueMin() ) / this.numPages ) );
					break;
				case $.ui.keyCode.UP:
				case $.ui.keyCode.RIGHT:
					if ( curVal === this._valueMax() ) {
						return;
					}
					newVal = this._trimAlignValue( curVal + step );
					break;
				case $.ui.keyCode.DOWN:
				case $.ui.keyCode.LEFT:
					if ( curVal === this._valueMin() ) {
						return;
					}
					newVal = this._trimAlignValue( curVal - step );
					break;
			}

			this._slide( event, index, newVal );
		},
		keyup: function( event ) {
			var index = $( event.target ).data( "ui-slider-handle-index" );

			if ( this._keySliding ) {
				this._keySliding = false;
				this._stop( event, index );
				this._change( event, index );
				this._removeClass( $( event.target ), null, "ui-state-active" );
			}
		}
	}
} );


/*!
 * jQuery UI Sortable 1.12.0
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Sortable
//>>group: Interactions
//>>description: Enables items in a list to be sorted using the mouse.
//>>docs: http://api.jqueryui.com/sortable/
//>>demos: http://jqueryui.com/sortable/
//>>css.structure: ../../themes/base/sortable.css



var widgetsSortable = $.widget( "ui.sortable", $.ui.mouse, {
	version: "1.12.0",
	widgetEventPrefix: "sort",
	ready: false,
	options: {
		appendTo: "parent",
		axis: false,
		connectWith: false,
		containment: false,
		cursor: "auto",
		cursorAt: false,
		dropOnEmpty: true,
		forcePlaceholderSize: false,
		forceHelperSize: false,
		grid: false,
		handle: false,
		helper: "original",
		items: "> *",
		opacity: false,
		placeholder: false,
		revert: false,
		scroll: true,
		scrollSensitivity: 20,
		scrollSpeed: 20,
		scope: "default",
		tolerance: "intersect",
		zIndex: 1000,

		// Callbacks
		activate: null,
		beforeStop: null,
		change: null,
		deactivate: null,
		out: null,
		over: null,
		receive: null,
		remove: null,
		sort: null,
		start: null,
		stop: null,
		update: null
	},

	_isOverAxis: function( x, reference, size ) {
		return ( x >= reference ) && ( x < ( reference + size ) );
	},

	_isFloating: function( item ) {
		return ( /left|right/ ).test( item.css( "float" ) ) ||
			( /inline|table-cell/ ).test( item.css( "display" ) );
	},

	_create: function() {
		this.containerCache = {};
		this._addClass( "ui-sortable" );

		//Get the items
		this.refresh();

		//Let's determine the parent's offset
		this.offset = this.element.offset();

		//Initialize mouse events for interaction
		this._mouseInit();

		this._setHandleClassName();

		//We're ready to go
		this.ready = true;

	},

	_setOption: function( key, value ) {
		this._super( key, value );

		if ( key === "handle" ) {
			this._setHandleClassName();
		}
	},

	_setHandleClassName: function() {
		var that = this;
		this._removeClass( this.element.find( ".ui-sortable-handle" ), "ui-sortable-handle" );
		$.each( this.items, function() {
			that._addClass(
				this.instance.options.handle ?
					this.item.find( this.instance.options.handle ) :
					this.item,
				"ui-sortable-handle"
			);
		} );
	},

	_destroy: function() {
		this._mouseDestroy();

		for ( var i = this.items.length - 1; i >= 0; i-- ) {
			this.items[ i ].item.removeData( this.widgetName + "-item" );
		}

		return this;
	},

	_mouseCapture: function( event, overrideHandle ) {
		var currentItem = null,
			validHandle = false,
			that = this;

		if ( this.reverting ) {
			return false;
		}

		if ( this.options.disabled || this.options.type === "static" ) {
			return false;
		}

		//We have to refresh the items data once first
		this._refreshItems( event );

		//Find out if the clicked node (or one of its parents) is a actual item in this.items
		$( event.target ).parents().each( function() {
			if ( $.data( this, that.widgetName + "-item" ) === that ) {
				currentItem = $( this );
				return false;
			}
		} );
		if ( $.data( event.target, that.widgetName + "-item" ) === that ) {
			currentItem = $( event.target );
		}

		if ( !currentItem ) {
			return false;
		}
		if ( this.options.handle && !overrideHandle ) {
			$( this.options.handle, currentItem ).find( "*" ).addBack().each( function() {
				if ( this === event.target ) {
					validHandle = true;
				}
			} );
			if ( !validHandle ) {
				return false;
			}
		}

		this.currentItem = currentItem;
		this._removeCurrentsFromItems();
		return true;

	},

	_mouseStart: function( event, overrideHandle, noActivation ) {

		var i, body,
			o = this.options;

		this.currentContainer = this;

		//We only need to call refreshPositions, because the refreshItems call has been moved to
		// mouseCapture
		this.refreshPositions();

		//Create and append the visible helper
		this.helper = this._createHelper( event );

		//Cache the helper size
		this._cacheHelperProportions();

		/*
		 * - Position generation -
		 * This block generates everything position related - it's the core of draggables.
		 */

		//Cache the margins of the original element
		this._cacheMargins();

		//Get the next scrolling parent
		this.scrollParent = this.helper.scrollParent();

		//The element's absolute position on the page minus margins
		this.offset = this.currentItem.offset();
		this.offset = {
			top: this.offset.top - this.margins.top,
			left: this.offset.left - this.margins.left
		};

		$.extend( this.offset, {
			click: { //Where the click happened, relative to the element
				left: event.pageX - this.offset.left,
				top: event.pageY - this.offset.top
			},
			parent: this._getParentOffset(),

			// This is a relative to absolute position minus the actual position calculation -
			// only used for relative positioned helper
			relative: this._getRelativeOffset()
		} );

		// Only after we got the offset, we can change the helper's position to absolute
		// TODO: Still need to figure out a way to make relative sorting possible
		this.helper.css( "position", "absolute" );
		this.cssPosition = this.helper.css( "position" );

		//Generate the original position
		this.originalPosition = this._generatePosition( event );
		this.originalPageX = event.pageX;
		this.originalPageY = event.pageY;

		//Adjust the mouse offset relative to the helper if "cursorAt" is supplied
		( o.cursorAt && this._adjustOffsetFromHelper( o.cursorAt ) );

		//Cache the former DOM position
		this.domPosition = {
			prev: this.currentItem.prev()[ 0 ],
			parent: this.currentItem.parent()[ 0 ]
		};

		// If the helper is not the original, hide the original so it's not playing any role during
		// the drag, won't cause anything bad this way
		if ( this.helper[ 0 ] !== this.currentItem[ 0 ] ) {
			this.currentItem.hide();
		}

		//Create the placeholder
		this._createPlaceholder();

		//Set a containment if given in the options
		if ( o.containment ) {
			this._setContainment();
		}

		if ( o.cursor && o.cursor !== "auto" ) { // cursor option
			body = this.document.find( "body" );

			// Support: IE
			this.storedCursor = body.css( "cursor" );
			body.css( "cursor", o.cursor );

			this.storedStylesheet =
				$( "<style>*{ cursor: " + o.cursor + " !important; }</style>" ).appendTo( body );
		}

		if ( o.opacity ) { // opacity option
			if ( this.helper.css( "opacity" ) ) {
				this._storedOpacity = this.helper.css( "opacity" );
			}
			this.helper.css( "opacity", o.opacity );
		}

		if ( o.zIndex ) { // zIndex option
			if ( this.helper.css( "zIndex" ) ) {
				this._storedZIndex = this.helper.css( "zIndex" );
			}
			this.helper.css( "zIndex", o.zIndex );
		}

		//Prepare scrolling
		if ( this.scrollParent[ 0 ] !== this.document[ 0 ] &&
				this.scrollParent[ 0 ].tagName !== "HTML" ) {
			this.overflowOffset = this.scrollParent.offset();
		}

		//Call callbacks
		this._trigger( "start", event, this._uiHash() );

		//Recache the helper size
		if ( !this._preserveHelperProportions ) {
			this._cacheHelperProportions();
		}

		//Post "activate" events to possible containers
		if ( !noActivation ) {
			for ( i = this.containers.length - 1; i >= 0; i-- ) {
				this.containers[ i ]._trigger( "activate", event, this._uiHash( this ) );
			}
		}

		//Prepare possible droppables
		if ( $.ui.ddmanager ) {
			$.ui.ddmanager.current = this;
		}

		if ( $.ui.ddmanager && !o.dropBehaviour ) {
			$.ui.ddmanager.prepareOffsets( this, event );
		}

		this.dragging = true;

		this._addClass( this.helper, "ui-sortable-helper" );

		// Execute the drag once - this causes the helper not to be visiblebefore getting its
		// correct position
		this._mouseDrag( event );
		return true;

	},

	_mouseDrag: function( event ) {
		var i, item, itemElement, intersection,
			o = this.options,
			scrolled = false;

		//Compute the helpers position
		this.position = this._generatePosition( event );
		this.positionAbs = this._convertPositionTo( "absolute" );

		if ( !this.lastPositionAbs ) {
			this.lastPositionAbs = this.positionAbs;
		}

		//Do scrolling
		if ( this.options.scroll ) {
			if ( this.scrollParent[ 0 ] !== this.document[ 0 ] &&
					this.scrollParent[ 0 ].tagName !== "HTML" ) {

				if ( ( this.overflowOffset.top + this.scrollParent[ 0 ].offsetHeight ) -
						event.pageY < o.scrollSensitivity ) {
					this.scrollParent[ 0 ].scrollTop =
						scrolled = this.scrollParent[ 0 ].scrollTop + o.scrollSpeed;
				} else if ( event.pageY - this.overflowOffset.top < o.scrollSensitivity ) {
					this.scrollParent[ 0 ].scrollTop =
						scrolled = this.scrollParent[ 0 ].scrollTop - o.scrollSpeed;
				}

				if ( ( this.overflowOffset.left + this.scrollParent[ 0 ].offsetWidth ) -
						event.pageX < o.scrollSensitivity ) {
					this.scrollParent[ 0 ].scrollLeft = scrolled =
						this.scrollParent[ 0 ].scrollLeft + o.scrollSpeed;
				} else if ( event.pageX - this.overflowOffset.left < o.scrollSensitivity ) {
					this.scrollParent[ 0 ].scrollLeft = scrolled =
						this.scrollParent[ 0 ].scrollLeft - o.scrollSpeed;
				}

			} else {

				if ( event.pageY - this.document.scrollTop() < o.scrollSensitivity ) {
					scrolled = this.document.scrollTop( this.document.scrollTop() - o.scrollSpeed );
				} else if ( this.window.height() - ( event.pageY - this.document.scrollTop() ) <
						o.scrollSensitivity ) {
					scrolled = this.document.scrollTop( this.document.scrollTop() + o.scrollSpeed );
				}

				if ( event.pageX - this.document.scrollLeft() < o.scrollSensitivity ) {
					scrolled = this.document.scrollLeft(
						this.document.scrollLeft() - o.scrollSpeed
					);
				} else if ( this.window.width() - ( event.pageX - this.document.scrollLeft() ) <
						o.scrollSensitivity ) {
					scrolled = this.document.scrollLeft(
						this.document.scrollLeft() + o.scrollSpeed
					);
				}

			}

			if ( scrolled !== false && $.ui.ddmanager && !o.dropBehaviour ) {
				$.ui.ddmanager.prepareOffsets( this, event );
			}
		}

		//Regenerate the absolute position used for position checks
		this.positionAbs = this._convertPositionTo( "absolute" );

		//Set the helper position
		if ( !this.options.axis || this.options.axis !== "y" ) {
			this.helper[ 0 ].style.left = this.position.left + "px";
		}
		if ( !this.options.axis || this.options.axis !== "x" ) {
			this.helper[ 0 ].style.top = this.position.top + "px";
		}

		//Rearrange
		for ( i = this.items.length - 1; i >= 0; i-- ) {

			//Cache variables and intersection, continue if no intersection
			item = this.items[ i ];
			itemElement = item.item[ 0 ];
			intersection = this._intersectsWithPointer( item );
			if ( !intersection ) {
				continue;
			}

			// Only put the placeholder inside the current Container, skip all
			// items from other containers. This works because when moving
			// an item from one container to another the
			// currentContainer is switched before the placeholder is moved.
			//
			// Without this, moving items in "sub-sortables" can cause
			// the placeholder to jitter between the outer and inner container.
			if ( item.instance !== this.currentContainer ) {
				continue;
			}

			// Cannot intersect with itself
			// no useless actions that have been done before
			// no action if the item moved is the parent of the item checked
			if ( itemElement !== this.currentItem[ 0 ] &&
				this.placeholder[ intersection === 1 ? "next" : "prev" ]()[ 0 ] !== itemElement &&
				!$.contains( this.placeholder[ 0 ], itemElement ) &&
				( this.options.type === "semi-dynamic" ?
					!$.contains( this.element[ 0 ], itemElement ) :
					true
				)
			) {

				this.direction = intersection === 1 ? "down" : "up";

				if ( this.options.tolerance === "pointer" || this._intersectsWithSides( item ) ) {
					this._rearrange( event, item );
				} else {
					break;
				}

				this._trigger( "change", event, this._uiHash() );
				break;
			}
		}

		//Post events to containers
		this._contactContainers( event );

		//Interconnect with droppables
		if ( $.ui.ddmanager ) {
			$.ui.ddmanager.drag( this, event );
		}

		//Call callbacks
		this._trigger( "sort", event, this._uiHash() );

		this.lastPositionAbs = this.positionAbs;
		return false;

	},

	_mouseStop: function( event, noPropagation ) {

		if ( !event ) {
			return;
		}

		//If we are using droppables, inform the manager about the drop
		if ( $.ui.ddmanager && !this.options.dropBehaviour ) {
			$.ui.ddmanager.drop( this, event );
		}

		if ( this.options.revert ) {
			var that = this,
				cur = this.placeholder.offset(),
				axis = this.options.axis,
				animation = {};

			if ( !axis || axis === "x" ) {
				animation.left = cur.left - this.offset.parent.left - this.margins.left +
					( this.offsetParent[ 0 ] === this.document[ 0 ].body ?
						0 :
						this.offsetParent[ 0 ].scrollLeft
					);
			}
			if ( !axis || axis === "y" ) {
				animation.top = cur.top - this.offset.parent.top - this.margins.top +
					( this.offsetParent[ 0 ] === this.document[ 0 ].body ?
						0 :
						this.offsetParent[ 0 ].scrollTop
					);
			}
			this.reverting = true;
			$( this.helper ).animate(
				animation,
				parseInt( this.options.revert, 10 ) || 500,
				function() {
					that._clear( event );
				}
			);
		} else {
			this._clear( event, noPropagation );
		}

		return false;

	},

	cancel: function() {

		if ( this.dragging ) {

			this._mouseUp( { target: null } );

			if ( this.options.helper === "original" ) {
				this.currentItem.css( this._storedCSS );
				this._removeClass( this.currentItem, "ui-sortable-helper" );
			} else {
				this.currentItem.show();
			}

			//Post deactivating events to containers
			for ( var i = this.containers.length - 1; i >= 0; i-- ) {
				this.containers[ i ]._trigger( "deactivate", null, this._uiHash( this ) );
				if ( this.containers[ i ].containerCache.over ) {
					this.containers[ i ]._trigger( "out", null, this._uiHash( this ) );
					this.containers[ i ].containerCache.over = 0;
				}
			}

		}

		if ( this.placeholder ) {

			//$(this.placeholder[0]).remove(); would have been the jQuery way - unfortunately,
			// it unbinds ALL events from the original node!
			if ( this.placeholder[ 0 ].parentNode ) {
				this.placeholder[ 0 ].parentNode.removeChild( this.placeholder[ 0 ] );
			}
			if ( this.options.helper !== "original" && this.helper &&
					this.helper[ 0 ].parentNode ) {
				this.helper.remove();
			}

			$.extend( this, {
				helper: null,
				dragging: false,
				reverting: false,
				_noFinalSort: null
			} );

			if ( this.domPosition.prev ) {
				$( this.domPosition.prev ).after( this.currentItem );
			} else {
				$( this.domPosition.parent ).prepend( this.currentItem );
			}
		}

		return this;

	},

	serialize: function( o ) {

		var items = this._getItemsAsjQuery( o && o.connected ),
			str = [];
		o = o || {};

		$( items ).each( function() {
			var res = ( $( o.item || this ).attr( o.attribute || "id" ) || "" )
				.match( o.expression || ( /(.+)[\-=_](.+)/ ) );
			if ( res ) {
				str.push(
					( o.key || res[ 1 ] + "[]" ) +
					"=" + ( o.key && o.expression ? res[ 1 ] : res[ 2 ] ) );
			}
		} );

		if ( !str.length && o.key ) {
			str.push( o.key + "=" );
		}

		return str.join( "&" );

	},

	toArray: function( o ) {

		var items = this._getItemsAsjQuery( o && o.connected ),
			ret = [];

		o = o || {};

		items.each( function() {
			ret.push( $( o.item || this ).attr( o.attribute || "id" ) || "" );
		} );
		return ret;

	},

	/* Be careful with the following core functions */
	_intersectsWith: function( item ) {

		var x1 = this.positionAbs.left,
			x2 = x1 + this.helperProportions.width,
			y1 = this.positionAbs.top,
			y2 = y1 + this.helperProportions.height,
			l = item.left,
			r = l + item.width,
			t = item.top,
			b = t + item.height,
			dyClick = this.offset.click.top,
			dxClick = this.offset.click.left,
			isOverElementHeight = ( this.options.axis === "x" ) || ( ( y1 + dyClick ) > t &&
				( y1 + dyClick ) < b ),
			isOverElementWidth = ( this.options.axis === "y" ) || ( ( x1 + dxClick ) > l &&
				( x1 + dxClick ) < r ),
			isOverElement = isOverElementHeight && isOverElementWidth;

		if ( this.options.tolerance === "pointer" ||
			this.options.forcePointerForContainers ||
			( this.options.tolerance !== "pointer" &&
				this.helperProportions[ this.floating ? "width" : "height" ] >
				item[ this.floating ? "width" : "height" ] )
		) {
			return isOverElement;
		} else {

			return ( l < x1 + ( this.helperProportions.width / 2 ) && // Right Half
				x2 - ( this.helperProportions.width / 2 ) < r && // Left Half
				t < y1 + ( this.helperProportions.height / 2 ) && // Bottom Half
				y2 - ( this.helperProportions.height / 2 ) < b ); // Top Half

		}
	},

	_intersectsWithPointer: function( item ) {
		var verticalDirection, horizontalDirection,
			isOverElementHeight = ( this.options.axis === "x" ) ||
				this._isOverAxis(
					this.positionAbs.top + this.offset.click.top, item.top, item.height ),
			isOverElementWidth = ( this.options.axis === "y" ) ||
				this._isOverAxis(
					this.positionAbs.left + this.offset.click.left, item.left, item.width ),
			isOverElement = isOverElementHeight && isOverElementWidth;

		if ( !isOverElement ) {
			return false;
		}

		verticalDirection = this._getDragVerticalDirection();
		horizontalDirection = this._getDragHorizontalDirection();

		return this.floating ?
			( ( horizontalDirection === "right" || verticalDirection === "down" ) ? 2 : 1 )
			: ( verticalDirection && ( verticalDirection === "down" ? 2 : 1 ) );

	},

	_intersectsWithSides: function( item ) {

		var isOverBottomHalf = this._isOverAxis( this.positionAbs.top +
				this.offset.click.top, item.top + ( item.height / 2 ), item.height ),
			isOverRightHalf = this._isOverAxis( this.positionAbs.left +
				this.offset.click.left, item.left + ( item.width / 2 ), item.width ),
			verticalDirection = this._getDragVerticalDirection(),
			horizontalDirection = this._getDragHorizontalDirection();

		if ( this.floating && horizontalDirection ) {
			return ( ( horizontalDirection === "right" && isOverRightHalf ) ||
				( horizontalDirection === "left" && !isOverRightHalf ) );
		} else {
			return verticalDirection && ( ( verticalDirection === "down" && isOverBottomHalf ) ||
				( verticalDirection === "up" && !isOverBottomHalf ) );
		}

	},

	_getDragVerticalDirection: function() {
		var delta = this.positionAbs.top - this.lastPositionAbs.top;
		return delta !== 0 && ( delta > 0 ? "down" : "up" );
	},

	_getDragHorizontalDirection: function() {
		var delta = this.positionAbs.left - this.lastPositionAbs.left;
		return delta !== 0 && ( delta > 0 ? "right" : "left" );
	},

	refresh: function( event ) {
		this._refreshItems( event );
		this._setHandleClassName();
		this.refreshPositions();
		return this;
	},

	_connectWith: function() {
		var options = this.options;
		return options.connectWith.constructor === String ?
			[ options.connectWith ] :
			options.connectWith;
	},

	_getItemsAsjQuery: function( connected ) {

		var i, j, cur, inst,
			items = [],
			queries = [],
			connectWith = this._connectWith();

		if ( connectWith && connected ) {
			for ( i = connectWith.length - 1; i >= 0; i-- ) {
				cur = $( connectWith[ i ], this.document[ 0 ] );
				for ( j = cur.length - 1; j >= 0; j-- ) {
					inst = $.data( cur[ j ], this.widgetFullName );
					if ( inst && inst !== this && !inst.options.disabled ) {
						queries.push( [ $.isFunction( inst.options.items ) ?
							inst.options.items.call( inst.element ) :
							$( inst.options.items, inst.element )
								.not( ".ui-sortable-helper" )
								.not( ".ui-sortable-placeholder" ), inst ] );
					}
				}
			}
		}

		queries.push( [ $.isFunction( this.options.items ) ?
			this.options.items
				.call( this.element, null, { options: this.options, item: this.currentItem } ) :
			$( this.options.items, this.element )
				.not( ".ui-sortable-helper" )
				.not( ".ui-sortable-placeholder" ), this ] );

		function addItems() {
			items.push( this );
		}
		for ( i = queries.length - 1; i >= 0; i-- ) {
			queries[ i ][ 0 ].each( addItems );
		}

		return $( items );

	},

	_removeCurrentsFromItems: function() {

		var list = this.currentItem.find( ":data(" + this.widgetName + "-item)" );

		this.items = $.grep( this.items, function( item ) {
			for ( var j = 0; j < list.length; j++ ) {
				if ( list[ j ] === item.item[ 0 ] ) {
					return false;
				}
			}
			return true;
		} );

	},

	_refreshItems: function( event ) {

		this.items = [];
		this.containers = [ this ];

		var i, j, cur, inst, targetData, _queries, item, queriesLength,
			items = this.items,
			queries = [ [ $.isFunction( this.options.items ) ?
				this.options.items.call( this.element[ 0 ], event, { item: this.currentItem } ) :
				$( this.options.items, this.element ), this ] ],
			connectWith = this._connectWith();

		//Shouldn't be run the first time through due to massive slow-down
		if ( connectWith && this.ready ) {
			for ( i = connectWith.length - 1; i >= 0; i-- ) {
				cur = $( connectWith[ i ], this.document[ 0 ] );
				for ( j = cur.length - 1; j >= 0; j-- ) {
					inst = $.data( cur[ j ], this.widgetFullName );
					if ( inst && inst !== this && !inst.options.disabled ) {
						queries.push( [ $.isFunction( inst.options.items ) ?
							inst.options.items
								.call( inst.element[ 0 ], event, { item: this.currentItem } ) :
							$( inst.options.items, inst.element ), inst ] );
						this.containers.push( inst );
					}
				}
			}
		}

		for ( i = queries.length - 1; i >= 0; i-- ) {
			targetData = queries[ i ][ 1 ];
			_queries = queries[ i ][ 0 ];

			for ( j = 0, queriesLength = _queries.length; j < queriesLength; j++ ) {
				item = $( _queries[ j ] );

				// Data for target checking (mouse manager)
				item.data( this.widgetName + "-item", targetData );

				items.push( {
					item: item,
					instance: targetData,
					width: 0, height: 0,
					left: 0, top: 0
				} );
			}
		}

	},

	refreshPositions: function( fast ) {

		// Determine whether items are being displayed horizontally
		this.floating = this.items.length ?
			this.options.axis === "x" || this._isFloating( this.items[ 0 ].item ) :
			false;

		//This has to be redone because due to the item being moved out/into the offsetParent,
		// the offsetParent's position will change
		if ( this.offsetParent && this.helper ) {
			this.offset.parent = this._getParentOffset();
		}

		var i, item, t, p;

		for ( i = this.items.length - 1; i >= 0; i-- ) {
			item = this.items[ i ];

			//We ignore calculating positions of all connected containers when we're not over them
			if ( item.instance !== this.currentContainer && this.currentContainer &&
					item.item[ 0 ] !== this.currentItem[ 0 ] ) {
				continue;
			}

			t = this.options.toleranceElement ?
				$( this.options.toleranceElement, item.item ) :
				item.item;

			if ( !fast ) {
				item.width = t.outerWidth();
				item.height = t.outerHeight();
			}

			p = t.offset();
			item.left = p.left;
			item.top = p.top;
		}

		if ( this.options.custom && this.options.custom.refreshContainers ) {
			this.options.custom.refreshContainers.call( this );
		} else {
			for ( i = this.containers.length - 1; i >= 0; i-- ) {
				p = this.containers[ i ].element.offset();
				this.containers[ i ].containerCache.left = p.left;
				this.containers[ i ].containerCache.top = p.top;
				this.containers[ i ].containerCache.width =
					this.containers[ i ].element.outerWidth();
				this.containers[ i ].containerCache.height =
					this.containers[ i ].element.outerHeight();
			}
		}

		return this;
	},

	_createPlaceholder: function( that ) {
		that = that || this;
		var className,
			o = that.options;

		if ( !o.placeholder || o.placeholder.constructor === String ) {
			className = o.placeholder;
			o.placeholder = {
				element: function() {

					var nodeName = that.currentItem[ 0 ].nodeName.toLowerCase(),
						element = $( "<" + nodeName + ">", that.document[ 0 ] );

						that._addClass( element, "ui-sortable-placeholder",
								className || that.currentItem[ 0 ].className )
							._removeClass( element, "ui-sortable-helper" );

					if ( nodeName === "tbody" ) {
						that._createTrPlaceholder(
							that.currentItem.find( "tr" ).eq( 0 ),
							$( "<tr>", that.document[ 0 ] ).appendTo( element )
						);
					} else if ( nodeName === "tr" ) {
						that._createTrPlaceholder( that.currentItem, element );
					} else if ( nodeName === "img" ) {
						element.attr( "src", that.currentItem.attr( "src" ) );
					}

					if ( !className ) {
						element.css( "visibility", "hidden" );
					}

					return element;
				},
				update: function( container, p ) {

					// 1. If a className is set as 'placeholder option, we don't force sizes -
					// the class is responsible for that
					// 2. The option 'forcePlaceholderSize can be enabled to force it even if a
					// class name is specified
					if ( className && !o.forcePlaceholderSize ) {
						return;
					}

					//If the element doesn't have a actual height by itself (without styles coming
					// from a stylesheet), it receives the inline height from the dragged item
					if ( !p.height() ) {
						p.height(
							that.currentItem.innerHeight() -
							parseInt( that.currentItem.css( "paddingTop" ) || 0, 10 ) -
							parseInt( that.currentItem.css( "paddingBottom" ) || 0, 10 ) );
					}
					if ( !p.width() ) {
						p.width(
							that.currentItem.innerWidth() -
							parseInt( that.currentItem.css( "paddingLeft" ) || 0, 10 ) -
							parseInt( that.currentItem.css( "paddingRight" ) || 0, 10 ) );
					}
				}
			};
		}

		//Create the placeholder
		that.placeholder = $( o.placeholder.element.call( that.element, that.currentItem ) );

		//Append it after the actual current item
		that.currentItem.after( that.placeholder );

		//Update the size of the placeholder (TODO: Logic to fuzzy, see line 316/317)
		o.placeholder.update( that, that.placeholder );

	},

	_createTrPlaceholder: function( sourceTr, targetTr ) {
		var that = this;

		sourceTr.children().each( function() {
			$( "<td>&#160;</td>", that.document[ 0 ] )
				.attr( "colspan", $( this ).attr( "colspan" ) || 1 )
				.appendTo( targetTr );
		} );
	},

	_contactContainers: function( event ) {
		var i, j, dist, itemWithLeastDistance, posProperty, sizeProperty, cur, nearBottom,
			floating, axis,
			innermostContainer = null,
			innermostIndex = null;

		// Get innermost container that intersects with item
		for ( i = this.containers.length - 1; i >= 0; i-- ) {

			// Never consider a container that's located within the item itself
			if ( $.contains( this.currentItem[ 0 ], this.containers[ i ].element[ 0 ] ) ) {
				continue;
			}

			if ( this._intersectsWith( this.containers[ i ].containerCache ) ) {

				// If we've already found a container and it's more "inner" than this, then continue
				if ( innermostContainer &&
						$.contains(
							this.containers[ i ].element[ 0 ],
							innermostContainer.element[ 0 ] ) ) {
					continue;
				}

				innermostContainer = this.containers[ i ];
				innermostIndex = i;

			} else {

				// container doesn't intersect. trigger "out" event if necessary
				if ( this.containers[ i ].containerCache.over ) {
					this.containers[ i ]._trigger( "out", event, this._uiHash( this ) );
					this.containers[ i ].containerCache.over = 0;
				}
			}

		}

		// If no intersecting containers found, return
		if ( !innermostContainer ) {
			return;
		}

		// Move the item into the container if it's not there already
		if ( this.containers.length === 1 ) {
			if ( !this.containers[ innermostIndex ].containerCache.over ) {
				this.containers[ innermostIndex ]._trigger( "over", event, this._uiHash( this ) );
				this.containers[ innermostIndex ].containerCache.over = 1;
			}
		} else {

			// When entering a new container, we will find the item with the least distance and
			// append our item near it
			dist = 10000;
			itemWithLeastDistance = null;
			floating = innermostContainer.floating || this._isFloating( this.currentItem );
			posProperty = floating ? "left" : "top";
			sizeProperty = floating ? "width" : "height";
			axis = floating ? "pageX" : "pageY";

			for ( j = this.items.length - 1; j >= 0; j-- ) {
				if ( !$.contains(
						this.containers[ innermostIndex ].element[ 0 ], this.items[ j ].item[ 0 ] )
				) {
					continue;
				}
				if ( this.items[ j ].item[ 0 ] === this.currentItem[ 0 ] ) {
					continue;
				}

				cur = this.items[ j ].item.offset()[ posProperty ];
				nearBottom = false;
				if ( event[ axis ] - cur > this.items[ j ][ sizeProperty ] / 2 ) {
					nearBottom = true;
				}

				if ( Math.abs( event[ axis ] - cur ) < dist ) {
					dist = Math.abs( event[ axis ] - cur );
					itemWithLeastDistance = this.items[ j ];
					this.direction = nearBottom ? "up" : "down";
				}
			}

			//Check if dropOnEmpty is enabled
			if ( !itemWithLeastDistance && !this.options.dropOnEmpty ) {
				return;
			}

			if ( this.currentContainer === this.containers[ innermostIndex ] ) {
				if ( !this.currentContainer.containerCache.over ) {
					this.containers[ innermostIndex ]._trigger( "over", event, this._uiHash() );
					this.currentContainer.containerCache.over = 1;
				}
				return;
			}

			itemWithLeastDistance ?
				this._rearrange( event, itemWithLeastDistance, null, true ) :
				this._rearrange( event, null, this.containers[ innermostIndex ].element, true );
			this._trigger( "change", event, this._uiHash() );
			this.containers[ innermostIndex ]._trigger( "change", event, this._uiHash( this ) );
			this.currentContainer = this.containers[ innermostIndex ];

			//Update the placeholder
			this.options.placeholder.update( this.currentContainer, this.placeholder );

			this.containers[ innermostIndex ]._trigger( "over", event, this._uiHash( this ) );
			this.containers[ innermostIndex ].containerCache.over = 1;
		}

	},

	_createHelper: function( event ) {

		var o = this.options,
			helper = $.isFunction( o.helper ) ?
				$( o.helper.apply( this.element[ 0 ], [ event, this.currentItem ] ) ) :
				( o.helper === "clone" ? this.currentItem.clone() : this.currentItem );

		//Add the helper to the DOM if that didn't happen already
		if ( !helper.parents( "body" ).length ) {
			$( o.appendTo !== "parent" ?
				o.appendTo :
				this.currentItem[ 0 ].parentNode )[ 0 ].appendChild( helper[ 0 ] );
		}

		if ( helper[ 0 ] === this.currentItem[ 0 ] ) {
			this._storedCSS = {
				width: this.currentItem[ 0 ].style.width,
				height: this.currentItem[ 0 ].style.height,
				position: this.currentItem.css( "position" ),
				top: this.currentItem.css( "top" ),
				left: this.currentItem.css( "left" )
			};
		}

		if ( !helper[ 0 ].style.width || o.forceHelperSize ) {
			helper.width( this.currentItem.width() );
		}
		if ( !helper[ 0 ].style.height || o.forceHelperSize ) {
			helper.height( this.currentItem.height() );
		}

		return helper;

	},

	_adjustOffsetFromHelper: function( obj ) {
		if ( typeof obj === "string" ) {
			obj = obj.split( " " );
		}
		if ( $.isArray( obj ) ) {
			obj = { left: +obj[ 0 ], top: +obj[ 1 ] || 0 };
		}
		if ( "left" in obj ) {
			this.offset.click.left = obj.left + this.margins.left;
		}
		if ( "right" in obj ) {
			this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;
		}
		if ( "top" in obj ) {
			this.offset.click.top = obj.top + this.margins.top;
		}
		if ( "bottom" in obj ) {
			this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;
		}
	},

	_getParentOffset: function() {

		//Get the offsetParent and cache its position
		this.offsetParent = this.helper.offsetParent();
		var po = this.offsetParent.offset();

		// This is a special case where we need to modify a offset calculated on start, since the
		// following happened:
		// 1. The position of the helper is absolute, so it's position is calculated based on the
		// next positioned parent
		// 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn't
		// the document, which means that the scroll is included in the initial calculation of the
		// offset of the parent, and never recalculated upon drag
		if ( this.cssPosition === "absolute" && this.scrollParent[ 0 ] !== this.document[ 0 ] &&
				$.contains( this.scrollParent[ 0 ], this.offsetParent[ 0 ] ) ) {
			po.left += this.scrollParent.scrollLeft();
			po.top += this.scrollParent.scrollTop();
		}

		// This needs to be actually done for all browsers, since pageX/pageY includes this
		// information with an ugly IE fix
		if ( this.offsetParent[ 0 ] === this.document[ 0 ].body ||
				( this.offsetParent[ 0 ].tagName &&
				this.offsetParent[ 0 ].tagName.toLowerCase() === "html" && $.ui.ie ) ) {
			po = { top: 0, left: 0 };
		}

		return {
			top: po.top + ( parseInt( this.offsetParent.css( "borderTopWidth" ), 10 ) || 0 ),
			left: po.left + ( parseInt( this.offsetParent.css( "borderLeftWidth" ), 10 ) || 0 )
		};

	},

	_getRelativeOffset: function() {

		if ( this.cssPosition === "relative" ) {
			var p = this.currentItem.position();
			return {
				top: p.top - ( parseInt( this.helper.css( "top" ), 10 ) || 0 ) +
					this.scrollParent.scrollTop(),
				left: p.left - ( parseInt( this.helper.css( "left" ), 10 ) || 0 ) +
					this.scrollParent.scrollLeft()
			};
		} else {
			return { top: 0, left: 0 };
		}

	},

	_cacheMargins: function() {
		this.margins = {
			left: ( parseInt( this.currentItem.css( "marginLeft" ), 10 ) || 0 ),
			top: ( parseInt( this.currentItem.css( "marginTop" ), 10 ) || 0 )
		};
	},

	_cacheHelperProportions: function() {
		this.helperProportions = {
			width: this.helper.outerWidth(),
			height: this.helper.outerHeight()
		};
	},

	_setContainment: function() {

		var ce, co, over,
			o = this.options;
		if ( o.containment === "parent" ) {
			o.containment = this.helper[ 0 ].parentNode;
		}
		if ( o.containment === "document" || o.containment === "window" ) {
			this.containment = [
				0 - this.offset.relative.left - this.offset.parent.left,
				0 - this.offset.relative.top - this.offset.parent.top,
				o.containment === "document" ?
					this.document.width() :
					this.window.width() - this.helperProportions.width - this.margins.left,
				( o.containment === "document" ?
					( this.document.height() || document.body.parentNode.scrollHeight ) :
					this.window.height() || this.document[ 0 ].body.parentNode.scrollHeight
				) - this.helperProportions.height - this.margins.top
			];
		}

		if ( !( /^(document|window|parent)$/ ).test( o.containment ) ) {
			ce = $( o.containment )[ 0 ];
			co = $( o.containment ).offset();
			over = ( $( ce ).css( "overflow" ) !== "hidden" );

			this.containment = [
				co.left + ( parseInt( $( ce ).css( "borderLeftWidth" ), 10 ) || 0 ) +
					( parseInt( $( ce ).css( "paddingLeft" ), 10 ) || 0 ) - this.margins.left,
				co.top + ( parseInt( $( ce ).css( "borderTopWidth" ), 10 ) || 0 ) +
					( parseInt( $( ce ).css( "paddingTop" ), 10 ) || 0 ) - this.margins.top,
				co.left + ( over ? Math.max( ce.scrollWidth, ce.offsetWidth ) : ce.offsetWidth ) -
					( parseInt( $( ce ).css( "borderLeftWidth" ), 10 ) || 0 ) -
					( parseInt( $( ce ).css( "paddingRight" ), 10 ) || 0 ) -
					this.helperProportions.width - this.margins.left,
				co.top + ( over ? Math.max( ce.scrollHeight, ce.offsetHeight ) : ce.offsetHeight ) -
					( parseInt( $( ce ).css( "borderTopWidth" ), 10 ) || 0 ) -
					( parseInt( $( ce ).css( "paddingBottom" ), 10 ) || 0 ) -
					this.helperProportions.height - this.margins.top
			];
		}

	},

	_convertPositionTo: function( d, pos ) {

		if ( !pos ) {
			pos = this.position;
		}
		var mod = d === "absolute" ? 1 : -1,
			scroll = this.cssPosition === "absolute" &&
				!( this.scrollParent[ 0 ] !== this.document[ 0 ] &&
				$.contains( this.scrollParent[ 0 ], this.offsetParent[ 0 ] ) ) ?
					this.offsetParent :
					this.scrollParent,
			scrollIsRootNode = ( /(html|body)/i ).test( scroll[ 0 ].tagName );

		return {
			top: (

				// The absolute mouse position
				pos.top	+

				// Only for relative positioned nodes: Relative offset from element to offset parent
				this.offset.relative.top * mod +

				// The offsetParent's offset without borders (offset + border)
				this.offset.parent.top * mod -
				( ( this.cssPosition === "fixed" ?
					-this.scrollParent.scrollTop() :
					( scrollIsRootNode ? 0 : scroll.scrollTop() ) ) * mod )
			),
			left: (

				// The absolute mouse position
				pos.left +

				// Only for relative positioned nodes: Relative offset from element to offset parent
				this.offset.relative.left * mod +

				// The offsetParent's offset without borders (offset + border)
				this.offset.parent.left * mod	-
				( ( this.cssPosition === "fixed" ?
					-this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 :
					scroll.scrollLeft() ) * mod )
			)
		};

	},

	_generatePosition: function( event ) {

		var top, left,
			o = this.options,
			pageX = event.pageX,
			pageY = event.pageY,
			scroll = this.cssPosition === "absolute" &&
				!( this.scrollParent[ 0 ] !== this.document[ 0 ] &&
				$.contains( this.scrollParent[ 0 ], this.offsetParent[ 0 ] ) ) ?
					this.offsetParent :
					this.scrollParent,
				scrollIsRootNode = ( /(html|body)/i ).test( scroll[ 0 ].tagName );

		// This is another very weird special case that only happens for relative elements:
		// 1. If the css position is relative
		// 2. and the scroll parent is the document or similar to the offset parent
		// we have to refresh the relative offset during the scroll so there are no jumps
		if ( this.cssPosition === "relative" && !( this.scrollParent[ 0 ] !== this.document[ 0 ] &&
				this.scrollParent[ 0 ] !== this.offsetParent[ 0 ] ) ) {
			this.offset.relative = this._getRelativeOffset();
		}

		/*
		 * - Position constraining -
		 * Constrain the position to a mix of grid, containment.
		 */

		if ( this.originalPosition ) { //If we are not dragging yet, we won't check for options

			if ( this.containment ) {
				if ( event.pageX - this.offset.click.left < this.containment[ 0 ] ) {
					pageX = this.containment[ 0 ] + this.offset.click.left;
				}
				if ( event.pageY - this.offset.click.top < this.containment[ 1 ] ) {
					pageY = this.containment[ 1 ] + this.offset.click.top;
				}
				if ( event.pageX - this.offset.click.left > this.containment[ 2 ] ) {
					pageX = this.containment[ 2 ] + this.offset.click.left;
				}
				if ( event.pageY - this.offset.click.top > this.containment[ 3 ] ) {
					pageY = this.containment[ 3 ] + this.offset.click.top;
				}
			}

			if ( o.grid ) {
				top = this.originalPageY + Math.round( ( pageY - this.originalPageY ) /
					o.grid[ 1 ] ) * o.grid[ 1 ];
				pageY = this.containment ?
					( ( top - this.offset.click.top >= this.containment[ 1 ] &&
						top - this.offset.click.top <= this.containment[ 3 ] ) ?
							top :
							( ( top - this.offset.click.top >= this.containment[ 1 ] ) ?
								top - o.grid[ 1 ] : top + o.grid[ 1 ] ) ) :
								top;

				left = this.originalPageX + Math.round( ( pageX - this.originalPageX ) /
					o.grid[ 0 ] ) * o.grid[ 0 ];
				pageX = this.containment ?
					( ( left - this.offset.click.left >= this.containment[ 0 ] &&
						left - this.offset.click.left <= this.containment[ 2 ] ) ?
							left :
							( ( left - this.offset.click.left >= this.containment[ 0 ] ) ?
								left - o.grid[ 0 ] : left + o.grid[ 0 ] ) ) :
								left;
			}

		}

		return {
			top: (

				// The absolute mouse position
				pageY -

				// Click offset (relative to the element)
				this.offset.click.top -

				// Only for relative positioned nodes: Relative offset from element to offset parent
				this.offset.relative.top -

				// The offsetParent's offset without borders (offset + border)
				this.offset.parent.top +
				( ( this.cssPosition === "fixed" ?
					-this.scrollParent.scrollTop() :
					( scrollIsRootNode ? 0 : scroll.scrollTop() ) ) )
			),
			left: (

				// The absolute mouse position
				pageX -

				// Click offset (relative to the element)
				this.offset.click.left -

				// Only for relative positioned nodes: Relative offset from element to offset parent
				this.offset.relative.left -

				// The offsetParent's offset without borders (offset + border)
				this.offset.parent.left +
				( ( this.cssPosition === "fixed" ?
					-this.scrollParent.scrollLeft() :
					scrollIsRootNode ? 0 : scroll.scrollLeft() ) )
			)
		};

	},

	_rearrange: function( event, i, a, hardRefresh ) {

		a ? a[ 0 ].appendChild( this.placeholder[ 0 ] ) :
			i.item[ 0 ].parentNode.insertBefore( this.placeholder[ 0 ],
				( this.direction === "down" ? i.item[ 0 ] : i.item[ 0 ].nextSibling ) );

		//Various things done here to improve the performance:
		// 1. we create a setTimeout, that calls refreshPositions
		// 2. on the instance, we have a counter variable, that get's higher after every append
		// 3. on the local scope, we copy the counter variable, and check in the timeout,
		// if it's still the same
		// 4. this lets only the last addition to the timeout stack through
		this.counter = this.counter ? ++this.counter : 1;
		var counter = this.counter;

		this._delay( function() {
			if ( counter === this.counter ) {

				//Precompute after each DOM insertion, NOT on mousemove
				this.refreshPositions( !hardRefresh );
			}
		} );

	},

	_clear: function( event, noPropagation ) {

		this.reverting = false;

		// We delay all events that have to be triggered to after the point where the placeholder
		// has been removed and everything else normalized again
		var i,
			delayedTriggers = [];

		// We first have to update the dom position of the actual currentItem
		// Note: don't do it if the current item is already removed (by a user), or it gets
		// reappended (see #4088)
		if ( !this._noFinalSort && this.currentItem.parent().length ) {
			this.placeholder.before( this.currentItem );
		}
		this._noFinalSort = null;

		if ( this.helper[ 0 ] === this.currentItem[ 0 ] ) {
			for ( i in this._storedCSS ) {
				if ( this._storedCSS[ i ] === "auto" || this._storedCSS[ i ] === "static" ) {
					this._storedCSS[ i ] = "";
				}
			}
			this.currentItem.css( this._storedCSS );
			this._removeClass( this.currentItem, "ui-sortable-helper" );
		} else {
			this.currentItem.show();
		}

		if ( this.fromOutside && !noPropagation ) {
			delayedTriggers.push( function( event ) {
				this._trigger( "receive", event, this._uiHash( this.fromOutside ) );
			} );
		}
		if ( ( this.fromOutside ||
				this.domPosition.prev !==
				this.currentItem.prev().not( ".ui-sortable-helper" )[ 0 ] ||
				this.domPosition.parent !== this.currentItem.parent()[ 0 ] ) && !noPropagation ) {

			// Trigger update callback if the DOM position has changed
			delayedTriggers.push( function( event ) {
				this._trigger( "update", event, this._uiHash() );
			} );
		}

		// Check if the items Container has Changed and trigger appropriate
		// events.
		if ( this !== this.currentContainer ) {
			if ( !noPropagation ) {
				delayedTriggers.push( function( event ) {
					this._trigger( "remove", event, this._uiHash() );
				} );
				delayedTriggers.push( ( function( c ) {
					return function( event ) {
						c._trigger( "receive", event, this._uiHash( this ) );
					};
				} ).call( this, this.currentContainer ) );
				delayedTriggers.push( ( function( c ) {
					return function( event ) {
						c._trigger( "update", event, this._uiHash( this ) );
					};
				} ).call( this, this.currentContainer ) );
			}
		}

		//Post events to containers
		function delayEvent( type, instance, container ) {
			return function( event ) {
				container._trigger( type, event, instance._uiHash( instance ) );
			};
		}
		for ( i = this.containers.length - 1; i >= 0; i-- ) {
			if ( !noPropagation ) {
				delayedTriggers.push( delayEvent( "deactivate", this, this.containers[ i ] ) );
			}
			if ( this.containers[ i ].containerCache.over ) {
				delayedTriggers.push( delayEvent( "out", this, this.containers[ i ] ) );
				this.containers[ i ].containerCache.over = 0;
			}
		}

		//Do what was originally in plugins
		if ( this.storedCursor ) {
			this.document.find( "body" ).css( "cursor", this.storedCursor );
			this.storedStylesheet.remove();
		}
		if ( this._storedOpacity ) {
			this.helper.css( "opacity", this._storedOpacity );
		}
		if ( this._storedZIndex ) {
			this.helper.css( "zIndex", this._storedZIndex === "auto" ? "" : this._storedZIndex );
		}

		this.dragging = false;

		if ( !noPropagation ) {
			this._trigger( "beforeStop", event, this._uiHash() );
		}

		//$(this.placeholder[0]).remove(); would have been the jQuery way - unfortunately,
		// it unbinds ALL events from the original node!
		this.placeholder[ 0 ].parentNode.removeChild( this.placeholder[ 0 ] );

		if ( !this.cancelHelperRemoval ) {
			if ( this.helper[ 0 ] !== this.currentItem[ 0 ] ) {
				this.helper.remove();
			}
			this.helper = null;
		}

		if ( !noPropagation ) {
			for ( i = 0; i < delayedTriggers.length; i++ ) {

				// Trigger all delayed events
				delayedTriggers[ i ].call( this, event );
			}
			this._trigger( "stop", event, this._uiHash() );
		}

		this.fromOutside = false;
		return !this.cancelHelperRemoval;

	},

	_trigger: function() {
		if ( $.Widget.prototype._trigger.apply( this, arguments ) === false ) {
			this.cancel();
		}
	},

	_uiHash: function( _inst ) {
		var inst = _inst || this;
		return {
			helper: inst.helper,
			placeholder: inst.placeholder || $( [] ),
			position: inst.position,
			originalPosition: inst.originalPosition,
			offset: inst.positionAbs,
			item: inst.currentItem,
			sender: _inst ? _inst.element : null
		};
	}

} );


/*!
 * jQuery UI Spinner 1.12.0
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Spinner
//>>group: Widgets
//>>description: Displays buttons to easily input numbers via the keyboard or mouse.
//>>docs: http://api.jqueryui.com/spinner/
//>>demos: http://jqueryui.com/spinner/
//>>css.structure: ../../themes/base/core.css
//>>css.structure: ../../themes/base/spinner.css
//>>css.theme: ../../themes/base/theme.css



function spinnerModifer( fn ) {
	return function() {
		var previous = this.element.val();
		fn.apply( this, arguments );
		this._refresh();
		if ( previous !== this.element.val() ) {
			this._trigger( "change" );
		}
	};
}

$.widget( "ui.spinner", {
	version: "1.12.0",
	defaultElement: "<input>",
	widgetEventPrefix: "spin",
	options: {
		classes: {
			"ui-spinner": "ui-corner-all",
			"ui-spinner-down": "ui-corner-br",
			"ui-spinner-up": "ui-corner-tr"
		},
		culture: null,
		icons: {
			down: "ui-icon-triangle-1-s",
			up: "ui-icon-triangle-1-n"
		},
		incremental: true,
		max: null,
		min: null,
		numberFormat: null,
		page: 10,
		step: 1,

		change: null,
		spin: null,
		start: null,
		stop: null
	},

	_create: function() {

		// handle string values that need to be parsed
		this._setOption( "max", this.options.max );
		this._setOption( "min", this.options.min );
		this._setOption( "step", this.options.step );

		// Only format if there is a value, prevents the field from being marked
		// as invalid in Firefox, see #9573.
		if ( this.value() !== "" ) {

			// Format the value, but don't constrain.
			this._value( this.element.val(), true );
		}

		this._draw();
		this._on( this._events );
		this._refresh();

		// Turning off autocomplete prevents the browser from remembering the
		// value when navigating through history, so we re-enable autocomplete
		// if the page is unloaded before the widget is destroyed. #7790
		this._on( this.window, {
			beforeunload: function() {
				this.element.removeAttr( "autocomplete" );
			}
		} );
	},

	_getCreateOptions: function() {
		var options = this._super();
		var element = this.element;

		$.each( [ "min", "max", "step" ], function( i, option ) {
			var value = element.attr( option );
			if ( value != null && value.length ) {
				options[ option ] = value;
			}
		} );

		return options;
	},

	_events: {
		keydown: function( event ) {
			if ( this._start( event ) && this._keydown( event ) ) {
				event.preventDefault();
			}
		},
		keyup: "_stop",
		focus: function() {
			this.previous = this.element.val();
		},
		blur: function( event ) {
			if ( this.cancelBlur ) {
				delete this.cancelBlur;
				return;
			}

			this._stop();
			this._refresh();
			if ( this.previous !== this.element.val() ) {
				this._trigger( "change", event );
			}
		},
		mousewheel: function( event, delta ) {
			if ( !delta ) {
				return;
			}
			if ( !this.spinning && !this._start( event ) ) {
				return false;
			}

			this._spin( ( delta > 0 ? 1 : -1 ) * this.options.step, event );
			clearTimeout( this.mousewheelTimer );
			this.mousewheelTimer = this._delay( function() {
				if ( this.spinning ) {
					this._stop( event );
				}
			}, 100 );
			event.preventDefault();
		},
		"mousedown .ui-spinner-button": function( event ) {
			var previous;

			// We never want the buttons to have focus; whenever the user is
			// interacting with the spinner, the focus should be on the input.
			// If the input is focused then this.previous is properly set from
			// when the input first received focus. If the input is not focused
			// then we need to set this.previous based on the value before spinning.
			previous = this.element[ 0 ] === $.ui.safeActiveElement( this.document[ 0 ] ) ?
				this.previous : this.element.val();
			function checkFocus() {
				var isActive = this.element[ 0 ] === $.ui.safeActiveElement( this.document[ 0 ] );
				if ( !isActive ) {
					this.element.trigger( "focus" );
					this.previous = previous;

					// support: IE
					// IE sets focus asynchronously, so we need to check if focus
					// moved off of the input because the user clicked on the button.
					this._delay( function() {
						this.previous = previous;
					} );
				}
			}

			// Ensure focus is on (or stays on) the text field
			event.preventDefault();
			checkFocus.call( this );

			// Support: IE
			// IE doesn't prevent moving focus even with event.preventDefault()
			// so we set a flag to know when we should ignore the blur event
			// and check (again) if focus moved off of the input.
			this.cancelBlur = true;
			this._delay( function() {
				delete this.cancelBlur;
				checkFocus.call( this );
			} );

			if ( this._start( event ) === false ) {
				return;
			}

			this._repeat( null, $( event.currentTarget )
				.hasClass( "ui-spinner-up" ) ? 1 : -1, event );
		},
		"mouseup .ui-spinner-button": "_stop",
		"mouseenter .ui-spinner-button": function( event ) {

			// button will add ui-state-active if mouse was down while mouseleave and kept down
			if ( !$( event.currentTarget ).hasClass( "ui-state-active" ) ) {
				return;
			}

			if ( this._start( event ) === false ) {
				return false;
			}
			this._repeat( null, $( event.currentTarget )
				.hasClass( "ui-spinner-up" ) ? 1 : -1, event );
		},

		// TODO: do we really want to consider this a stop?
		// shouldn't we just stop the repeater and wait until mouseup before
		// we trigger the stop event?
		"mouseleave .ui-spinner-button": "_stop"
	},

	// Support mobile enhanced option and make backcompat more sane
	_enhance: function() {
		this.uiSpinner = this.element
			.attr( "autocomplete", "off" )
			.wrap( "<span>" )
			.parent()

				// Add buttons
				.append(
					"<a></a><a></a>"
				);
	},

	_draw: function() {
		this._enhance();

		this._addClass( this.uiSpinner, "ui-spinner", "ui-widget ui-widget-content" );
		this._addClass( "ui-spinner-input" );

		this.element.attr( "role", "spinbutton" );

		// Button bindings
		this.buttons = this.uiSpinner.children( "a" )
			.attr( "tabIndex", -1 )
			.attr( "aria-hidden", true )
			.button( {
				classes: {
					"ui-button": ""
				}
			} );

		// TODO: Right now button does not support classes this is already updated in button PR
		this._removeClass( this.buttons, "ui-corner-all" );

		this._addClass( this.buttons.first(), "ui-spinner-button ui-spinner-up" );
		this._addClass( this.buttons.last(), "ui-spinner-button ui-spinner-down" );
		this.buttons.first().button( {
			"icon": this.options.icons.up,
			"showLabel": false
		} );
		this.buttons.last().button( {
			"icon": this.options.icons.down,
			"showLabel": false
		} );

		// IE 6 doesn't understand height: 50% for the buttons
		// unless the wrapper has an explicit height
		if ( this.buttons.height() > Math.ceil( this.uiSpinner.height() * 0.5 ) &&
				this.uiSpinner.height() > 0 ) {
			this.uiSpinner.height( this.uiSpinner.height() );
		}
	},

	_keydown: function( event ) {
		var options = this.options,
			keyCode = $.ui.keyCode;

		switch ( event.keyCode ) {
		case keyCode.UP:
			this._repeat( null, 1, event );
			return true;
		case keyCode.DOWN:
			this._repeat( null, -1, event );
			return true;
		case keyCode.PAGE_UP:
			this._repeat( null, options.page, event );
			return true;
		case keyCode.PAGE_DOWN:
			this._repeat( null, -options.page, event );
			return true;
		}

		return false;
	},

	_start: function( event ) {
		if ( !this.spinning && this._trigger( "start", event ) === false ) {
			return false;
		}

		if ( !this.counter ) {
			this.counter = 1;
		}
		this.spinning = true;
		return true;
	},

	_repeat: function( i, steps, event ) {
		i = i || 500;

		clearTimeout( this.timer );
		this.timer = this._delay( function() {
			this._repeat( 40, steps, event );
		}, i );

		this._spin( steps * this.options.step, event );
	},

	_spin: function( step, event ) {
		var value = this.value() || 0;

		if ( !this.counter ) {
			this.counter = 1;
		}

		value = this._adjustValue( value + step * this._increment( this.counter ) );

		if ( !this.spinning || this._trigger( "spin", event, { value: value } ) !== false ) {
			this._value( value );
			this.counter++;
		}
	},

	_increment: function( i ) {
		var incremental = this.options.incremental;

		if ( incremental ) {
			return $.isFunction( incremental ) ?
				incremental( i ) :
				Math.floor( i * i * i / 50000 - i * i / 500 + 17 * i / 200 + 1 );
		}

		return 1;
	},

	_precision: function() {
		var precision = this._precisionOf( this.options.step );
		if ( this.options.min !== null ) {
			precision = Math.max( precision, this._precisionOf( this.options.min ) );
		}
		return precision;
	},

	_precisionOf: function( num ) {
		var str = num.toString(),
			decimal = str.indexOf( "." );
		return decimal === -1 ? 0 : str.length - decimal - 1;
	},

	_adjustValue: function( value ) {
		var base, aboveMin,
			options = this.options;

		// Make sure we're at a valid step
		// - find out where we are relative to the base (min or 0)
		base = options.min !== null ? options.min : 0;
		aboveMin = value - base;

		// - round to the nearest step
		aboveMin = Math.round( aboveMin / options.step ) * options.step;

		// - rounding is based on 0, so adjust back to our base
		value = base + aboveMin;

		// Fix precision from bad JS floating point math
		value = parseFloat( value.toFixed( this._precision() ) );

		// Clamp the value
		if ( options.max !== null && value > options.max ) {
			return options.max;
		}
		if ( options.min !== null && value < options.min ) {
			return options.min;
		}

		return value;
	},

	_stop: function( event ) {
		if ( !this.spinning ) {
			return;
		}

		clearTimeout( this.timer );
		clearTimeout( this.mousewheelTimer );
		this.counter = 0;
		this.spinning = false;
		this._trigger( "stop", event );
	},

	_setOption: function( key, value ) {
		var prevValue, first, last;

		if ( key === "culture" || key === "numberFormat" ) {
			prevValue = this._parse( this.element.val() );
			this.options[ key ] = value;
			this.element.val( this._format( prevValue ) );
			return;
		}

		if ( key === "max" || key === "min" || key === "step" ) {
			if ( typeof value === "string" ) {
				value = this._parse( value );
			}
		}
		if ( key === "icons" ) {
			first = this.buttons.first().find( ".ui-icon" );
			this._removeClass( first, null, this.options.icons.up );
			this._addClass( first, null, value.up );
			last = this.buttons.last().find( ".ui-icon" );
			this._removeClass( last, null, this.options.icons.down );
			this._addClass( last, null, value.down );
		}

		this._super( key, value );
	},

	_setOptionDisabled: function( value ) {
		this._super( value );

		this._toggleClass( this.uiSpinner, null, "ui-state-disabled", !!value );
		this.element.prop( "disabled", !!value );
		this.buttons.button( value ? "disable" : "enable" );
	},

	_setOptions: spinnerModifer( function( options ) {
		this._super( options );
	} ),

	_parse: function( val ) {
		if ( typeof val === "string" && val !== "" ) {
			val = window.Globalize && this.options.numberFormat ?
				Globalize.parseFloat( val, 10, this.options.culture ) : +val;
		}
		return val === "" || isNaN( val ) ? null : val;
	},

	_format: function( value ) {
		if ( value === "" ) {
			return "";
		}
		return window.Globalize && this.options.numberFormat ?
			Globalize.format( value, this.options.numberFormat, this.options.culture ) :
			value;
	},

	_refresh: function() {
		this.element.attr( {
			"aria-valuemin": this.options.min,
			"aria-valuemax": this.options.max,

			// TODO: what should we do with values that can't be parsed?
			"aria-valuenow": this._parse( this.element.val() )
		} );
	},

	isValid: function() {
		var value = this.value();

		// Null is invalid
		if ( value === null ) {
			return false;
		}

		// If value gets adjusted, it's invalid
		return value === this._adjustValue( value );
	},

	// Update the value without triggering change
	_value: function( value, allowAny ) {
		var parsed;
		if ( value !== "" ) {
			parsed = this._parse( value );
			if ( parsed !== null ) {
				if ( !allowAny ) {
					parsed = this._adjustValue( parsed );
				}
				value = this._format( parsed );
			}
		}
		this.element.val( value );
		this._refresh();
	},

	_destroy: function() {
		this.element
			.prop( "disabled", false )
			.removeAttr( "autocomplete role aria-valuemin aria-valuemax aria-valuenow" );

		this.uiSpinner.replaceWith( this.element );
	},

	stepUp: spinnerModifer( function( steps ) {
		this._stepUp( steps );
	} ),
	_stepUp: function( steps ) {
		if ( this._start() ) {
			this._spin( ( steps || 1 ) * this.options.step );
			this._stop();
		}
	},

	stepDown: spinnerModifer( function( steps ) {
		this._stepDown( steps );
	} ),
	_stepDown: function( steps ) {
		if ( this._start() ) {
			this._spin( ( steps || 1 ) * -this.options.step );
			this._stop();
		}
	},

	pageUp: spinnerModifer( function( pages ) {
		this._stepUp( ( pages || 1 ) * this.options.page );
	} ),

	pageDown: spinnerModifer( function( pages ) {
		this._stepDown( ( pages || 1 ) * this.options.page );
	} ),

	value: function( newVal ) {
		if ( !arguments.length ) {
			return this._parse( this.element.val() );
		}
		spinnerModifer( this._value ).call( this, newVal );
	},

	widget: function() {
		return this.uiSpinner;
	}
} );

// DEPRECATED
// TODO: switch return back to widget declaration at top of file when this is removed
if ( $.uiBackCompat !== false ) {

	// Backcompat for spinner html extension points
	$.widget( "ui.spinner", $.ui.spinner, {
		_enhance: function() {
			this.uiSpinner = this.element
				.attr( "autocomplete", "off" )
				.wrap( this._uiSpinnerHtml() )
				.parent()

					// Add buttons
					.append( this._buttonHtml() );
		},
		_uiSpinnerHtml: function() {
			return "<span>";
		},

		_buttonHtml: function() {
			return "<a></a><a></a>";
		}
	} );
}

var widgetsSpinner = $.ui.spinner;


/*!
 * jQuery UI Tabs 1.12.0
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Tabs
//>>group: Widgets
//>>description: Transforms a set of container elements into a tab structure.
//>>docs: http://api.jqueryui.com/tabs/
//>>demos: http://jqueryui.com/tabs/
//>>css.structure: ../../themes/base/core.css
//>>css.structure: ../../themes/base/tabs.css
//>>css.theme: ../../themes/base/theme.css



$.widget( "ui.tabs", {
	version: "1.12.0",
	delay: 300,
	options: {
		active: null,
		classes: {
			"ui-tabs": "ui-corner-all",
			"ui-tabs-nav": "ui-corner-all",
			"ui-tabs-panel": "ui-corner-bottom",
			"ui-tabs-tab": "ui-corner-top"
		},
		collapsible: false,
		event: "click",
		heightStyle: "content",
		hide: null,
		show: null,

		// Callbacks
		activate: null,
		beforeActivate: null,
		beforeLoad: null,
		load: null
	},

	_isLocal: ( function() {
		var rhash = /#.*$/;

		return function( anchor ) {
			var anchorUrl, locationUrl;

			anchorUrl = anchor.href.replace( rhash, "" );
			locationUrl = location.href.replace( rhash, "" );

			// Decoding may throw an error if the URL isn't UTF-8 (#9518)
			try {
				anchorUrl = decodeURIComponent( anchorUrl );
			} catch ( error ) {}
			try {
				locationUrl = decodeURIComponent( locationUrl );
			} catch ( error ) {}

			return anchor.hash.length > 1 && anchorUrl === locationUrl;
		};
	} )(),

	_create: function() {
		var that = this,
			options = this.options;

		this.running = false;

		this._addClass( "ui-tabs", "ui-widget ui-widget-content" );
		this._toggleClass( "ui-tabs-collapsible", null, options.collapsible );

		this._processTabs();
		options.active = this._initialActive();

		// Take disabling tabs via class attribute from HTML
		// into account and update option properly.
		if ( $.isArray( options.disabled ) ) {
			options.disabled = $.unique( options.disabled.concat(
				$.map( this.tabs.filter( ".ui-state-disabled" ), function( li ) {
					return that.tabs.index( li );
				} )
			) ).sort();
		}

		// Check for length avoids error when initializing empty list
		if ( this.options.active !== false && this.anchors.length ) {
			this.active = this._findActive( options.active );
		} else {
			this.active = $();
		}

		this._refresh();

		if ( this.active.length ) {
			this.load( options.active );
		}
	},

	_initialActive: function() {
		var active = this.options.active,
			collapsible = this.options.collapsible,
			locationHash = location.hash.substring( 1 );

		if ( active === null ) {

			// check the fragment identifier in the URL
			if ( locationHash ) {
				this.tabs.each( function( i, tab ) {
					if ( $( tab ).attr( "aria-controls" ) === locationHash ) {
						active = i;
						return false;
					}
				} );
			}

			// Check for a tab marked active via a class
			if ( active === null ) {
				active = this.tabs.index( this.tabs.filter( ".ui-tabs-active" ) );
			}

			// No active tab, set to false
			if ( active === null || active === -1 ) {
				active = this.tabs.length ? 0 : false;
			}
		}

		// Handle numbers: negative, out of range
		if ( active !== false ) {
			active = this.tabs.index( this.tabs.eq( active ) );
			if ( active === -1 ) {
				active = collapsible ? false : 0;
			}
		}

		// Don't allow collapsible: false and active: false
		if ( !collapsible && active === false && this.anchors.length ) {
			active = 0;
		}

		return active;
	},

	_getCreateEventData: function() {
		return {
			tab: this.active,
			panel: !this.active.length ? $() : this._getPanelForTab( this.active )
		};
	},

	_tabKeydown: function( event ) {
		var focusedTab = $( $.ui.safeActiveElement( this.document[ 0 ] ) ).closest( "li" ),
			selectedIndex = this.tabs.index( focusedTab ),
			goingForward = true;

		if ( this._handlePageNav( event ) ) {
			return;
		}

		switch ( event.keyCode ) {
		case $.ui.keyCode.RIGHT:
		case $.ui.keyCode.DOWN:
			selectedIndex++;
			break;
		case $.ui.keyCode.UP:
		case $.ui.keyCode.LEFT:
			goingForward = false;
			selectedIndex--;
			break;
		case $.ui.keyCode.END:
			selectedIndex = this.anchors.length - 1;
			break;
		case $.ui.keyCode.HOME:
			selectedIndex = 0;
			break;
		case $.ui.keyCode.SPACE:

			// Activate only, no collapsing
			event.preventDefault();
			clearTimeout( this.activating );
			this._activate( selectedIndex );
			return;
		case $.ui.keyCode.ENTER:

			// Toggle (cancel delayed activation, allow collapsing)
			event.preventDefault();
			clearTimeout( this.activating );

			// Determine if we should collapse or activate
			this._activate( selectedIndex === this.options.active ? false : selectedIndex );
			return;
		default:
			return;
		}

		// Focus the appropriate tab, based on which key was pressed
		event.preventDefault();
		clearTimeout( this.activating );
		selectedIndex = this._focusNextTab( selectedIndex, goingForward );

		// Navigating with control/command key will prevent automatic activation
		if ( !event.ctrlKey && !event.metaKey ) {

			// Update aria-selected immediately so that AT think the tab is already selected.
			// Otherwise AT may confuse the user by stating that they need to activate the tab,
			// but the tab will already be activated by the time the announcement finishes.
			focusedTab.attr( "aria-selected", "false" );
			this.tabs.eq( selectedIndex ).attr( "aria-selected", "true" );

			this.activating = this._delay( function() {
				this.option( "active", selectedIndex );
			}, this.delay );
		}
	},

	_panelKeydown: function( event ) {
		if ( this._handlePageNav( event ) ) {
			return;
		}

		// Ctrl+up moves focus to the current tab
		if ( event.ctrlKey && event.keyCode === $.ui.keyCode.UP ) {
			event.preventDefault();
			this.active.trigger( "focus" );
		}
	},

	// Alt+page up/down moves focus to the previous/next tab (and activates)
	_handlePageNav: function( event ) {
		if ( event.altKey && event.keyCode === $.ui.keyCode.PAGE_UP ) {
			this._activate( this._focusNextTab( this.options.active - 1, false ) );
			return true;
		}
		if ( event.altKey && event.keyCode === $.ui.keyCode.PAGE_DOWN ) {
			this._activate( this._focusNextTab( this.options.active + 1, true ) );
			return true;
		}
	},

	_findNextTab: function( index, goingForward ) {
		var lastTabIndex = this.tabs.length - 1;

		function constrain() {
			if ( index > lastTabIndex ) {
				index = 0;
			}
			if ( index < 0 ) {
				index = lastTabIndex;
			}
			return index;
		}

		while ( $.inArray( constrain(), this.options.disabled ) !== -1 ) {
			index = goingForward ? index + 1 : index - 1;
		}

		return index;
	},

	_focusNextTab: function( index, goingForward ) {
		index = this._findNextTab( index, goingForward );
		this.tabs.eq( index ).trigger( "focus" );
		return index;
	},

	_setOption: function( key, value ) {
		if ( key === "active" ) {

			// _activate() will handle invalid values and update this.options
			this._activate( value );
			return;
		}

		this._super( key, value );

		if ( key === "collapsible" ) {
			this._toggleClass( "ui-tabs-collapsible", null, value );

			// Setting collapsible: false while collapsed; open first panel
			if ( !value && this.options.active === false ) {
				this._activate( 0 );
			}
		}

		if ( key === "event" ) {
			this._setupEvents( value );
		}

		if ( key === "heightStyle" ) {
			this._setupHeightStyle( value );
		}
	},

	_sanitizeSelector: function( hash ) {
		return hash ? hash.replace( /[!"$%&'()*+,.\/:;<=>?@\[\]\^`{|}~]/g, "\\$&" ) : "";
	},

	refresh: function() {
		var options = this.options,
			lis = this.tablist.children( ":has(a[href])" );

		// Get disabled tabs from class attribute from HTML
		// this will get converted to a boolean if needed in _refresh()
		options.disabled = $.map( lis.filter( ".ui-state-disabled" ), function( tab ) {
			return lis.index( tab );
		} );

		this._processTabs();

		// Was collapsed or no tabs
		if ( options.active === false || !this.anchors.length ) {
			options.active = false;
			this.active = $();

		// was active, but active tab is gone
		} else if ( this.active.length && !$.contains( this.tablist[ 0 ], this.active[ 0 ] ) ) {

			// all remaining tabs are disabled
			if ( this.tabs.length === options.disabled.length ) {
				options.active = false;
				this.active = $();

			// activate previous tab
			} else {
				this._activate( this._findNextTab( Math.max( 0, options.active - 1 ), false ) );
			}

		// was active, active tab still exists
		} else {

			// make sure active index is correct
			options.active = this.tabs.index( this.active );
		}

		this._refresh();
	},

	_refresh: function() {
		this._setOptionDisabled( this.options.disabled );
		this._setupEvents( this.options.event );
		this._setupHeightStyle( this.options.heightStyle );

		this.tabs.not( this.active ).attr( {
			"aria-selected": "false",
			"aria-expanded": "false",
			tabIndex: -1
		} );
		this.panels.not( this._getPanelForTab( this.active ) )
			.hide()
			.attr( {
				"aria-hidden": "true"
			} );

		// Make sure one tab is in the tab order
		if ( !this.active.length ) {
			this.tabs.eq( 0 ).attr( "tabIndex", 0 );
		} else {
			this.active
				.attr( {
					"aria-selected": "true",
					"aria-expanded": "true",
					tabIndex: 0
				} );
			this._addClass( this.active, "ui-tabs-active", "ui-state-active" );
			this._getPanelForTab( this.active )
				.show()
				.attr( {
					"aria-hidden": "false"
				} );
		}
	},

	_processTabs: function() {
		var that = this,
			prevTabs = this.tabs,
			prevAnchors = this.anchors,
			prevPanels = this.panels;

		this.tablist = this._getList().attr( "role", "tablist" );
		this._addClass( this.tablist, "ui-tabs-nav",
			"ui-helper-reset ui-helper-clearfix ui-widget-header" );

		// Prevent users from focusing disabled tabs via click
		this.tablist
			.on( "mousedown" + this.eventNamespace, "> li", function( event ) {
				if ( $( this ).is( ".ui-state-disabled" ) ) {
					event.preventDefault();
				}
			} )

			// Support: IE <9
			// Preventing the default action in mousedown doesn't prevent IE
			// from focusing the element, so if the anchor gets focused, blur.
			// We don't have to worry about focusing the previously focused
			// element since clicking on a non-focusable element should focus
			// the body anyway.
			.on( "focus" + this.eventNamespace, ".ui-tabs-anchor", function() {
				if ( $( this ).closest( "li" ).is( ".ui-state-disabled" ) ) {
					this.blur();
				}
			} );

		this.tabs = this.tablist.find( "> li:has(a[href])" )
			.attr( {
				role: "tab",
				tabIndex: -1
			} );
		this._addClass( this.tabs, "ui-tabs-tab", "ui-state-default" );

		this.anchors = this.tabs.map( function() {
			return $( "a", this )[ 0 ];
		} )
			.attr( {
				role: "presentation",
				tabIndex: -1
			} );
		this._addClass( this.anchors, "ui-tabs-anchor" );

		this.panels = $();

		this.anchors.each( function( i, anchor ) {
			var selector, panel, panelId,
				anchorId = $( anchor ).uniqueId().attr( "id" ),
				tab = $( anchor ).closest( "li" ),
				originalAriaControls = tab.attr( "aria-controls" );

			// Inline tab
			if ( that._isLocal( anchor ) ) {
				selector = anchor.hash;
				panelId = selector.substring( 1 );
				panel = that.element.find( that._sanitizeSelector( selector ) );

			// remote tab
			} else {

				// If the tab doesn't already have aria-controls,
				// generate an id by using a throw-away element
				panelId = tab.attr( "aria-controls" ) || $( {} ).uniqueId()[ 0 ].id;
				selector = "#" + panelId;
				panel = that.element.find( selector );
				if ( !panel.length ) {
					panel = that._createPanel( panelId );
					panel.insertAfter( that.panels[ i - 1 ] || that.tablist );
				}
				panel.attr( "aria-live", "polite" );
			}

			if ( panel.length ) {
				that.panels = that.panels.add( panel );
			}
			if ( originalAriaControls ) {
				tab.data( "ui-tabs-aria-controls", originalAriaControls );
			}
			tab.attr( {
				"aria-controls": panelId,
				"aria-labelledby": anchorId
			} );
			panel.attr( "aria-labelledby", anchorId );
		} );

		this.panels.attr( "role", "tabpanel" );
		this._addClass( this.panels, "ui-tabs-panel", "ui-widget-content" );

		// Avoid memory leaks (#10056)
		if ( prevTabs ) {
			this._off( prevTabs.not( this.tabs ) );
			this._off( prevAnchors.not( this.anchors ) );
			this._off( prevPanels.not( this.panels ) );
		}
	},

	// Allow overriding how to find the list for rare usage scenarios (#7715)
	_getList: function() {
		return this.tablist || this.element.find( "ol, ul" ).eq( 0 );
	},

	_createPanel: function( id ) {
		return $( "<div>" )
			.attr( "id", id )
			.data( "ui-tabs-destroy", true );
	},

	_setOptionDisabled: function( disabled ) {
		var currentItem, li, i;

		if ( $.isArray( disabled ) ) {
			if ( !disabled.length ) {
				disabled = false;
			} else if ( disabled.length === this.anchors.length ) {
				disabled = true;
			}
		}

		// Disable tabs
		for ( i = 0; ( li = this.tabs[ i ] ); i++ ) {
			currentItem = $( li );
			if ( disabled === true || $.inArray( i, disabled ) !== -1 ) {
				currentItem.attr( "aria-disabled", "true" );
				this._addClass( currentItem, null, "ui-state-disabled" );
			} else {
				currentItem.removeAttr( "aria-disabled" );
				this._removeClass( currentItem, null, "ui-state-disabled" );
			}
		}

		this.options.disabled = disabled;

		this._toggleClass( this.widget(), this.widgetFullName + "-disabled", null,
			disabled === true );
	},

	_setupEvents: function( event ) {
		var events = {};
		if ( event ) {
			$.each( event.split( " " ), function( index, eventName ) {
				events[ eventName ] = "_eventHandler";
			} );
		}

		this._off( this.anchors.add( this.tabs ).add( this.panels ) );

		// Always prevent the default action, even when disabled
		this._on( true, this.anchors, {
			click: function( event ) {
				event.preventDefault();
			}
		} );
		this._on( this.anchors, events );
		this._on( this.tabs, { keydown: "_tabKeydown" } );
		this._on( this.panels, { keydown: "_panelKeydown" } );

		this._focusable( this.tabs );
		this._hoverable( this.tabs );
	},

	_setupHeightStyle: function( heightStyle ) {
		var maxHeight,
			parent = this.element.parent();

		if ( heightStyle === "fill" ) {
			maxHeight = parent.height();
			maxHeight -= this.element.outerHeight() - this.element.height();

			this.element.siblings( ":visible" ).each( function() {
				var elem = $( this ),
					position = elem.css( "position" );

				if ( position === "absolute" || position === "fixed" ) {
					return;
				}
				maxHeight -= elem.outerHeight( true );
			} );

			this.element.children().not( this.panels ).each( function() {
				maxHeight -= $( this ).outerHeight( true );
			} );

			this.panels.each( function() {
				$( this ).height( Math.max( 0, maxHeight -
					$( this ).innerHeight() + $( this ).height() ) );
			} )
				.css( "overflow", "auto" );
		} else if ( heightStyle === "auto" ) {
			maxHeight = 0;
			this.panels.each( function() {
				maxHeight = Math.max( maxHeight, $( this ).height( "" ).height() );
			} ).height( maxHeight );
		}
	},

	_eventHandler: function( event ) {
		var options = this.options,
			active = this.active,
			anchor = $( event.currentTarget ),
			tab = anchor.closest( "li" ),
			clickedIsActive = tab[ 0 ] === active[ 0 ],
			collapsing = clickedIsActive && options.collapsible,
			toShow = collapsing ? $() : this._getPanelForTab( tab ),
			toHide = !active.length ? $() : this._getPanelForTab( active ),
			eventData = {
				oldTab: active,
				oldPanel: toHide,
				newTab: collapsing ? $() : tab,
				newPanel: toShow
			};

		event.preventDefault();

		if ( tab.hasClass( "ui-state-disabled" ) ||

				// tab is already loading
				tab.hasClass( "ui-tabs-loading" ) ||

				// can't switch durning an animation
				this.running ||

				// click on active header, but not collapsible
				( clickedIsActive && !options.collapsible ) ||

				// allow canceling activation
				( this._trigger( "beforeActivate", event, eventData ) === false ) ) {
			return;
		}

		options.active = collapsing ? false : this.tabs.index( tab );

		this.active = clickedIsActive ? $() : tab;
		if ( this.xhr ) {
			this.xhr.abort();
		}

		if ( !toHide.length && !toShow.length ) {
			$.error( "jQuery UI Tabs: Mismatching fragment identifier." );
		}

		if ( toShow.length ) {
			this.load( this.tabs.index( tab ), event );
		}
		this._toggle( event, eventData );
	},

	// Handles show/hide for selecting tabs
	_toggle: function( event, eventData ) {
		var that = this,
			toShow = eventData.newPanel,
			toHide = eventData.oldPanel;

		this.running = true;

		function complete() {
			that.running = false;
			that._trigger( "activate", event, eventData );
		}

		function show() {
			that._addClass( eventData.newTab.closest( "li" ), "ui-tabs-active", "ui-state-active" );

			if ( toShow.length && that.options.show ) {
				that._show( toShow, that.options.show, complete );
			} else {
				toShow.show();
				complete();
			}
		}

		// Start out by hiding, then showing, then completing
		if ( toHide.length && this.options.hide ) {
			this._hide( toHide, this.options.hide, function() {
				that._removeClass( eventData.oldTab.closest( "li" ),
					"ui-tabs-active", "ui-state-active" );
				show();
			} );
		} else {
			this._removeClass( eventData.oldTab.closest( "li" ),
				"ui-tabs-active", "ui-state-active" );
			toHide.hide();
			show();
		}

		toHide.attr( "aria-hidden", "true" );
		eventData.oldTab.attr( {
			"aria-selected": "false",
			"aria-expanded": "false"
		} );

		// If we're switching tabs, remove the old tab from the tab order.
		// If we're opening from collapsed state, remove the previous tab from the tab order.
		// If we're collapsing, then keep the collapsing tab in the tab order.
		if ( toShow.length && toHide.length ) {
			eventData.oldTab.attr( "tabIndex", -1 );
		} else if ( toShow.length ) {
			this.tabs.filter( function() {
				return $( this ).attr( "tabIndex" ) === 0;
			} )
				.attr( "tabIndex", -1 );
		}

		toShow.attr( "aria-hidden", "false" );
		eventData.newTab.attr( {
			"aria-selected": "true",
			"aria-expanded": "true",
			tabIndex: 0
		} );
	},

	_activate: function( index ) {
		var anchor,
			active = this._findActive( index );

		// Trying to activate the already active panel
		if ( active[ 0 ] === this.active[ 0 ] ) {
			return;
		}

		// Trying to collapse, simulate a click on the current active header
		if ( !active.length ) {
			active = this.active;
		}

		anchor = active.find( ".ui-tabs-anchor" )[ 0 ];
		this._eventHandler( {
			target: anchor,
			currentTarget: anchor,
			preventDefault: $.noop
		} );
	},

	_findActive: function( index ) {
		return index === false ? $() : this.tabs.eq( index );
	},

	_getIndex: function( index ) {

		// meta-function to give users option to provide a href string instead of a numerical index.
		if ( typeof index === "string" ) {
			index = this.anchors.index( this.anchors.filter( "[href$='" +
				$.ui.escapeSelector( index ) + "']" ) );
		}

		return index;
	},

	_destroy: function() {
		if ( this.xhr ) {
			this.xhr.abort();
		}

		this.tablist
			.removeAttr( "role" )
			.off( this.eventNamespace );

		this.anchors
			.removeAttr( "role tabIndex" )
			.removeUniqueId();

		this.tabs.add( this.panels ).each( function() {
			if ( $.data( this, "ui-tabs-destroy" ) ) {
				$( this ).remove();
			} else {
				$( this ).removeAttr( "role tabIndex " +
					"aria-live aria-busy aria-selected aria-labelledby aria-hidden aria-expanded" );
			}
		} );

		this.tabs.each( function() {
			var li = $( this ),
				prev = li.data( "ui-tabs-aria-controls" );
			if ( prev ) {
				li
					.attr( "aria-controls", prev )
					.removeData( "ui-tabs-aria-controls" );
			} else {
				li.removeAttr( "aria-controls" );
			}
		} );

		this.panels.show();

		if ( this.options.heightStyle !== "content" ) {
			this.panels.css( "height", "" );
		}
	},

	enable: function( index ) {
		var disabled = this.options.disabled;
		if ( disabled === false ) {
			return;
		}

		if ( index === undefined ) {
			disabled = false;
		} else {
			index = this._getIndex( index );
			if ( $.isArray( disabled ) ) {
				disabled = $.map( disabled, function( num ) {
					return num !== index ? num : null;
				} );
			} else {
				disabled = $.map( this.tabs, function( li, num ) {
					return num !== index ? num : null;
				} );
			}
		}
		this._setOptionDisabled( disabled );
	},

	disable: function( index ) {
		var disabled = this.options.disabled;
		if ( disabled === true ) {
			return;
		}

		if ( index === undefined ) {
			disabled = true;
		} else {
			index = this._getIndex( index );
			if ( $.inArray( index, disabled ) !== -1 ) {
				return;
			}
			if ( $.isArray( disabled ) ) {
				disabled = $.merge( [ index ], disabled ).sort();
			} else {
				disabled = [ index ];
			}
		}
		this._setOptionDisabled( disabled );
	},

	load: function( index, event ) {
		index = this._getIndex( index );
		var that = this,
			tab = this.tabs.eq( index ),
			anchor = tab.find( ".ui-tabs-anchor" ),
			panel = this._getPanelForTab( tab ),
			eventData = {
				tab: tab,
				panel: panel
			},
			complete = function( jqXHR, status ) {
				if ( status === "abort" ) {
					that.panels.stop( false, true );
				}

				that._removeClass( tab, "ui-tabs-loading" );
				panel.removeAttr( "aria-busy" );

				if ( jqXHR === that.xhr ) {
					delete that.xhr;
				}
			};

		// Not remote
		if ( this._isLocal( anchor[ 0 ] ) ) {
			return;
		}

		this.xhr = $.ajax( this._ajaxSettings( anchor, event, eventData ) );

		// Support: jQuery <1.8
		// jQuery <1.8 returns false if the request is canceled in beforeSend,
		// but as of 1.8, $.ajax() always returns a jqXHR object.
		if ( this.xhr && this.xhr.statusText !== "canceled" ) {
			this._addClass( tab, "ui-tabs-loading" );
			panel.attr( "aria-busy", "true" );

			this.xhr
				.done( function( response, status, jqXHR ) {

					// support: jQuery <1.8
					// http://bugs.jquery.com/ticket/11778
					setTimeout( function() {
						panel.html( response );
						that._trigger( "load", event, eventData );

						complete( jqXHR, status );
					}, 1 );
				} )
				.fail( function( jqXHR, status ) {

					// support: jQuery <1.8
					// http://bugs.jquery.com/ticket/11778
					setTimeout( function() {
						complete( jqXHR, status );
					}, 1 );
				} );
		}
	},

	_ajaxSettings: function( anchor, event, eventData ) {
		var that = this;
		return {
			url: anchor.attr( "href" ),
			beforeSend: function( jqXHR, settings ) {
				return that._trigger( "beforeLoad", event,
					$.extend( { jqXHR: jqXHR, ajaxSettings: settings }, eventData ) );
			}
		};
	},

	_getPanelForTab: function( tab ) {
		var id = $( tab ).attr( "aria-controls" );
		return this.element.find( this._sanitizeSelector( "#" + id ) );
	}
} );

// DEPRECATED
// TODO: Switch return back to widget declaration at top of file when this is removed
if ( $.uiBackCompat !== false ) {

	// Backcompat for ui-tab class (now ui-tabs-tab)
	$.widget( "ui.tabs", $.ui.tabs, {
		_processTabs: function() {
			this._superApply( arguments );
			this._addClass( this.tabs, "ui-tab" );
		}
	} );
}

var widgetsTabs = $.ui.tabs;


/*!
 * jQuery UI Tooltip 1.12.0
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Tooltip
//>>group: Widgets
//>>description: Shows additional information for any element on hover or focus.
//>>docs: http://api.jqueryui.com/tooltip/
//>>demos: http://jqueryui.com/tooltip/
//>>css.structure: ../../themes/base/core.css
//>>css.structure: ../../themes/base/tooltip.css
//>>css.theme: ../../themes/base/theme.css



$.widget( "ui.tooltip", {
	version: "1.12.0",
	options: {
		classes: {
			"ui-tooltip": "ui-corner-all ui-widget-shadow"
		},
		content: function() {

			// support: IE<9, Opera in jQuery <1.7
			// .text() can't accept undefined, so coerce to a string
			var title = $( this ).attr( "title" ) || "";

			// Escape title, since we're going from an attribute to raw HTML
			return $( "<a>" ).text( title ).html();
		},
		hide: true,

		// Disabled elements have inconsistent behavior across browsers (#8661)
		items: "[title]:not([disabled])",
		position: {
			my: "left top+15",
			at: "left bottom",
			collision: "flipfit flip"
		},
		show: true,
		track: false,

		// Callbacks
		close: null,
		open: null
	},

	_addDescribedBy: function( elem, id ) {
		var describedby = ( elem.attr( "aria-describedby" ) || "" ).split( /\s+/ );
		describedby.push( id );
		elem
			.data( "ui-tooltip-id", id )
			.attr( "aria-describedby", $.trim( describedby.join( " " ) ) );
	},

	_removeDescribedBy: function( elem ) {
		var id = elem.data( "ui-tooltip-id" ),
			describedby = ( elem.attr( "aria-describedby" ) || "" ).split( /\s+/ ),
			index = $.inArray( id, describedby );

		if ( index !== -1 ) {
			describedby.splice( index, 1 );
		}

		elem.removeData( "ui-tooltip-id" );
		describedby = $.trim( describedby.join( " " ) );
		if ( describedby ) {
			elem.attr( "aria-describedby", describedby );
		} else {
			elem.removeAttr( "aria-describedby" );
		}
	},

	_create: function() {
		this._on( {
			mouseover: "open",
			focusin: "open"
		} );

		// IDs of generated tooltips, needed for destroy
		this.tooltips = {};

		// IDs of parent tooltips where we removed the title attribute
		this.parents = {};

		// Append the aria-live region so tooltips announce correctly
		this.liveRegion = $( "<div>" )
			.attr( {
				role: "log",
				"aria-live": "assertive",
				"aria-relevant": "additions"
			} )
			.appendTo( this.document[ 0 ].body );
		this._addClass( this.liveRegion, null, "ui-helper-hidden-accessible" );

		this.disabledTitles = $( [] );
	},

	_setOption: function( key, value ) {
		var that = this;

		this._super( key, value );

		if ( key === "content" ) {
			$.each( this.tooltips, function( id, tooltipData ) {
				that._updateContent( tooltipData.element );
			} );
		}
	},

	_setOptionDisabled: function( value ) {
		this[ value ? "_disable" : "_enable" ]();
	},

	_disable: function() {
		var that = this;

		// Close open tooltips
		$.each( this.tooltips, function( id, tooltipData ) {
			var event = $.Event( "blur" );
			event.target = event.currentTarget = tooltipData.element[ 0 ];
			that.close( event, true );
		} );

		// Remove title attributes to prevent native tooltips
		this.disabledTitles = this.disabledTitles.add(
			this.element.find( this.options.items ).addBack()
				.filter( function() {
					var element = $( this );
					if ( element.is( "[title]" ) ) {
						return element
							.data( "ui-tooltip-title", element.attr( "title" ) )
							.removeAttr( "title" );
					}
				} )
		);
	},

	_enable: function() {

		// restore title attributes
		this.disabledTitles.each( function() {
			var element = $( this );
			if ( element.data( "ui-tooltip-title" ) ) {
				element.attr( "title", element.data( "ui-tooltip-title" ) );
			}
		} );
		this.disabledTitles = $( [] );
	},

	open: function( event ) {
		var that = this,
			target = $( event ? event.target : this.element )

				// we need closest here due to mouseover bubbling,
				// but always pointing at the same event target
				.closest( this.options.items );

		// No element to show a tooltip for or the tooltip is already open
		if ( !target.length || target.data( "ui-tooltip-id" ) ) {
			return;
		}

		if ( target.attr( "title" ) ) {
			target.data( "ui-tooltip-title", target.attr( "title" ) );
		}

		target.data( "ui-tooltip-open", true );

		// Kill parent tooltips, custom or native, for hover
		if ( event && event.type === "mouseover" ) {
			target.parents().each( function() {
				var parent = $( this ),
					blurEvent;
				if ( parent.data( "ui-tooltip-open" ) ) {
					blurEvent = $.Event( "blur" );
					blurEvent.target = blurEvent.currentTarget = this;
					that.close( blurEvent, true );
				}
				if ( parent.attr( "title" ) ) {
					parent.uniqueId();
					that.parents[ this.id ] = {
						element: this,
						title: parent.attr( "title" )
					};
					parent.attr( "title", "" );
				}
			} );
		}

		this._registerCloseHandlers( event, target );
		this._updateContent( target, event );
	},

	_updateContent: function( target, event ) {
		var content,
			contentOption = this.options.content,
			that = this,
			eventType = event ? event.type : null;

		if ( typeof contentOption === "string" || contentOption.nodeType ||
				contentOption.jquery ) {
			return this._open( event, target, contentOption );
		}

		content = contentOption.call( target[ 0 ], function( response ) {

			// IE may instantly serve a cached response for ajax requests
			// delay this call to _open so the other call to _open runs first
			that._delay( function() {

				// Ignore async response if tooltip was closed already
				if ( !target.data( "ui-tooltip-open" ) ) {
					return;
				}

				// JQuery creates a special event for focusin when it doesn't
				// exist natively. To improve performance, the native event
				// object is reused and the type is changed. Therefore, we can't
				// rely on the type being correct after the event finished
				// bubbling, so we set it back to the previous value. (#8740)
				if ( event ) {
					event.type = eventType;
				}
				this._open( event, target, response );
			} );
		} );
		if ( content ) {
			this._open( event, target, content );
		}
	},

	_open: function( event, target, content ) {
		var tooltipData, tooltip, delayedShow, a11yContent,
			positionOption = $.extend( {}, this.options.position );

		if ( !content ) {
			return;
		}

		// Content can be updated multiple times. If the tooltip already
		// exists, then just update the content and bail.
		tooltipData = this._find( target );
		if ( tooltipData ) {
			tooltipData.tooltip.find( ".ui-tooltip-content" ).html( content );
			return;
		}

		// If we have a title, clear it to prevent the native tooltip
		// we have to check first to avoid defining a title if none exists
		// (we don't want to cause an element to start matching [title])
		//
		// We use removeAttr only for key events, to allow IE to export the correct
		// accessible attributes. For mouse events, set to empty string to avoid
		// native tooltip showing up (happens only when removing inside mouseover).
		if ( target.is( "[title]" ) ) {
			if ( event && event.type === "mouseover" ) {
				target.attr( "title", "" );
			} else {
				target.removeAttr( "title" );
			}
		}

		tooltipData = this._tooltip( target );
		tooltip = tooltipData.tooltip;
		this._addDescribedBy( target, tooltip.attr( "id" ) );
		tooltip.find( ".ui-tooltip-content" ).html( content );

		// Support: Voiceover on OS X, JAWS on IE <= 9
		// JAWS announces deletions even when aria-relevant="additions"
		// Voiceover will sometimes re-read the entire log region's contents from the beginning
		this.liveRegion.children().hide();
		a11yContent = $( "<div>" ).html( tooltip.find( ".ui-tooltip-content" ).html() );
		a11yContent.removeAttr( "name" ).find( "[name]" ).removeAttr( "name" );
		a11yContent.removeAttr( "id" ).find( "[id]" ).removeAttr( "id" );
		a11yContent.appendTo( this.liveRegion );

		function position( event ) {
			positionOption.of = event;
			if ( tooltip.is( ":hidden" ) ) {
				return;
			}
			tooltip.position( positionOption );
		}
		if ( this.options.track && event && /^mouse/.test( event.type ) ) {
			this._on( this.document, {
				mousemove: position
			} );

			// trigger once to override element-relative positioning
			position( event );
		} else {
			tooltip.position( $.extend( {
				of: target
			}, this.options.position ) );
		}

		tooltip.hide();

		this._show( tooltip, this.options.show );

		// Handle tracking tooltips that are shown with a delay (#8644). As soon
		// as the tooltip is visible, position the tooltip using the most recent
		// event.
		// Adds the check to add the timers only when both delay and track options are set (#14682)
		if ( this.options.track && this.options.show && this.options.show.delay ) {
			delayedShow = this.delayedShow = setInterval( function() {
				if ( tooltip.is( ":visible" ) ) {
					position( positionOption.of );
					clearInterval( delayedShow );
				}
			}, $.fx.interval );
		}

		this._trigger( "open", event, { tooltip: tooltip } );
	},

	_registerCloseHandlers: function( event, target ) {
		var events = {
			keyup: function( event ) {
				if ( event.keyCode === $.ui.keyCode.ESCAPE ) {
					var fakeEvent = $.Event( event );
					fakeEvent.currentTarget = target[ 0 ];
					this.close( fakeEvent, true );
				}
			}
		};

		// Only bind remove handler for delegated targets. Non-delegated
		// tooltips will handle this in destroy.
		if ( target[ 0 ] !== this.element[ 0 ] ) {
			events.remove = function() {
				this._removeTooltip( this._find( target ).tooltip );
			};
		}

		if ( !event || event.type === "mouseover" ) {
			events.mouseleave = "close";
		}
		if ( !event || event.type === "focusin" ) {
			events.focusout = "close";
		}
		this._on( true, target, events );
	},

	close: function( event ) {
		var tooltip,
			that = this,
			target = $( event ? event.currentTarget : this.element ),
			tooltipData = this._find( target );

		// The tooltip may already be closed
		if ( !tooltipData ) {

			// We set ui-tooltip-open immediately upon open (in open()), but only set the
			// additional data once there's actually content to show (in _open()). So even if the
			// tooltip doesn't have full data, we always remove ui-tooltip-open in case we're in
			// the period between open() and _open().
			target.removeData( "ui-tooltip-open" );
			return;
		}

		tooltip = tooltipData.tooltip;

		// Disabling closes the tooltip, so we need to track when we're closing
		// to avoid an infinite loop in case the tooltip becomes disabled on close
		if ( tooltipData.closing ) {
			return;
		}

		// Clear the interval for delayed tracking tooltips
		clearInterval( this.delayedShow );

		// Only set title if we had one before (see comment in _open())
		// If the title attribute has changed since open(), don't restore
		if ( target.data( "ui-tooltip-title" ) && !target.attr( "title" ) ) {
			target.attr( "title", target.data( "ui-tooltip-title" ) );
		}

		this._removeDescribedBy( target );

		tooltipData.hiding = true;
		tooltip.stop( true );
		this._hide( tooltip, this.options.hide, function() {
			that._removeTooltip( $( this ) );
		} );

		target.removeData( "ui-tooltip-open" );
		this._off( target, "mouseleave focusout keyup" );

		// Remove 'remove' binding only on delegated targets
		if ( target[ 0 ] !== this.element[ 0 ] ) {
			this._off( target, "remove" );
		}
		this._off( this.document, "mousemove" );

		if ( event && event.type === "mouseleave" ) {
			$.each( this.parents, function( id, parent ) {
				$( parent.element ).attr( "title", parent.title );
				delete that.parents[ id ];
			} );
		}

		tooltipData.closing = true;
		this._trigger( "close", event, { tooltip: tooltip } );
		if ( !tooltipData.hiding ) {
			tooltipData.closing = false;
		}
	},

	_tooltip: function( element ) {
		var tooltip = $( "<div>" ).attr( "role", "tooltip" ),
			content = $( "<div>" ).appendTo( tooltip ),
			id = tooltip.uniqueId().attr( "id" );

		this._addClass( content, "ui-tooltip-content" );
		this._addClass( tooltip, "ui-tooltip", "ui-widget ui-widget-content" );

		tooltip.appendTo( this._appendTo( element ) );

		return this.tooltips[ id ] = {
			element: element,
			tooltip: tooltip
		};
	},

	_find: function( target ) {
		var id = target.data( "ui-tooltip-id" );
		return id ? this.tooltips[ id ] : null;
	},

	_removeTooltip: function( tooltip ) {
		tooltip.remove();
		delete this.tooltips[ tooltip.attr( "id" ) ];
	},

	_appendTo: function( target ) {
		var element = target.closest( ".ui-front, dialog" );

		if ( !element.length ) {
			element = this.document[ 0 ].body;
		}

		return element;
	},

	_destroy: function() {
		var that = this;

		// Close open tooltips
		$.each( this.tooltips, function( id, tooltipData ) {

			// Delegate to close method to handle common cleanup
			var event = $.Event( "blur" ),
				element = tooltipData.element;
			event.target = event.currentTarget = element[ 0 ];
			that.close( event, true );

			// Remove immediately; destroying an open tooltip doesn't use the
			// hide animation
			$( "#" + id ).remove();

			// Restore the title
			if ( element.data( "ui-tooltip-title" ) ) {

				// If the title attribute has changed since open(), don't restore
				if ( !element.attr( "title" ) ) {
					element.attr( "title", element.data( "ui-tooltip-title" ) );
				}
				element.removeData( "ui-tooltip-title" );
			}
		} );
		this.liveRegion.remove();
	}
} );

// DEPRECATED
// TODO: Switch return back to widget declaration at top of file when this is removed
if ( $.uiBackCompat !== false ) {

	// Backcompat for tooltipClass option
	$.widget( "ui.tooltip", $.ui.tooltip, {
		options: {
			tooltipClass: null
		},
		_tooltip: function() {
			var tooltipData = this._superApply( arguments );
			if ( this.options.tooltipClass ) {
				tooltipData.tooltip.addClass( this.options.tooltipClass );
			}
			return tooltipData;
		}
	} );
}

var widgetsTooltip = $.ui.tooltip;




}));/*
 *  jQuery OwlCarousel v1.3.2
 *
 *  Copyright (c) 2013 Bartosz Wojciechowski
 *  http://www.owlgraphic.com/owlcarousel/
 *
 *  Licensed under MIT
 *
 */

/*JS Lint helpers: */
/*global dragMove: false, dragEnd: false, $, jQuery, alert, window, document */
/*jslint nomen: true, continue:true */

if (typeof Object.create !== "function") {
    Object.create = function (obj) {
        function F() {}
        F.prototype = obj;
        return new F();
    };
}
(function ($, window, document) {

    var Carousel = {
        init : function (options, el) {
            var base = this;

            base.$elem = $(el);
            base.options = $.extend({}, $.fn.owlCarousel.options, base.$elem.data(), options);

            base.userOptions = options;
            base.loadContent();
        },

        loadContent : function () {
            var base = this, url;

            function getData(data) {
                var i, content = "";
                if (typeof base.options.jsonSuccess === "function") {
                    base.options.jsonSuccess.apply(this, [data]);
                } else {
                    for (i in data.owl) {
                        if (data.owl.hasOwnProperty(i)) {
                            content += data.owl[i].item;
                        }
                    }
                    base.$elem.html(content);
                }
                base.logIn();
            }

            if (typeof base.options.beforeInit === "function") {
                base.options.beforeInit.apply(this, [base.$elem]);
            }

            if (typeof base.options.jsonPath === "string") {
                url = base.options.jsonPath;
                $.getJSON(url, getData);
            } else {
                base.logIn();
            }
        },

        logIn : function () {
            var base = this;

            base.$elem.data("owl-originalStyles", base.$elem.attr("style"))
                      .data("owl-originalClasses", base.$elem.attr("class"));

            base.$elem.css({opacity: 0});
            base.orignalItems = base.options.items;
            base.checkBrowser();
            base.wrapperWidth = 0;
            base.checkVisible = null;
            base.setVars();
        },

        setVars : function () {
            var base = this;
            if (base.$elem.children().length === 0) {return false; }
            base.baseClass();
            base.eventTypes();
            base.$userItems = base.$elem.children();
            base.itemsAmount = base.$userItems.length;
            base.wrapItems();
            base.$owlItems = base.$elem.find(".owl-item");
            base.$owlWrapper = base.$elem.find(".owl-wrapper");
            base.playDirection = "next";
            base.prevItem = 0;
            base.prevArr = [0];
            base.currentItem = 0;
            base.customEvents();
            base.onStartup();
        },

        onStartup : function () {
            var base = this;
            base.updateItems();
            base.calculateAll();
            base.buildControls();
            base.updateControls();
            base.response();
            base.moveEvents();
            base.stopOnHover();
            base.owlStatus();

            if (base.options.transitionStyle !== false) {
                base.transitionTypes(base.options.transitionStyle);
            }
            if (base.options.autoPlay === true) {
                base.options.autoPlay = 5000;
            }
            base.play();

            base.$elem.find(".owl-wrapper").css("display", "block");

            if (!base.$elem.is(":visible")) {
                base.watchVisibility();
            } else {
                base.$elem.css("opacity", 1);
            }
            base.onstartup = false;
            base.eachMoveUpdate();
            if (typeof base.options.afterInit === "function") {
                base.options.afterInit.apply(this, [base.$elem]);
            }
        },

        eachMoveUpdate : function () {
            var base = this;

            if (base.options.lazyLoad === true) {
                base.lazyLoad();
            }
            if (base.options.autoHeight === true) {
                base.autoHeight();
            }
            base.onVisibleItems();

            if (typeof base.options.afterAction === "function") {
                base.options.afterAction.apply(this, [base.$elem]);
            }
        },

        updateVars : function () {
            var base = this;
            if (typeof base.options.beforeUpdate === "function") {
                base.options.beforeUpdate.apply(this, [base.$elem]);
            }
            base.watchVisibility();
            base.updateItems();
            base.calculateAll();
            base.updatePosition();
            base.updateControls();
            base.eachMoveUpdate();
            if (typeof base.options.afterUpdate === "function") {
                base.options.afterUpdate.apply(this, [base.$elem]);
            }
        },

        reload : function () {
            var base = this;
            window.setTimeout(function () {
                base.updateVars();
            }, 0);
        },

        watchVisibility : function () {
            var base = this;

            if (base.$elem.is(":visible") === false) {
                base.$elem.css({opacity: 0});
                window.clearInterval(base.autoPlayInterval);
                window.clearInterval(base.checkVisible);
            } else {
                return false;
            }
            base.checkVisible = window.setInterval(function () {
                if (base.$elem.is(":visible")) {
                    base.reload();
                    base.$elem.animate({opacity: 1}, 200);
                    window.clearInterval(base.checkVisible);
                }
            }, 500);
        },

        wrapItems : function () {
            var base = this;
            base.$userItems.wrapAll("<div class=\"owl-wrapper\">").wrap("<div class=\"owl-item\"></div>");
            base.$elem.find(".owl-wrapper").wrap("<div class=\"owl-wrapper-outer\">");
            base.wrapperOuter = base.$elem.find(".owl-wrapper-outer");
            base.$elem.css("display", "block");
        },

        baseClass : function () {
            var base = this,
                hasBaseClass = base.$elem.hasClass(base.options.baseClass),
                hasThemeClass = base.$elem.hasClass(base.options.theme);

            if (!hasBaseClass) {
                base.$elem.addClass(base.options.baseClass);
            }

            if (!hasThemeClass) {
                base.$elem.addClass(base.options.theme);
            }
        },

        updateItems : function () {
            var base = this, width, i;

            if (base.options.responsive === false) {
                return false;
            }
            if (base.options.singleItem === true) {
                base.options.items = base.orignalItems = 1;
                base.options.itemsCustom = false;
                base.options.itemsDesktop = false;
                base.options.itemsDesktopSmall = false;
                base.options.itemsTablet = false;
                base.options.itemsTabletSmall = false;
                base.options.itemsMobile = false;
                return false;
            }

            width = $(base.options.responsiveBaseWidth).width();

            if (width > (base.options.itemsDesktop[0] || base.orignalItems)) {
                base.options.items = base.orignalItems;
            }
            if (base.options.itemsCustom !== false) {
                //Reorder array by screen size
                base.options.itemsCustom.sort(function (a, b) {return a[0] - b[0]; });

                for (i = 0; i < base.options.itemsCustom.length; i += 1) {
                    if (base.options.itemsCustom[i][0] <= width) {
                        base.options.items = base.options.itemsCustom[i][1];
                    }
                }

            } else {

                if (width <= base.options.itemsDesktop[0] && base.options.itemsDesktop !== false) {
                    base.options.items = base.options.itemsDesktop[1];
                }

                if (width <= base.options.itemsDesktopSmall[0] && base.options.itemsDesktopSmall !== false) {
                    base.options.items = base.options.itemsDesktopSmall[1];
                }

                if (width <= base.options.itemsTablet[0] && base.options.itemsTablet !== false) {
                    base.options.items = base.options.itemsTablet[1];
                }

                if (width <= base.options.itemsTabletSmall[0] && base.options.itemsTabletSmall !== false) {
                    base.options.items = base.options.itemsTabletSmall[1];
                }

                if (width <= base.options.itemsMobile[0] && base.options.itemsMobile !== false) {
                    base.options.items = base.options.itemsMobile[1];
                }
            }

            //if number of items is less than declared
            if (base.options.items > base.itemsAmount && base.options.itemsScaleUp === true) {
                base.options.items = base.itemsAmount;
            }
        },

        response : function () {
            var base = this,
                smallDelay,
                lastWindowWidth;

            if (base.options.responsive !== true) {
                return false;
            }
            lastWindowWidth = $(window).width();

            base.resizer = function () {
                if ($(window).width() !== lastWindowWidth) {
                    if (base.options.autoPlay !== false) {
                        window.clearInterval(base.autoPlayInterval);
                    }
                    window.clearTimeout(smallDelay);
                    smallDelay = window.setTimeout(function () {
                        lastWindowWidth = $(window).width();
                        base.updateVars();
                    }, base.options.responsiveRefreshRate);
                }
            };
            $(window).resize(base.resizer);
        },

        updatePosition : function () {
            var base = this;
            base.jumpTo(base.currentItem);
            if (base.options.autoPlay !== false) {
                base.checkAp();
            }
        },

        appendItemsSizes : function () {
            var base = this,
                roundPages = 0,
                lastItem = base.itemsAmount - base.options.items;

            base.$owlItems.each(function (index) {
                var $this = $(this);
                $this
                    .css({"width": base.itemWidth})
                    .data("owl-item", Number(index));

                if (index % base.options.items === 0 || index === lastItem) {
                    if (!(index > lastItem)) {
                        roundPages += 1;
                    }
                }
                $this.data("owl-roundPages", roundPages);
            });
        },

        appendWrapperSizes : function () {
            var base = this,
                width = base.$owlItems.length * base.itemWidth;

            base.$owlWrapper.css({
                "width": width * 2,
                "left": 0
            });
            base.appendItemsSizes();
        },

        calculateAll : function () {
            var base = this;
            base.calculateWidth();
            base.appendWrapperSizes();
            base.loops();
            base.max();
        },

        calculateWidth : function () {
            var base = this;
            base.itemWidth = Math.round(base.$elem.width() / base.options.items);
        },

        max : function () {
            var base = this,
                maximum = ((base.itemsAmount * base.itemWidth) - base.options.items * base.itemWidth) * -1;
            if (base.options.items > base.itemsAmount) {
                base.maximumItem = 0;
                maximum = 0;
                base.maximumPixels = 0;
            } else {
                base.maximumItem = base.itemsAmount - base.options.items;
                base.maximumPixels = maximum;
            }
            return maximum;
        },

        min : function () {
            return 0;
        },

        loops : function () {
            var base = this,
                prev = 0,
                elWidth = 0,
                i,
                item,
                roundPageNum;

            base.positionsInArray = [0];
            base.pagesInArray = [];

            for (i = 0; i < base.itemsAmount; i += 1) {
                elWidth += base.itemWidth;
                base.positionsInArray.push(-elWidth);

                if (base.options.scrollPerPage === true) {
                    item = $(base.$owlItems[i]);
                    roundPageNum = item.data("owl-roundPages");
                    if (roundPageNum !== prev) {
                        base.pagesInArray[prev] = base.positionsInArray[i];
                        prev = roundPageNum;
                    }
                }
            }
        },

        buildControls : function () {
            var base = this;
            if (base.options.navigation === true || base.options.pagination === true) {
                base.owlControls = $("<div class=\"owl-controls\"/>").toggleClass("clickable", !base.browser.isTouch).appendTo(base.$elem);
            }
            if (base.options.pagination === true) {
                base.buildPagination();
            }
            if (base.options.navigation === true) {
                base.buildButtons();
            }
        },

        buildButtons : function () {
            var base = this,
                buttonsWrapper = $("<div class=\"owl-buttons\"/>");
            base.owlControls.append(buttonsWrapper);

            base.buttonPrev = $("<div/>", {
                "class" : "owl-prev",
                "html" : base.options.navigationText[0] || ""
            });

            base.buttonNext = $("<div/>", {
                "class" : "owl-next",
                "html" : base.options.navigationText[1] || ""
            });

            buttonsWrapper
                .append(base.buttonPrev)
                .append(base.buttonNext);

            buttonsWrapper.on("touchstart.owlControls mousedown.owlControls", "div[class^=\"owl\"]", function (event) {
                event.preventDefault();
            });

            buttonsWrapper.on("touchend.owlControls mouseup.owlControls", "div[class^=\"owl\"]", function (event) {
                event.preventDefault();
                if ($(this).hasClass("owl-next")) {
                    base.next();
                } else {
                    base.prev();
                }
            });
        },

        buildPagination : function () {
            var base = this;

            base.paginationWrapper = $("<div class=\"owl-pagination\"/>");
            base.owlControls.append(base.paginationWrapper);

            base.paginationWrapper.on("touchend.owlControls mouseup.owlControls", ".owl-page", function (event) {
                event.preventDefault();
                if (Number($(this).data("owl-page")) !== base.currentItem) {
                    base.goTo(Number($(this).data("owl-page")), true);
                }
            });
        },

        updatePagination : function () {
            var base = this,
                counter,
                lastPage,
                lastItem,
                i,
                paginationButton,
                paginationButtonInner;

            if (base.options.pagination === false) {
                return false;
            }

            base.paginationWrapper.html("");

            counter = 0;
            lastPage = base.itemsAmount - base.itemsAmount % base.options.items;

            for (i = 0; i < base.itemsAmount; i += 1) {
                if (i % base.options.items === 0) {
                    counter += 1;
                    if (lastPage === i) {
                        lastItem = base.itemsAmount - base.options.items;
                    }
                    paginationButton = $("<div/>", {
                        "class" : "owl-page"
                    });
                    paginationButtonInner = $("<span></span>", {
                        "text": base.options.paginationNumbers === true ? counter : "",
                        "class": base.options.paginationNumbers === true ? "owl-numbers" : ""
                    });
                    paginationButton.append(paginationButtonInner);

                    paginationButton.data("owl-page", lastPage === i ? lastItem : i);
                    paginationButton.data("owl-roundPages", counter);

                    base.paginationWrapper.append(paginationButton);
                }
            }
            base.checkPagination();
        },
        checkPagination : function () {
            var base = this;
            if (base.options.pagination === false) {
                return false;
            }
            base.paginationWrapper.find(".owl-page").each(function () {
                if ($(this).data("owl-roundPages") === $(base.$owlItems[base.currentItem]).data("owl-roundPages")) {
                    base.paginationWrapper
                        .find(".owl-page")
                        .removeClass("active");
                    $(this).addClass("active");
                }
            });
        },

        checkNavigation : function () {
            var base = this;

            if (base.options.navigation === false) {
                return false;
            }
            if (base.options.rewindNav === false) {
                if (base.currentItem === 0 && base.maximumItem === 0) {
                    base.buttonPrev.addClass("disabled");
                    base.buttonNext.addClass("disabled");
                } else if (base.currentItem === 0 && base.maximumItem !== 0) {
                    base.buttonPrev.addClass("disabled");
                    base.buttonNext.removeClass("disabled");
                } else if (base.currentItem === base.maximumItem) {
                    base.buttonPrev.removeClass("disabled");
                    base.buttonNext.addClass("disabled");
                } else if (base.currentItem !== 0 && base.currentItem !== base.maximumItem) {
                    base.buttonPrev.removeClass("disabled");
                    base.buttonNext.removeClass("disabled");
                }
            }
        },

        updateControls : function () {
            var base = this;
            base.updatePagination();
            base.checkNavigation();
            if (base.owlControls) {
                if (base.options.items >= base.itemsAmount) {
                    base.owlControls.hide();
                } else {
                    base.owlControls.show();
                }
            }
        },

        destroyControls : function () {
            var base = this;
            if (base.owlControls) {
                base.owlControls.remove();
            }
        },

        next : function (speed) {
            var base = this;

            if (base.isTransition) {
                return false;
            }

            base.currentItem += base.options.scrollPerPage === true ? base.options.items : 1;
            if (base.currentItem > base.maximumItem + (base.options.scrollPerPage === true ? (base.options.items - 1) : 0)) {
                if (base.options.rewindNav === true) {
                    base.currentItem = 0;
                    speed = "rewind";
                } else {
                    base.currentItem = base.maximumItem;
                    return false;
                }
            }
            base.goTo(base.currentItem, speed);
        },

        prev : function (speed) {
            var base = this;

            if (base.isTransition) {
                return false;
            }

            if (base.options.scrollPerPage === true && base.currentItem > 0 && base.currentItem < base.options.items) {
                base.currentItem = 0;
            } else {
                base.currentItem -= base.options.scrollPerPage === true ? base.options.items : 1;
            }
            if (base.currentItem < 0) {
                if (base.options.rewindNav === true) {
                    base.currentItem = base.maximumItem;
                    speed = "rewind";
                } else {
                    base.currentItem = 0;
                    return false;
                }
            }
            base.goTo(base.currentItem, speed);
        },

        goTo : function (position, speed, drag) {
            var base = this,
                goToPixel;

            if (base.isTransition) {
                return false;
            }
            if (typeof base.options.beforeMove === "function") {
                base.options.beforeMove.apply(this, [base.$elem]);
            }
            if (position >= base.maximumItem) {
                position = base.maximumItem;
            } else if (position <= 0) {
                position = 0;
            }

            base.currentItem = base.owl.currentItem = position;
            if (base.options.transitionStyle !== false && drag !== "drag" && base.options.items === 1 && base.browser.support3d === true) {
                base.swapSpeed(0);
                if (base.browser.support3d === true) {
                    base.transition3d(base.positionsInArray[position]);
                } else {
                    base.css2slide(base.positionsInArray[position], 1);
                }
                base.afterGo();
                base.singleItemTransition();
                return false;
            }
            goToPixel = base.positionsInArray[position];

            if (base.browser.support3d === true) {
                base.isCss3Finish = false;

                if (speed === true) {
                    base.swapSpeed("paginationSpeed");
                    window.setTimeout(function () {
                        base.isCss3Finish = true;
                    }, base.options.paginationSpeed);

                } else if (speed === "rewind") {
                    base.swapSpeed(base.options.rewindSpeed);
                    window.setTimeout(function () {
                        base.isCss3Finish = true;
                    }, base.options.rewindSpeed);

                } else {
                    base.swapSpeed("slideSpeed");
                    window.setTimeout(function () {
                        base.isCss3Finish = true;
                    }, base.options.slideSpeed);
                }
                base.transition3d(goToPixel);
            } else {
                if (speed === true) {
                    base.css2slide(goToPixel, base.options.paginationSpeed);
                } else if (speed === "rewind") {
                    base.css2slide(goToPixel, base.options.rewindSpeed);
                } else {
                    base.css2slide(goToPixel, base.options.slideSpeed);
                }
            }
            base.afterGo();
        },

        jumpTo : function (position) {
            var base = this;
            if (typeof base.options.beforeMove === "function") {
                base.options.beforeMove.apply(this, [base.$elem]);
            }
            if (position >= base.maximumItem || position === -1) {
                position = base.maximumItem;
            } else if (position <= 0) {
                position = 0;
            }
            base.swapSpeed(0);
            if (base.browser.support3d === true) {
                base.transition3d(base.positionsInArray[position]);
            } else {
                base.css2slide(base.positionsInArray[position], 1);
            }
            base.currentItem = base.owl.currentItem = position;
            base.afterGo();
        },

        afterGo : function () {
            var base = this;

            base.prevArr.push(base.currentItem);
            base.prevItem = base.owl.prevItem = base.prevArr[base.prevArr.length - 2];
            base.prevArr.shift(0);

            if (base.prevItem !== base.currentItem) {
                base.checkPagination();
                base.checkNavigation();
                base.eachMoveUpdate();

                if (base.options.autoPlay !== false) {
                    base.checkAp();
                }
            }
            if (typeof base.options.afterMove === "function" && base.prevItem !== base.currentItem) {
                base.options.afterMove.apply(this, [base.$elem]);
            }
        },

        stop : function () {
            var base = this;
            base.apStatus = "stop";
            window.clearInterval(base.autoPlayInterval);
        },

        checkAp : function () {
            var base = this;
            if (base.apStatus !== "stop") {
                base.play();
            }
        },

        play : function () {
            var base = this;
            base.apStatus = "play";
            if (base.options.autoPlay === false) {
                return false;
            }
            window.clearInterval(base.autoPlayInterval);
            base.autoPlayInterval = window.setInterval(function () {
                base.next(true);
            }, base.options.autoPlay);
        },

        swapSpeed : function (action) {
            var base = this;
            if (action === "slideSpeed") {
                base.$owlWrapper.css(base.addCssSpeed(base.options.slideSpeed));
            } else if (action === "paginationSpeed") {
                base.$owlWrapper.css(base.addCssSpeed(base.options.paginationSpeed));
            } else if (typeof action !== "string") {
                base.$owlWrapper.css(base.addCssSpeed(action));
            }
        },

        addCssSpeed : function (speed) {
            return {
                "-webkit-transition": "all " + speed + "ms ease",
                "-moz-transition": "all " + speed + "ms ease",
                "-o-transition": "all " + speed + "ms ease",
                "transition": "all " + speed + "ms ease"
            };
        },

        removeTransition : function () {
            return {
                "-webkit-transition": "",
                "-moz-transition": "",
                "-o-transition": "",
                "transition": ""
            };
        },

        doTranslate : function (pixels) {
            return {
                "-webkit-transform": "translate3d(" + pixels + "px, 0px, 0px)",
                "-moz-transform": "translate3d(" + pixels + "px, 0px, 0px)",
                "-o-transform": "translate3d(" + pixels + "px, 0px, 0px)",
                "-ms-transform": "translate3d(" + pixels + "px, 0px, 0px)",
                "transform": "translate3d(" + pixels + "px, 0px,0px)"
            };
        },

        transition3d : function (value) {
            var base = this;
            base.$owlWrapper.css(base.doTranslate(value));
        },

        css2move : function (value) {
            var base = this;
            base.$owlWrapper.css({"left" : value});
        },

        css2slide : function (value, speed) {
            var base = this;

            base.isCssFinish = false;
            base.$owlWrapper.stop(true, true).animate({
                "left" : value
            }, {
                duration : speed || base.options.slideSpeed,
                complete : function () {
                    base.isCssFinish = true;
                }
            });
        },

        checkBrowser : function () {
            var base = this,
                translate3D = "translate3d(0px, 0px, 0px)",
                tempElem = document.createElement("div"),
                regex,
                asSupport,
                support3d,
                isTouch;

            tempElem.style.cssText = "  -moz-transform:" + translate3D +
                                  "; -ms-transform:"     + translate3D +
                                  "; -o-transform:"      + translate3D +
                                  "; -webkit-transform:" + translate3D +
                                  "; transform:"         + translate3D;
            regex = /translate3d\(0px, 0px, 0px\)/g;
            asSupport = tempElem.style.cssText.match(regex);
            support3d = (asSupport !== null && asSupport.length === 1);

            isTouch = "ontouchstart" in window || window.navigator.msMaxTouchPoints;

            base.browser = {
                "support3d" : support3d,
                "isTouch" : isTouch
            };
        },

        moveEvents : function () {
            var base = this;
            if (base.options.mouseDrag !== false || base.options.touchDrag !== false) {
                base.gestures();
                base.disabledEvents();
            }
        },

        eventTypes : function () {
            var base = this,
                types = ["s", "e", "x"];

            base.ev_types = {};

            if (base.options.mouseDrag === true && base.options.touchDrag === true) {
                types = [
                    "touchstart.owl mousedown.owl",
                    "touchmove.owl mousemove.owl",
                    "touchend.owl touchcancel.owl mouseup.owl"
                ];
            } else if (base.options.mouseDrag === false && base.options.touchDrag === true) {
                types = [
                    "touchstart.owl",
                    "touchmove.owl",
                    "touchend.owl touchcancel.owl"
                ];
            } else if (base.options.mouseDrag === true && base.options.touchDrag === false) {
                types = [
                    "mousedown.owl",
                    "mousemove.owl",
                    "mouseup.owl"
                ];
            }

            base.ev_types.start = types[0];
            base.ev_types.move = types[1];
            base.ev_types.end = types[2];
        },

        disabledEvents :  function () {
            var base = this;
            base.$elem.on("dragstart.owl", function (event) { event.preventDefault(); });
            base.$elem.on("mousedown.disableTextSelect", function (e) {
                return $(e.target).is('input, textarea, select, option');
            });
        },

        gestures : function () {
            /*jslint unparam: true*/
            var base = this,
                locals = {
                    offsetX : 0,
                    offsetY : 0,
                    baseElWidth : 0,
                    relativePos : 0,
                    position: null,
                    minSwipe : null,
                    maxSwipe: null,
                    sliding : null,
                    dargging: null,
                    targetElement : null
                };

            base.isCssFinish = true;

            function getTouches(event) {
                if (event.touches !== undefined) {
                    return {
                        x : event.touches[0].pageX,
                        y : event.touches[0].pageY
                    };
                }

                if (event.touches === undefined) {
                    if (event.pageX !== undefined) {
                        return {
                            x : event.pageX,
                            y : event.pageY
                        };
                    }
                    if (event.pageX === undefined) {
                        return {
                            x : event.clientX,
                            y : event.clientY
                        };
                    }
                }
            }

            function swapEvents(type) {
                if (type === "on") {
                    $(document).on(base.ev_types.move, dragMove);
                    $(document).on(base.ev_types.end, dragEnd);
                } else if (type === "off") {
                    $(document).off(base.ev_types.move);
                    $(document).off(base.ev_types.end);
                }
            }

            function dragStart(event) {
                var ev = event.originalEvent || event || window.event,
                    position;

                if (ev.which === 3) {
                    return false;
                }
                if (base.itemsAmount <= base.options.items) {
                    return;
                }
                if (base.isCssFinish === false && !base.options.dragBeforeAnimFinish) {
                    return false;
                }
                if (base.isCss3Finish === false && !base.options.dragBeforeAnimFinish) {
                    return false;
                }

                if (base.options.autoPlay !== false) {
                    window.clearInterval(base.autoPlayInterval);
                }

                if (base.browser.isTouch !== true && !base.$owlWrapper.hasClass("grabbing")) {
                    base.$owlWrapper.addClass("grabbing");
                }

                base.newPosX = 0;
                base.newRelativeX = 0;

                $(this).css(base.removeTransition());

                position = $(this).position();
                locals.relativePos = position.left;

                locals.offsetX = getTouches(ev).x - position.left;
                locals.offsetY = getTouches(ev).y - position.top;

                swapEvents("on");

                locals.sliding = false;
                locals.targetElement = ev.target || ev.srcElement;
            }

            function dragMove(event) {
                var ev = event.originalEvent || event || window.event,
                    minSwipe,
                    maxSwipe;

                base.newPosX = getTouches(ev).x - locals.offsetX;
                base.newPosY = getTouches(ev).y - locals.offsetY;
                base.newRelativeX = base.newPosX - locals.relativePos;

                if (typeof base.options.startDragging === "function" && locals.dragging !== true && base.newRelativeX !== 0) {
                    locals.dragging = true;
                    base.options.startDragging.apply(base, [base.$elem]);
                }

                if ((base.newRelativeX > 8 || base.newRelativeX < -8) && (base.browser.isTouch === true)) {
                    if (ev.preventDefault !== undefined) {
                        ev.preventDefault();
                    } else {
                        ev.returnValue = false;
                    }
                    locals.sliding = true;
                }

                if ((base.newPosY > 10 || base.newPosY < -10) && locals.sliding === false) {
                    $(document).off("touchmove.owl");
                }

                minSwipe = function () {
                    return base.newRelativeX / 5;
                };

                maxSwipe = function () {
                    return base.maximumPixels + base.newRelativeX / 5;
                };

                base.newPosX = Math.max(Math.min(base.newPosX, minSwipe()), maxSwipe());
                if (base.browser.support3d === true) {
                    base.transition3d(base.newPosX);
                } else {
                    base.css2move(base.newPosX);
                }
            }

            function dragEnd(event) {
                var ev = event.originalEvent || event || window.event,
                    newPosition,
                    handlers,
                    owlStopEvent;

                ev.target = ev.target || ev.srcElement;

                locals.dragging = false;

                if (base.browser.isTouch !== true) {
                    base.$owlWrapper.removeClass("grabbing");
                }

                if (base.newRelativeX < 0) {
                    base.dragDirection = base.owl.dragDirection = "left";
                } else {
                    base.dragDirection = base.owl.dragDirection = "right";
                }

                if (base.newRelativeX !== 0) {
                    newPosition = base.getNewPosition();
                    base.goTo(newPosition, false, "drag");
                    if (locals.targetElement === ev.target && base.browser.isTouch !== true) {
                        $(ev.target).on("click.disable", function (ev) {
                            ev.stopImmediatePropagation();
                            ev.stopPropagation();
                            ev.preventDefault();
                            $(ev.target).off("click.disable");
                        });
                        handlers = $._data(ev.target, "events").click;
                        owlStopEvent = handlers.pop();
                        handlers.splice(0, 0, owlStopEvent);
                    }
                }
                swapEvents("off");
            }
            base.$elem.on(base.ev_types.start, ".owl-wrapper", dragStart);
        },

        getNewPosition : function () {
            var base = this,
                newPosition = base.closestItem();

            if (newPosition > base.maximumItem) {
                base.currentItem = base.maximumItem;
                newPosition  = base.maximumItem;
            } else if (base.newPosX >= 0) {
                newPosition = 0;
                base.currentItem = 0;
            }
            return newPosition;
        },
        closestItem : function () {
            var base = this,
                array = base.options.scrollPerPage === true ? base.pagesInArray : base.positionsInArray,
                goal = base.newPosX,
                closest = null;

            $.each(array, function (i, v) {
                if (goal - (base.itemWidth / 20) > array[i + 1] && goal - (base.itemWidth / 20) < v && base.moveDirection() === "left") {
                    closest = v;
                    if (base.options.scrollPerPage === true) {
                        base.currentItem = $.inArray(closest, base.positionsInArray);
                    } else {
                        base.currentItem = i;
                    }
                } else if (goal + (base.itemWidth / 20) < v && goal + (base.itemWidth / 20) > (array[i + 1] || array[i] - base.itemWidth) && base.moveDirection() === "right") {
                    if (base.options.scrollPerPage === true) {
                        closest = array[i + 1] || array[array.length - 1];
                        base.currentItem = $.inArray(closest, base.positionsInArray);
                    } else {
                        closest = array[i + 1];
                        base.currentItem = i + 1;
                    }
                }
            });
            return base.currentItem;
        },

        moveDirection : function () {
            var base = this,
                direction;
            if (base.newRelativeX < 0) {
                direction = "right";
                base.playDirection = "next";
            } else {
                direction = "left";
                base.playDirection = "prev";
            }
            return direction;
        },

        customEvents : function () {
            /*jslint unparam: true*/
            var base = this;
            base.$elem.on("owl.next", function () {
                base.next();
            });
            base.$elem.on("owl.prev", function () {
                base.prev();
            });
            base.$elem.on("owl.play", function (event, speed) {
                base.options.autoPlay = speed;
                base.play();
                base.hoverStatus = "play";
            });
            base.$elem.on("owl.stop", function () {
                base.stop();
                base.hoverStatus = "stop";
            });
            base.$elem.on("owl.goTo", function (event, item) {
                base.goTo(item);
            });
            base.$elem.on("owl.jumpTo", function (event, item) {
                base.jumpTo(item);
            });
        },

        stopOnHover : function () {
            var base = this;
            if (base.options.stopOnHover === true && base.browser.isTouch !== true && base.options.autoPlay !== false) {
                base.$elem.on("mouseover", function () {
                    base.stop();
                });
                base.$elem.on("mouseout", function () {
                    if (base.hoverStatus !== "stop") {
                        base.play();
                    }
                });
            }
        },

        lazyLoad : function () {
            var base = this,
                i,
                $item,
                itemNumber,
                $lazyImg,
                follow;

            if (base.options.lazyLoad === false) {
                return false;
            }
            for (i = 0; i < base.itemsAmount; i += 1) {
                $item = $(base.$owlItems[i]);

                if ($item.data("owl-loaded") === "loaded") {
                    continue;
                }

                itemNumber = $item.data("owl-item");
                $lazyImg = $item.find(".lazyOwl");

                if (typeof $lazyImg.data("src") !== "string") {
                    $item.data("owl-loaded", "loaded");
                    continue;
                }
                if ($item.data("owl-loaded") === undefined) {
                    $lazyImg.hide();
                    $item.addClass("loading").data("owl-loaded", "checked");
                }
                if (base.options.lazyFollow === true) {
                    follow = itemNumber >= base.currentItem;
                } else {
                    follow = true;
                }
                if (follow && itemNumber < base.currentItem + base.options.items && $lazyImg.length) {
                    base.lazyPreload($item, $lazyImg);
                }
            }
        },

        lazyPreload : function ($item, $lazyImg) {
            var base = this,
                iterations = 0,
                isBackgroundImg;

            if ($lazyImg.prop("tagName") === "DIV") {
                $lazyImg.css("background-image", "url(" + $lazyImg.data("src") + ")");
                isBackgroundImg = true;
            } else {
                $lazyImg[0].src = $lazyImg.data("src");
            }

            function showImage() {
                $item.data("owl-loaded", "loaded").removeClass("loading");
                $lazyImg.removeAttr("data-src");
                if (base.options.lazyEffect === "fade") {
                    $lazyImg.fadeIn(400);
                } else {
                    $lazyImg.show();
                }
                if (typeof base.options.afterLazyLoad === "function") {
                    base.options.afterLazyLoad.apply(this, [base.$elem]);
                }
            }

            function checkLazyImage() {
                iterations += 1;
                if (base.completeImg($lazyImg.get(0)) || isBackgroundImg === true) {
                    showImage();
                } else if (iterations <= 100) {//if image loads in less than 10 seconds 
                    window.setTimeout(checkLazyImage, 100);
                } else {
                    showImage();
                }
            }

            checkLazyImage();
        },

        autoHeight : function () {
            var base = this,
                $currentimg = $(base.$owlItems[base.currentItem]).find("img"),
                iterations;

            function addHeight() {
                var $currentItem = $(base.$owlItems[base.currentItem]).height();
                base.wrapperOuter.css("height", $currentItem + "px");
                if (!base.wrapperOuter.hasClass("autoHeight")) {
                    window.setTimeout(function () {
                        base.wrapperOuter.addClass("autoHeight");
                    }, 0);
                }
            }

            function checkImage() {
                iterations += 1;
                if (base.completeImg($currentimg.get(0))) {
                    addHeight();
                } else if (iterations <= 100) { //if image loads in less than 10 seconds 
                    window.setTimeout(checkImage, 100);
                } else {
                    base.wrapperOuter.css("height", ""); //Else remove height attribute
                }
            }

            if ($currentimg.get(0) !== undefined) {
                iterations = 0;
                checkImage();
            } else {
                addHeight();
            }
        },

        completeImg : function (img) {
            var naturalWidthType;

            if (!img.complete) {
                return false;
            }
            naturalWidthType = typeof img.naturalWidth;
            if (naturalWidthType !== "undefined" && img.naturalWidth === 0) {
                return false;
            }
            return true;
        },

        onVisibleItems : function () {
            var base = this,
                i;

            if (base.options.addClassActive === true) {
                base.$owlItems.removeClass("active");
            }
            base.visibleItems = [];
            for (i = base.currentItem; i < base.currentItem + base.options.items; i += 1) {
                base.visibleItems.push(i);

                if (base.options.addClassActive === true) {
                    $(base.$owlItems[i]).addClass("active");
                }
            }
            base.owl.visibleItems = base.visibleItems;
        },

        transitionTypes : function (className) {
            var base = this;
            //Currently available: "fade", "backSlide", "goDown", "fadeUp"
            base.outClass = "owl-" + className + "-out";
            base.inClass = "owl-" + className + "-in";
        },

        singleItemTransition : function () {
            var base = this,
                outClass = base.outClass,
                inClass = base.inClass,
                $currentItem = base.$owlItems.eq(base.currentItem),
                $prevItem = base.$owlItems.eq(base.prevItem),
                prevPos = Math.abs(base.positionsInArray[base.currentItem]) + base.positionsInArray[base.prevItem],
                origin = Math.abs(base.positionsInArray[base.currentItem]) + base.itemWidth / 2,
                animEnd = 'webkitAnimationEnd oAnimationEnd MSAnimationEnd animationend';

            base.isTransition = true;

            base.$owlWrapper
                .addClass('owl-origin')
                .css({
                    "-webkit-transform-origin" : origin + "px",
                    "-moz-perspective-origin" : origin + "px",
                    "perspective-origin" : origin + "px"
                });
            function transStyles(prevPos) {
                return {
                    "position" : "relative",
                    "left" : prevPos + "px"
                };
            }

            $prevItem
                .css(transStyles(prevPos, 10))
                .addClass(outClass)
                .on(animEnd, function () {
                    base.endPrev = true;
                    $prevItem.off(animEnd);
                    base.clearTransStyle($prevItem, outClass);
                });

            $currentItem
                .addClass(inClass)
                .on(animEnd, function () {
                    base.endCurrent = true;
                    $currentItem.off(animEnd);
                    base.clearTransStyle($currentItem, inClass);
                });
        },

        clearTransStyle : function (item, classToRemove) {
            var base = this;
            item.css({
                "position" : "",
                "left" : ""
            }).removeClass(classToRemove);

            if (base.endPrev && base.endCurrent) {
                base.$owlWrapper.removeClass('owl-origin');
                base.endPrev = false;
                base.endCurrent = false;
                base.isTransition = false;
            }
        },

        owlStatus : function () {
            var base = this;
            base.owl = {
                "userOptions"   : base.userOptions,
                "baseElement"   : base.$elem,
                "userItems"     : base.$userItems,
                "owlItems"      : base.$owlItems,
                "currentItem"   : base.currentItem,
                "prevItem"      : base.prevItem,
                "visibleItems"  : base.visibleItems,
                "isTouch"       : base.browser.isTouch,
                "browser"       : base.browser,
                "dragDirection" : base.dragDirection
            };
        },

        clearEvents : function () {
            var base = this;
            base.$elem.off(".owl owl mousedown.disableTextSelect");
            $(document).off(".owl owl");
            $(window).off("resize", base.resizer);
        },

        unWrap : function () {
            var base = this;
            if (base.$elem.children().length !== 0) {
                base.$owlWrapper.unwrap();
                base.$userItems.unwrap().unwrap();
                if (base.owlControls) {
                    base.owlControls.remove();
                }
            }
            base.clearEvents();
            base.$elem
                .attr("style", base.$elem.data("owl-originalStyles") || "")
                .attr("class", base.$elem.data("owl-originalClasses"));
        },

        destroy : function () {
            var base = this;
            base.stop();
            window.clearInterval(base.checkVisible);
            base.unWrap();
            base.$elem.removeData();
        },

        reinit : function (newOptions) {
            var base = this,
                options = $.extend({}, base.userOptions, newOptions);
            base.unWrap();
            base.init(options, base.$elem);
        },

        addItem : function (htmlString, targetPosition) {
            var base = this,
                position;

            if (!htmlString) {return false; }

            if (base.$elem.children().length === 0) {
                base.$elem.append(htmlString);
                base.setVars();
                return false;
            }
            base.unWrap();
            if (targetPosition === undefined || targetPosition === -1) {
                position = -1;
            } else {
                position = targetPosition;
            }
            if (position >= base.$userItems.length || position === -1) {
                base.$userItems.eq(-1).after(htmlString);
            } else {
                base.$userItems.eq(position).before(htmlString);
            }

            base.setVars();
        },

        removeItem : function (targetPosition) {
            var base = this,
                position;

            if (base.$elem.children().length === 0) {
                return false;
            }
            if (targetPosition === undefined || targetPosition === -1) {
                position = -1;
            } else {
                position = targetPosition;
            }

            base.unWrap();
            base.$userItems.eq(position).remove();
            base.setVars();
        }

    };

    $.fn.owlCarousel = function (options) {
        return this.each(function () {
            if ($(this).data("owl-init") === true) {
                return false;
            }
            $(this).data("owl-init", true);
            var carousel = Object.create(Carousel);
            carousel.init(options, this);
            $.data(this, "owlCarousel", carousel);
        });
    };

    $.fn.owlCarousel.options = {

        items : 5,
        itemsCustom : false,
        itemsDesktop : [1199, 4],
        itemsDesktopSmall : [979, 3],
        itemsTablet : [768, 2],
        itemsTabletSmall : false,
        itemsMobile : [479, 1],
        singleItem : false,
        itemsScaleUp : false,

        slideSpeed : 200,
        paginationSpeed : 800,
        rewindSpeed : 1000,

        autoPlay : false,
        stopOnHover : false,

        navigation : false,
        navigationText : ["prev", "next"],
        rewindNav : true,
        scrollPerPage : false,

        pagination : true,
        paginationNumbers : false,

        responsive : true,
        responsiveRefreshRate : 200,
        responsiveBaseWidth : window,

        baseClass : "owl-carousel",
        theme : "owl-theme",

        lazyLoad : false,
        lazyFollow : true,
        lazyEffect : "fade",

        autoHeight : false,

        jsonPath : false,
        jsonSuccess : false,

        dragBeforeAnimFinish : true,
        mouseDrag : true,
        touchDrag : true,

        addClassActive : false,
        transitionStyle : false,

        beforeUpdate : false,
        afterUpdate : false,
        beforeInit : false,
        afterInit : false,
        beforeMove : false,
        afterMove : false,
        afterAction : false,
        startDragging : false,
        afterLazyLoad: false
    };
}(jQuery, window, document));/**
 * CLDR JavaScript Library v0.4.8
 * http://jquery.com/
 *
 * Copyright 2013 Rafael Xavier de Souza
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2016-11-26T15:03Z
 */
/*!
 * CLDR JavaScript Library v0.4.8 2016-11-26T15:03Z MIT license  Rafael Xavier
 * http://git.io/h4lmVg
 */
(function( root, factory ) {

	if ( typeof define === "function" && define.amd ) {
		// AMD.
		define( factory );
	} else if ( typeof module === "object" && typeof module.exports === "object" ) {
		// Node. CommonJS.
		module.exports = factory();
	} else {
		// Global
		root.Cldr = factory();
	}

}( this, function() {


	var arrayIsArray = Array.isArray || function( obj ) {
		return Object.prototype.toString.call( obj ) === "[object Array]";
	};




	var pathNormalize = function( path, attributes ) {
		if ( arrayIsArray( path ) ) {
			path = path.join( "/" );
		}
		if ( typeof path !== "string" ) {
			throw new Error( "invalid path \"" + path + "\"" );
		}
		// 1: Ignore leading slash `/`
		// 2: Ignore leading `cldr/`
		path = path
			.replace( /^\// , "" ) /* 1 */
			.replace( /^cldr\// , "" ); /* 2 */

		// Replace {attribute}'s
		path = path.replace( /{[a-zA-Z]+}/g, function( name ) {
			name = name.replace( /^{([^}]*)}$/, "$1" );
			return attributes[ name ];
		});

		return path.split( "/" );
	};




	var arraySome = function( array, callback ) {
		var i, length;
		if ( array.some ) {
			return array.some( callback );
		}
		for ( i = 0, length = array.length; i < length; i++ ) {
			if ( callback( array[ i ], i, array ) ) {
				return true;
			}
		}
		return false;
	};




	/**
	 * Return the maximized language id as defined in
	 * http://www.unicode.org/reports/tr35/#Likely_Subtags
	 * 1. Canonicalize.
	 * 1.1 Make sure the input locale is in canonical form: uses the right
	 * separator, and has the right casing.
	 * TODO Right casing? What df? It seems languages are lowercase, scripts are
	 * Capitalized, territory is uppercase. I am leaving this as an exercise to
	 * the user.
	 *
	 * 1.2 Replace any deprecated subtags with their canonical values using the
	 * <alias> data in supplemental metadata. Use the first value in the
	 * replacement list, if it exists. Language tag replacements may have multiple
	 * parts, such as "sh"  "sr_Latn" or mo"  "ro_MD". In such a case, the
	 * original script and/or region are retained if there is one. Thus
	 * "sh_Arab_AQ"  "sr_Arab_AQ", not "sr_Latn_AQ".
	 * TODO What <alias> data?
	 *
	 * 1.3 If the tag is grandfathered (see <variable id="$grandfathered"
	 * type="choice"> in the supplemental data), then return it.
	 * TODO grandfathered?
	 *
	 * 1.4 Remove the script code 'Zzzz' and the region code 'ZZ' if they occur.
	 * 1.5 Get the components of the cleaned-up source tag (languages, scripts,
	 * and regions), plus any variants and extensions.
	 * 2. Lookup. Lookup each of the following in order, and stop on the first
	 * match:
	 * 2.1 languages_scripts_regions
	 * 2.2 languages_regions
	 * 2.3 languages_scripts
	 * 2.4 languages
	 * 2.5 und_scripts
	 * 3. Return
	 * 3.1 If there is no match, either return an error value, or the match for
	 * "und" (in APIs where a valid language tag is required).
	 * 3.2 Otherwise there is a match = languagem_scriptm_regionm
	 * 3.3 Let xr = xs if xs is not empty, and xm otherwise.
	 * 3.4 Return the language tag composed of languager _ scriptr _ regionr +
	 * variants + extensions.
	 *
	 * @subtags [Array] normalized language id subtags tuple (see init.js).
	 */
	var coreLikelySubtags = function( Cldr, cldr, subtags, options ) {
		var match, matchFound,
			language = subtags[ 0 ],
			script = subtags[ 1 ],
			sep = Cldr.localeSep,
			territory = subtags[ 2 ],
			variants = subtags.slice( 3, 4 );
		options = options || {};

		// Skip if (language, script, territory) is not empty [3.3]
		if ( language !== "und" && script !== "Zzzz" && territory !== "ZZ" ) {
			return [ language, script, territory ].concat( variants );
		}

		// Skip if no supplemental likelySubtags data is present
		if ( typeof cldr.get( "supplemental/likelySubtags" ) === "undefined" ) {
			return;
		}

		// [2]
		matchFound = arraySome([
			[ language, script, territory ],
			[ language, territory ],
			[ language, script ],
			[ language ],
			[ "und", script ]
		], function( test ) {
			return match = !(/\b(Zzzz|ZZ)\b/).test( test.join( sep ) ) /* [1.4] */ && cldr.get( [ "supplemental/likelySubtags", test.join( sep ) ] );
		});

		// [3]
		if ( matchFound ) {
			// [3.2 .. 3.4]
			match = match.split( sep );
			return [
				language !== "und" ? language : match[ 0 ],
				script !== "Zzzz" ? script : match[ 1 ],
				territory !== "ZZ" ? territory : match[ 2 ]
			].concat( variants );
		} else if ( options.force ) {
			// [3.1.2]
			return cldr.get( "supplemental/likelySubtags/und" ).split( sep );
		} else {
			// [3.1.1]
			return;
		}
	};



	/**
	 * Given a locale, remove any fields that Add Likely Subtags would add.
	 * http://www.unicode.org/reports/tr35/#Likely_Subtags
	 * 1. First get max = AddLikelySubtags(inputLocale). If an error is signaled,
	 * return it.
	 * 2. Remove the variants from max.
	 * 3. Then for trial in {language, language _ region, language _ script}. If
	 * AddLikelySubtags(trial) = max, then return trial + variants.
	 * 4. If you do not get a match, return max + variants.
	 * 
	 * @maxLanguageId [Array] maxLanguageId tuple (see init.js).
	 */
	var coreRemoveLikelySubtags = function( Cldr, cldr, maxLanguageId ) {
		var match, matchFound,
			language = maxLanguageId[ 0 ],
			script = maxLanguageId[ 1 ],
			territory = maxLanguageId[ 2 ],
			variants = maxLanguageId[ 3 ];

		// [3]
		matchFound = arraySome([
			[ [ language, "Zzzz", "ZZ" ], [ language ] ],
			[ [ language, "Zzzz", territory ], [ language, territory ] ],
			[ [ language, script, "ZZ" ], [ language, script ] ]
		], function( test ) {
			var result = coreLikelySubtags( Cldr, cldr, test[ 0 ] );
			match = test[ 1 ];
			return result && result[ 0 ] === maxLanguageId[ 0 ] &&
				result[ 1 ] === maxLanguageId[ 1 ] &&
				result[ 2 ] === maxLanguageId[ 2 ];
		});

		if ( matchFound ) {
			if ( variants ) {
				match.push( variants );
			}
			return match;
		}

		// [4]
		return maxLanguageId;
	};




	/**
	 * subtags( locale )
	 *
	 * @locale [String]
	 */
	var coreSubtags = function( locale ) {
		var aux, unicodeLanguageId,
			subtags = [];

		locale = locale.replace( /_/, "-" );

		// Unicode locale extensions.
		aux = locale.split( "-u-" );
		if ( aux[ 1 ] ) {
			aux[ 1 ] = aux[ 1 ].split( "-t-" );
			locale = aux[ 0 ] + ( aux[ 1 ][ 1 ] ? "-t-" + aux[ 1 ][ 1 ] : "");
			subtags[ 4 /* unicodeLocaleExtensions */ ] = aux[ 1 ][ 0 ];
		}

		// TODO normalize transformed extensions. Currently, skipped.
		// subtags[ x ] = locale.split( "-t-" )[ 1 ];
		unicodeLanguageId = locale.split( "-t-" )[ 0 ];

		// unicode_language_id = "root"
		//   | unicode_language_subtag         
		//     (sep unicode_script_subtag)? 
		//     (sep unicode_region_subtag)?
		//     (sep unicode_variant_subtag)* ;
		//
		// Although unicode_language_subtag = alpha{2,8}, I'm using alpha{2,3}. Because, there's no language on CLDR lengthier than 3.
		aux = unicodeLanguageId.match( /^(([a-z]{2,3})(-([A-Z][a-z]{3}))?(-([A-Z]{2}|[0-9]{3}))?)((-([a-zA-Z0-9]{5,8}|[0-9][a-zA-Z0-9]{3}))*)$|^(root)$/ );
		if ( aux === null ) {
			return [ "und", "Zzzz", "ZZ" ];
		}
		subtags[ 0 /* language */ ] = aux[ 10 ] /* root */ || aux[ 2 ] || "und";
		subtags[ 1 /* script */ ] = aux[ 4 ] || "Zzzz";
		subtags[ 2 /* territory */ ] = aux[ 6 ] || "ZZ";
		if ( aux[ 7 ] && aux[ 7 ].length ) {
			subtags[ 3 /* variant */ ] = aux[ 7 ].slice( 1 ) /* remove leading "-" */;
		}

		// 0: language
		// 1: script
		// 2: territory (aka region)
		// 3: variant
		// 4: unicodeLocaleExtensions
		return subtags;
	};




	var arrayForEach = function( array, callback ) {
		var i, length;
		if ( array.forEach ) {
			return array.forEach( callback );
		}
		for ( i = 0, length = array.length; i < length; i++ ) {
			callback( array[ i ], i, array );
		}
	};




	/**
	 * bundleLookup( minLanguageId )
	 *
	 * @Cldr [Cldr class]
	 *
	 * @cldr [Cldr instance]
	 *
	 * @minLanguageId [String] requested languageId after applied remove likely subtags.
	 */
	var bundleLookup = function( Cldr, cldr, minLanguageId ) {
		var availableBundleMap = Cldr._availableBundleMap,
			availableBundleMapQueue = Cldr._availableBundleMapQueue;

		if ( availableBundleMapQueue.length ) {
			arrayForEach( availableBundleMapQueue, function( bundle ) {
				var existing, maxBundle, minBundle, subtags;
				subtags = coreSubtags( bundle );
				maxBundle = coreLikelySubtags( Cldr, cldr, subtags );
				minBundle = coreRemoveLikelySubtags( Cldr, cldr, maxBundle );
				minBundle = minBundle.join( Cldr.localeSep );
				existing = availableBundleMapQueue[ minBundle ];
				if ( existing && existing.length < bundle.length ) {
					return;
				}
				availableBundleMap[ minBundle ] = bundle;
			});
			Cldr._availableBundleMapQueue = [];
		}

		return availableBundleMap[ minLanguageId ] || null;
	};




	var objectKeys = function( object ) {
		var i,
			result = [];

		if ( Object.keys ) {
			return Object.keys( object );
		}

		for ( i in object ) {
			result.push( i );
		}

		return result;
	};




	var createError = function( code, attributes ) {
		var error, message;

		message = code + ( attributes && JSON ? ": " + JSON.stringify( attributes ) : "" );
		error = new Error( message );
		error.code = code;

		// extend( error, attributes );
		arrayForEach( objectKeys( attributes ), function( attribute ) {
			error[ attribute ] = attributes[ attribute ];
		});

		return error;
	};




	var validate = function( code, check, attributes ) {
		if ( !check ) {
			throw createError( code, attributes );
		}
	};




	var validatePresence = function( value, name ) {
		validate( "E_MISSING_PARAMETER", typeof value !== "undefined", {
			name: name
		});
	};




	var validateType = function( value, name, check, expected ) {
		validate( "E_INVALID_PAR_TYPE", check, {
			expected: expected,
			name: name,
			value: value
		});
	};




	var validateTypePath = function( value, name ) {
		validateType( value, name, typeof value === "string" || arrayIsArray( value ), "String or Array" );
	};




	/**
	 * Function inspired by jQuery Core, but reduced to our use case.
	 */
	var isPlainObject = function( obj ) {
		return obj !== null && "" + obj === "[object Object]";
	};




	var validateTypePlainObject = function( value, name ) {
		validateType( value, name, typeof value === "undefined" || isPlainObject( value ), "Plain Object" );
	};




	var validateTypeString = function( value, name ) {
		validateType( value, name, typeof value === "string", "a string" );
	};




	// @path: normalized path
	var resourceGet = function( data, path ) {
		var i,
			node = data,
			length = path.length;

		for ( i = 0; i < length - 1; i++ ) {
			node = node[ path[ i ] ];
			if ( !node ) {
				return undefined;
			}
		}
		return node[ path[ i ] ];
	};




	/**
	 * setAvailableBundles( Cldr, json )
	 *
	 * @Cldr [Cldr class]
	 *
	 * @json resolved/unresolved cldr data.
	 *
	 * Set available bundles queue based on passed json CLDR data. Considers a bundle as any String at /main/{bundle}.
	 */
	var coreSetAvailableBundles = function( Cldr, json ) {
		var bundle,
			availableBundleMapQueue = Cldr._availableBundleMapQueue,
			main = resourceGet( json, [ "main" ] );

		if ( main ) {
			for ( bundle in main ) {
				if ( main.hasOwnProperty( bundle ) && bundle !== "root" &&
							availableBundleMapQueue.indexOf( bundle ) === -1 ) {
					availableBundleMapQueue.push( bundle );
				}
			}
		}
	};



	var alwaysArray = function( somethingOrArray ) {
		return arrayIsArray( somethingOrArray ) ?  somethingOrArray : [ somethingOrArray ];
	};


	var jsonMerge = (function() {

	// Returns new deeply merged JSON.
	//
	// Eg.
	// merge( { a: { b: 1, c: 2 } }, { a: { b: 3, d: 4 } } )
	// -> { a: { b: 3, c: 2, d: 4 } }
	//
	// @arguments JSON's
	// 
	var merge = function() {
		var destination = {},
			sources = [].slice.call( arguments, 0 );
		arrayForEach( sources, function( source ) {
			var prop;
			for ( prop in source ) {
				if ( prop in destination && typeof destination[ prop ] === "object" && !arrayIsArray( destination[ prop ] ) ) {

					// Merge Objects
					destination[ prop ] = merge( destination[ prop ], source[ prop ] );

				} else {

					// Set new values
					destination[ prop ] = source[ prop ];

				}
			}
		});
		return destination;
	};

	return merge;

}());


	/**
	 * load( Cldr, source, jsons )
	 *
	 * @Cldr [Cldr class]
	 *
	 * @source [Object]
	 *
	 * @jsons [arguments]
	 */
	var coreLoad = function( Cldr, source, jsons ) {
		var i, j, json;

		validatePresence( jsons[ 0 ], "json" );

		// Support arbitrary parameters, e.g., `Cldr.load({...}, {...})`.
		for ( i = 0; i < jsons.length; i++ ) {

			// Support array parameters, e.g., `Cldr.load([{...}, {...}])`.
			json = alwaysArray( jsons[ i ] );

			for ( j = 0; j < json.length; j++ ) {
				validateTypePlainObject( json[ j ], "json" );
				source = jsonMerge( source, json[ j ] );
				coreSetAvailableBundles( Cldr, json[ j ] );
			}
		}

		return source;
	};



	var itemGetResolved = function( Cldr, path, attributes ) {
		// Resolve path
		var normalizedPath = pathNormalize( path, attributes );

		return resourceGet( Cldr._resolved, normalizedPath );
	};




	/**
	 * new Cldr()
	 */
	var Cldr = function( locale ) {
		this.init( locale );
	};

	// Build optimization hack to avoid duplicating functions across modules.
	Cldr._alwaysArray = alwaysArray;
	Cldr._coreLoad = coreLoad;
	Cldr._createError = createError;
	Cldr._itemGetResolved = itemGetResolved;
	Cldr._jsonMerge = jsonMerge;
	Cldr._pathNormalize = pathNormalize;
	Cldr._resourceGet = resourceGet;
	Cldr._validatePresence = validatePresence;
	Cldr._validateType = validateType;
	Cldr._validateTypePath = validateTypePath;
	Cldr._validateTypePlainObject = validateTypePlainObject;

	Cldr._availableBundleMap = {};
	Cldr._availableBundleMapQueue = [];
	Cldr._resolved = {};

	// Allow user to override locale separator "-" (default) | "_". According to http://www.unicode.org/reports/tr35/#Unicode_language_identifier, both "-" and "_" are valid locale separators (eg. "en_GB", "en-GB"). According to http://unicode.org/cldr/trac/ticket/6786 its usage must be consistent throughout the data set.
	Cldr.localeSep = "-";

	/**
	 * Cldr.load( json [, json, ...] )
	 *
	 * @json [JSON] CLDR data or [Array] Array of @json's.
	 *
	 * Load resolved cldr data.
	 */
	Cldr.load = function() {
		Cldr._resolved = coreLoad( Cldr, Cldr._resolved, arguments );
	};

	/**
	 * .init() automatically run on instantiation/construction.
	 */
	Cldr.prototype.init = function( locale ) {
		var attributes, language, maxLanguageId, minLanguageId, script, subtags, territory, unicodeLocaleExtensions, variant,
			sep = Cldr.localeSep,
			unicodeLocaleExtensionsRaw = "";

		validatePresence( locale, "locale" );
		validateTypeString( locale, "locale" );

		subtags = coreSubtags( locale );

		if ( subtags.length === 5 ) {
			unicodeLocaleExtensions = subtags.pop();
			unicodeLocaleExtensionsRaw = sep + "u" + sep + unicodeLocaleExtensions;
			// Remove trailing null when there is unicodeLocaleExtensions but no variants.
			if ( !subtags[ 3 ] ) {
				subtags.pop();
			}
		}
		variant = subtags[ 3 ];

		// Normalize locale code.
		// Get (or deduce) the "triple subtags": language, territory (also aliased as region), and script subtags.
		// Get the variant subtags (calendar, collation, currency, etc).
		// refs:
		// - http://www.unicode.org/reports/tr35/#Field_Definitions
		// - http://www.unicode.org/reports/tr35/#Language_and_Locale_IDs
		// - http://www.unicode.org/reports/tr35/#Unicode_locale_identifier

		// When a locale id does not specify a language, or territory (region), or script, they are obtained by Likely Subtags.
		maxLanguageId = coreLikelySubtags( Cldr, this, subtags, { force: true } ) || subtags;
		language = maxLanguageId[ 0 ];
		script = maxLanguageId[ 1 ];
		territory = maxLanguageId[ 2 ];

		minLanguageId = coreRemoveLikelySubtags( Cldr, this, maxLanguageId ).join( sep );

		// Set attributes
		this.attributes = attributes = {
			bundle: bundleLookup( Cldr, this, minLanguageId ),

			// Unicode Language Id
			minLanguageId: minLanguageId + unicodeLocaleExtensionsRaw,
			maxLanguageId: maxLanguageId.join( sep ) + unicodeLocaleExtensionsRaw,

			// Unicode Language Id Subtabs
			language: language,
			script: script,
			territory: territory,
			region: territory, /* alias */
			variant: variant
		};

		// Unicode locale extensions.
		unicodeLocaleExtensions && ( "-" + unicodeLocaleExtensions ).replace( /-[a-z]{3,8}|(-[a-z]{2})-([a-z]{3,8})/g, function( attribute, key, type ) {

			if ( key ) {

				// Extension is in the `keyword` form.
				attributes[ "u" + key ] = type;
			} else {

				// Extension is in the `attribute` form.
				attributes[ "u" + attribute ] = true;
			}
		});

		this.locale = locale;
	};

	/**
	 * .get()
	 */
	Cldr.prototype.get = function( path ) {

		validatePresence( path, "path" );
		validateTypePath( path, "path" );

		return itemGetResolved( Cldr, path, this.attributes );
	};

	/**
	 * .main()
	 */
	Cldr.prototype.main = function( path ) {
		validatePresence( path, "path" );
		validateTypePath( path, "path" );

		validate( "E_MISSING_BUNDLE", this.attributes.bundle !== null, {
			locale: this.locale
		});

		path = alwaysArray( path );
		return this.get( [ "main/{bundle}" ].concat( path ) );
	};

	return Cldr;




}));
/**
 * CLDR JavaScript Library v0.4.8
 * http://jquery.com/
 *
 * Copyright 2013 Rafael Xavier de Souza
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2016-11-26T15:03Z
 */
/*!
 * CLDR JavaScript Library v0.4.8 2016-11-26T15:03Z MIT license  Rafael Xavier
 * http://git.io/h4lmVg
 */
(function( factory ) {

	if ( typeof define === "function" && define.amd ) {
		// AMD.
		define( [ "../cldr" ], factory );
	} else if ( typeof module === "object" && typeof module.exports === "object" ) {
		// Node. CommonJS.
		module.exports = factory( require( "../cldr" ) );
	} else {
		// Global
		factory( Cldr );
	}

}(function( Cldr ) {

	// Build optimization hack to avoid duplicating functions across modules.
	var pathNormalize = Cldr._pathNormalize,
		validatePresence = Cldr._validatePresence,
		validateType = Cldr._validateType;

/*!
 * EventEmitter v4.2.7 - git.io/ee
 * Oliver Caldwell
 * MIT license
 * @preserve
 */

var EventEmitter;
/* jshint ignore:start */
EventEmitter = (function () {


	/**
	 * Class for managing events.
	 * Can be extended to provide event functionality in other classes.
	 *
	 * @class EventEmitter Manages event registering and emitting.
	 */
	function EventEmitter() {}

	// Shortcuts to improve speed and size
	var proto = EventEmitter.prototype;
	var exports = this;
	var originalGlobalValue = exports.EventEmitter;

	/**
	 * Finds the index of the listener for the event in it's storage array.
	 *
	 * @param {Function[]} listeners Array of listeners to search through.
	 * @param {Function} listener Method to look for.
	 * @return {Number} Index of the specified listener, -1 if not found
	 * @api private
	 */
	function indexOfListener(listeners, listener) {
		var i = listeners.length;
		while (i--) {
			if (listeners[i].listener === listener) {
				return i;
			}
		}

		return -1;
	}

	/**
	 * Alias a method while keeping the context correct, to allow for overwriting of target method.
	 *
	 * @param {String} name The name of the target method.
	 * @return {Function} The aliased method
	 * @api private
	 */
	function alias(name) {
		return function aliasClosure() {
			return this[name].apply(this, arguments);
		};
	}

	/**
	 * Returns the listener array for the specified event.
	 * Will initialise the event object and listener arrays if required.
	 * Will return an object if you use a regex search. The object contains keys for each matched event. So /ba[rz]/ might return an object containing bar and baz. But only if you have either defined them with defineEvent or added some listeners to them.
	 * Each property in the object response is an array of listener functions.
	 *
	 * @param {String|RegExp} evt Name of the event to return the listeners from.
	 * @return {Function[]|Object} All listener functions for the event.
	 */
	proto.getListeners = function getListeners(evt) {
		var events = this._getEvents();
		var response;
		var key;

		// Return a concatenated array of all matching events if
		// the selector is a regular expression.
		if (evt instanceof RegExp) {
			response = {};
			for (key in events) {
				if (events.hasOwnProperty(key) && evt.test(key)) {
					response[key] = events[key];
				}
			}
		}
		else {
			response = events[evt] || (events[evt] = []);
		}

		return response;
	};

	/**
	 * Takes a list of listener objects and flattens it into a list of listener functions.
	 *
	 * @param {Object[]} listeners Raw listener objects.
	 * @return {Function[]} Just the listener functions.
	 */
	proto.flattenListeners = function flattenListeners(listeners) {
		var flatListeners = [];
		var i;

		for (i = 0; i < listeners.length; i += 1) {
			flatListeners.push(listeners[i].listener);
		}

		return flatListeners;
	};

	/**
	 * Fetches the requested listeners via getListeners but will always return the results inside an object. This is mainly for internal use but others may find it useful.
	 *
	 * @param {String|RegExp} evt Name of the event to return the listeners from.
	 * @return {Object} All listener functions for an event in an object.
	 */
	proto.getListenersAsObject = function getListenersAsObject(evt) {
		var listeners = this.getListeners(evt);
		var response;

		if (listeners instanceof Array) {
			response = {};
			response[evt] = listeners;
		}

		return response || listeners;
	};

	/**
	 * Adds a listener function to the specified event.
	 * The listener will not be added if it is a duplicate.
	 * If the listener returns true then it will be removed after it is called.
	 * If you pass a regular expression as the event name then the listener will be added to all events that match it.
	 *
	 * @param {String|RegExp} evt Name of the event to attach the listener to.
	 * @param {Function} listener Method to be called when the event is emitted. If the function returns true then it will be removed after calling.
	 * @return {Object} Current instance of EventEmitter for chaining.
	 */
	proto.addListener = function addListener(evt, listener) {
		var listeners = this.getListenersAsObject(evt);
		var listenerIsWrapped = typeof listener === 'object';
		var key;

		for (key in listeners) {
			if (listeners.hasOwnProperty(key) && indexOfListener(listeners[key], listener) === -1) {
				listeners[key].push(listenerIsWrapped ? listener : {
					listener: listener,
					once: false
				});
			}
		}

		return this;
	};

	/**
	 * Alias of addListener
	 */
	proto.on = alias('addListener');

	/**
	 * Semi-alias of addListener. It will add a listener that will be
	 * automatically removed after it's first execution.
	 *
	 * @param {String|RegExp} evt Name of the event to attach the listener to.
	 * @param {Function} listener Method to be called when the event is emitted. If the function returns true then it will be removed after calling.
	 * @return {Object} Current instance of EventEmitter for chaining.
	 */
	proto.addOnceListener = function addOnceListener(evt, listener) {
		return this.addListener(evt, {
			listener: listener,
			once: true
		});
	};

	/**
	 * Alias of addOnceListener.
	 */
	proto.once = alias('addOnceListener');

	/**
	 * Defines an event name. This is required if you want to use a regex to add a listener to multiple events at once. If you don't do this then how do you expect it to know what event to add to? Should it just add to every possible match for a regex? No. That is scary and bad.
	 * You need to tell it what event names should be matched by a regex.
	 *
	 * @param {String} evt Name of the event to create.
	 * @return {Object} Current instance of EventEmitter for chaining.
	 */
	proto.defineEvent = function defineEvent(evt) {
		this.getListeners(evt);
		return this;
	};

	/**
	 * Uses defineEvent to define multiple events.
	 *
	 * @param {String[]} evts An array of event names to define.
	 * @return {Object} Current instance of EventEmitter for chaining.
	 */
	proto.defineEvents = function defineEvents(evts) {
		for (var i = 0; i < evts.length; i += 1) {
			this.defineEvent(evts[i]);
		}
		return this;
	};

	/**
	 * Removes a listener function from the specified event.
	 * When passed a regular expression as the event name, it will remove the listener from all events that match it.
	 *
	 * @param {String|RegExp} evt Name of the event to remove the listener from.
	 * @param {Function} listener Method to remove from the event.
	 * @return {Object} Current instance of EventEmitter for chaining.
	 */
	proto.removeListener = function removeListener(evt, listener) {
		var listeners = this.getListenersAsObject(evt);
		var index;
		var key;

		for (key in listeners) {
			if (listeners.hasOwnProperty(key)) {
				index = indexOfListener(listeners[key], listener);

				if (index !== -1) {
					listeners[key].splice(index, 1);
				}
			}
		}

		return this;
	};

	/**
	 * Alias of removeListener
	 */
	proto.off = alias('removeListener');

	/**
	 * Adds listeners in bulk using the manipulateListeners method.
	 * If you pass an object as the second argument you can add to multiple events at once. The object should contain key value pairs of events and listeners or listener arrays. You can also pass it an event name and an array of listeners to be added.
	 * You can also pass it a regular expression to add the array of listeners to all events that match it.
	 * Yeah, this function does quite a bit. That's probably a bad thing.
	 *
	 * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to add to multiple events at once.
	 * @param {Function[]} [listeners] An optional array of listener functions to add.
	 * @return {Object} Current instance of EventEmitter for chaining.
	 */
	proto.addListeners = function addListeners(evt, listeners) {
		// Pass through to manipulateListeners
		return this.manipulateListeners(false, evt, listeners);
	};

	/**
	 * Removes listeners in bulk using the manipulateListeners method.
	 * If you pass an object as the second argument you can remove from multiple events at once. The object should contain key value pairs of events and listeners or listener arrays.
	 * You can also pass it an event name and an array of listeners to be removed.
	 * You can also pass it a regular expression to remove the listeners from all events that match it.
	 *
	 * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to remove from multiple events at once.
	 * @param {Function[]} [listeners] An optional array of listener functions to remove.
	 * @return {Object} Current instance of EventEmitter for chaining.
	 */
	proto.removeListeners = function removeListeners(evt, listeners) {
		// Pass through to manipulateListeners
		return this.manipulateListeners(true, evt, listeners);
	};

	/**
	 * Edits listeners in bulk. The addListeners and removeListeners methods both use this to do their job. You should really use those instead, this is a little lower level.
	 * The first argument will determine if the listeners are removed (true) or added (false).
	 * If you pass an object as the second argument you can add/remove from multiple events at once. The object should contain key value pairs of events and listeners or listener arrays.
	 * You can also pass it an event name and an array of listeners to be added/removed.
	 * You can also pass it a regular expression to manipulate the listeners of all events that match it.
	 *
	 * @param {Boolean} remove True if you want to remove listeners, false if you want to add.
	 * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to add/remove from multiple events at once.
	 * @param {Function[]} [listeners] An optional array of listener functions to add/remove.
	 * @return {Object} Current instance of EventEmitter for chaining.
	 */
	proto.manipulateListeners = function manipulateListeners(remove, evt, listeners) {
		var i;
		var value;
		var single = remove ? this.removeListener : this.addListener;
		var multiple = remove ? this.removeListeners : this.addListeners;

		// If evt is an object then pass each of it's properties to this method
		if (typeof evt === 'object' && !(evt instanceof RegExp)) {
			for (i in evt) {
				if (evt.hasOwnProperty(i) && (value = evt[i])) {
					// Pass the single listener straight through to the singular method
					if (typeof value === 'function') {
						single.call(this, i, value);
					}
					else {
						// Otherwise pass back to the multiple function
						multiple.call(this, i, value);
					}
				}
			}
		}
		else {
			// So evt must be a string
			// And listeners must be an array of listeners
			// Loop over it and pass each one to the multiple method
			i = listeners.length;
			while (i--) {
				single.call(this, evt, listeners[i]);
			}
		}

		return this;
	};

	/**
	 * Removes all listeners from a specified event.
	 * If you do not specify an event then all listeners will be removed.
	 * That means every event will be emptied.
	 * You can also pass a regex to remove all events that match it.
	 *
	 * @param {String|RegExp} [evt] Optional name of the event to remove all listeners for. Will remove from every event if not passed.
	 * @return {Object} Current instance of EventEmitter for chaining.
	 */
	proto.removeEvent = function removeEvent(evt) {
		var type = typeof evt;
		var events = this._getEvents();
		var key;

		// Remove different things depending on the state of evt
		if (type === 'string') {
			// Remove all listeners for the specified event
			delete events[evt];
		}
		else if (evt instanceof RegExp) {
			// Remove all events matching the regex.
			for (key in events) {
				if (events.hasOwnProperty(key) && evt.test(key)) {
					delete events[key];
				}
			}
		}
		else {
			// Remove all listeners in all events
			delete this._events;
		}

		return this;
	};

	/**
	 * Alias of removeEvent.
	 *
	 * Added to mirror the node API.
	 */
	proto.removeAllListeners = alias('removeEvent');

	/**
	 * Emits an event of your choice.
	 * When emitted, every listener attached to that event will be executed.
	 * If you pass the optional argument array then those arguments will be passed to every listener upon execution.
	 * Because it uses `apply`, your array of arguments will be passed as if you wrote them out separately.
	 * So they will not arrive within the array on the other side, they will be separate.
	 * You can also pass a regular expression to emit to all events that match it.
	 *
	 * @param {String|RegExp} evt Name of the event to emit and execute listeners for.
	 * @param {Array} [args] Optional array of arguments to be passed to each listener.
	 * @return {Object} Current instance of EventEmitter for chaining.
	 */
	proto.emitEvent = function emitEvent(evt, args) {
		var listeners = this.getListenersAsObject(evt);
		var listener;
		var i;
		var key;
		var response;

		for (key in listeners) {
			if (listeners.hasOwnProperty(key)) {
				i = listeners[key].length;

				while (i--) {
					// If the listener returns true then it shall be removed from the event
					// The function is executed either with a basic call or an apply if there is an args array
					listener = listeners[key][i];

					if (listener.once === true) {
						this.removeListener(evt, listener.listener);
					}

					response = listener.listener.apply(this, args || []);

					if (response === this._getOnceReturnValue()) {
						this.removeListener(evt, listener.listener);
					}
				}
			}
		}

		return this;
	};

	/**
	 * Alias of emitEvent
	 */
	proto.trigger = alias('emitEvent');

	/**
	 * Subtly different from emitEvent in that it will pass its arguments on to the listeners, as opposed to taking a single array of arguments to pass on.
	 * As with emitEvent, you can pass a regex in place of the event name to emit to all events that match it.
	 *
	 * @param {String|RegExp} evt Name of the event to emit and execute listeners for.
	 * @param {...*} Optional additional arguments to be passed to each listener.
	 * @return {Object} Current instance of EventEmitter for chaining.
	 */
	proto.emit = function emit(evt) {
		var args = Array.prototype.slice.call(arguments, 1);
		return this.emitEvent(evt, args);
	};

	/**
	 * Sets the current value to check against when executing listeners. If a
	 * listeners return value matches the one set here then it will be removed
	 * after execution. This value defaults to true.
	 *
	 * @param {*} value The new value to check for when executing listeners.
	 * @return {Object} Current instance of EventEmitter for chaining.
	 */
	proto.setOnceReturnValue = function setOnceReturnValue(value) {
		this._onceReturnValue = value;
		return this;
	};

	/**
	 * Fetches the current value to check against when executing listeners. If
	 * the listeners return value matches this one then it should be removed
	 * automatically. It will return true by default.
	 *
	 * @return {*|Boolean} The current value to check for or the default, true.
	 * @api private
	 */
	proto._getOnceReturnValue = function _getOnceReturnValue() {
		if (this.hasOwnProperty('_onceReturnValue')) {
			return this._onceReturnValue;
		}
		else {
			return true;
		}
	};

	/**
	 * Fetches the events object and creates one if required.
	 *
	 * @return {Object} The events storage object.
	 * @api private
	 */
	proto._getEvents = function _getEvents() {
		return this._events || (this._events = {});
	};

	/**
	 * Reverts the global {@link EventEmitter} to its previous value and returns a reference to this version.
	 *
	 * @return {Function} Non conflicting EventEmitter class.
	 */
	EventEmitter.noConflict = function noConflict() {
		exports.EventEmitter = originalGlobalValue;
		return EventEmitter;
	};

	return EventEmitter;
}());
/* jshint ignore:end */



	var validateTypeFunction = function( value, name ) {
		validateType( value, name, typeof value === "undefined" || typeof value === "function", "Function" );
	};




	var superGet, superInit,
		globalEe = new EventEmitter();

	function validateTypeEvent( value, name ) {
		validateType( value, name, typeof value === "string" || value instanceof RegExp, "String or RegExp" );
	}

	function validateThenCall( method, self ) {
		return function( event, listener ) {
			validatePresence( event, "event" );
			validateTypeEvent( event, "event" );

			validatePresence( listener, "listener" );
			validateTypeFunction( listener, "listener" );

			return self[ method ].apply( self, arguments );
		};
	}

	function off( self ) {
		return validateThenCall( "off", self );
	}

	function on( self ) {
		return validateThenCall( "on", self );
	}

	function once( self ) {
		return validateThenCall( "once", self );
	}

	Cldr.off = off( globalEe );
	Cldr.on = on( globalEe );
	Cldr.once = once( globalEe );

	/**
	 * Overload Cldr.prototype.init().
	 */
	superInit = Cldr.prototype.init;
	Cldr.prototype.init = function() {
		var ee;
		this.ee = ee = new EventEmitter();
		this.off = off( ee );
		this.on = on( ee );
		this.once = once( ee );
		superInit.apply( this, arguments );
	};

	/**
	 * getOverload is encapsulated, because of cldr/unresolved. If it's loaded
	 * after cldr/event (and note it overwrites .get), it can trigger this
	 * overload again.
	 */
	function getOverload() {

		/**
		 * Overload Cldr.prototype.get().
		 */
		superGet = Cldr.prototype.get;
		Cldr.prototype.get = function( path ) {
			var value = superGet.apply( this, arguments );
			path = pathNormalize( path, this.attributes ).join( "/" );
			globalEe.trigger( "get", [ path, value ] );
			this.ee.trigger( "get", [ path, value ] );
			return value;
		};
	}

	Cldr._eventInit = getOverload;
	getOverload();

	return Cldr;




}));
/**
 * CLDR JavaScript Library v0.4.8
 * http://jquery.com/
 *
 * Copyright 2013 Rafael Xavier de Souza
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2016-11-26T15:03Z
 */
/*!
 * CLDR JavaScript Library v0.4.8 2016-11-26T15:03Z MIT license  Rafael Xavier
 * http://git.io/h4lmVg
 */
(function( factory ) {

	if ( typeof define === "function" && define.amd ) {
		// AMD.
		define( [ "../cldr" ], factory );
	} else if ( typeof module === "object" && typeof module.exports === "object" ) {
		// Node. CommonJS.
		module.exports = factory( require( "../cldr" ) );
	} else {
		// Global
		factory( Cldr );
	}

}(function( Cldr ) {

	// Build optimization hack to avoid duplicating functions across modules.
	var alwaysArray = Cldr._alwaysArray;



	var supplementalMain = function( cldr ) {

		var prepend, supplemental;
		
		prepend = function( prepend ) {
			return function( path ) {
				path = alwaysArray( path );
				return cldr.get( [ prepend ].concat( path ) );
			};
		};

		supplemental = prepend( "supplemental" );

		// Week Data
		// http://www.unicode.org/reports/tr35/tr35-dates.html#Week_Data
		supplemental.weekData = prepend( "supplemental/weekData" );

		supplemental.weekData.firstDay = function() {
			return cldr.get( "supplemental/weekData/firstDay/{territory}" ) ||
				cldr.get( "supplemental/weekData/firstDay/001" );
		};

		supplemental.weekData.minDays = function() {
			var minDays = cldr.get( "supplemental/weekData/minDays/{territory}" ) ||
				cldr.get( "supplemental/weekData/minDays/001" );
			return parseInt( minDays, 10 );
		};

		// Time Data
		// http://www.unicode.org/reports/tr35/tr35-dates.html#Time_Data
		supplemental.timeData = prepend( "supplemental/timeData" );

		supplemental.timeData.allowed = function() {
			return cldr.get( "supplemental/timeData/{territory}/_allowed" ) ||
				cldr.get( "supplemental/timeData/001/_allowed" );
		};

		supplemental.timeData.preferred = function() {
			return cldr.get( "supplemental/timeData/{territory}/_preferred" ) ||
				cldr.get( "supplemental/timeData/001/_preferred" );
		};

		return supplemental;

	};




	var initSuper = Cldr.prototype.init;

	/**
	 * .init() automatically ran on construction.
	 *
	 * Overload .init().
	 */
	Cldr.prototype.init = function() {
		initSuper.apply( this, arguments );
		this.supplemental = supplementalMain( this );
	};

	return Cldr;




}));
/**
 * Globalize v1.1.2
 *
 * http://github.com/jquery/globalize
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2016-11-08T12:09Z
 */
/*!
 * Globalize v1.1.2 2016-11-08T12:09Z Released under the MIT license
 * http://git.io/TrdQbw
 */
(function( root, factory ) {

	// UMD returnExports
	if ( typeof define === "function" && define.amd ) {

		// AMD
		define([
			"cldr",
			"cldr/event"
		], factory );
	} else if ( typeof exports === "object" ) {

		// Node, CommonJS
		module.exports = factory( require( "cldrjs" ) );
	} else {

		// Global
		root.Globalize = factory( root.Cldr );
	}
}( this, function( Cldr ) {


/**
 * A toString method that outputs meaningful values for objects or arrays and
 * still performs as fast as a plain string in case variable is string, or as
 * fast as `"" + number` in case variable is a number.
 * Ref: http://jsperf.com/my-stringify
 */
var toString = function( variable ) {
	return typeof variable === "string" ? variable : ( typeof variable === "number" ? "" +
		variable : JSON.stringify( variable ) );
};




/**
 * formatMessage( message, data )
 *
 * @message [String] A message with optional {vars} to be replaced.
 *
 * @data [Array or JSON] Object with replacing-variables content.
 *
 * Return the formatted message. For example:
 *
 * - formatMessage( "{0} second", [ 1 ] ); // 1 second
 *
 * - formatMessage( "{0}/{1}", ["m", "s"] ); // m/s
 *
 * - formatMessage( "{name} <{email}>", {
 *     name: "Foo",
 *     email: "bar@baz.qux"
 *   }); // Foo <bar@baz.qux>
 */
var formatMessage = function( message, data ) {

	// Replace {attribute}'s
	message = message.replace( /{[0-9a-zA-Z-_. ]+}/g, function( name ) {
		name = name.replace( /^{([^}]*)}$/, "$1" );
		return toString( data[ name ] );
	});

	return message;
};




var objectExtend = function() {
	var destination = arguments[ 0 ],
		sources = [].slice.call( arguments, 1 );

	sources.forEach(function( source ) {
		var prop;
		for ( prop in source ) {
			destination[ prop ] = source[ prop ];
		}
	});

	return destination;
};




var createError = function( code, message, attributes ) {
	var error;

	message = code + ( message ? ": " + formatMessage( message, attributes ) : "" );
	error = new Error( message );
	error.code = code;

	objectExtend( error, attributes );

	return error;
};




// Based on http://stackoverflow.com/questions/7616461/generate-a-hash-from-string-in-javascript-jquery
var stringHash = function( str ) {
	return [].reduce.call( str, function( hash, i ) {
		var chr = i.charCodeAt( 0 );
		hash = ( ( hash << 5 ) - hash ) + chr;
		return hash | 0;
	}, 0 );
};




var runtimeKey = function( fnName, locale, args, argsStr ) {
	var hash;
	argsStr = argsStr || JSON.stringify( args );
	hash = stringHash( fnName + locale + argsStr );
	return hash > 0 ? "a" + hash : "b" + Math.abs( hash );
};




var functionName = function( fn ) {
	if ( fn.name !== undefined ) {
		return fn.name;
	}

	// fn.name is not supported by IE.
	var matches = /^function\s+([\w\$]+)\s*\(/.exec( fn.toString() );

	if ( matches && matches.length > 0 ) {
		return matches[ 1 ];
	}
};




var runtimeBind = function( args, cldr, fn, runtimeArgs ) {

	var argsStr = JSON.stringify( args ),
		fnName = functionName( fn ),
		locale = cldr.locale;

	// If name of the function is not available, this is most likely due uglification,
	// which most likely means we are in production, and runtimeBind here is not necessary.
	if ( !fnName ) {
		return fn;
	}

	fn.runtimeKey = runtimeKey( fnName, locale, null, argsStr );

	fn.generatorString = function() {
		return "Globalize(\"" + locale + "\")." + fnName + "(" + argsStr.slice( 1, -1 ) + ")";
	};

	fn.runtimeArgs = runtimeArgs;

	return fn;
};




var validate = function( code, message, check, attributes ) {
	if ( !check ) {
		throw createError( code, message, attributes );
	}
};




var alwaysArray = function( stringOrArray ) {
	return Array.isArray( stringOrArray ) ? stringOrArray : stringOrArray ? [ stringOrArray ] : [];
};




var validateCldr = function( path, value, options ) {
	var skipBoolean;
	options = options || {};

	skipBoolean = alwaysArray( options.skip ).some(function( pathRe ) {
		return pathRe.test( path );
	});

	validate( "E_MISSING_CLDR", "Missing required CLDR content `{path}`.", value || skipBoolean, {
		path: path
	});
};




var validateDefaultLocale = function( value ) {
	validate( "E_DEFAULT_LOCALE_NOT_DEFINED", "Default locale has not been defined.",
		value !== undefined, {} );
};




var validateParameterPresence = function( value, name ) {
	validate( "E_MISSING_PARAMETER", "Missing required parameter `{name}`.",
		value !== undefined, { name: name });
};




/**
 * range( value, name, minimum, maximum )
 *
 * @value [Number].
 *
 * @name [String] name of variable.
 *
 * @minimum [Number]. The lowest valid value, inclusive.
 *
 * @maximum [Number]. The greatest valid value, inclusive.
 */
var validateParameterRange = function( value, name, minimum, maximum ) {
	validate(
		"E_PAR_OUT_OF_RANGE",
		"Parameter `{name}` has value `{value}` out of range [{minimum}, {maximum}].",
		value === undefined || value >= minimum && value <= maximum,
		{
			maximum: maximum,
			minimum: minimum,
			name: name,
			value: value
		}
	);
};




var validateParameterType = function( value, name, check, expected ) {
	validate(
		"E_INVALID_PAR_TYPE",
		"Invalid `{name}` parameter ({value}). {expected} expected.",
		check,
		{
			expected: expected,
			name: name,
			value: value
		}
	);
};




var validateParameterTypeLocale = function( value, name ) {
	validateParameterType(
		value,
		name,
		value === undefined || typeof value === "string" || value instanceof Cldr,
		"String or Cldr instance"
	);
};




/**
 * Function inspired by jQuery Core, but reduced to our use case.
 */
var isPlainObject = function( obj ) {
	return obj !== null && "" + obj === "[object Object]";
};




var validateParameterTypePlainObject = function( value, name ) {
	validateParameterType(
		value,
		name,
		value === undefined || isPlainObject( value ),
		"Plain Object"
	);
};




var alwaysCldr = function( localeOrCldr ) {
	return localeOrCldr instanceof Cldr ? localeOrCldr : new Cldr( localeOrCldr );
};




// ref: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions?redirectlocale=en-US&redirectslug=JavaScript%2FGuide%2FRegular_Expressions
var regexpEscape = function( string ) {
	return string.replace( /([.*+?^=!:${}()|\[\]\/\\])/g, "\\$1" );
};




var stringPad = function( str, count, right ) {
	var length;
	if ( typeof str !== "string" ) {
		str = String( str );
	}
	for ( length = str.length; length < count; length += 1 ) {
		str = ( right ? ( str + "0" ) : ( "0" + str ) );
	}
	return str;
};




function validateLikelySubtags( cldr ) {
	cldr.once( "get", validateCldr );
	cldr.get( "supplemental/likelySubtags" );
}

/**
 * [new] Globalize( locale|cldr )
 *
 * @locale [String]
 *
 * @cldr [Cldr instance]
 *
 * Create a Globalize instance.
 */
function Globalize( locale ) {
	if ( !( this instanceof Globalize ) ) {
		return new Globalize( locale );
	}

	validateParameterPresence( locale, "locale" );
	validateParameterTypeLocale( locale, "locale" );

	this.cldr = alwaysCldr( locale );

	validateLikelySubtags( this.cldr );
}

/**
 * Globalize.load( json, ... )
 *
 * @json [JSON]
 *
 * Load resolved or unresolved cldr data.
 * Somewhat equivalent to previous Globalize.addCultureInfo(...).
 */
Globalize.load = function() {

	// validations are delegated to Cldr.load().
	Cldr.load.apply( Cldr, arguments );
};

/**
 * Globalize.locale( [locale|cldr] )
 *
 * @locale [String]
 *
 * @cldr [Cldr instance]
 *
 * Set default Cldr instance if locale or cldr argument is passed.
 *
 * Return the default Cldr instance.
 */
Globalize.locale = function( locale ) {
	validateParameterTypeLocale( locale, "locale" );

	if ( arguments.length ) {
		this.cldr = alwaysCldr( locale );
		validateLikelySubtags( this.cldr );
	}
	return this.cldr;
};

/**
 * Optimization to avoid duplicating some internal functions across modules.
 */
Globalize._alwaysArray = alwaysArray;
Globalize._createError = createError;
Globalize._formatMessage = formatMessage;
Globalize._isPlainObject = isPlainObject;
Globalize._objectExtend = objectExtend;
Globalize._regexpEscape = regexpEscape;
Globalize._runtimeBind = runtimeBind;
Globalize._stringPad = stringPad;
Globalize._validate = validate;
Globalize._validateCldr = validateCldr;
Globalize._validateDefaultLocale = validateDefaultLocale;
Globalize._validateParameterPresence = validateParameterPresence;
Globalize._validateParameterRange = validateParameterRange;
Globalize._validateParameterTypePlainObject = validateParameterTypePlainObject;
Globalize._validateParameterType = validateParameterType;

return Globalize;




}));
/**
 * Globalize v1.1.2
 *
 * http://github.com/jquery/globalize
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2016-11-08T12:09Z
 */
/*!
 * Globalize v1.1.2 2016-11-08T12:09Z Released under the MIT license
 * http://git.io/TrdQbw
 */
(function( root, factory ) {

	// UMD returnExports
	if ( typeof define === "function" && define.amd ) {

		// AMD
		define([
			"cldr",
			"../globalize",
			"cldr/event"
		], factory );
	} else if ( typeof exports === "object" ) {

		// Node, CommonJS
		module.exports = factory( require( "cldrjs" ), require( "globalize" ) );
	} else {

		// Extend global
		factory( root.Cldr, root.Globalize );
	}
}(this, function( Cldr, Globalize ) {

var alwaysArray = Globalize._alwaysArray,
	createError = Globalize._createError,
	isPlainObject = Globalize._isPlainObject,
	runtimeBind = Globalize._runtimeBind,
	validateDefaultLocale = Globalize._validateDefaultLocale,
	validate = Globalize._validate,
	validateParameterPresence = Globalize._validateParameterPresence,
	validateParameterType = Globalize._validateParameterType,
	validateParameterTypePlainObject = Globalize._validateParameterTypePlainObject;
var MessageFormat;
/* jshint ignore:start */
MessageFormat = (function() {
MessageFormat._parse = (function() {

  /*
   * Generated by PEG.js 0.8.0.
   *
   * http://pegjs.majda.cz/
   */

  function peg$subclass(child, parent) {
    function ctor() { this.constructor = child; }
    ctor.prototype = parent.prototype;
    child.prototype = new ctor();
  }

  function SyntaxError(message, expected, found, offset, line, column) {
    this.message  = message;
    this.expected = expected;
    this.found    = found;
    this.offset   = offset;
    this.line     = line;
    this.column   = column;

    this.name     = "SyntaxError";
  }

  peg$subclass(SyntaxError, Error);

  function parse(input) {
    var options = arguments.length > 1 ? arguments[1] : {},

        peg$FAILED = {},

        peg$startRuleFunctions = { start: peg$parsestart },
        peg$startRuleFunction  = peg$parsestart,

        peg$c0 = [],
        peg$c1 = function(st) {
              return { type: 'messageFormatPattern', statements: st };
            },
        peg$c2 = peg$FAILED,
        peg$c3 = "{",
        peg$c4 = { type: "literal", value: "{", description: "\"{\"" },
        peg$c5 = null,
        peg$c6 = ",",
        peg$c7 = { type: "literal", value: ",", description: "\",\"" },
        peg$c8 = "}",
        peg$c9 = { type: "literal", value: "}", description: "\"}\"" },
        peg$c10 = function(argIdx, efmt) {
              var res = {
                type: "messageFormatElement",
                argumentIndex: argIdx
              };
              if (efmt && efmt.length) {
                res.elementFormat = efmt[1];
              } else {
                res.output = true;
              }
              return res;
            },
        peg$c11 = "plural",
        peg$c12 = { type: "literal", value: "plural", description: "\"plural\"" },
        peg$c13 = function(t, s) {
              return { type: "elementFormat", key: t, val: s };
            },
        peg$c14 = "selectordinal",
        peg$c15 = { type: "literal", value: "selectordinal", description: "\"selectordinal\"" },
        peg$c16 = "select",
        peg$c17 = { type: "literal", value: "select", description: "\"select\"" },
        peg$c18 = function(t, p) {
              return { type: "elementFormat", key: t, val: p };
            },
        peg$c19 = function(op, pf) {
              return { type: "pluralFormatPattern", pluralForms: pf, offset: op || 0 };
            },
        peg$c20 = "offset",
        peg$c21 = { type: "literal", value: "offset", description: "\"offset\"" },
        peg$c22 = ":",
        peg$c23 = { type: "literal", value: ":", description: "\":\"" },
        peg$c24 = function(d) { return d; },
        peg$c25 = function(k, mfp) {
              return { key: k, val: mfp };
            },
        peg$c26 = function(i) { return i; },
        peg$c27 = "=",
        peg$c28 = { type: "literal", value: "=", description: "\"=\"" },
        peg$c29 = function(pf) { return { type: "selectFormatPattern", pluralForms: pf }; },
        peg$c30 = function(p) { return p; },
        peg$c31 = "#",
        peg$c32 = { type: "literal", value: "#", description: "\"#\"" },
        peg$c33 = function() { return {type: 'octothorpe'}; },
        peg$c34 = function(s) { return { type: "string", val: s.join('') }; },
        peg$c35 = { type: "other", description: "identifier" },
        peg$c36 = /^[0-9a-zA-Z$_]/,
        peg$c37 = { type: "class", value: "[0-9a-zA-Z$_]", description: "[0-9a-zA-Z$_]" },
        peg$c38 = /^[^ \t\n\r,.+={}]/,
        peg$c39 = { type: "class", value: "[^ \\t\\n\\r,.+={}]", description: "[^ \\t\\n\\r,.+={}]" },
        peg$c40 = function(s) { return s; },
        peg$c41 = function(chars) { return chars.join(''); },
        peg$c42 = /^[^{}#\\\0-\x1F \t\n\r]/,
        peg$c43 = { type: "class", value: "[^{}#\\\\\\0-\\x1F \\t\\n\\r]", description: "[^{}#\\\\\\0-\\x1F \\t\\n\\r]" },
        peg$c44 = function(x) { return x; },
        peg$c45 = "\\\\",
        peg$c46 = { type: "literal", value: "\\\\", description: "\"\\\\\\\\\"" },
        peg$c47 = function() { return "\\"; },
        peg$c48 = "\\#",
        peg$c49 = { type: "literal", value: "\\#", description: "\"\\\\#\"" },
        peg$c50 = function() { return "#"; },
        peg$c51 = "\\{",
        peg$c52 = { type: "literal", value: "\\{", description: "\"\\\\{\"" },
        peg$c53 = function() { return "\u007B"; },
        peg$c54 = "\\}",
        peg$c55 = { type: "literal", value: "\\}", description: "\"\\\\}\"" },
        peg$c56 = function() { return "\u007D"; },
        peg$c57 = "\\u",
        peg$c58 = { type: "literal", value: "\\u", description: "\"\\\\u\"" },
        peg$c59 = function(h1, h2, h3, h4) {
              return String.fromCharCode(parseInt("0x" + h1 + h2 + h3 + h4));
            },
        peg$c60 = /^[0-9]/,
        peg$c61 = { type: "class", value: "[0-9]", description: "[0-9]" },
        peg$c62 = function(ds) {
            //the number might start with 0 but must not be interpreted as an octal number
            //Hence, the base is passed to parseInt explicitely
            return parseInt((ds.join('')), 10);
          },
        peg$c63 = /^[0-9a-fA-F]/,
        peg$c64 = { type: "class", value: "[0-9a-fA-F]", description: "[0-9a-fA-F]" },
        peg$c65 = { type: "other", description: "whitespace" },
        peg$c66 = function(w) { return w.join(''); },
        peg$c67 = /^[ \t\n\r]/,
        peg$c68 = { type: "class", value: "[ \\t\\n\\r]", description: "[ \\t\\n\\r]" },

        peg$currPos          = 0,
        peg$reportedPos      = 0,
        peg$cachedPos        = 0,
        peg$cachedPosDetails = { line: 1, column: 1, seenCR: false },
        peg$maxFailPos       = 0,
        peg$maxFailExpected  = [],
        peg$silentFails      = 0,

        peg$result;

    if ("startRule" in options) {
      if (!(options.startRule in peg$startRuleFunctions)) {
        throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
      }

      peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
    }

    function text() {
      return input.substring(peg$reportedPos, peg$currPos);
    }

    function offset() {
      return peg$reportedPos;
    }

    function line() {
      return peg$computePosDetails(peg$reportedPos).line;
    }

    function column() {
      return peg$computePosDetails(peg$reportedPos).column;
    }

    function expected(description) {
      throw peg$buildException(
        null,
        [{ type: "other", description: description }],
        peg$reportedPos
      );
    }

    function error(message) {
      throw peg$buildException(message, null, peg$reportedPos);
    }

    function peg$computePosDetails(pos) {
      function advance(details, startPos, endPos) {
        var p, ch;

        for (p = startPos; p < endPos; p++) {
          ch = input.charAt(p);
          if (ch === "\n") {
            if (!details.seenCR) { details.line++; }
            details.column = 1;
            details.seenCR = false;
          } else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
            details.line++;
            details.column = 1;
            details.seenCR = true;
          } else {
            details.column++;
            details.seenCR = false;
          }
        }
      }

      if (peg$cachedPos !== pos) {
        if (peg$cachedPos > pos) {
          peg$cachedPos = 0;
          peg$cachedPosDetails = { line: 1, column: 1, seenCR: false };
        }
        advance(peg$cachedPosDetails, peg$cachedPos, pos);
        peg$cachedPos = pos;
      }

      return peg$cachedPosDetails;
    }

    function peg$fail(expected) {
      if (peg$currPos < peg$maxFailPos) { return; }

      if (peg$currPos > peg$maxFailPos) {
        peg$maxFailPos = peg$currPos;
        peg$maxFailExpected = [];
      }

      peg$maxFailExpected.push(expected);
    }

    function peg$buildException(message, expected, pos) {
      function cleanupExpected(expected) {
        var i = 1;

        expected.sort(function(a, b) {
          if (a.description < b.description) {
            return -1;
          } else if (a.description > b.description) {
            return 1;
          } else {
            return 0;
          }
        });

        while (i < expected.length) {
          if (expected[i - 1] === expected[i]) {
            expected.splice(i, 1);
          } else {
            i++;
          }
        }
      }

      function buildMessage(expected, found) {
        function stringEscape(s) {
          function hex(ch) { return ch.charCodeAt(0).toString(16).toUpperCase(); }

          return s
            .replace(/\\/g,   '\\\\')
            .replace(/"/g,    '\\"')
            .replace(/\x08/g, '\\b')
            .replace(/\t/g,   '\\t')
            .replace(/\n/g,   '\\n')
            .replace(/\f/g,   '\\f')
            .replace(/\r/g,   '\\r')
            .replace(/[\x00-\x07\x0B\x0E\x0F]/g, function(ch) { return '\\x0' + hex(ch); })
            .replace(/[\x10-\x1F\x80-\xFF]/g,    function(ch) { return '\\x'  + hex(ch); })
            .replace(/[\u0180-\u0FFF]/g,         function(ch) { return '\\u0' + hex(ch); })
            .replace(/[\u1080-\uFFFF]/g,         function(ch) { return '\\u'  + hex(ch); });
        }

        var expectedDescs = new Array(expected.length),
            expectedDesc, foundDesc, i;

        for (i = 0; i < expected.length; i++) {
          expectedDescs[i] = expected[i].description;
        }

        expectedDesc = expected.length > 1
          ? expectedDescs.slice(0, -1).join(", ")
              + " or "
              + expectedDescs[expected.length - 1]
          : expectedDescs[0];

        foundDesc = found ? "\"" + stringEscape(found) + "\"" : "end of input";

        return "Expected " + expectedDesc + " but " + foundDesc + " found.";
      }

      var posDetails = peg$computePosDetails(pos),
          found      = pos < input.length ? input.charAt(pos) : null;

      if (expected !== null) {
        cleanupExpected(expected);
      }

      return new SyntaxError(
        message !== null ? message : buildMessage(expected, found),
        expected,
        found,
        pos,
        posDetails.line,
        posDetails.column
      );
    }

    function peg$parsestart() {
      var s0;

      s0 = peg$parsemessageFormatPattern();

      return s0;
    }

    function peg$parsemessageFormatPattern() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parsemessageFormatElement();
      if (s2 === peg$FAILED) {
        s2 = peg$parsestring();
        if (s2 === peg$FAILED) {
          s2 = peg$parseoctothorpe();
        }
      }
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$parsemessageFormatElement();
        if (s2 === peg$FAILED) {
          s2 = peg$parsestring();
          if (s2 === peg$FAILED) {
            s2 = peg$parseoctothorpe();
          }
        }
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c1(s1);
      }
      s0 = s1;

      return s0;
    }

    function peg$parsemessageFormatElement() {
      var s0, s1, s2, s3, s4, s5, s6;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 123) {
        s1 = peg$c3;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c4); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseid();
          if (s3 !== peg$FAILED) {
            s4 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 44) {
              s5 = peg$c6;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c7); }
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parseelementFormat();
              if (s6 !== peg$FAILED) {
                s5 = [s5, s6];
                s4 = s5;
              } else {
                peg$currPos = s4;
                s4 = peg$c2;
              }
            } else {
              peg$currPos = s4;
              s4 = peg$c2;
            }
            if (s4 === peg$FAILED) {
              s4 = peg$c5;
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parse_();
              if (s5 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 125) {
                  s6 = peg$c8;
                  peg$currPos++;
                } else {
                  s6 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c9); }
                }
                if (s6 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c10(s3, s4);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c2;
      }

      return s0;
    }

    function peg$parseelementFormat() {
      var s0, s1, s2, s3, s4, s5, s6, s7;

      s0 = peg$currPos;
      s1 = peg$parse_();
      if (s1 !== peg$FAILED) {
        if (input.substr(peg$currPos, 6) === peg$c11) {
          s2 = peg$c11;
          peg$currPos += 6;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c12); }
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 44) {
              s4 = peg$c6;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c7); }
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parse_();
              if (s5 !== peg$FAILED) {
                s6 = peg$parsepluralFormatPattern();
                if (s6 !== peg$FAILED) {
                  s7 = peg$parse_();
                  if (s7 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c13(s2, s6);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c2;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parse_();
        if (s1 !== peg$FAILED) {
          if (input.substr(peg$currPos, 13) === peg$c14) {
            s2 = peg$c14;
            peg$currPos += 13;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c15); }
          }
          if (s2 !== peg$FAILED) {
            s3 = peg$parse_();
            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 44) {
                s4 = peg$c6;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c7); }
              }
              if (s4 !== peg$FAILED) {
                s5 = peg$parse_();
                if (s5 !== peg$FAILED) {
                  s6 = peg$parsepluralFormatPattern();
                  if (s6 !== peg$FAILED) {
                    s7 = peg$parse_();
                    if (s7 !== peg$FAILED) {
                      peg$reportedPos = s0;
                      s1 = peg$c13(s2, s6);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c2;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parse_();
          if (s1 !== peg$FAILED) {
            if (input.substr(peg$currPos, 6) === peg$c16) {
              s2 = peg$c16;
              peg$currPos += 6;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c17); }
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parse_();
              if (s3 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 44) {
                  s4 = peg$c6;
                  peg$currPos++;
                } else {
                  s4 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c7); }
                }
                if (s4 !== peg$FAILED) {
                  s5 = peg$parse_();
                  if (s5 !== peg$FAILED) {
                    s6 = peg$parseselectFormatPattern();
                    if (s6 !== peg$FAILED) {
                      s7 = peg$parse_();
                      if (s7 !== peg$FAILED) {
                        peg$reportedPos = s0;
                        s1 = peg$c13(s2, s6);
                        s0 = s1;
                      } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c2;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parse_();
            if (s1 !== peg$FAILED) {
              s2 = peg$parseid();
              if (s2 !== peg$FAILED) {
                s3 = [];
                s4 = peg$parseargStylePattern();
                while (s4 !== peg$FAILED) {
                  s3.push(s4);
                  s4 = peg$parseargStylePattern();
                }
                if (s3 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c18(s2, s3);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          }
        }
      }

      return s0;
    }

    function peg$parsepluralFormatPattern() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      s1 = peg$parseoffsetPattern();
      if (s1 === peg$FAILED) {
        s1 = peg$c5;
      }
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$parsepluralForm();
        if (s3 !== peg$FAILED) {
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$parsepluralForm();
          }
        } else {
          s2 = peg$c2;
        }
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c19(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c2;
      }

      return s0;
    }

    function peg$parseoffsetPattern() {
      var s0, s1, s2, s3, s4, s5, s6, s7;

      s0 = peg$currPos;
      s1 = peg$parse_();
      if (s1 !== peg$FAILED) {
        if (input.substr(peg$currPos, 6) === peg$c20) {
          s2 = peg$c20;
          peg$currPos += 6;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c21); }
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 58) {
              s4 = peg$c22;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c23); }
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parse_();
              if (s5 !== peg$FAILED) {
                s6 = peg$parsedigits();
                if (s6 !== peg$FAILED) {
                  s7 = peg$parse_();
                  if (s7 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c24(s6);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c2;
      }

      return s0;
    }

    function peg$parsepluralForm() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8;

      s0 = peg$currPos;
      s1 = peg$parse_();
      if (s1 !== peg$FAILED) {
        s2 = peg$parsepluralKey();
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 123) {
              s4 = peg$c3;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c4); }
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parse_();
              if (s5 !== peg$FAILED) {
                s6 = peg$parsemessageFormatPattern();
                if (s6 !== peg$FAILED) {
                  s7 = peg$parse_();
                  if (s7 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 125) {
                      s8 = peg$c8;
                      peg$currPos++;
                    } else {
                      s8 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c9); }
                    }
                    if (s8 !== peg$FAILED) {
                      peg$reportedPos = s0;
                      s1 = peg$c25(s2, s6);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c2;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c2;
      }

      return s0;
    }

    function peg$parsepluralKey() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = peg$parseid();
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c26(s1);
      }
      s0 = s1;
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 61) {
          s1 = peg$c27;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c28); }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parsedigits();
          if (s2 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c24(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
      }

      return s0;
    }

    function peg$parseselectFormatPattern() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parseselectForm();
      if (s2 !== peg$FAILED) {
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parseselectForm();
        }
      } else {
        s1 = peg$c2;
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c29(s1);
      }
      s0 = s1;

      return s0;
    }

    function peg$parseselectForm() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8;

      s0 = peg$currPos;
      s1 = peg$parse_();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseid();
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 123) {
              s4 = peg$c3;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c4); }
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parse_();
              if (s5 !== peg$FAILED) {
                s6 = peg$parsemessageFormatPattern();
                if (s6 !== peg$FAILED) {
                  s7 = peg$parse_();
                  if (s7 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 125) {
                      s8 = peg$c8;
                      peg$currPos++;
                    } else {
                      s8 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c9); }
                    }
                    if (s8 !== peg$FAILED) {
                      peg$reportedPos = s0;
                      s1 = peg$c25(s2, s6);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c2;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c2;
      }

      return s0;
    }

    function peg$parseargStylePattern() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      s1 = peg$parse_();
      if (s1 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 44) {
          s2 = peg$c6;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c7); }
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            s4 = peg$parseid();
            if (s4 !== peg$FAILED) {
              s5 = peg$parse_();
              if (s5 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c30(s4);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c2;
      }

      return s0;
    }

    function peg$parseoctothorpe() {
      var s0, s1;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 35) {
        s1 = peg$c31;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c32); }
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c33();
      }
      s0 = s1;

      return s0;
    }

    function peg$parsestring() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parsechars();
      if (s2 === peg$FAILED) {
        s2 = peg$parsewhitespace();
      }
      if (s2 !== peg$FAILED) {
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parsechars();
          if (s2 === peg$FAILED) {
            s2 = peg$parsewhitespace();
          }
        }
      } else {
        s1 = peg$c2;
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c34(s1);
      }
      s0 = s1;

      return s0;
    }

    function peg$parseid() {
      var s0, s1, s2, s3, s4, s5, s6;

      peg$silentFails++;
      s0 = peg$currPos;
      s1 = peg$parse_();
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        s3 = peg$currPos;
        if (peg$c36.test(input.charAt(peg$currPos))) {
          s4 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s4 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c37); }
        }
        if (s4 !== peg$FAILED) {
          s5 = [];
          if (peg$c38.test(input.charAt(peg$currPos))) {
            s6 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s6 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c39); }
          }
          while (s6 !== peg$FAILED) {
            s5.push(s6);
            if (peg$c38.test(input.charAt(peg$currPos))) {
              s6 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s6 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c39); }
            }
          }
          if (s5 !== peg$FAILED) {
            s4 = [s4, s5];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$c2;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$c2;
        }
        if (s3 !== peg$FAILED) {
          s3 = input.substring(s2, peg$currPos);
        }
        s2 = s3;
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c40(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c2;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c35); }
      }

      return s0;
    }

    function peg$parsechars() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parsechar();
      if (s2 !== peg$FAILED) {
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parsechar();
        }
      } else {
        s1 = peg$c2;
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c41(s1);
      }
      s0 = s1;

      return s0;
    }

    function peg$parsechar() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      if (peg$c42.test(input.charAt(peg$currPos))) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c43); }
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c44(s1);
      }
      s0 = s1;
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 2) === peg$c45) {
          s1 = peg$c45;
          peg$currPos += 2;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c46); }
        }
        if (s1 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c47();
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c48) {
            s1 = peg$c48;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c49); }
          }
          if (s1 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c50();
          }
          s0 = s1;
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.substr(peg$currPos, 2) === peg$c51) {
              s1 = peg$c51;
              peg$currPos += 2;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c52); }
            }
            if (s1 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c53();
            }
            s0 = s1;
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              if (input.substr(peg$currPos, 2) === peg$c54) {
                s1 = peg$c54;
                peg$currPos += 2;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c55); }
              }
              if (s1 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c56();
              }
              s0 = s1;
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                if (input.substr(peg$currPos, 2) === peg$c57) {
                  s1 = peg$c57;
                  peg$currPos += 2;
                } else {
                  s1 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c58); }
                }
                if (s1 !== peg$FAILED) {
                  s2 = peg$parsehexDigit();
                  if (s2 !== peg$FAILED) {
                    s3 = peg$parsehexDigit();
                    if (s3 !== peg$FAILED) {
                      s4 = peg$parsehexDigit();
                      if (s4 !== peg$FAILED) {
                        s5 = peg$parsehexDigit();
                        if (s5 !== peg$FAILED) {
                          peg$reportedPos = s0;
                          s1 = peg$c59(s2, s3, s4, s5);
                          s0 = s1;
                        } else {
                          peg$currPos = s0;
                          s0 = peg$c2;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c2;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              }
            }
          }
        }
      }

      return s0;
    }

    function peg$parsedigits() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = [];
      if (peg$c60.test(input.charAt(peg$currPos))) {
        s2 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c61); }
      }
      if (s2 !== peg$FAILED) {
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          if (peg$c60.test(input.charAt(peg$currPos))) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c61); }
          }
        }
      } else {
        s1 = peg$c2;
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c62(s1);
      }
      s0 = s1;

      return s0;
    }

    function peg$parsehexDigit() {
      var s0;

      if (peg$c63.test(input.charAt(peg$currPos))) {
        s0 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c64); }
      }

      return s0;
    }

    function peg$parse_() {
      var s0, s1, s2;

      peg$silentFails++;
      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parsewhitespace();
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$parsewhitespace();
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c66(s1);
      }
      s0 = s1;
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c65); }
      }

      return s0;
    }

    function peg$parsewhitespace() {
      var s0;

      if (peg$c67.test(input.charAt(peg$currPos))) {
        s0 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c68); }
      }

      return s0;
    }

    peg$result = peg$startRuleFunction();

    if (peg$result !== peg$FAILED && peg$currPos === input.length) {
      return peg$result;
    } else {
      if (peg$result !== peg$FAILED && peg$currPos < input.length) {
        peg$fail({ type: "end", description: "end of input" });
      }

      throw peg$buildException(null, peg$maxFailExpected, peg$maxFailPos);
    }
  }

  return {
    SyntaxError: SyntaxError,
    parse:       parse
  };
}()).parse;


/** @file messageformat.js - ICU PluralFormat + SelectFormat for JavaScript
 *  @author Alex Sexton - @SlexAxton
 *  @version 0.3.0-1
 *  @copyright 2012-2015 Alex Sexton, Eemeli Aro, and Contributors
 *  @license To use or fork, MIT. To contribute back, Dojo CLA  */


/** Utility function for quoting an Object's key value iff required
 *  @private  */
function propname(key, obj) {
  if (/^[A-Z_$][0-9A-Z_$]*$/i.test(key)) {
    return obj ? obj + '.' + key : key;
  } else {
    var jkey = JSON.stringify(key);
    return obj ? obj + '[' + jkey + ']' : jkey;
  }
};


/** Create a new message formatter
 *
 *  @class
 *  @global
 *  @param {string|string[]} [locale="en"] - The locale to use, with fallbacks
 *  @param {function} [pluralFunc] - Optional custom pluralization function
 *  @param {function[]} [formatters] - Optional custom formatting functions  */
function MessageFormat(locale, pluralFunc, formatters) {
  this.lc = [locale];  
  this.runtime.pluralFuncs = {};
  this.runtime.pluralFuncs[this.lc[0]] = pluralFunc;
  this.runtime.fmt = {};
  if (formatters) for (var f in formatters) {
    this.runtime.fmt[f] = formatters[f];
  }
}




/** Parse an input string to its AST
 *
 *  Precompiled from `lib/messageformat-parser.pegjs` by
 *  {@link http://pegjs.org/ PEG.js}. Included in MessageFormat object
 *  to enable testing.
 *
 *  @private  */



/** Pluralization functions from
 *  {@link http://github.com/eemeli/make-plural.js make-plural}
 *
 *  @memberof MessageFormat
 *  @type Object.<string,function>  */
MessageFormat.plurals = {};


/** Default number formatting functions in the style of ICU's
 *  {@link http://icu-project.org/apiref/icu4j/com/ibm/icu/text/MessageFormat.html simpleArg syntax}
 *  implemented using the
 *  {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl Intl}
 *  object defined by ECMA-402.
 *
 *  **Note**: Intl is not defined in default Node until 0.11.15 / 0.12.0, so
 *  earlier versions require a {@link https://www.npmjs.com/package/intl polyfill}.
 *  Therefore {@link MessageFormat.withIntlSupport} needs to be true for these
 *  functions to be available for inclusion in the output.
 *
 *  @see MessageFormat#setIntlSupport
 *
 *  @namespace
 *  @memberof MessageFormat
 *  @property {function} number - Represent a number as an integer, percent or currency value
 *  @property {function} date - Represent a date as a full/long/default/short string
 *  @property {function} time - Represent a time as a full/long/default/short string
 *
 *  @example
 *  > var MessageFormat = require('messageformat');
 *  > var mf = (new MessageFormat('en')).setIntlSupport(true);
 *  > mf.currency = 'EUR';
 *  > var mfunc = mf.compile("The total is {V,number,currency}.");
 *  > mfunc({V:5.5})
 *  "The total is 5.50."
 *
 *  @example
 *  > var MessageFormat = require('messageformat');
 *  > var mf = new MessageFormat('en', null, {number: MessageFormat.number});
 *  > mf.currency = 'EUR';
 *  > var mfunc = mf.compile("The total is {V,number,currency}.");
 *  > mfunc({V:5.5})
 *  "The total is 5.50."  */
MessageFormat.formatters = {};

/** Enable or disable support for the default formatters, which require the
 *  `Intl` object. Note that this can't be autodetected, as the environment
 *  in which the formatted text is compiled into Javascript functions is not
 *  necessarily the same environment in which they will get executed.
 *
 *  @see MessageFormat.formatters
 *
 *  @memberof MessageFormat
 *  @param {boolean} [enable=true]
 *  @returns {Object} The MessageFormat instance, to allow for chaining
 *  @example
 *  > var Intl = require('intl');
 *  > var MessageFormat = require('messageformat');
 *  > var mf = (new MessageFormat('en')).setIntlSupport(true);
 *  > mf.currency = 'EUR';
 *  > mf.compile("The total is {V,number,currency}.")({V:5.5});
 *  "The total is 5.50."  */



/** A set of utility functions that are called by the compiled Javascript
 *  functions, these are included locally in the output of {@link
 *  MessageFormat#compile compile()}.
 *
 *  @namespace
 *  @memberof MessageFormat  */
MessageFormat.prototype.runtime = {

  /** Utility function for `#` in plural rules
   *
   *  @param {number} value - The value to operate on
   *  @param {number} [offset=0] - An optional offset, set by the surrounding context  */
  number: function(value, offset) {
    if (isNaN(value)) throw new Error("'" + value + "' isn't a number.");
    return value - (offset || 0);
  },

  /** Utility function for `{N, plural|selectordinal, ...}`
   *
   *  @param {number} value - The key to use to find a pluralization rule
   *  @param {number} offset - An offset to apply to `value`
   *  @param {function} lcfunc - A locale function from `pluralFuncs`
   *  @param {Object.<string,string>} data - The object from which results are looked up
   *  @param {?boolean} isOrdinal - If true, use ordinal rather than cardinal rules
   *  @returns {string} The result of the pluralization  */
  plural: function(value, offset, lcfunc, data, isOrdinal) {
    if ({}.hasOwnProperty.call(data, value)) return data[value]();
    if (offset) value -= offset;
    var key = lcfunc(value, isOrdinal);
    if (key in data) return data[key]();
    return data.other();
  },

  /** Utility function for `{N, select, ...}`
   *
   *  @param {number} value - The key to use to find a selection
   *  @param {Object.<string,string>} data - The object from which results are looked up
   *  @returns {string} The result of the select statement  */
  select: function(value, data) {
    if ({}.hasOwnProperty.call(data, value)) return data[value]();
    return data.other()
  },

  /** Pluralization functions included in compiled output
   *  @instance
   *  @type Object.<string,function>  */
  pluralFuncs: {},

  /** Custom formatting functions called by `{var, fn[, args]*}` syntax
   *
   *  For examples, see {@link MessageFormat.formatters}
   *
   *  @instance
   *  @see MessageFormat.formatters
   *  @type Object.<string,function>  */
  fmt: {},

  /** Custom stringifier to clean up browser inconsistencies
   *  @instance  */
  toString: function () {
    var _stringify = function(o, level) {
      if (typeof o != 'object') {
        var funcStr = o.toString().replace(/^(function )\w*/, '$1');
        var indent = /([ \t]*)\S.*$/.exec(funcStr);
        return indent ? funcStr.replace(new RegExp('^' + indent[1], 'mg'), '') : funcStr;
      }
      var s = [];
      for (var i in o) if (i != 'toString') {
        if (level == 0) s.push('var ' + i + ' = ' + _stringify(o[i], level + 1) + ';\n');
        else s.push(propname(i) + ': ' + _stringify(o[i], level + 1));
      }
      if (level == 0) return s.join('');
      if (s.length == 0) return '{}';
      var indent = '  '; while (--level) indent += '  ';
      return '{\n' + s.join(',\n').replace(/^/gm, indent) + '\n}';
    };
    return _stringify(this, 0);
  }
};


/** Recursively map an AST to its resulting string
 *
 *  @memberof MessageFormat
 *
 *  @param ast - the Ast node for which the JS code should be generated
 *
 *  @private  */
MessageFormat.prototype._precompile = function(ast, data) {
  data = data || { keys: {}, offset: {} };
  var r = [], i, tmp, args = [];

  switch ( ast.type ) {
    case 'messageFormatPattern':
      for ( i = 0; i < ast.statements.length; ++i ) {
        r.push(this._precompile( ast.statements[i], data ));
      }
      tmp = r.join(' + ') || '""';
      return data.pf_count ? tmp : 'function(d) { return ' + tmp + '; }';

    case 'messageFormatElement':
      data.pf_count = data.pf_count || 0;
      if ( ast.output ) {
        return propname(ast.argumentIndex, 'd');
      }
      else {
        data.keys[data.pf_count] = ast.argumentIndex;
        return this._precompile( ast.elementFormat, data );
      }
      return '';

    case 'elementFormat':
      args = [ propname(data.keys[data.pf_count], 'd') ];
      switch (ast.key) {
        case 'select':
          args.push(this._precompile(ast.val, data));
          return 'select(' + args.join(', ') + ')';
        case 'selectordinal':
          args = args.concat([ 0, propname(this.lc[0], 'pluralFuncs'), this._precompile(ast.val, data), 1 ]);
          return 'plural(' + args.join(', ') + ')';
        case 'plural':
          data.offset[data.pf_count || 0] = ast.val.offset || 0;
          args = args.concat([ data.offset[data.pf_count] || 0, propname(this.lc[0], 'pluralFuncs'), this._precompile(ast.val, data) ]);
          return 'plural(' + args.join(', ') + ')';
        default:
          if (this.withIntlSupport && !(ast.key in this.runtime.fmt) && (ast.key in MessageFormat.formatters)) {
            tmp = MessageFormat.formatters[ast.key];
            this.runtime.fmt[ast.key] = (typeof tmp(this) == 'function') ? tmp(this) : tmp;
          }
          args.push(JSON.stringify(this.lc));
          if (ast.val && ast.val.length) args.push(JSON.stringify(ast.val.length == 1 ? ast.val[0] : ast.val));
          return 'fmt.' + ast.key + '(' + args.join(', ') + ')';
      }

    case 'pluralFormatPattern':
    case 'selectFormatPattern':
      data.pf_count = data.pf_count || 0;
      if (ast.type == 'selectFormatPattern') data.offset[data.pf_count] = 0;
      var needOther = true;
      for (i = 0; i < ast.pluralForms.length; ++i) {
        var key = ast.pluralForms[i].key;
        if (key === 'other') needOther = false;
        var data_copy = JSON.parse(JSON.stringify(data));
        data_copy.pf_count++;
        r.push(propname(key) + ': function() { return ' + this._precompile(ast.pluralForms[i].val, data_copy) + ';}');
      }
      if (needOther) throw new Error("No 'other' form found in " + ast.type + " " + data.pf_count);
      return '{ ' + r.join(', ') + ' }';

    case 'string':
      return JSON.stringify(ast.val || "");

    case 'octothorpe':
      if (!data.pf_count) return '"#"';
      args = [ propname(data.keys[data.pf_count-1], 'd') ];
      if (data.offset[data.pf_count-1]) args.push(data.offset[data.pf_count-1]);
      return 'number(' + args.join(', ') + ')';

    default:
      throw new Error( 'Bad AST type: ' + ast.type );
  }
};

/** Compile messages into an executable function with clean string
 *  representation.
 *
 *  If `messages` is a single string including ICU MessageFormat declarations,
 *  `opt` is ignored and the returned function takes a single Object parameter
 *  `d` representing each of the input's defined variables. The returned
 *  function will be defined in a local scope that includes all the required
 *  runtime variables.
 *
 *  If `messages` is a map of keys to strings, or a map of namespace keys to
 *  such key/string maps, the returned function will fill the specified global
 *  with javascript functions matching the structure of the input. In such use,
 *  the output of `compile()` is expected to be serialized using `.toString()`,
 *  and will include definitions of the runtime functions. If `opt.global` is
 *  null, calling the output function will return the object itself.
 *
 *  Together, the input parameters should match the following patterns:
 *  ```js
 *  messages = "string" || { key0: "string0", key1: "string1", ... } || {
 *    ns0: { key0: "string0", key1: "string1", ...  },
 *    ns1: { key0: "string0", key1: "string1", ...  },
 *    ...
 *  }
 *
 *  opt = null || {
 *    locale: null || {
 *      ns0: "lc0" || [ "lc0", ... ],
 *      ns1: "lc1" || [ "lc1", ... ],
 *      ...
 *    },
 *    global: null || "module.exports" || "exports" || "i18n" || ...
 *  }
 *  ```
 *
 *  @memberof MessageFormat
 *  @param {string|Object}
 *      messages - The input message(s) to be compiled, in ICU MessageFormat
 *  @param {Object} [opt={}] - Options controlling output for non-simple intput
 *  @param {Object} [opt.locale] - The locales to use for the messages, with a
 *      structure matching that of `messages`
 *  @param {string} [opt.global=""] - The global variable that the output
 *      function should use, or a null string for none. "exports" and
 *      "module.exports" are recognised as special cases.
 *  @returns {function} The first match found for the given locale(s)
 *
 *  @example
 * > var MessageFormat = require('messageformat'),
 * ...   mf = new MessageFormat('en'),
 * ...   mfunc0 = mf.compile('A {TYPE} example.');
 * > mfunc0({TYPE:'simple'})
 * 'A simple example.'
 * > mfunc0.toString()
 * 'function (d) { return "A " + d.TYPE + " example."; }'
 *
 *  @example
 * > var msgSet = { a: 'A {TYPE} example.',
 * ...              b: 'This has {COUNT, plural, one{one member} other{# members}}.' },
 * ...   mfuncSet = mf.compile(msgSet);
 * > mfuncSet().a({TYPE:'more complex'})
 * 'A more complex example.'
 * > mfuncSet().b({COUNT:2})
 * 'This has 2 members.'
 *
 * > console.log(mfuncSet.toString())
 * function anonymous() {
 * var number = function (value, offset) {
 *   if (isNaN(value)) throw new Error("'" + value + "' isn't a number.");
 *   return value - (offset || 0);
 * };
 * var plural = function (value, offset, lcfunc, data, isOrdinal) {
 *   if ({}.hasOwnProperty.call(data, value)) return data[value]();
 *   if (offset) value -= offset;
 *   var key = lcfunc(value, isOrdinal);
 *   if (key in data) return data[key]();
 *   return data.other();
 * };
 * var select = function (value, data) {
 *   if ({}.hasOwnProperty.call(data, value)) return data[value]();
 *   return data.other()
 * };
 * var pluralFuncs = {
 *   en: function (n, ord) {
 *     var s = String(n).split('.'), v0 = !s[1], t0 = Number(s[0]) == n,
 *         n10 = t0 && s[0].slice(-1), n100 = t0 && s[0].slice(-2);
 *     if (ord) return (n10 == 1 && n100 != 11) ? 'one'
 *         : (n10 == 2 && n100 != 12) ? 'two'
 *         : (n10 == 3 && n100 != 13) ? 'few'
 *         : 'other';
 *     return (n == 1 && v0) ? 'one' : 'other';
 *   }
 * };
 * var fmt = {};
 *
 * return {
 *   a: function(d) { return "A " + d.TYPE + " example."; },
 *   b: function(d) { return "This has " + plural(d.COUNT, 0, pluralFuncs.en, { one: function() { return "one member";}, other: function() { return number(d.COUNT)+" members";} }) + "."; }
 * }
 * }
 *
 *  @example
 * > mf.runtime.pluralFuncs.fi = MessageFormat.plurals.fi;
 * > var multiSet = { en: { a: 'A {TYPE} example.',
 * ...                      b: 'This is the {COUNT, selectordinal, one{#st} two{#nd} few{#rd} other{#th}} example.' },
 * ...                fi: { a: '{TYPE} esimerkki.',
 * ...                      b: 'Tm on {COUNT, selectordinal, other{#.}} esimerkki.' } },
 * ...   multiSetLocales = { en: 'en', fi: 'fi' },
 * ...   mfuncSet = mf.compile(multiSet, { locale: multiSetLocales, global: 'i18n' });
 * > mfuncSet(this);
 * > i18n.en.b({COUNT:3})
 * 'This is the 3rd example.'
 * > i18n.fi.b({COUNT:3})
 * 'Tm on 3. esimerkki.'  */
MessageFormat.prototype.compile = function ( messages, opt ) {
  var r = {}, lc0 = this.lc,
      compileMsg = function(self, msg) {
        try {
          var ast = MessageFormat._parse(msg);
          return self._precompile(ast);
        } catch (e) {
          throw new Error((ast ? 'Precompiler' : 'Parser') + ' error: ' + e.toString());
        }
      },
      stringify = function(r, level) {
        if (!level) level = 0;
        if (typeof r != 'object') return r;
        var o = [], indent = '';
        for (var i = 0; i < level; ++i) indent += '  ';
        for (var k in r) o.push('\n' + indent + '  ' + propname(k) + ': ' + stringify(r[k], level + 1));
        return '{' + o.join(',') + '\n' + indent + '}';
      };

  if (typeof messages == 'string') {
    var f = new Function(
        'number, plural, select, pluralFuncs, fmt',
        'return ' + compileMsg(this, messages));
    return f(this.runtime.number, this.runtime.plural, this.runtime.select,
        this.runtime.pluralFuncs, this.runtime.fmt);
  }

  opt = opt || {};

  for (var ns in messages) {
    if (opt.locale) this.lc = opt.locale[ns] && [].concat(opt.locale[ns]) || lc0;
    if (typeof messages[ns] == 'string') {
      try { r[ns] = compileMsg(this, messages[ns]); }
      catch (e) { e.message = e.message.replace(':', ' with `' + ns + '`:'); throw e; }
    } else {
      r[ns] = {};
      for (var key in messages[ns]) {
        try { r[ns][key] = compileMsg(this, messages[ns][key]); }
        catch (e) { e.message = e.message.replace(':', ' with `' + key + '` in `' + ns + '`:'); throw e; }
      }
    }
  }

  this.lc = lc0;
  var s = this.runtime.toString() + '\n';
  switch (opt.global || '') {
    case 'exports':
      var o = [];
      for (var k in r) o.push(propname(k, 'exports') + ' = ' + stringify(r[k]));
      return new Function(s + o.join(';\n'));
    case 'module.exports':
      return new Function(s + 'module.exports = ' + stringify(r));
    case '':
      return new Function(s + 'return ' + stringify(r));
    default:
      return new Function('G', s + propname(opt.global, 'G') + ' = ' + stringify(r));
  }
};


return MessageFormat;
}());
/* jshint ignore:end */


var createErrorPluralModulePresence = function() {
	return createError( "E_MISSING_PLURAL_MODULE", "Plural module not loaded." );
};




var validateMessageBundle = function( cldr ) {
	validate(
		"E_MISSING_MESSAGE_BUNDLE",
		"Missing message bundle for locale `{locale}`.",
		cldr.attributes.bundle && cldr.get( "globalize-messages/{bundle}" ) !== undefined,
		{
			locale: cldr.locale
		}
	);
};




var validateMessagePresence = function( path, value ) {
	path = path.join( "/" );
	validate( "E_MISSING_MESSAGE", "Missing required message content `{path}`.",
		value !== undefined, { path: path } );
};




var validateMessageType = function( path, value ) {
	path = path.join( "/" );
	validate(
		"E_INVALID_MESSAGE",
		"Invalid message content `{path}`. {expected} expected.",
		typeof value === "string",
		{
			expected: "a string",
			path: path
		}
	);
};




var validateParameterTypeMessageVariables = function( value, name ) {
	validateParameterType(
		value,
		name,
		value === undefined || isPlainObject( value ) || Array.isArray( value ),
		"Array or Plain Object"
	);
};




var messageFormatterFn = function( formatter ) {
	return function messageFormatter( variables ) {
		if ( typeof variables === "number" || typeof variables === "string" ) {
			variables = [].slice.call( arguments, 0 );
		}
		validateParameterTypeMessageVariables( variables, "variables" );
		return formatter( variables );
	};
};




var messageFormatterRuntimeBind = function( cldr, messageformatter ) {
	var locale = cldr.locale,
		origToString = messageformatter.toString;

	messageformatter.toString = function() {
		var argNames, argValues, output,
			args = {};

		// Properly adjust SlexAxton/messageformat.js compiled variables with Globalize variables:
		output = origToString.call( messageformatter );

		if ( /number\(/.test( output ) ) {
			args.number = "messageFormat.number";
		}

		if ( /plural\(/.test( output ) ) {
			args.plural = "messageFormat.plural";
		}

		if ( /select\(/.test( output ) ) {
			args.select = "messageFormat.select";
		}

		output.replace( /pluralFuncs(\[([^\]]+)\]|\.([a-zA-Z]+))/, function( match ) {
			args.pluralFuncs = "{" +
				"\"" + locale + "\": Globalize(\"" + locale + "\").pluralGenerator()" +
				"}";
			return match;
		});

		argNames = Object.keys( args ).join( ", " );
		argValues = Object.keys( args ).map(function( key ) {
			return args[ key ];
		}).join( ", " );

		return "(function( " + argNames + " ) {\n" +
			"  return " + output + "\n" +
			"})(" + argValues + ")";
	};

	return messageformatter;
};




var slice = [].slice;

/**
 * .loadMessages( json )
 *
 * @json [JSON]
 *
 * Load translation data.
 */
Globalize.loadMessages = function( json ) {
	var locale,
		customData = {
			"globalize-messages": json,
			"main": {}
		};

	validateParameterPresence( json, "json" );
	validateParameterTypePlainObject( json, "json" );

	// Set available bundles by populating customData main dataset.
	for ( locale in json ) {
		if ( json.hasOwnProperty( locale ) ) {
			customData.main[ locale ] = {};
		}
	}

	Cldr.load( customData );
};

/**
 * .messageFormatter( path )
 *
 * @path [String or Array]
 *
 * Format a message given its path.
 */
Globalize.messageFormatter =
Globalize.prototype.messageFormatter = function( path ) {
	var cldr, formatter, message, pluralGenerator, returnFn,
		args = slice.call( arguments, 0 );

	validateParameterPresence( path, "path" );
	validateParameterType( path, "path", typeof path === "string" || Array.isArray( path ),
		"a String nor an Array" );

	path = alwaysArray( path );
	cldr = this.cldr;

	validateDefaultLocale( cldr );
	validateMessageBundle( cldr );

	message = cldr.get( [ "globalize-messages/{bundle}" ].concat( path ) );
	validateMessagePresence( path, message );

	// If message is an Array, concatenate it.
	if ( Array.isArray( message ) ) {
		message = message.join( " " );
	}
	validateMessageType( path, message );

	// Is plural module present? Yes, use its generator. Nope, use an error generator.
	pluralGenerator = this.plural !== undefined ?
		this.pluralGenerator() :
		createErrorPluralModulePresence;

	formatter = new MessageFormat( cldr.locale, pluralGenerator ).compile( message );

	returnFn = messageFormatterFn( formatter );

	runtimeBind( args, cldr, returnFn,
		[ messageFormatterRuntimeBind( cldr, formatter ), pluralGenerator ] );

	return returnFn;
};

/**
 * .formatMessage( path [, variables] )
 *
 * @path [String or Array]
 *
 * @variables [Number, String, Array or Object]
 *
 * Format a message given its path.
 */
Globalize.formatMessage =
Globalize.prototype.formatMessage = function( path /* , variables */ ) {
	return this.messageFormatter( path ).apply( {}, slice.call( arguments, 1 ) );
};

return Globalize;




}));
/**
 * Globalize v1.1.2
 *
 * http://github.com/jquery/globalize
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2016-11-08T12:09Z
 */
/*!
 * Globalize v1.1.2 2016-11-08T12:09Z Released under the MIT license
 * http://git.io/TrdQbw
 */
(function( root, factory ) {

	// UMD returnExports
	if ( typeof define === "function" && define.amd ) {

		// AMD
		define([
			"cldr",
			"../globalize",
			"cldr/event",
			"cldr/supplemental"
		], factory );
	} else if ( typeof exports === "object" ) {

		// Node, CommonJS
		module.exports = factory( require( "cldrjs" ), require( "globalize" ) );
	} else {

		// Global
		factory( root.Cldr, root.Globalize );
	}
}(this, function( Cldr, Globalize ) {

var createError = Globalize._createError,
	objectExtend = Globalize._objectExtend,
	regexpEscape = Globalize._regexpEscape,
	runtimeBind = Globalize._runtimeBind,
	stringPad = Globalize._stringPad,
	validateCldr = Globalize._validateCldr,
	validateDefaultLocale = Globalize._validateDefaultLocale,
	validateParameterPresence = Globalize._validateParameterPresence,
	validateParameterRange = Globalize._validateParameterRange,
	validateParameterType = Globalize._validateParameterType,
	validateParameterTypePlainObject = Globalize._validateParameterTypePlainObject;


var createErrorUnsupportedFeature = function( feature ) {
	return createError( "E_UNSUPPORTED", "Unsupported {feature}.", {
		feature: feature
	});
};




var validateParameterTypeNumber = function( value, name ) {
	validateParameterType(
		value,
		name,
		value === undefined || typeof value === "number",
		"Number"
	);
};




var validateParameterTypeString = function( value, name ) {
	validateParameterType(
		value,
		name,
		value === undefined || typeof value === "string",
		"a string"
	);
};




/**
 * goupingSeparator( number, primaryGroupingSize, secondaryGroupingSize )
 *
 * @number [Number].
 *
 * @primaryGroupingSize [Number]
 *
 * @secondaryGroupingSize [Number]
 *
 * Return the formatted number with group separator.
 */
var numberFormatGroupingSeparator = function( number, primaryGroupingSize, secondaryGroupingSize ) {
	var index,
		currentGroupingSize = primaryGroupingSize,
		ret = "",
		sep = ",",
		switchToSecondary = secondaryGroupingSize ? true : false;

	number = String( number ).split( "." );
	index = number[ 0 ].length;

	while ( index > currentGroupingSize ) {
		ret = number[ 0 ].slice( index - currentGroupingSize, index ) +
			( ret.length ? sep : "" ) + ret;
		index -= currentGroupingSize;
		if ( switchToSecondary ) {
			currentGroupingSize = secondaryGroupingSize;
			switchToSecondary = false;
		}
	}

	number[ 0 ] = number[ 0 ].slice( 0, index ) + ( ret.length ? sep : "" ) + ret;
	return number.join( "." );
};




/**
 * integerFractionDigits( number, minimumIntegerDigits, minimumFractionDigits,
 * maximumFractionDigits, round, roundIncrement )
 *
 * @number [Number]
 *
 * @minimumIntegerDigits [Number]
 *
 * @minimumFractionDigits [Number]
 *
 * @maximumFractionDigits [Number]
 *
 * @round [Function]
 *
 * @roundIncrement [Function]
 *
 * Return the formatted integer and fraction digits.
 */
var numberFormatIntegerFractionDigits = function( number, minimumIntegerDigits, minimumFractionDigits, maximumFractionDigits, round,
	roundIncrement ) {

	// Fraction
	if ( maximumFractionDigits ) {

		// Rounding
		if ( roundIncrement ) {
			number = round( number, roundIncrement );

		// Maximum fraction digits
		} else {
			number = round( number, { exponent: -maximumFractionDigits } );
		}

		// Minimum fraction digits
		if ( minimumFractionDigits ) {
			number = String( number ).split( "." );
			number[ 1 ] = stringPad( number[ 1 ] || "", minimumFractionDigits, true );
			number = number.join( "." );
		}
	} else {
		number = round( number );
	}

	number = String( number );

	// Minimum integer digits
	if ( minimumIntegerDigits ) {
		number = number.split( "." );
		number[ 0 ] = stringPad( number[ 0 ], minimumIntegerDigits );
		number = number.join( "." );
	}

	return number;
};




/**
 * toPrecision( number, precision, round )
 *
 * @number (Number)
 *
 * @precision (Number) significant figures precision (not decimal precision).
 *
 * @round (Function)
 *
 * Return number.toPrecision( precision ) using the given round function.
 */
var numberToPrecision = function( number, precision, round ) {
	var roundOrder;

	// Get number at two extra significant figure precision.
	number = number.toPrecision( precision + 2 );

	// Then, round it to the required significant figure precision.
	roundOrder = Math.ceil( Math.log( Math.abs( number ) ) / Math.log( 10 ) );
	roundOrder -= precision;

	return round( number, { exponent: roundOrder } );
};




/**
 * toPrecision( number, minimumSignificantDigits, maximumSignificantDigits, round )
 *
 * @number [Number]
 *
 * @minimumSignificantDigits [Number]
 *
 * @maximumSignificantDigits [Number]
 *
 * @round [Function]
 *
 * Return the formatted significant digits number.
 */
var numberFormatSignificantDigits = function( number, minimumSignificantDigits, maximumSignificantDigits, round ) {
	var atMinimum, atMaximum;

	// Sanity check.
	if ( minimumSignificantDigits > maximumSignificantDigits ) {
		maximumSignificantDigits = minimumSignificantDigits;
	}

	atMinimum = numberToPrecision( number, minimumSignificantDigits, round );
	atMaximum = numberToPrecision( number, maximumSignificantDigits, round );

	// Use atMaximum only if it has more significant digits than atMinimum.
	number = +atMinimum === +atMaximum ? atMinimum : atMaximum;

	// Expand integer numbers, eg. 123e5 to 12300.
	number = ( +number ).toString( 10 );

	if ( ( /e/ ).test( number ) ) {
		throw createErrorUnsupportedFeature({
			feature: "integers out of (1e21, 1e-7)"
		});
	}

	// Add trailing zeros if necessary.
	if ( minimumSignificantDigits - number.replace( /^0+|\./g, "" ).length > 0 ) {
		number = number.split( "." );
		number[ 1 ] = stringPad( number[ 1 ] || "", minimumSignificantDigits - number[ 0 ].replace( /^0+/, "" ).length, true );
		number = number.join( "." );
	}

	return number;
};




/**
 * format( number, properties )
 *
 * @number [Number].
 *
 * @properties [Object] Output of number/format-properties.
 *
 * Return the formatted number.
 * ref: http://www.unicode.org/reports/tr35/tr35-numbers.html
 */
var numberFormat = function( number, properties ) {
	var infinitySymbol, maximumFractionDigits, maximumSignificantDigits, minimumFractionDigits,
	minimumIntegerDigits, minimumSignificantDigits, nanSymbol, nuDigitsMap, padding, prefix,
	primaryGroupingSize, pattern, ret, round, roundIncrement, secondaryGroupingSize, suffix,
	symbolMap;

	padding = properties[ 1 ];
	minimumIntegerDigits = properties[ 2 ];
	minimumFractionDigits = properties[ 3 ];
	maximumFractionDigits = properties[ 4 ];
	minimumSignificantDigits = properties[ 5 ];
	maximumSignificantDigits = properties[ 6 ];
	roundIncrement = properties[ 7 ];
	primaryGroupingSize = properties[ 8 ];
	secondaryGroupingSize = properties[ 9 ];
	round = properties[ 15 ];
	infinitySymbol = properties[ 16 ];
	nanSymbol = properties[ 17 ];
	symbolMap = properties[ 18 ];
	nuDigitsMap = properties[ 19 ];

	// NaN
	if ( isNaN( number ) ) {
		return nanSymbol;
	}

	if ( number < 0 ) {
		pattern = properties[ 12 ];
		prefix = properties[ 13 ];
		suffix = properties[ 14 ];
	} else {
		pattern = properties[ 11 ];
		prefix = properties[ 0 ];
		suffix = properties[ 10 ];
	}

	// Infinity
	if ( !isFinite( number ) ) {
		return prefix + infinitySymbol + suffix;
	}

	ret = prefix;

	// Percent
	if ( pattern.indexOf( "%" ) !== -1 ) {
		number *= 100;

	// Per mille
	} else if ( pattern.indexOf( "\u2030" ) !== -1 ) {
		number *= 1000;
	}

	// Significant digit format
	if ( !isNaN( minimumSignificantDigits * maximumSignificantDigits ) ) {
		number = numberFormatSignificantDigits( number, minimumSignificantDigits,
			maximumSignificantDigits, round );

	// Integer and fractional format
	} else {
		number = numberFormatIntegerFractionDigits( number, minimumIntegerDigits,
			minimumFractionDigits, maximumFractionDigits, round, roundIncrement );
	}

	// Remove the possible number minus sign
	number = number.replace( /^-/, "" );

	// Grouping separators
	if ( primaryGroupingSize ) {
		number = numberFormatGroupingSeparator( number, primaryGroupingSize,
			secondaryGroupingSize );
	}

	ret += number;

	// Scientific notation
	// TODO implement here

	// Padding/'([^']|'')+'|''|[.,\-+E%\u2030]/g
	// TODO implement here

	ret += suffix;

	return ret.replace( /('([^']|'')+'|'')|./g, function( character, literal ) {

		// Literals
		if ( literal ) {
			literal = literal.replace( /''/, "'" );
			if ( literal.length > 2 ) {
				literal = literal.slice( 1, -1 );
			}
			return literal;
		}

		// Symbols
		character = character.replace( /[.,\-+E%\u2030]/, function( symbol ) {
			return symbolMap[ symbol ];
		});

		// Numbering system
		if ( nuDigitsMap ) {
			character = character.replace( /[0-9]/, function( digit ) {
				return nuDigitsMap[ +digit ];
			});
		}

		return character;
	});
};




var numberFormatterFn = function( properties ) {
	return function numberFormatter( value ) {
		validateParameterPresence( value, "value" );
		validateParameterTypeNumber( value, "value" );

		return numberFormat( value, properties );
	};
};




/**
 * NumberingSystem( cldr )
 *
 * - http://www.unicode.org/reports/tr35/tr35-numbers.html#otherNumberingSystems
 * - http://cldr.unicode.org/index/bcp47-extension
 * - http://www.unicode.org/reports/tr35/#u_Extension
 */
var numberNumberingSystem = function( cldr ) {
	var nu = cldr.attributes[ "u-nu" ];

	if ( nu ) {
		if ( nu === "traditio" ) {
			nu = "traditional";
		}
		if ( [ "native", "traditional", "finance" ].indexOf( nu ) !== -1 ) {

			// Unicode locale extension `u-nu` is set using either (native, traditional or
			// finance). So, lookup the respective locale's numberingSystem and return it.
			return cldr.main([ "numbers/otherNumberingSystems", nu ]);
		}

		// Unicode locale extension `u-nu` is set with an explicit numberingSystem. Return it.
		return nu;
	}

	// Return the default numberingSystem.
	return cldr.main( "numbers/defaultNumberingSystem" );
};




/**
 * nuMap( cldr )
 *
 * @cldr [Cldr instance].
 *
 * Return digits map if numbering system is different than `latn`.
 */
var numberNumberingSystemDigitsMap = function( cldr ) {
	var aux,
		nu = numberNumberingSystem( cldr );

	if ( nu === "latn" ) {
		return;
	}

	aux = cldr.supplemental([ "numberingSystems", nu ]);

	if ( aux._type !== "numeric" ) {
		throw createErrorUnsupportedFeature( "`" + aux._type + "` numbering system" );
	}

	return aux._digits;
};




/**
 * EBNF representation:
 *
 * number_pattern_re =        prefix?
 *                            padding?
 *                            (integer_fraction_pattern | significant_pattern)
 *                            scientific_notation?
 *                            suffix?
 *
 * prefix =                   non_number_stuff
 *
 * padding =                  "*" regexp(.)
 *
 * integer_fraction_pattern = integer_pattern
 *                            fraction_pattern?
 *
 * integer_pattern =          regexp([#,]*[0,]*0+)
 *
 * fraction_pattern =         "." regexp(0*[0-9]*#*)
 *
 * significant_pattern =      regexp([#,]*@+#*)
 *
 * scientific_notation =      regexp(E\+?0+)
 *
 * suffix =                   non_number_stuff
 *
 * non_number_stuff =         regexp(('[^']+'|''|[^*#@0,.E])*)
 *
 *
 * Regexp groups:
 *
 *  0: number_pattern_re
 *  1: prefix
 *  2: -
 *  3: padding
 *  4: (integer_fraction_pattern | significant_pattern)
 *  5: integer_fraction_pattern
 *  6: integer_pattern
 *  7: fraction_pattern
 *  8: significant_pattern
 *  9: scientific_notation
 * 10: suffix
 * 11: -
 */
var numberPatternRe = ( /^(('[^']+'|''|[^*#@0,.E])*)(\*.)?((([#,]*[0,]*0+)(\.0*[0-9]*#*)?)|([#,]*@+#*))(E\+?0+)?(('[^']+'|''|[^*#@0,.E])*)$/ );




/**
 * format( number, pattern )
 *
 * @number [Number].
 *
 * @pattern [String] raw pattern for numbers.
 *
 * Return the formatted number.
 * ref: http://www.unicode.org/reports/tr35/tr35-numbers.html
 */
var numberPatternProperties = function( pattern ) {
	var aux1, aux2, fractionPattern, integerFractionOrSignificantPattern, integerPattern,
		maximumFractionDigits, maximumSignificantDigits, minimumFractionDigits,
		minimumIntegerDigits, minimumSignificantDigits, padding, prefix, primaryGroupingSize,
		roundIncrement, scientificNotation, secondaryGroupingSize, significantPattern, suffix;

	pattern = pattern.match( numberPatternRe );
	if ( !pattern ) {
		throw new Error( "Invalid pattern: " + pattern );
	}

	prefix = pattern[ 1 ];
	padding = pattern[ 3 ];
	integerFractionOrSignificantPattern = pattern[ 4 ];
	significantPattern = pattern[ 8 ];
	scientificNotation = pattern[ 9 ];
	suffix = pattern[ 10 ];

	// Significant digit format
	if ( significantPattern ) {
		significantPattern.replace( /(@+)(#*)/, function( match, minimumSignificantDigitsMatch, maximumSignificantDigitsMatch ) {
			minimumSignificantDigits = minimumSignificantDigitsMatch.length;
			maximumSignificantDigits = minimumSignificantDigits +
				maximumSignificantDigitsMatch.length;
		});

	// Integer and fractional format
	} else {
		fractionPattern = pattern[ 7 ];
		integerPattern = pattern[ 6 ];

		if ( fractionPattern ) {

			// Minimum fraction digits, and rounding.
			fractionPattern.replace( /[0-9]+/, function( match ) {
				minimumFractionDigits = match;
			});
			if ( minimumFractionDigits ) {
				roundIncrement = +( "0." + minimumFractionDigits );
				minimumFractionDigits = minimumFractionDigits.length;
			} else {
				minimumFractionDigits = 0;
			}

			// Maximum fraction digits
			// 1: ignore decimal character
			maximumFractionDigits = fractionPattern.length - 1 /* 1 */;
		}

		// Minimum integer digits
		integerPattern.replace( /0+$/, function( match ) {
			minimumIntegerDigits = match.length;
		});
	}

	// Scientific notation
	if ( scientificNotation ) {
		throw createErrorUnsupportedFeature({
			feature: "scientific notation (not implemented)"
		});
	}

	// Padding
	if ( padding ) {
		throw createErrorUnsupportedFeature({
			feature: "padding (not implemented)"
		});
	}

	// Grouping
	if ( ( aux1 = integerFractionOrSignificantPattern.lastIndexOf( "," ) ) !== -1 ) {

		// Primary grouping size is the interval between the last group separator and the end of
		// the integer (or the end of the significant pattern).
		aux2 = integerFractionOrSignificantPattern.split( "." )[ 0 ];
		primaryGroupingSize = aux2.length - aux1 - 1;

		// Secondary grouping size is the interval between the last two group separators.
		if ( ( aux2 = integerFractionOrSignificantPattern.lastIndexOf( ",", aux1 - 1 ) ) !== -1 ) {
			secondaryGroupingSize = aux1 - 1 - aux2;
		}
	}

	// Return:
	//  0: @prefix String
	//  1: @padding Array [ <character>, <count> ] TODO
	//  2: @minimumIntegerDigits non-negative integer Number value indicating the minimum integer
	//        digits to be used. Numbers will be padded with leading zeroes if necessary.
	//  3: @minimumFractionDigits and
	//  4: @maximumFractionDigits are non-negative integer Number values indicating the minimum and
	//        maximum fraction digits to be used. Numbers will be rounded or padded with trailing
	//        zeroes if necessary.
	//  5: @minimumSignificantDigits and
	//  6: @maximumSignificantDigits are positive integer Number values indicating the minimum and
	//        maximum fraction digits to be shown. Either none or both of these properties are
	//        present; if they are, they override minimum and maximum integer and fraction digits
	//         the formatter uses however many integer and fraction digits are required to display
	//        the specified number of significant digits.
	//  7: @roundIncrement Decimal round increment or null
	//  8: @primaryGroupingSize
	//  9: @secondaryGroupingSize
	// 10: @suffix String
	return [
		prefix,
		padding,
		minimumIntegerDigits,
		minimumFractionDigits,
		maximumFractionDigits,
		minimumSignificantDigits,
		maximumSignificantDigits,
		roundIncrement,
		primaryGroupingSize,
		secondaryGroupingSize,
		suffix
	];
};




/**
 * Symbol( name, cldr )
 *
 * @name [String] Symbol name.
 *
 * @cldr [Cldr instance].
 *
 * Return the localized symbol given its name.
 */
var numberSymbol = function( name, cldr ) {
	return cldr.main([
		"numbers/symbols-numberSystem-" + numberNumberingSystem( cldr ),
		name
	]);
};




var numberSymbolName = {
	".": "decimal",
	",": "group",
	"%": "percentSign",
	"+": "plusSign",
	"-": "minusSign",
	"E": "exponential",
	"\u2030": "perMille"
};




/**
 * symbolMap( cldr )
 *
 * @cldr [Cldr instance].
 *
 * Return the (localized symbol, pattern symbol) key value pair, eg. {
 *   ".": "",
 *   ",": "",
 *   "%": "",
 *   ...
 * };
 */
var numberSymbolMap = function( cldr ) {
	var symbol,
		symbolMap = {};

	for ( symbol in numberSymbolName ) {
		symbolMap[ symbol ] = numberSymbol( numberSymbolName[ symbol ], cldr );
	}

	return symbolMap;
};




var numberTruncate = function( value ) {
	if ( isNaN( value ) ) {
		return NaN;
	}
	return Math[ value < 0 ? "ceil" : "floor" ]( value );
};




/**
 * round( method )
 *
 * @method [String] with either "round", "ceil", "floor", or "truncate".
 *
 * Return function( value, incrementOrExp ):
 *
 *   @value [Number] eg. 123.45.
 *
 *   @incrementOrExp [Number] optional, eg. 0.1; or
 *     [Object] Either { increment: <value> } or { exponent: <value> }
 *
 *   Return the rounded number, eg:
 *   - round( "round" )( 123.45 ): 123;
 *   - round( "ceil" )( 123.45 ): 124;
 *   - round( "floor" )( 123.45 ): 123;
 *   - round( "truncate" )( 123.45 ): 123;
 *   - round( "round" )( 123.45, 0.1 ): 123.5;
 *   - round( "round" )( 123.45, 10 ): 120;
 *
 *   Based on https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/round
 *   Ref: #376
 */
var numberRound = function( method ) {
	method = method || "round";
	method = method === "truncate" ? numberTruncate : Math[ method ];

	return function( value, incrementOrExp ) {
		var exp, increment;

		value = +value;

		// If the value is not a number, return NaN.
		if ( isNaN( value ) ) {
			return NaN;
		}

		// Exponent given.
		if ( typeof incrementOrExp === "object" && incrementOrExp.exponent ) {
			exp = +incrementOrExp.exponent;
			increment = 1;

			if ( exp === 0 ) {
				return method( value );
			}

			// If the exp is not an integer, return NaN.
			if ( !( typeof exp === "number" && exp % 1 === 0 ) ) {
				return NaN;
			}

		// Increment given.
		} else {
			increment = +incrementOrExp || 1;

			if ( increment === 1 ) {
				return method( value );
			}

			// If the increment is not a number, return NaN.
			if ( isNaN( increment ) ) {
				return NaN;
			}

			increment = increment.toExponential().split( "e" );
			exp = +increment[ 1 ];
			increment = +increment[ 0 ];
		}

		// Shift & Round
		value = value.toString().split( "e" );
		value[ 0 ] = +value[ 0 ] / increment;
		value[ 1 ] = value[ 1 ] ? ( +value[ 1 ] - exp ) : -exp;
		value = method( +( value[ 0 ] + "e" + value[ 1 ] ) );

		// Shift back
		value = value.toString().split( "e" );
		value[ 0 ] = +value[ 0 ] * increment;
		value[ 1 ] = value[ 1 ] ? ( +value[ 1 ] + exp ) : exp;
		return +( value[ 0 ] + "e" + value[ 1 ] );
	};
};




/**
 * formatProperties( pattern, cldr [, options] )
 *
 * @pattern [String] raw pattern for numbers.
 *
 * @cldr [Cldr instance].
 *
 * @options [Object]:
 * - minimumIntegerDigits [Number]
 * - minimumFractionDigits, maximumFractionDigits [Number]
 * - minimumSignificantDigits, maximumSignificantDigits [Number]
 * - round [String] "ceil", "floor", "round" (default), or "truncate".
 * - useGrouping [Boolean] default true.
 *
 * Return the processed properties that will be used in number/format.
 * ref: http://www.unicode.org/reports/tr35/tr35-numbers.html
 */
var numberFormatProperties = function( pattern, cldr, options ) {
	var negativePattern, negativePrefix, negativeProperties, negativeSuffix, positivePattern,
		roundFn, properties;

	function getOptions( attribute, propertyIndex ) {
		if ( attribute in options ) {
			properties[ propertyIndex ] = options[ attribute ];
		}
	}

	options = options || {};
	pattern = pattern.split( ";" );

	positivePattern = pattern[ 0 ];

	negativePattern = pattern[ 1 ] || "-" + positivePattern;
	negativeProperties = numberPatternProperties( negativePattern );
	negativePrefix = negativeProperties[ 0 ];
	negativeSuffix = negativeProperties[ 10 ];

	// Have runtime code to refer to numberRound() instead of including it explicitly.
	roundFn = numberRound( options.round );
	roundFn.generatorString = function() {
		return "numberRound(" + ( options.round ? "\"" + options.round + "\"" : "" ) + ")";
	};

	properties = numberPatternProperties( positivePattern ).concat([
		positivePattern,
		negativePrefix + positivePattern + negativeSuffix,
		negativePrefix,
		negativeSuffix,
		roundFn,
		numberSymbol( "infinity", cldr ),
		numberSymbol( "nan", cldr ),
		numberSymbolMap( cldr ),
		numberNumberingSystemDigitsMap( cldr )
	]);

	getOptions( "minimumIntegerDigits", 2 );
	getOptions( "minimumFractionDigits", 3 );
	getOptions( "maximumFractionDigits", 4 );
	getOptions( "minimumSignificantDigits", 5 );
	getOptions( "maximumSignificantDigits", 6 );

	// Grouping separators
	if ( options.useGrouping === false ) {
		properties[ 8 ] = null;
	}

	// Normalize number of digits if only one of either minimumFractionDigits or
	// maximumFractionDigits is passed in as an option
	if ( "minimumFractionDigits" in options && !( "maximumFractionDigits" in options ) ) {

		// maximumFractionDigits = Math.max( minimumFractionDigits, maximumFractionDigits );
		properties[ 4 ] = Math.max( properties[ 3 ], properties[ 4 ] );
	} else if ( !( "minimumFractionDigits" in options ) &&
			"maximumFractionDigits" in options ) {

		// minimumFractionDigits = Math.min( minimumFractionDigits, maximumFractionDigits );
		properties[ 3 ] = Math.min( properties[ 3 ], properties[ 4 ] );
	}

	// Return:
	// 0-10: see number/pattern-properties.
	// 11: @positivePattern [String] Positive pattern.
	// 12: @negativePattern [String] Negative pattern.
	// 13: @negativePrefix [String] Negative prefix.
	// 14: @negativeSuffix [String] Negative suffix.
	// 15: @round [Function] Round function.
	// 16: @infinitySymbol [String] Infinity symbol.
	// 17: @nanSymbol [String] NaN symbol.
	// 18: @symbolMap [Object] A bunch of other symbols.
	// 19: @nuDigitsMap [Array] Digits map if numbering system is different than `latn`.
	return properties;
};




/**
 * EBNF representation:
 *
 * number_pattern_re =        prefix_including_padding?
 *                            number
 *                            scientific_notation?
 *                            suffix?
 *
 * number =                   integer_including_group_separator fraction_including_decimal_separator
 *
 * integer_including_group_separator =
 *                            regexp([0-9,]*[0-9]+)
 *
 * fraction_including_decimal_separator =
 *                            regexp((\.[0-9]+)?)

 * prefix_including_padding = non_number_stuff
 *
 * scientific_notation =      regexp(E[+-]?[0-9]+)
 *
 * suffix =                   non_number_stuff
 *
 * non_number_stuff =         regexp([^0-9]*)
 *
 *
 * Regexp groups:
 *
 * 0: number_pattern_re
 * 1: prefix
 * 2: integer_including_group_separator fraction_including_decimal_separator
 * 3: integer_including_group_separator
 * 4: fraction_including_decimal_separator
 * 5: scientific_notation
 * 6: suffix
 */
var numberNumberRe = ( /^([^0-9]*)(([0-9,]*[0-9]+)(\.[0-9]+)?)(E[+-]?[0-9]+)?([^0-9]*)$/ );




/**
 * parse( value, properties )
 *
 * @value [String].
 *
 * @properties [Object] Parser properties is a reduced pre-processed cldr
 * data set returned by numberParserProperties().
 *
 * Return the parsed Number (including Infinity) or NaN when value is invalid.
 * ref: http://www.unicode.org/reports/tr35/tr35-numbers.html
 */
var numberParse = function( value, properties ) {
	var aux, infinitySymbol, invertedNuDigitsMap, invertedSymbolMap, localizedDigitRe,
		localizedSymbolsRe, negativePrefix, negativeSuffix, number, prefix, suffix;

	infinitySymbol = properties[ 0 ];
	invertedSymbolMap = properties[ 1 ];
	negativePrefix = properties[ 2 ];
	negativeSuffix = properties[ 3 ];
	invertedNuDigitsMap = properties[ 4 ];

	// Infinite number.
	if ( aux = value.match( infinitySymbol ) ) {

		number = Infinity;
		prefix = value.slice( 0, aux.length );
		suffix = value.slice( aux.length + 1 );

	// Finite number.
	} else {

		// TODO: Create it during setup, i.e., make it a property.
		localizedSymbolsRe = new RegExp(
			Object.keys( invertedSymbolMap ).map(function( localizedSymbol ) {
				return regexpEscape( localizedSymbol );
			}).join( "|" ),
			"g"
		);

		// Reverse localized symbols.
		value = value.replace( localizedSymbolsRe, function( localizedSymbol ) {
			return invertedSymbolMap[ localizedSymbol ];
		});

		// Reverse localized numbering system.
		if ( invertedNuDigitsMap ) {

			// TODO: Create it during setup, i.e., make it a property.
			localizedDigitRe = new RegExp(
				Object.keys( invertedNuDigitsMap ).map(function( localizedDigit ) {
					return regexpEscape( localizedDigit );
				}).join( "|" ),
				"g"
			);
			value = value.replace( localizedDigitRe, function( localizedDigit ) {
				return invertedNuDigitsMap[ localizedDigit ];
			});
		}

		// Add padding zero to leading decimal.
		if ( value.charAt( 0 ) === "." ) {
			value = "0" + value;
		}

		// Is it a valid number?
		value = value.match( numberNumberRe );
		if ( !value ) {

			// Invalid number.
			return NaN;
		}

		prefix = value[ 1 ];
		suffix = value[ 6 ];

		// Remove grouping separators.
		number = value[ 2 ].replace( /,/g, "" );

		// Scientific notation
		if ( value[ 5 ] ) {
			number += value[ 5 ];
		}

		number = +number;

		// Is it a valid number?
		if ( isNaN( number ) ) {

			// Invalid number.
			return NaN;
		}

		// Percent
		if ( value[ 0 ].indexOf( "%" ) !== -1 ) {
			number /= 100;
			suffix = suffix.replace( "%", "" );

		// Per mille
		} else if ( value[ 0 ].indexOf( "\u2030" ) !== -1 ) {
			number /= 1000;
			suffix = suffix.replace( "\u2030", "" );
		}
	}

	// Negative number
	// "If there is an explicit negative subpattern, it serves only to specify the negative prefix
	// and suffix. If there is no explicit negative subpattern, the negative subpattern is the
	// localized minus sign prefixed to the positive subpattern" UTS#35
	if ( prefix === negativePrefix && suffix === negativeSuffix ) {
		number *= -1;
	}

	return number;
};




var numberParserFn = function( properties ) {
	return function numberParser( value ) {
		validateParameterPresence( value, "value" );
		validateParameterTypeString( value, "value" );

		return numberParse( value, properties );
	};

};




/**
 * symbolMap( cldr )
 *
 * @cldr [Cldr instance].
 *
 * Return the (localized symbol, pattern symbol) key value pair, eg. {
 *   "": ".",
 *   "": ",",
 *   "": "%",
 *   ...
 * };
 */
var numberSymbolInvertedMap = function( cldr ) {
	var symbol,
		symbolMap = {};

	for ( symbol in numberSymbolName ) {
		symbolMap[ numberSymbol( numberSymbolName[ symbol ], cldr ) ] = symbol;
	}

	return symbolMap;
};




/**
 * parseProperties( pattern, cldr )
 *
 * @pattern [String] raw pattern for numbers.
 *
 * @cldr [Cldr instance].
 *
 * Return parser properties, used to feed parser function.
 */
var numberParseProperties = function( pattern, cldr ) {
	var invertedNuDigitsMap, invertedNuDigitsMapSanityCheck, negativePattern, negativeProperties,
		nuDigitsMap = numberNumberingSystemDigitsMap( cldr );

	pattern = pattern.split( ";" );
	negativePattern = pattern[ 1 ] || "-" + pattern[ 0 ];
	negativeProperties = numberPatternProperties( negativePattern );
	if ( nuDigitsMap ) {
		invertedNuDigitsMap = nuDigitsMap.split( "" ).reduce(function( object, localizedDigit, i ) {
			object[ localizedDigit ] = String( i );
			return object;
		}, {} );
		invertedNuDigitsMapSanityCheck = "0123456789".split( "" ).reduce(function( object, digit ) {
			object[ digit ] = "invalid";
			return object;
		}, {} );
		invertedNuDigitsMap = objectExtend(
			invertedNuDigitsMapSanityCheck,
			invertedNuDigitsMap
		);
	}

	// 0: @infinitySymbol [String] Infinity symbol.
	// 1: @invertedSymbolMap [Object] Inverted symbol map augmented with sanity check.
	//    The sanity check prevents permissive parsing, i.e., it prevents symbols that doesn't
	//    belong to the localized set to pass through. This is obtained with the result of the
	//    inverted map object overloading symbol name map object (the remaining symbol name
	//    mappings will invalidate parsing, working as the sanity check).
	// 2: @negativePrefix [String] Negative prefix.
	// 3: @negativeSuffix [String] Negative suffix with percent or per mille stripped out.
	// 4: @invertedNuDigitsMap [Object] Inverted digits map if numbering system is different than
	//    `latn` augmented with sanity check (similar to invertedSymbolMap).
	return [
		numberSymbol( "infinity", cldr ),
		objectExtend( {}, numberSymbolName, numberSymbolInvertedMap( cldr ) ),
		negativeProperties[ 0 ],
		negativeProperties[ 10 ].replace( "%", "" ).replace( "\u2030", "" ),
		invertedNuDigitsMap
	];
};




/**
 * Pattern( style )
 *
 * @style [String] "decimal" (default) or "percent".
 *
 * @cldr [Cldr instance].
 */
var numberPattern = function( style, cldr ) {
	if ( style !== "decimal" && style !== "percent" ) {
		throw new Error( "Invalid style" );
	}

	return cldr.main([
		"numbers",
		style + "Formats-numberSystem-" + numberNumberingSystem( cldr ),
		"standard"
	]);
};




function validateDigits( properties ) {
	var minimumIntegerDigits = properties[ 2 ],
		minimumFractionDigits = properties[ 3 ],
		maximumFractionDigits = properties[ 4 ],
		minimumSignificantDigits = properties[ 5 ],
		maximumSignificantDigits = properties[ 6 ];

	// Validate significant digit format properties
	if ( !isNaN( minimumSignificantDigits * maximumSignificantDigits ) ) {
		validateParameterRange( minimumSignificantDigits, "minimumSignificantDigits", 1, 21 );
		validateParameterRange( maximumSignificantDigits, "maximumSignificantDigits",
			minimumSignificantDigits, 21 );

	} else if ( !isNaN( minimumSignificantDigits ) || !isNaN( maximumSignificantDigits ) ) {
		throw new Error( "Neither or both the minimum and maximum significant digits must be " +
			"present" );

	// Validate integer and fractional format
	} else {
		validateParameterRange( minimumIntegerDigits, "minimumIntegerDigits", 1, 21 );
		validateParameterRange( minimumFractionDigits, "minimumFractionDigits", 0, 20 );
		validateParameterRange( maximumFractionDigits, "maximumFractionDigits",
			minimumFractionDigits, 20 );
	}
}

/**
 * .numberFormatter( [options] )
 *
 * @options [Object]:
 * - style: [String] "decimal" (default) or "percent".
 * - see also number/format options.
 *
 * Return a function that formats a number according to the given options and default/instance
 * locale.
 */
Globalize.numberFormatter =
Globalize.prototype.numberFormatter = function( options ) {
	var args, cldr, pattern, properties, returnFn;

	validateParameterTypePlainObject( options, "options" );

	options = options || {};
	cldr = this.cldr;

	args = [ options ];

	validateDefaultLocale( cldr );

	cldr.on( "get", validateCldr );

	if ( options.raw ) {
		pattern = options.raw;
	} else {
		pattern = numberPattern( options.style || "decimal", cldr );
	}

	properties = numberFormatProperties( pattern, cldr, options );

	cldr.off( "get", validateCldr );

	validateDigits( properties );

	returnFn = numberFormatterFn( properties );

	runtimeBind( args, cldr, returnFn, [ properties ] );

	return returnFn;
};

/**
 * .numberParser( [options] )
 *
 * @options [Object]:
 * - style: [String] "decimal" (default) or "percent".
 *
 * Return the number parser according to the default/instance locale.
 */
Globalize.numberParser =
Globalize.prototype.numberParser = function( options ) {
	var args, cldr, pattern, properties, returnFn;

	validateParameterTypePlainObject( options, "options" );

	options = options || {};
	cldr = this.cldr;

	args = [ options ];

	validateDefaultLocale( cldr );

	cldr.on( "get", validateCldr );

	if ( options.raw ) {
		pattern = options.raw;
	} else {
		pattern = numberPattern( options.style || "decimal", cldr );
	}

	properties = numberParseProperties( pattern, cldr );

	cldr.off( "get", validateCldr );

	returnFn = numberParserFn( properties );

	runtimeBind( args, cldr, returnFn, [ properties ] );

	return returnFn;
};

/**
 * .formatNumber( value [, options] )
 *
 * @value [Number] number to be formatted.
 *
 * @options [Object]: see number/format-properties.
 *
 * Format a number according to the given options and default/instance locale.
 */
Globalize.formatNumber =
Globalize.prototype.formatNumber = function( value, options ) {
	validateParameterPresence( value, "value" );
	validateParameterTypeNumber( value, "value" );

	return this.numberFormatter( options )( value );
};

/**
 * .parseNumber( value [, options] )
 *
 * @value [String]
 *
 * @options [Object]: See numberParser().
 *
 * Return the parsed Number (including Infinity) or NaN when value is invalid.
 */
Globalize.parseNumber =
Globalize.prototype.parseNumber = function( value, options ) {
	validateParameterPresence( value, "value" );
	validateParameterTypeString( value, "value" );

	return this.numberParser( options )( value );
};

/**
 * Optimization to avoid duplicating some internal functions across modules.
 */
Globalize._createErrorUnsupportedFeature = createErrorUnsupportedFeature;
Globalize._numberNumberingSystem = numberNumberingSystem;
Globalize._numberPattern = numberPattern;
Globalize._numberSymbol = numberSymbol;
Globalize._stringPad = stringPad;
Globalize._validateParameterTypeNumber = validateParameterTypeNumber;
Globalize._validateParameterTypeString = validateParameterTypeString;

return Globalize;




}));
/*!
 * Globalize v1.1.2
 *
 * http://github.com/jquery/globalize
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2016-11-08T12:09Z
 */
(function( root, factory ) {

	// UMD returnExports
	if ( typeof define === "function" && define.amd ) {

		// AMD
		define([
			"cldr",
			"../globalize",
			"./number",
			"cldr/event",
			"cldr/supplemental"
		], factory );
	} else if ( typeof exports === "object" ) {

		// Node, CommonJS
		module.exports = factory( require( "cldrjs" ), require( "globalize" ) );
	} else {

		// Global
		factory( root.Cldr, root.Globalize );
	}
}(this, function( Cldr, Globalize ) {

var alwaysArray = Globalize._alwaysArray,
	formatMessage = Globalize._formatMessage,
	numberNumberingSystem = Globalize._numberNumberingSystem,
	numberPattern = Globalize._numberPattern,
	runtimeBind = Globalize._runtimeBind,
	stringPad = Globalize._stringPad,
	validateCldr = Globalize._validateCldr,
	validateDefaultLocale = Globalize._validateDefaultLocale,
	validateParameterPresence = Globalize._validateParameterPresence,
	validateParameterType = Globalize._validateParameterType,
	validateParameterTypeNumber = Globalize._validateParameterTypeNumber,
	validateParameterTypePlainObject = Globalize._validateParameterTypePlainObject;


var validateParameterTypeCurrency = function( value, name ) {
	validateParameterType(
		value,
		name,
		value === undefined || typeof value === "string" && ( /^[A-Za-z]{3}$/ ).test( value ),
		"3-letter currency code string as defined by ISO 4217"
	);
};




/**
 * supplementalOverride( currency, pattern, cldr )
 *
 * Return pattern with fraction digits overriden by supplemental currency data.
 */
var currencySupplementalOverride = function( currency, pattern, cldr ) {
	var digits,
		fraction = "",
		fractionData = cldr.supplemental([ "currencyData/fractions", currency ]) ||
			cldr.supplemental( "currencyData/fractions/DEFAULT" );

	digits = +fractionData._digits;

	if ( digits ) {
		fraction = "." + stringPad( "0", digits ).slice( 0, -1 ) + fractionData._rounding;
	}

	return pattern.replace( /\.(#+|0*[0-9]|0+[0-9]?)/g, fraction );
};




var objectFilter = function( object, testRe ) {
	var key,
		copy = {};

	for ( key in object ) {
		if ( testRe.test( key ) ) {
			copy[ key ] = object[ key ];
		}
	}

	return copy;
};




var currencyUnitPatterns = function( cldr ) {
	return objectFilter( cldr.main([
		"numbers",
		"currencyFormats-numberSystem-" + numberNumberingSystem( cldr )
	]), /^unitPattern/ );
};




/**
 * codeProperties( currency, cldr )
 *
 * Return number pattern with the appropriate currency code in as literal.
 */
var currencyCodeProperties = function( currency, cldr ) {
	var pattern = numberPattern( "decimal", cldr );

	// The number of decimal places and the rounding for each currency is not locale-specific. Those
	// values overridden by Supplemental Currency Data.
	pattern = currencySupplementalOverride( currency, pattern, cldr );

	return {
		currency: currency,
		pattern: pattern,
		unitPatterns: currencyUnitPatterns( cldr )
	};
};




/**
 * nameFormat( formattedNumber, pluralForm, properties )
 *
 * Return the appropriate name form currency format.
 */
var currencyNameFormat = function( formattedNumber, pluralForm, properties ) {
	var displayName, unitPattern,
		displayNames = properties.displayNames || {},
		unitPatterns = properties.unitPatterns;

	displayName = displayNames[ "displayName-count-" + pluralForm ] ||
		displayNames[ "displayName-count-other" ] ||
		displayNames.displayName ||
		properties.currency;
	unitPattern = unitPatterns[ "unitPattern-count-" + pluralForm ] ||
		unitPatterns[ "unitPattern-count-other" ];

	return formatMessage( unitPattern, [ formattedNumber, displayName ]);
};




var currencyFormatterFn = function( numberFormatter, pluralGenerator, properties ) {
	var fn;

	// Return formatter when style is "code" or "name".
	if ( pluralGenerator && properties ) {
		fn = function currencyFormatter( value ) {
			validateParameterPresence( value, "value" );
			validateParameterTypeNumber( value, "value" );
			return currencyNameFormat(
				numberFormatter( value ),
				pluralGenerator( value ),
				properties
			);
		};

	// Return formatter when style is "symbol" or "accounting".
	} else {
		fn = function currencyFormatter( value ) {
			return numberFormatter( value );
		};
	}

	return fn;
};




/**
 * nameProperties( currency, cldr )
 *
 * Return number pattern with the appropriate currency code in as literal.
 */
var currencyNameProperties = function( currency, cldr ) {
	var properties = currencyCodeProperties( currency, cldr );

	properties.displayNames = objectFilter( cldr.main([
		"numbers/currencies",
		currency
	]), /^displayName/ );

	return properties;
};




/**
 * Unicode regular expression for: everything except math symbols, currency signs, dingbats, and
 * box-drawing characters.
 *
 * Generated by:
 *
 * regenerate()
 *   .addRange( 0x0, 0x10FFFF )
 *   .remove( require( "unicode-7.0.0/categories/S/symbols" ) ).toString();
 *
 * https://github.com/mathiasbynens/regenerate
 * https://github.com/mathiasbynens/unicode-7.0.0
 */
var regexpNotS = /[\0-#%-\*,-;\?-\]_a-\{\}\x7F-\xA1\xA7\xAA\xAB\xAD\xB2\xB3\xB5-\xB7\xB9-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376-\u0383\u0386-\u03F5\u03F7-\u0481\u0483-\u058C\u0590-\u0605\u0609\u060A\u060C\u060D\u0610-\u06DD\u06DF-\u06E8\u06EA-\u06FC\u06FF-\u07F5\u07F7-\u09F1\u09F4-\u09F9\u09FC-\u0AF0\u0AF2-\u0B6F\u0B71-\u0BF2\u0BFB-\u0C7E\u0C80-\u0D78\u0D7A-\u0E3E\u0E40-\u0F00\u0F04-\u0F12\u0F14\u0F18\u0F19\u0F20-\u0F33\u0F35\u0F37\u0F39-\u0FBD\u0FC6\u0FCD\u0FD0-\u0FD4\u0FD9-\u109D\u10A0-\u138F\u139A-\u17DA\u17DC-\u193F\u1941-\u19DD\u1A00-\u1B60\u1B6B-\u1B73\u1B7D-\u1FBC\u1FBE\u1FC2-\u1FCC\u1FD0-\u1FDC\u1FE0-\u1FEC\u1FF0-\u1FFC\u1FFF-\u2043\u2045-\u2051\u2053-\u2079\u207D-\u2089\u208D-\u209F\u20BE-\u20FF\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2150-\u218F\u2308-\u230B\u2329\u232A\u23FB-\u23FF\u2427-\u243F\u244B-\u249B\u24EA-\u24FF\u2768-\u2793\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2B74\u2B75\u2B96\u2B97\u2BBA-\u2BBC\u2BC9\u2BD2-\u2CE4\u2CEB-\u2E7F\u2E9A\u2EF4-\u2EFF\u2FD6-\u2FEF\u2FFC-\u3003\u3005-\u3011\u3014-\u301F\u3021-\u3035\u3038-\u303D\u3040-\u309A\u309D-\u318F\u3192-\u3195\u31A0-\u31BF\u31E4-\u31FF\u321F-\u3229\u3248-\u324F\u3251-\u325F\u3280-\u3289\u32B1-\u32BF\u32FF\u3400-\u4DBF\u4E00-\uA48F\uA4C7-\uA6FF\uA717-\uA71F\uA722-\uA788\uA78B-\uA827\uA82C-\uA835\uA83A-\uAA76\uAA7A-\uAB5A\uAB5C-\uD7FF\uDC00-\uFB28\uFB2A-\uFBB1\uFBC2-\uFDFB\uFDFE-\uFE61\uFE63\uFE67\uFE68\uFE6A-\uFF03\uFF05-\uFF0A\uFF0C-\uFF1B\uFF1F-\uFF3D\uFF3F\uFF41-\uFF5B\uFF5D\uFF5F-\uFFDF\uFFE7\uFFEF-\uFFFB\uFFFE\uFFFF]|\uD800[\uDC00-\uDD36\uDD40-\uDD78\uDD8A\uDD8B\uDD8D-\uDD8F\uDD9C-\uDD9F\uDDA1-\uDDCF\uDDFD-\uDFFF]|[\uD801\uD803-\uD819\uD81B-\uD82E\uD830-\uD833\uD836-\uD83A\uD83F-\uDBFF][\uDC00-\uDFFF]|\uD802[\uDC00-\uDC76\uDC79-\uDEC7\uDEC9-\uDFFF]|\uD81A[\uDC00-\uDF3B\uDF40-\uDF44\uDF46-\uDFFF]|\uD82F[\uDC00-\uDC9B\uDC9D-\uDFFF]|\uD834[\uDCF6-\uDCFF\uDD27\uDD28\uDD65-\uDD69\uDD6D-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDDDE-\uDDFF\uDE42-\uDE44\uDE46-\uDEFF\uDF57-\uDFFF]|\uD835[\uDC00-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFFF]|\uD83B[\uDC00-\uDEEF\uDEF2-\uDFFF]|\uD83C[\uDC2C-\uDC2F\uDC94-\uDC9F\uDCAF\uDCB0\uDCC0\uDCD0\uDCF6-\uDD0F\uDD2F\uDD6C-\uDD6F\uDD9B-\uDDE5\uDE03-\uDE0F\uDE3B-\uDE3F\uDE49-\uDE4F\uDE52-\uDEFF\uDF2D-\uDF2F\uDF7E\uDF7F\uDFCF-\uDFD3\uDFF8-\uDFFF]|\uD83D[\uDCFF\uDD4B-\uDD4F\uDD7A\uDDA4\uDE43\uDE44\uDED0-\uDEDF\uDEED-\uDEEF\uDEF4-\uDEFF\uDF74-\uDF7F\uDFD5-\uDFFF]|\uD83E[\uDC0C-\uDC0F\uDC48-\uDC4F\uDC5A-\uDC5F\uDC88-\uDC8F\uDCAE-\uDFFF]|[\uD800-\uDBFF]/;




/**
 * symbolProperties( currency, cldr )
 *
 * Return pattern replacing `` with the appropriate currency symbol literal.
 */
var currencySymbolProperties = function( currency, cldr, options ) {
	var currencySpacing, pattern,
		regexp = {
			"[:digit:]": /\d/,
			"[:^S:]": regexpNotS
		},
		symbol = cldr.main([
			"numbers/currencies",
			currency,
			"symbol"
		]);

	currencySpacing = [ "beforeCurrency", "afterCurrency" ].map(function( position ) {
		return cldr.main([
			"numbers",
			"currencyFormats-numberSystem-" + numberNumberingSystem( cldr ),
			"currencySpacing",
			position
		]);
	});

	pattern = cldr.main([
		"numbers",
		"currencyFormats-numberSystem-" + numberNumberingSystem( cldr ),
		options.style === "accounting" ? "accounting" : "standard"
	]);

	pattern =

		// The number of decimal places and the rounding for each currency is not locale-specific.
		// Those values are overridden by Supplemental Currency Data.
		currencySupplementalOverride( currency, pattern, cldr )

		// Replace "" (\u00A4) with the appropriate symbol literal.
		.split( ";" ).map(function( pattern ) {

			return pattern.split( "\u00A4" ).map(function( part, i ) {
				var currencyMatch = regexp[ currencySpacing[ i ].currencyMatch ],
					surroundingMatch = regexp[ currencySpacing[ i ].surroundingMatch ],
					insertBetween = "";

				// For currencyMatch and surroundingMatch definitions, read [1].
				// When i === 0, beforeCurrency is being handled. Otherwise, afterCurrency.
				// 1: http://www.unicode.org/reports/tr35/tr35-numbers.html#Currencies
				currencyMatch = currencyMatch.test( symbol.charAt( i ? symbol.length - 1 : 0 ) );
				surroundingMatch = surroundingMatch.test(
					part.charAt( i ? 0 : part.length - 1 ).replace( /[#@,.]/g, "0" )
				);

				if ( currencyMatch && part && surroundingMatch ) {
					insertBetween = currencySpacing[ i ].insertBetween;
				}

				return ( i ? insertBetween : "" ) + part + ( i ? "" : insertBetween );
			}).join( "'" + symbol + "'" );
		}).join( ";" );

	return {
		pattern: pattern
	};
};




/**
 * objectOmit( object, keys )
 *
 * Return a copy of the object, filtered to omit the blacklisted key or array of keys.
 */
var objectOmit = function( object, keys ) {
	var key,
		copy = {};

	keys = alwaysArray( keys );

	for ( key in object ) {
		if ( keys.indexOf( key ) === -1 ) {
			copy[ key ] = object[ key ];
		}
	}

	return copy;
};




function validateRequiredCldr( path, value ) {
	validateCldr( path, value, {
		skip: [ /supplemental\/currencyData\/fractions\/[A-Za-z]{3}$/ ]
	});
}

/**
 * .currencyFormatter( currency [, options] )
 *
 * @currency [String] 3-letter currency code as defined by ISO 4217.
 *
 * @options [Object]:
 * - style: [String] "symbol" (default), "accounting", "code" or "name".
 * - see also number/format options.
 *
 * Return a function that formats a currency according to the given options and default/instance
 * locale.
 */
Globalize.currencyFormatter =
Globalize.prototype.currencyFormatter = function( currency, options ) {
	var args, cldr, numberFormatter, pluralGenerator, properties, returnFn, style;

	validateParameterPresence( currency, "currency" );
	validateParameterTypeCurrency( currency, "currency" );

	validateParameterTypePlainObject( options, "options" );

	cldr = this.cldr;
	options = options || {};

	args = [ currency, options ];
	style = options.style || "symbol";

	validateDefaultLocale( cldr );

	// Get properties given style ("symbol" default, "code" or "name").
	cldr.on( "get", validateRequiredCldr );
	properties = ({
		accounting: currencySymbolProperties,
		code: currencyCodeProperties,
		name: currencyNameProperties,
		symbol: currencySymbolProperties
	}[ style ] )( currency, cldr, options );
	cldr.off( "get", validateRequiredCldr );

	// options = options minus style, plus raw pattern.
	options = objectOmit( options, "style" );
	options.raw = properties.pattern;

	// Return formatter when style is "symbol" or "accounting".
	if ( style === "symbol" || style === "accounting" ) {
		numberFormatter = this.numberFormatter( options );

		returnFn = currencyFormatterFn( numberFormatter );

		runtimeBind( args, cldr, returnFn, [ numberFormatter ] );

	// Return formatter when style is "code" or "name".
	} else {
		numberFormatter = this.numberFormatter( options );
		pluralGenerator = this.pluralGenerator();

		returnFn = currencyFormatterFn( numberFormatter, pluralGenerator, properties );

		runtimeBind( args, cldr, returnFn, [ numberFormatter, pluralGenerator, properties ] );
	}

	return returnFn;
};

/**
 * .currencyParser( currency [, options] )
 *
 * @currency [String] 3-letter currency code as defined by ISO 4217.
 *
 * @options [Object] see currencyFormatter.
 *
 * Return the currency parser according to the given options and the default/instance locale.
 */
Globalize.currencyParser =
Globalize.prototype.currencyParser = function( /* currency, options */ ) {

	// TODO implement parser.

};

/**
 * .formatCurrency( value, currency [, options] )
 *
 * @value [Number] number to be formatted.
 *
 * @currency [String] 3-letter currency code as defined by ISO 4217.
 *
 * @options [Object] see currencyFormatter.
 *
 * Format a currency according to the given options and the default/instance locale.
 */
Globalize.formatCurrency =
Globalize.prototype.formatCurrency = function( value, currency, options ) {
	validateParameterPresence( value, "value" );
	validateParameterTypeNumber( value, "value" );

	return this.currencyFormatter( currency, options )( value );
};

/**
 * .parseCurrency( value, currency [, options] )
 *
 * @value [String]
 *
 * @currency [String] 3-letter currency code as defined by ISO 4217.
 *
 * @options [Object]: See currencyFormatter.
 *
 * Return the parsed currency or NaN when value is invalid.
 */
Globalize.parseCurrency =
Globalize.prototype.parseCurrency = function( /* value, currency, options */ ) {
};

return Globalize;




}));
/**
 * Globalize v1.1.2
 *
 * http://github.com/jquery/globalize
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2016-11-08T12:09Z
 */
/*!
 * Globalize v1.1.2 2016-11-08T12:09Z Released under the MIT license
 * http://git.io/TrdQbw
 */
(function( root, factory ) {

	// UMD returnExports
	if ( typeof define === "function" && define.amd ) {

		// AMD
		define([
			"cldr",
			"../globalize",
			"./number",
			"cldr/event",
			"cldr/supplemental"
		], factory );
	} else if ( typeof exports === "object" ) {

		// Node, CommonJS
		module.exports = factory( require( "cldrjs" ), require( "globalize" ) );
	} else {

		// Extend global
		factory( root.Cldr, root.Globalize );
	}
}(this, function( Cldr, Globalize ) {

var createError = Globalize._createError,
	createErrorUnsupportedFeature = Globalize._createErrorUnsupportedFeature,
	formatMessage = Globalize._formatMessage,
	numberSymbol = Globalize._numberSymbol,
	regexpEscape = Globalize._regexpEscape,
	runtimeBind = Globalize._runtimeBind,
	stringPad = Globalize._stringPad,
	validateCldr = Globalize._validateCldr,
	validateDefaultLocale = Globalize._validateDefaultLocale,
	validateParameterPresence = Globalize._validateParameterPresence,
	validateParameterType = Globalize._validateParameterType,
	validateParameterTypePlainObject = Globalize._validateParameterTypePlainObject,
	validateParameterTypeString = Globalize._validateParameterTypeString;


var validateParameterTypeDate = function( value, name ) {
	validateParameterType( value, name, value === undefined || value instanceof Date, "Date" );
};




var createErrorInvalidParameterValue = function( name, value ) {
	return createError( "E_INVALID_PAR_VALUE", "Invalid `{name}` value ({value}).", {
		name: name,
		value: value
	});
};




/**
 * expandPattern( options, cldr )
 *
 * @options [Object] if String, it's considered a skeleton. Object accepts:
 * - skeleton: [String] lookup availableFormat;
 * - date: [String] ( "full" | "long" | "medium" | "short" );
 * - time: [String] ( "full" | "long" | "medium" | "short" );
 * - datetime: [String] ( "full" | "long" | "medium" | "short" );
 * - raw: [String] For more info see datetime/format.js.
 *
 * @cldr [Cldr instance].
 *
 * Return the corresponding pattern.
 * Eg for "en":
 * - "GyMMMd" returns "MMM d, y G";
 * - { skeleton: "GyMMMd" } returns "MMM d, y G";
 * - { date: "full" } returns "EEEE, MMMM d, y";
 * - { time: "full" } returns "h:mm:ss a zzzz";
 * - { datetime: "full" } returns "EEEE, MMMM d, y 'at' h:mm:ss a zzzz";
 * - { raw: "dd/mm" } returns "dd/mm";
 */

var dateExpandPattern = function( options, cldr ) {
	var dateSkeleton, result, skeleton, timeSkeleton, type;

	function combineDateTime( type, datePattern, timePattern ) {
		return formatMessage(
			cldr.main([
				"dates/calendars/gregorian/dateTimeFormats",
				type
			]),
			[ timePattern, datePattern ]
		);
	}

	switch ( true ) {
		case "skeleton" in options:
			skeleton = options.skeleton;
			result = cldr.main([
				"dates/calendars/gregorian/dateTimeFormats/availableFormats",
				skeleton
			]);
			if ( !result ) {
				timeSkeleton = skeleton.split( /[^hHKkmsSAzZOvVXx]/ ).slice( -1 )[ 0 ];
				dateSkeleton = skeleton.split( /[^GyYuUrQqMLlwWdDFgEec]/ )[ 0 ];
				if ( /(MMMM|LLLL).*[Ec]/.test( dateSkeleton ) ) {
					type = "full";
				} else if ( /MMMM/g.test( dateSkeleton ) ) {
					type = "long";
				} else if ( /MMM/g.test( dateSkeleton ) || /LLL/g.test( dateSkeleton ) ) {
					type = "medium";
				} else {
					type = "short";
				}
				result = combineDateTime( type,
					cldr.main([
						"dates/calendars/gregorian/dateTimeFormats/availableFormats",
						dateSkeleton
					]),
					cldr.main([
						"dates/calendars/gregorian/dateTimeFormats/availableFormats",
						timeSkeleton
					])
				);
			}
			break;

		case "date" in options:
		case "time" in options:
			result = cldr.main([
				"dates/calendars/gregorian",
				"date" in options ? "dateFormats" : "timeFormats",
				( options.date || options.time )
			]);
			break;

		case "datetime" in options:
			result = combineDateTime( options.datetime,
				cldr.main([ "dates/calendars/gregorian/dateFormats", options.datetime ]),
				cldr.main([ "dates/calendars/gregorian/timeFormats", options.datetime ])
			);
			break;

		case "raw" in options:
			result = options.raw;
			break;

		default:
			throw createErrorInvalidParameterValue({
				name: "options",
				value: options
			});
	}

	return result;
};




/**
 * dayOfWeek( date, firstDay )
 *
 * @date
 *
 * @firstDay the result of `dateFirstDayOfWeek( cldr )`
 *
 * Return the day of the week normalized by the territory's firstDay [0-6].
 * Eg for "mon":
 * - return 0 if territory is GB, or BR, or DE, or FR (week starts on "mon");
 * - return 1 if territory is US (week starts on "sun");
 * - return 2 if territory is EG (week starts on "sat");
 */
var dateDayOfWeek = function( date, firstDay ) {
	return ( date.getDay() - firstDay + 7 ) % 7;
};




/**
 * distanceInDays( from, to )
 *
 * Return the distance in days between from and to Dates.
 */
var dateDistanceInDays = function( from, to ) {
	var inDays = 864e5;
	return ( to.getTime() - from.getTime() ) / inDays;
};




/**
 * startOf changes the input to the beginning of the given unit.
 *
 * For example, starting at the start of a day, resets hours, minutes
 * seconds and milliseconds to 0. Starting at the month does the same, but
 * also sets the date to 1.
 *
 * Returns the modified date
 */
var dateStartOf = function( date, unit ) {
	date = new Date( date.getTime() );
	switch ( unit ) {
		case "year":
			date.setMonth( 0 );
		/* falls through */
		case "month":
			date.setDate( 1 );
		/* falls through */
		case "day":
			date.setHours( 0 );
		/* falls through */
		case "hour":
			date.setMinutes( 0 );
		/* falls through */
		case "minute":
			date.setSeconds( 0 );
		/* falls through */
		case "second":
			date.setMilliseconds( 0 );
	}
	return date;
};




/**
 * dayOfYear
 *
 * Return the distance in days of the date to the begin of the year [0-d].
 */
var dateDayOfYear = function( date ) {
	return Math.floor( dateDistanceInDays( dateStartOf( date, "year" ), date ) );
};




/**
 * millisecondsInDay
 */
var dateMillisecondsInDay = function( date ) {

	// TODO Handle daylight savings discontinuities
	return date - dateStartOf( date, "day" );
};




var datePatternRe = ( /([a-z])\1*|'([^']|'')+'|''|./ig );




/**
 * hourFormat( date, format, timeSeparator, formatNumber )
 *
 * Return date's timezone offset according to the format passed.
 * Eg for format when timezone offset is 180:
 * - "+H;-H": -3
 * - "+HHmm;-HHmm": -0300
 * - "+HH:mm;-HH:mm": -03:00
 */
var dateTimezoneHourFormat = function( date, format, timeSeparator, formatNumber ) {
	var absOffset,
		offset = date.getTimezoneOffset();

	absOffset = Math.abs( offset );
	formatNumber = formatNumber || {
		1: function( value ) {
			return stringPad( value, 1 );
		},
		2: function( value ) {
			return stringPad( value, 2 );
		}
	};

	return format

		// Pick the correct sign side (+ or -).
		.split( ";" )[ offset > 0 ? 1 : 0 ]

		// Localize time separator
		.replace( ":", timeSeparator )

		// Update hours offset.
		.replace( /HH?/, function( match ) {
			return formatNumber[ match.length ]( Math.floor( absOffset / 60 ) );
		})

		// Update minutes offset and return.
		.replace( /mm/, function() {
			return formatNumber[ 2 ]( absOffset % 60 );
		});
};




var dateWeekDays = [ "sun", "mon", "tue", "wed", "thu", "fri", "sat" ];




/**
 * format( date, properties )
 *
 * @date [Date instance].
 *
 * @properties
 *
 * TODO Support other calendar types.
 *
 * Disclosure: this function borrows excerpts of dojo/date/locale.
 */
var dateFormat = function( date, numberFormatters, properties ) {
	var timeSeparator = properties.timeSeparator;

	return properties.pattern.replace( datePatternRe, function( current ) {
		var ret,
			chr = current.charAt( 0 ),
			length = current.length;

		if ( chr === "j" ) {

			// Locale preferred hHKk.
			// http://www.unicode.org/reports/tr35/tr35-dates.html#Time_Data
			chr = properties.preferredTime;
		}

		if ( chr === "Z" ) {

			// Z..ZZZ: same as "xxxx".
			if ( length < 4 ) {
				chr = "x";
				length = 4;

			// ZZZZ: same as "OOOO".
			} else if ( length < 5 ) {
				chr = "O";
				length = 4;

			// ZZZZZ: same as "XXXXX"
			} else {
				chr = "X";
				length = 5;
			}
		}

		switch ( chr ) {

			// Era
			case "G":
				ret = properties.eras[ date.getFullYear() < 0 ? 0 : 1 ];
				break;

			// Year
			case "y":

				// Plain year.
				// The length specifies the padding, but for two letters it also specifies the
				// maximum length.
				ret = date.getFullYear();
				if ( length === 2 ) {
					ret = String( ret );
					ret = +ret.substr( ret.length - 2 );
				}
				break;

			case "Y":

				// Year in "Week of Year"
				// The length specifies the padding, but for two letters it also specifies the
				// maximum length.
				// yearInWeekofYear = date + DaysInAWeek - (dayOfWeek - firstDay) - minDays
				ret = new Date( date.getTime() );
				ret.setDate(
					ret.getDate() + 7 -
					dateDayOfWeek( date, properties.firstDay ) -
					properties.firstDay -
					properties.minDays
				);
				ret = ret.getFullYear();
				if ( length === 2 ) {
					ret = String( ret );
					ret = +ret.substr( ret.length - 2 );
				}
				break;

			// Quarter
			case "Q":
			case "q":
				ret = Math.ceil( ( date.getMonth() + 1 ) / 3 );
				if ( length > 2 ) {
					ret = properties.quarters[ chr ][ length ][ ret ];
				}
				break;

			// Month
			case "M":
			case "L":
				ret = date.getMonth() + 1;
				if ( length > 2 ) {
					ret = properties.months[ chr ][ length ][ ret ];
				}
				break;

			// Week
			case "w":

				// Week of Year.
				// woy = ceil( ( doy + dow of 1/1 ) / 7 ) - minDaysStuff ? 1 : 0.
				// TODO should pad on ww? Not documented, but I guess so.
				ret = dateDayOfWeek( dateStartOf( date, "year" ), properties.firstDay );
				ret = Math.ceil( ( dateDayOfYear( date ) + ret ) / 7 ) -
					( 7 - ret >= properties.minDays ? 0 : 1 );
				break;

			case "W":

				// Week of Month.
				// wom = ceil( ( dom + dow of `1/month` ) / 7 ) - minDaysStuff ? 1 : 0.
				ret = dateDayOfWeek( dateStartOf( date, "month" ), properties.firstDay );
				ret = Math.ceil( ( date.getDate() + ret ) / 7 ) -
					( 7 - ret >= properties.minDays ? 0 : 1 );
				break;

			// Day
			case "d":
				ret = date.getDate();
				break;

			case "D":
				ret = dateDayOfYear( date ) + 1;
				break;

			case "F":

				// Day of Week in month. eg. 2nd Wed in July.
				ret = Math.floor( date.getDate() / 7 ) + 1;
				break;

			// Week day
			case "e":
			case "c":
				if ( length <= 2 ) {

					// Range is [1-7] (deduced by example provided on documentation)
					// TODO Should pad with zeros (not specified in the docs)?
					ret = dateDayOfWeek( date, properties.firstDay ) + 1;
					break;
				}

			/* falls through */
			case "E":
				ret = dateWeekDays[ date.getDay() ];
				ret = properties.days[ chr ][ length ][ ret ];
				break;

			// Period (AM or PM)
			case "a":
				ret = properties.dayPeriods[ date.getHours() < 12 ? "am" : "pm" ];
				break;

			// Hour
			case "h": // 1-12
				ret = ( date.getHours() % 12 ) || 12;
				break;

			case "H": // 0-23
				ret = date.getHours();
				break;

			case "K": // 0-11
				ret = date.getHours() % 12;
				break;

			case "k": // 1-24
				ret = date.getHours() || 24;
				break;

			// Minute
			case "m":
				ret = date.getMinutes();
				break;

			// Second
			case "s":
				ret = date.getSeconds();
				break;

			case "S":
				ret = Math.round( date.getMilliseconds() * Math.pow( 10, length - 3 ) );
				break;

			case "A":
				ret = Math.round( dateMillisecondsInDay( date ) * Math.pow( 10, length - 3 ) );
				break;

			// Zone
			case "z":
			case "O":

				// O: "{gmtFormat}+H;{gmtFormat}-H" or "{gmtZeroFormat}", eg. "GMT-8" or "GMT".
				// OOOO: "{gmtFormat}{hourFormat}" or "{gmtZeroFormat}", eg. "GMT-08:00" or "GMT".
				if ( date.getTimezoneOffset() === 0 ) {
					ret = properties.gmtZeroFormat;
				} else {
					ret = dateTimezoneHourFormat(
						date,
						length < 4 ? "+H;-H" : properties.tzLongHourFormat,
						timeSeparator,
						numberFormatters
					);
					ret = properties.gmtFormat.replace( /\{0\}/, ret );
				}
				break;

			case "X":

				// Same as x*, except it uses "Z" for zero offset.
				if ( date.getTimezoneOffset() === 0 ) {
					ret = "Z";
					break;
				}

			/* falls through */
			case "x":

				// x: hourFormat("+HH;-HH")
				// xx or xxxx: hourFormat("+HHmm;-HHmm")
				// xxx or xxxxx: hourFormat("+HH:mm;-HH:mm")
				ret = length === 1 ? "+HH;-HH" : ( length % 2 ? "+HH:mm;-HH:mm" : "+HHmm;-HHmm" );
				ret = dateTimezoneHourFormat( date, ret, ":" );
				break;

			// timeSeparator
			case ":":
				ret = timeSeparator;
				break;

			// ' literals.
			case "'":
				current = current.replace( /''/, "'" );
				if ( length > 2 ) {
					current = current.slice( 1, -1 );
				}
				ret = current;
				break;

			// Anything else is considered a literal, including [ ,:/.@#], chinese, japonese, and
			// arabic characters.
			default:
				ret = current;
		}
		if ( typeof ret === "number" ) {
			ret = numberFormatters[ length ]( ret );
		}
		return ret;
	});
};




var dateFormatterFn = function( numberFormatters, properties ) {
	return function dateFormatter( value ) {
		validateParameterPresence( value, "value" );
		validateParameterTypeDate( value, "value" );

		return dateFormat( value, numberFormatters, properties );
	};

};




/**
 * firstDayOfWeek
 */
var dateFirstDayOfWeek = function( cldr ) {
	return dateWeekDays.indexOf( cldr.supplemental.weekData.firstDay() );
};




/**
 * properties( pattern, cldr )
 *
 * @pattern [String] raw pattern.
 * ref: http://www.unicode.org/reports/tr35/tr35-dates.html#Date_Format_Patterns
 *
 * @cldr [Cldr instance].
 *
 * Return the properties given the pattern and cldr.
 *
 * TODO Support other calendar types.
 */
var dateFormatProperties = function( pattern, cldr ) {
	var properties = {
			numberFormatters: {},
			pattern: pattern,
			timeSeparator: numberSymbol( "timeSeparator", cldr )
		},
		widths = [ "abbreviated", "wide", "narrow" ];

	function setNumberFormatterPattern( pad ) {
		properties.numberFormatters[ pad ] = stringPad( "", pad );
	}

	pattern.replace( datePatternRe, function( current ) {
		var formatNumber,
			chr = current.charAt( 0 ),
			length = current.length;

		if ( chr === "j" ) {

			// Locale preferred hHKk.
			// http://www.unicode.org/reports/tr35/tr35-dates.html#Time_Data
			properties.preferredTime = chr = cldr.supplemental.timeData.preferred();
		}

		// ZZZZ: same as "OOOO".
		if ( chr === "Z" && length === 4 ) {
			chr = "O";
			length = 4;
		}

		switch ( chr ) {

			// Era
			case "G":
				properties.eras = cldr.main([
					"dates/calendars/gregorian/eras",
					length <= 3 ? "eraAbbr" : ( length === 4 ? "eraNames" : "eraNarrow" )
				]);
				break;

			// Year
			case "y":

				// Plain year.
				formatNumber = true;
				break;

			case "Y":

				// Year in "Week of Year"
				properties.firstDay = dateFirstDayOfWeek( cldr );
				properties.minDays = cldr.supplemental.weekData.minDays();
				formatNumber = true;
				break;

			case "u": // Extended year. Need to be implemented.
			case "U": // Cyclic year name. Need to be implemented.
				throw createErrorUnsupportedFeature({
					feature: "year pattern `" + chr + "`"
				});

			// Quarter
			case "Q":
			case "q":
				if ( length > 2 ) {
					if ( !properties.quarters ) {
						properties.quarters = {};
					}
					if ( !properties.quarters[ chr ] ) {
						properties.quarters[ chr ] = {};
					}
					properties.quarters[ chr ][ length ] = cldr.main([
						"dates/calendars/gregorian/quarters",
						chr === "Q" ? "format" : "stand-alone",
						widths[ length - 3 ]
					]);
				} else {
					formatNumber = true;
				}
				break;

			// Month
			case "M":
			case "L":
				if ( length > 2 ) {
					if ( !properties.months ) {
						properties.months = {};
					}
					if ( !properties.months[ chr ] ) {
						properties.months[ chr ] = {};
					}
					properties.months[ chr ][ length ] = cldr.main([
						"dates/calendars/gregorian/months",
						chr === "M" ? "format" : "stand-alone",
						widths[ length - 3 ]
					]);
				} else {
					formatNumber = true;
				}
				break;

			// Week - Week of Year (w) or Week of Month (W).
			case "w":
			case "W":
				properties.firstDay = dateFirstDayOfWeek( cldr );
				properties.minDays = cldr.supplemental.weekData.minDays();
				formatNumber = true;
				break;

			// Day
			case "d":
			case "D":
			case "F":
				formatNumber = true;
				break;

			case "g":

				// Modified Julian day. Need to be implemented.
				throw createErrorUnsupportedFeature({
					feature: "Julian day pattern `g`"
				});

			// Week day
			case "e":
			case "c":
				if ( length <= 2 ) {
					properties.firstDay = dateFirstDayOfWeek( cldr );
					formatNumber = true;
					break;
				}

			/* falls through */
			case "E":
				if ( !properties.days ) {
					properties.days = {};
				}
				if ( !properties.days[ chr ] ) {
					properties.days[ chr ] = {};
				}
				if ( length === 6 ) {

					// If short day names are not explicitly specified, abbreviated day names are
					// used instead.
					// http://www.unicode.org/reports/tr35/tr35-dates.html#months_days_quarters_eras
					// http://unicode.org/cldr/trac/ticket/6790
					properties.days[ chr ][ length ] = cldr.main([
							"dates/calendars/gregorian/days",
							chr === "c" ? "stand-alone" : "format",
							"short"
						]) || cldr.main([
							"dates/calendars/gregorian/days",
							chr === "c" ? "stand-alone" : "format",
							"abbreviated"
						]);
				} else {
					properties.days[ chr ][ length ] = cldr.main([
						"dates/calendars/gregorian/days",
						chr === "c" ? "stand-alone" : "format",
						widths[ length < 3 ? 0 : length - 3 ]
					]);
				}
				break;

			// Period (AM or PM)
			case "a":
				properties.dayPeriods = cldr.main(
					"dates/calendars/gregorian/dayPeriods/format/wide"
				);
				break;

			// Hour
			case "h": // 1-12
			case "H": // 0-23
			case "K": // 0-11
			case "k": // 1-24

			// Minute
			case "m":

			// Second
			case "s":
			case "S":
			case "A":
				formatNumber = true;
				break;

			// Zone
			case "z":
			case "O":

				// O: "{gmtFormat}+H;{gmtFormat}-H" or "{gmtZeroFormat}", eg. "GMT-8" or "GMT".
				// OOOO: "{gmtFormat}{hourFormat}" or "{gmtZeroFormat}", eg. "GMT-08:00" or "GMT".
				properties.gmtFormat = cldr.main( "dates/timeZoneNames/gmtFormat" );
				properties.gmtZeroFormat = cldr.main( "dates/timeZoneNames/gmtZeroFormat" );
				properties.tzLongHourFormat = cldr.main( "dates/timeZoneNames/hourFormat" );

			/* falls through */
			case "Z":
			case "X":
			case "x":
				setNumberFormatterPattern( 1 );
				setNumberFormatterPattern( 2 );
				break;

			case "v":
			case "V":
				throw createErrorUnsupportedFeature({
					feature: "timezone pattern `" + chr + "`"
				});
		}

		if ( formatNumber ) {
			setNumberFormatterPattern( length );
		}
	});

	return properties;
};




/**
 * isLeapYear( year )
 *
 * @year [Number]
 *
 * Returns an indication whether the specified year is a leap year.
 */
var dateIsLeapYear = function( year ) {
	return new Date( year, 1, 29 ).getMonth() === 1;
};




/**
 * lastDayOfMonth( date )
 *
 * @date [Date]
 *
 * Return the last day of the given date's month
 */
var dateLastDayOfMonth = function( date ) {
	return new Date( date.getFullYear(), date.getMonth() + 1, 0 ).getDate();
};




/**
 * Differently from native date.setDate(), this function returns a date whose
 * day remains inside the month boundaries. For example:
 *
 * setDate( FebDate, 31 ): a "Feb 28" date.
 * setDate( SepDate, 31 ): a "Sep 30" date.
 */
var dateSetDate = function( date, day ) {
	var lastDay = new Date( date.getFullYear(), date.getMonth() + 1, 0 ).getDate();

	date.setDate( day < 1 ? 1 : day < lastDay ? day : lastDay );
};




/**
 * Differently from native date.setMonth(), this function adjusts date if
 * needed, so final month is always the one set.
 *
 * setMonth( Jan31Date, 1 ): a "Feb 28" date.
 * setDate( Jan31Date, 8 ): a "Sep 30" date.
 */
var dateSetMonth = function( date, month ) {
	var originalDate = date.getDate();

	date.setDate( 1 );
	date.setMonth( month );
	dateSetDate( date, originalDate );
};




var outOfRange = function( value, low, high ) {
	return value < low || value > high;
};




/**
 * parse( value, tokens, properties )
 *
 * @value [String] string date.
 *
 * @tokens [Object] tokens returned by date/tokenizer.
 *
 * @properties [Object] output returned by date/tokenizer-properties.
 *
 * ref: http://www.unicode.org/reports/tr35/tr35-dates.html#Date_Format_Patterns
 */
var dateParse = function( value, tokens, properties ) {
	var amPm, day, daysOfYear, month, era, hour, hour12, timezoneOffset, valid,
		YEAR = 0,
		MONTH = 1,
		DAY = 2,
		HOUR = 3,
		MINUTE = 4,
		SECOND = 5,
		MILLISECONDS = 6,
		date = new Date(),
		truncateAt = [],
		units = [ "year", "month", "day", "hour", "minute", "second", "milliseconds" ];

	if ( !tokens.length ) {
		return null;
	}

	valid = tokens.every(function( token ) {
		var century, chr, value, length;

		if ( token.type === "literal" ) {

			// continue
			return true;
		}

		chr = token.type.charAt( 0 );
		length = token.type.length;

		if ( chr === "j" ) {

			// Locale preferred hHKk.
			// http://www.unicode.org/reports/tr35/tr35-dates.html#Time_Data
			chr = properties.preferredTimeData;
		}

		switch ( chr ) {

			// Era
			case "G":
				truncateAt.push( YEAR );
				era = +token.value;
				break;

			// Year
			case "y":
				value = token.value;
				if ( length === 2 ) {
					if ( outOfRange( value, 0, 99 ) ) {
						return false;
					}

					// mimic dojo/date/locale: choose century to apply, according to a sliding
					// window of 80 years before and 20 years after present year.
					century = Math.floor( date.getFullYear() / 100 ) * 100;
					value += century;
					if ( value > date.getFullYear() + 20 ) {
						value -= 100;
					}
				}
				date.setFullYear( value );
				truncateAt.push( YEAR );
				break;

			case "Y": // Year in "Week of Year"
				throw createErrorUnsupportedFeature({
					feature: "year pattern `" + chr + "`"
				});

			// Quarter (skip)
			case "Q":
			case "q":
				break;

			// Month
			case "M":
			case "L":
				if ( length <= 2 ) {
					value = token.value;
				} else {
					value = +token.value;
				}
				if ( outOfRange( value, 1, 12 ) ) {
					return false;
				}

				// Setting the month later so that we have the correct year and can determine
				// the correct last day of February in case of leap year.
				month = value;
				truncateAt.push( MONTH );
				break;

			// Week (skip)
			case "w": // Week of Year.
			case "W": // Week of Month.
				break;

			// Day
			case "d":
				day = token.value;
				truncateAt.push( DAY );
				break;

			case "D":
				daysOfYear = token.value;
				truncateAt.push( DAY );
				break;

			case "F":

				// Day of Week in month. eg. 2nd Wed in July.
				// Skip
				break;

			// Week day
			case "e":
			case "c":
			case "E":

				// Skip.
				// value = arrayIndexOf( dateWeekDays, token.value );
				break;

			// Period (AM or PM)
			case "a":
				amPm = token.value;
				break;

			// Hour
			case "h": // 1-12
				value = token.value;
				if ( outOfRange( value, 1, 12 ) ) {
					return false;
				}
				hour = hour12 = true;
				date.setHours( value === 12 ? 0 : value );
				truncateAt.push( HOUR );
				break;

			case "K": // 0-11
				value = token.value;
				if ( outOfRange( value, 0, 11 ) ) {
					return false;
				}
				hour = hour12 = true;
				date.setHours( value );
				truncateAt.push( HOUR );
				break;

			case "k": // 1-24
				value = token.value;
				if ( outOfRange( value, 1, 24 ) ) {
					return false;
				}
				hour = true;
				date.setHours( value === 24 ? 0 : value );
				truncateAt.push( HOUR );
				break;

			case "H": // 0-23
				value = token.value;
				if ( outOfRange( value, 0, 23 ) ) {
					return false;
				}
				hour = true;
				date.setHours( value );
				truncateAt.push( HOUR );
				break;

			// Minute
			case "m":
				value = token.value;
				if ( outOfRange( value, 0, 59 ) ) {
					return false;
				}
				date.setMinutes( value );
				truncateAt.push( MINUTE );
				break;

			// Second
			case "s":
				value = token.value;
				if ( outOfRange( value, 0, 59 ) ) {
					return false;
				}
				date.setSeconds( value );
				truncateAt.push( SECOND );
				break;

			case "A":
				date.setHours( 0 );
				date.setMinutes( 0 );
				date.setSeconds( 0 );

			/* falls through */
			case "S":
				value = Math.round( token.value * Math.pow( 10, 3 - length ) );
				date.setMilliseconds( value );
				truncateAt.push( MILLISECONDS );
				break;

			// Zone
			case "Z":
			case "z":
			case "O":
			case "X":
			case "x":
				timezoneOffset = token.value - date.getTimezoneOffset();
				break;
		}

		return true;
	});

	if ( !valid ) {
		return null;
	}

	// 12-hour format needs AM or PM, 24-hour format doesn't, ie. return null
	// if amPm && !hour12 || !amPm && hour12.
	if ( hour && !( !amPm ^ hour12 ) ) {
		return null;
	}

	if ( era === 0 ) {

		// 1 BC = year 0
		date.setFullYear( date.getFullYear() * -1 + 1 );
	}

	if ( month !== undefined ) {
		dateSetMonth( date, month - 1 );
	}

	if ( day !== undefined ) {
		if ( outOfRange( day, 1, dateLastDayOfMonth( date ) ) ) {
			return null;
		}
		date.setDate( day );
	} else if ( daysOfYear !== undefined ) {
		if ( outOfRange( daysOfYear, 1, dateIsLeapYear( date.getFullYear() ) ? 366 : 365 ) ) {
			return null;
		}
		date.setMonth( 0 );
		date.setDate( daysOfYear );
	}

	if ( hour12 && amPm === "pm" ) {
		date.setHours( date.getHours() + 12 );
	}

	if ( timezoneOffset ) {
		date.setMinutes( date.getMinutes() + timezoneOffset );
	}

	// Truncate date at the most precise unit defined. Eg.
	// If value is "12/31", and pattern is "MM/dd":
	// => new Date( <current Year>, 12, 31, 0, 0, 0, 0 );
	truncateAt = Math.max.apply( null, truncateAt );
	date = dateStartOf( date, units[ truncateAt ] );

	return date;
};




/**
 * Generated by:
 *
 * regenerate().add( require( "unicode-7.0.0/categories/N/symbols" ) ).toString();
 *
 * https://github.com/mathiasbynens/regenerate
 * https://github.com/mathiasbynens/unicode-7.0.0
 */
var regexpN = /[0-9\xB2\xB3\xB9\xBC-\xBE\u0660-\u0669\u06F0-\u06F9\u07C0-\u07C9\u0966-\u096F\u09E6-\u09EF\u09F4-\u09F9\u0A66-\u0A6F\u0AE6-\u0AEF\u0B66-\u0B6F\u0B72-\u0B77\u0BE6-\u0BF2\u0C66-\u0C6F\u0C78-\u0C7E\u0CE6-\u0CEF\u0D66-\u0D75\u0DE6-\u0DEF\u0E50-\u0E59\u0ED0-\u0ED9\u0F20-\u0F33\u1040-\u1049\u1090-\u1099\u1369-\u137C\u16EE-\u16F0\u17E0-\u17E9\u17F0-\u17F9\u1810-\u1819\u1946-\u194F\u19D0-\u19DA\u1A80-\u1A89\u1A90-\u1A99\u1B50-\u1B59\u1BB0-\u1BB9\u1C40-\u1C49\u1C50-\u1C59\u2070\u2074-\u2079\u2080-\u2089\u2150-\u2182\u2185-\u2189\u2460-\u249B\u24EA-\u24FF\u2776-\u2793\u2CFD\u3007\u3021-\u3029\u3038-\u303A\u3192-\u3195\u3220-\u3229\u3248-\u324F\u3251-\u325F\u3280-\u3289\u32B1-\u32BF\uA620-\uA629\uA6E6-\uA6EF\uA830-\uA835\uA8D0-\uA8D9\uA900-\uA909\uA9D0-\uA9D9\uA9F0-\uA9F9\uAA50-\uAA59\uABF0-\uABF9\uFF10-\uFF19]|\uD800[\uDD07-\uDD33\uDD40-\uDD78\uDD8A\uDD8B\uDEE1-\uDEFB\uDF20-\uDF23\uDF41\uDF4A\uDFD1-\uDFD5]|\uD801[\uDCA0-\uDCA9]|\uD802[\uDC58-\uDC5F\uDC79-\uDC7F\uDCA7-\uDCAF\uDD16-\uDD1B\uDE40-\uDE47\uDE7D\uDE7E\uDE9D-\uDE9F\uDEEB-\uDEEF\uDF58-\uDF5F\uDF78-\uDF7F\uDFA9-\uDFAF]|\uD803[\uDE60-\uDE7E]|\uD804[\uDC52-\uDC6F\uDCF0-\uDCF9\uDD36-\uDD3F\uDDD0-\uDDD9\uDDE1-\uDDF4\uDEF0-\uDEF9]|\uD805[\uDCD0-\uDCD9\uDE50-\uDE59\uDEC0-\uDEC9]|\uD806[\uDCE0-\uDCF2]|\uD809[\uDC00-\uDC6E]|\uD81A[\uDE60-\uDE69\uDF50-\uDF59\uDF5B-\uDF61]|\uD834[\uDF60-\uDF71]|\uD835[\uDFCE-\uDFFF]|\uD83A[\uDCC7-\uDCCF]|\uD83C[\uDD00-\uDD0C]/;




/**
 * tokenizer( value, pattern, properties )
 *
 * @value [String] string date.
 *
 * @properties [Object] output returned by date/tokenizer-properties.
 *
 * Returns an Array of tokens, eg. value "5 o'clock PM", pattern "h 'o''clock' a":
 * [{
 *   type: "h",
 *   lexeme: "5"
 * }, {
 *   type: "literal",
 *   lexeme: " "
 * }, {
 *   type: "literal",
 *   lexeme: "o'clock"
 * }, {
 *   type: "literal",
 *   lexeme: " "
 * }, {
 *   type: "a",
 *   lexeme: "PM",
 *   value: "pm"
 * }]
 *
 * OBS: lexeme's are always String and may return invalid ranges depending of the token type.
 * Eg. "99" for month number.
 *
 * Return an empty Array when not successfully parsed.
 */
var dateTokenizer = function( value, numberParser, properties ) {
	var valid,
		timeSeparator = properties.timeSeparator,
		tokens = [],
		widths = [ "abbreviated", "wide", "narrow" ];

	valid = properties.pattern.match( datePatternRe ).every(function( current ) {
		var chr, length, numeric, tokenRe,
			token = {};

		function hourFormatParse( tokenRe, numberParser ) {
			var aux = value.match( tokenRe );
			numberParser = numberParser || function( value ) {
				return +value;
			};

			if ( !aux ) {
				return false;
			}

			// hourFormat containing H only, e.g., `+H;-H`
			if ( aux.length < 8 ) {
				token.value =
					( aux[ 1 ] ? -numberParser( aux[ 1 ] ) : numberParser( aux[ 4 ] ) ) * 60;

			// hourFormat containing H and m, e.g., `+HHmm;-HHmm`
			} else {
				token.value =
					( aux[ 1 ] ? -numberParser( aux[ 1 ] ) : numberParser( aux[ 7 ] ) ) * 60 +
					( aux[ 1 ] ? -numberParser( aux[ 4 ] ) : numberParser( aux[ 10 ] ) );
			}

			return true;
		}

		// Transform:
		// - "+H;-H" -> /\+(\d\d?)|-(\d\d?)/
		// - "+HH;-HH" -> /\+(\d\d)|-(\d\d)/
		// - "+HHmm;-HHmm" -> /\+(\d\d)(\d\d)|-(\d\d)(\d\d)/
		// - "+HH:mm;-HH:mm" -> /\+(\d\d):(\d\d)|-(\d\d):(\d\d)/
		//
		// If gmtFormat is GMT{0}, the regexp must fill {0} in each side, e.g.:
		// - "+H;-H" -> /GMT\+(\d\d?)|GMT-(\d\d?)/
		function hourFormatRe( hourFormat, gmtFormat, timeSeparator ) {
			var re;

			if ( !gmtFormat ) {
				gmtFormat = "{0}";
			}

			re = hourFormat
				.replace( "+", "\\+" )

				// Unicode equivalent to (\\d\\d)
				.replace( /HH|mm/g, "((" + regexpN.source + ")(" + regexpN.source + "))" )

				// Unicode equivalent to (\\d\\d?)
				.replace( /H|m/g, "((" + regexpN.source + ")(" + regexpN.source + ")?)" );

			if ( timeSeparator ) {
				re = re.replace( /:/g, timeSeparator );
			}

			re = re.split( ";" ).map(function( part ) {
				return gmtFormat.replace( "{0}", part );
			}).join( "|" );

			return new RegExp( re );
		}

		function oneDigitIfLengthOne() {
			if ( length === 1 ) {

				// Unicode equivalent to /\d/
				numeric = true;
				return tokenRe = regexpN;
			}
		}

		function oneOrTwoDigitsIfLengthOne() {
			if ( length === 1 ) {

				// Unicode equivalent to /\d\d?/
				numeric = true;
				return tokenRe = new RegExp( "(" + regexpN.source + ")(" + regexpN.source + ")?" );
			}
		}

		function twoDigitsIfLengthTwo() {
			if ( length === 2 ) {

				// Unicode equivalent to /\d\d/
				numeric = true;
				return tokenRe = new RegExp( "(" + regexpN.source + ")(" + regexpN.source + ")" );
			}
		}

		// Brute-force test every locale entry in an attempt to match the given value.
		// Return the first found one (and set token accordingly), or null.
		function lookup( path ) {
			var i, re,
				data = properties[ path.join( "/" ) ];

			for ( i in data ) {
				re = new RegExp( "^" + data[ i ] );
				if ( re.test( value ) ) {
					token.value = i;
					return tokenRe = new RegExp( data[ i ] );
				}
			}
			return null;
		}

		token.type = current;
		chr = current.charAt( 0 ),
		length = current.length;

		if ( chr === "Z" ) {

			// Z..ZZZ: same as "xxxx".
			if ( length < 4 ) {
				chr = "x";
				length = 4;

			// ZZZZ: same as "OOOO".
			} else if ( length < 5 ) {
				chr = "O";
				length = 4;

			// ZZZZZ: same as "XXXXX"
			} else {
				chr = "X";
				length = 5;
			}
		}

		switch ( chr ) {

			// Era
			case "G":
				lookup([
					"gregorian/eras",
					length <= 3 ? "eraAbbr" : ( length === 4 ? "eraNames" : "eraNarrow" )
				]);
				break;

			// Year
			case "y":
			case "Y":
				numeric = true;

				// number l=1:+, l=2:{2}, l=3:{3,}, l=4:{4,}, ...
				if ( length === 1 ) {

					// Unicode equivalent to /\d+/.
					tokenRe = new RegExp( "(" + regexpN.source + ")+" );
				} else if ( length === 2 ) {

					// Unicode equivalent to /\d\d/
					tokenRe = new RegExp( "(" + regexpN.source + ")(" + regexpN.source + ")" );
				} else {

					// Unicode equivalent to /\d{length,}/
					tokenRe = new RegExp( "(" + regexpN.source + "){" + length + ",}" );
				}
				break;

			// Quarter
			case "Q":
			case "q":

				// number l=1:{1}, l=2:{2}.
				// lookup l=3...
				oneDigitIfLengthOne() || twoDigitsIfLengthTwo() || lookup([
					"gregorian/quarters",
					chr === "Q" ? "format" : "stand-alone",
					widths[ length - 3 ]
				]);
				break;

			// Month
			case "M":
			case "L":

				// number l=1:{1,2}, l=2:{2}.
				// lookup l=3...
				oneOrTwoDigitsIfLengthOne() || twoDigitsIfLengthTwo() || lookup([
					"gregorian/months",
					chr === "M" ? "format" : "stand-alone",
					widths[ length - 3 ]
				]);
				break;

			// Day
			case "D":

				// number {l,3}.
				if ( length <= 3 ) {

					// Unicode equivalent to /\d{length,3}/
					numeric = true;
					tokenRe = new RegExp( "(" + regexpN.source + "){" + length + ",3}" );
				}
				break;

			case "W":
			case "F":

				// number l=1:{1}.
				oneDigitIfLengthOne();
				break;

			// Week day
			case "e":
			case "c":

				// number l=1:{1}, l=2:{2}.
				// lookup for length >=3.
				if ( length <= 2 ) {
					oneDigitIfLengthOne() || twoDigitsIfLengthTwo();
					break;
				}

			/* falls through */
			case "E":
				if ( length === 6 ) {

					// Note: if short day names are not explicitly specified, abbreviated day
					// names are used instead http://www.unicode.org/reports/tr35/tr35-dates.html#months_days_quarters_eras
					lookup([
						"gregorian/days",
						[ chr === "c" ? "stand-alone" : "format" ],
						"short"
					]) || lookup([
						"gregorian/days",
						[ chr === "c" ? "stand-alone" : "format" ],
						"abbreviated"
					]);
				} else {
					lookup([
						"gregorian/days",
						[ chr === "c" ? "stand-alone" : "format" ],
						widths[ length < 3 ? 0 : length - 3 ]
					]);
				}
				break;

			// Period (AM or PM)
			case "a":
				lookup([
					"gregorian/dayPeriods/format/wide"
				]);
				break;

			// Week, Day, Hour, Minute, or Second
			case "w":
			case "d":
			case "h":
			case "H":
			case "K":
			case "k":
			case "j":
			case "m":
			case "s":

				// number l1:{1,2}, l2:{2}.
				oneOrTwoDigitsIfLengthOne() || twoDigitsIfLengthTwo();
				break;

			case "S":

				// number {l}.

				// Unicode equivalent to /\d{length}/
				numeric = true;
				tokenRe = new RegExp( "(" + regexpN.source + "){" + length + "}" );
				break;

			case "A":

				// number {l+5}.

				// Unicode equivalent to /\d{length+5}/
				numeric = true;
				tokenRe = new RegExp( "(" + regexpN.source + "){" + ( length + 5 ) + "}" );
				break;

			// Zone
			case "z":
			case "O":

				// O: "{gmtFormat}+H;{gmtFormat}-H" or "{gmtZeroFormat}", eg. "GMT-8" or "GMT".
				// OOOO: "{gmtFormat}{hourFormat}" or "{gmtZeroFormat}", eg. "GMT-08:00" or "GMT".
				if ( value === properties[ "timeZoneNames/gmtZeroFormat" ] ) {
					token.value = 0;
					tokenRe = new RegExp( properties[ "timeZoneNames/gmtZeroFormat" ] );
				} else {
					tokenRe = hourFormatRe(
						length < 4 ? "+H;-H" : properties[ "timeZoneNames/hourFormat" ],
						properties[ "timeZoneNames/gmtFormat" ],
						timeSeparator
					);
					if ( !hourFormatParse( tokenRe, numberParser ) ) {
						return null;
					}
				}
				break;

			case "X":

				// Same as x*, except it uses "Z" for zero offset.
				if ( value === "Z" ) {
					token.value = 0;
					tokenRe = /Z/;
					break;
				}

			/* falls through */
			case "x":

				// x: hourFormat("+HH;-HH")
				// xx or xxxx: hourFormat("+HHmm;-HHmm")
				// xxx or xxxxx: hourFormat("+HH:mm;-HH:mm")
				tokenRe = hourFormatRe(
					length === 1 ? "+HH;-HH" : ( length % 2 ? "+HH:mm;-HH:mm" : "+HHmm;-HHmm" )
				);
				if ( !hourFormatParse( tokenRe ) ) {
					return null;
				}
				break;

			case "'":
				token.type = "literal";
				current = current.replace( /''/, "'" );
				if ( length > 2 ) {
					current = current.slice( 1, -1 );
				}
				tokenRe = new RegExp( regexpEscape( current ) );
				break;

			default:
				token.type = "literal";
				tokenRe = /./;
		}

		if ( !tokenRe ) {
			return false;
		}

		// Get lexeme and consume it.
		value = value.replace( new RegExp( "^" + tokenRe.source ), function( lexeme ) {
			token.lexeme = lexeme;
			if ( numeric ) {
				token.value = numberParser( lexeme );
			}
			return "";
		});

		if ( !token.lexeme ) {
			return false;
		}

		tokens.push( token );
		return true;
	});

	if ( value !== "" ) {
		valid = false;
	}

	return valid ? tokens : [];
};




var dateParserFn = function( numberParser, parseProperties, tokenizerProperties ) {
	return function dateParser( value ) {
		var tokens;

		validateParameterPresence( value, "value" );
		validateParameterTypeString( value, "value" );

		tokens = dateTokenizer( value, numberParser, tokenizerProperties );
		return dateParse( value, tokens, parseProperties ) || null;
	};
};




/**
 * parseProperties( cldr )
 *
 * @cldr [Cldr instance].
 *
 * Return parser properties.
 */
var dateParseProperties = function( cldr ) {
	return {
		preferredTimeData: cldr.supplemental.timeData.preferred()
	};
};




/**
 * tokenizerProperties( pattern, cldr )
 *
 * @pattern [String] raw pattern.
 *
 * @cldr [Cldr instance].
 *
 * Return Object with data that will be used by tokenizer.
 */
var dateTokenizerProperties = function( pattern, cldr ) {
	var properties = {
			pattern: pattern,
			timeSeparator: numberSymbol( "timeSeparator", cldr )
		},
		widths = [ "abbreviated", "wide", "narrow" ];

	function populateProperties( path, value ) {

		// The `dates` and `calendars` trim's purpose is to reduce properties' key size only.
		properties[ path.replace( /^.*\/dates\//, "" ).replace( /calendars\//, "" ) ] = value;
	}

	cldr.on( "get", populateProperties );

	pattern.match( datePatternRe ).forEach(function( current ) {
		var chr, length;

		chr = current.charAt( 0 ),
		length = current.length;

		if ( chr === "Z" && length < 5 ) {
				chr = "O";
				length = 4;
		}

		switch ( chr ) {

			// Era
			case "G":
				cldr.main([
					"dates/calendars/gregorian/eras",
					length <= 3 ? "eraAbbr" : ( length === 4 ? "eraNames" : "eraNarrow" )
				]);
				break;

			// Year
			case "u": // Extended year. Need to be implemented.
			case "U": // Cyclic year name. Need to be implemented.
				throw createErrorUnsupportedFeature({
					feature: "year pattern `" + chr + "`"
				});

			// Quarter
			case "Q":
			case "q":
				if ( length > 2 ) {
					cldr.main([
						"dates/calendars/gregorian/quarters",
						chr === "Q" ? "format" : "stand-alone",
						widths[ length - 3 ]
					]);
				}
				break;

			// Month
			case "M":
			case "L":

				// number l=1:{1,2}, l=2:{2}.
				// lookup l=3...
				if ( length > 2 ) {
					cldr.main([
						"dates/calendars/gregorian/months",
						chr === "M" ? "format" : "stand-alone",
						widths[ length - 3 ]
					]);
				}
				break;

			// Day
			case "g":

				// Modified Julian day. Need to be implemented.
				throw createErrorUnsupportedFeature({
					feature: "Julian day pattern `g`"
				});

			// Week day
			case "e":
			case "c":

				// lookup for length >=3.
				if ( length <= 2 ) {
					break;
				}

			/* falls through */
			case "E":
				if ( length === 6 ) {

					// Note: if short day names are not explicitly specified, abbreviated day
					// names are used instead http://www.unicode.org/reports/tr35/tr35-dates.html#months_days_quarters_eras
					cldr.main([
						"dates/calendars/gregorian/days",
						[ chr === "c" ? "stand-alone" : "format" ],
						"short"
					]) || cldr.main([
						"dates/calendars/gregorian/days",
						[ chr === "c" ? "stand-alone" : "format" ],
						"abbreviated"
					]);
				} else {
					cldr.main([
						"dates/calendars/gregorian/days",
						[ chr === "c" ? "stand-alone" : "format" ],
						widths[ length < 3 ? 0 : length - 3 ]
					]);
				}
				break;

			// Period (AM or PM)
			case "a":
				cldr.main([
					"dates/calendars/gregorian/dayPeriods/format/wide"
				]);
				break;

			// Zone
			case "z":
			case "O":
				cldr.main( "dates/timeZoneNames/gmtFormat" );
				cldr.main( "dates/timeZoneNames/gmtZeroFormat" );
				cldr.main( "dates/timeZoneNames/hourFormat" );
				break;

			case "v":
			case "V":
				throw createErrorUnsupportedFeature({
					feature: "timezone pattern `" + chr + "`"
				});
		}
	});

	cldr.off( "get", populateProperties );

	return properties;
};




function validateRequiredCldr( path, value ) {
	validateCldr( path, value, {
		skip: [
			/dates\/calendars\/gregorian\/dateTimeFormats\/availableFormats/,
			/dates\/calendars\/gregorian\/days\/.*\/short/,
			/supplemental\/timeData\/(?!001)/,
			/supplemental\/weekData\/(?!001)/
		]
	});
}

/**
 * .dateFormatter( options )
 *
 * @options [Object] see date/expand_pattern for more info.
 *
 * Return a date formatter function (of the form below) according to the given options and the
 * default/instance locale.
 *
 * fn( value )
 *
 * @value [Date]
 *
 * Return a function that formats a date according to the given `format` and the default/instance
 * locale.
 */
Globalize.dateFormatter =
Globalize.prototype.dateFormatter = function( options ) {
	var args, cldr, numberFormatters, pad, pattern, properties, returnFn;

	validateParameterTypePlainObject( options, "options" );

	cldr = this.cldr;
	options = options || { skeleton: "yMd" };

	args = [ options ];

	validateDefaultLocale( cldr );

	cldr.on( "get", validateRequiredCldr );
	pattern = dateExpandPattern( options, cldr );
	properties = dateFormatProperties( pattern, cldr );
	cldr.off( "get", validateRequiredCldr );

	// Create needed number formatters.
	numberFormatters = properties.numberFormatters;
	delete properties.numberFormatters;
	for ( pad in numberFormatters ) {
		numberFormatters[ pad ] = this.numberFormatter({
			raw: numberFormatters[ pad ]
		});
	}

	returnFn = dateFormatterFn( numberFormatters, properties );

	runtimeBind( args, cldr, returnFn, [ numberFormatters, properties ] );

	return returnFn;
};

/**
 * .dateParser( options )
 *
 * @options [Object] see date/expand_pattern for more info.
 *
 * Return a function that parses a string date according to the given `formats` and the
 * default/instance locale.
 */
Globalize.dateParser =
Globalize.prototype.dateParser = function( options ) {
	var args, cldr, numberParser, parseProperties, pattern, tokenizerProperties, returnFn;

	validateParameterTypePlainObject( options, "options" );

	cldr = this.cldr;
	options = options || { skeleton: "yMd" };

	args = [ options ];

	validateDefaultLocale( cldr );

	cldr.on( "get", validateRequiredCldr );
	pattern = dateExpandPattern( options, cldr );
	tokenizerProperties = dateTokenizerProperties( pattern, cldr );
	parseProperties = dateParseProperties( cldr );
	cldr.off( "get", validateRequiredCldr );

	numberParser = this.numberParser({ raw: "0" });

	returnFn = dateParserFn( numberParser, parseProperties, tokenizerProperties );

	runtimeBind( args, cldr, returnFn, [ numberParser, parseProperties, tokenizerProperties ] );

	return returnFn;
};

/**
 * .formatDate( value, options )
 *
 * @value [Date]
 *
 * @options [Object] see date/expand_pattern for more info.
 *
 * Formats a date or number according to the given options string and the default/instance locale.
 */
Globalize.formatDate =
Globalize.prototype.formatDate = function( value, options ) {
	validateParameterPresence( value, "value" );
	validateParameterTypeDate( value, "value" );

	return this.dateFormatter( options )( value );
};

/**
 * .parseDate( value, options )
 *
 * @value [String]
 *
 * @options [Object] see date/expand_pattern for more info.
 *
 * Return a Date instance or null.
 */
Globalize.parseDate =
Globalize.prototype.parseDate = function( value, options ) {
	validateParameterPresence( value, "value" );
	validateParameterTypeString( value, "value" );

	return this.dateParser( options )( value );
};

return Globalize;




}));
//-----------------------------------------------------------------
// Licensed Materials - Property of IBM
//
// WebSphere Commerce
//
// (C) Copyright IBM Corp. 2009, 2016 All Rights Reserved.
//
// US Government Users Restricted Rights - Use, duplication or
// disclosure restricted by GSA ADP Schedule Contract with
// IBM Corp.
//-----------------------------------------------------------------

/**
 * This file is Generic analytics event listener 
 * @version 1.0
 * 
 **/

/**
* GenericEventListener is the base object from which various analtyic vendor implementations should extend from.
* 
**/

if(typeof(GenericEventListener) === "undefined" || !GenericEventListener || !GenericEventListener.topicNamespace){
	GenericEventListener = {

		_loaded: false,
		
		_useHostedCMLib: false,
		
		/**
		 * initializer Event listener initialization method an Empty placeholder method
		 */
		initializer: function () {
			
		},

		/**
		 *  This method sets up the listener to listen for the supported event types. Currently, they are "/wc/analytics/pageview",
		 *  	"/wc/analytics/productview", "/wc/analytics/cartview", "/wc/analytics/addcart" and "/wc/analytics/element".
		 *		For each event type, a corresponding handler method is defined. This method
		*		should be called by its creator before generating events.
		*/	
		load: function() {
			load(false);
		},
		
		/**
		 *  This method sets up the listener to listen for the supported event types. Currently, they are "/wc/analytics/pageview",
		 *  	"/wc/analytics/productview", "/wc/analytics/cartview", "/wc/analytics/addcart" and "/wc/analytics/element".
		 *		For each event type, a corresponding handler method is defined. This method
		*		should be called by its creator before generating events.
		*/
		load: function(useHostedLib) {
			if(this._loaded === false) {
				wcTopic.subscribe("/wc/analytics/pageview", $.proxy(this.handlePageView, this));
				wcTopic.subscribe("/wc/analytics/productview", $.proxy(this.handleProductView, this));
				wcTopic.subscribe("/wc/analytics/cartview", $.proxy(this.handleCartView, this));
				wcTopic.subscribe("/wc/analytics/addcart", $.proxy(this.handleAddCart, this));
				wcTopic.subscribe("/wc/analytics/element", $.proxy(this.handleElement, this));
				wcTopic.subscribe("/wc/analytics/registration", $.proxy(this.handleRegistration, this));
				wcTopic.subscribe("/wc/analytics/conversionevent", $.proxy(this.handleConversionEvent, this));

				this._loaded = true;
				
				if (useHostedLib === true) {
					this._useHostedCMLib = true;
				}
			}
		},
		
		/**
		 *  Handler for PageView events.This is the method called when a PageView event is triggered via the "/wc/analytics/pageview" topic.
		 *  	This is an empty placeholder that should be extended by the implementation.
		 *@param{Object} obj JSON object containing field names as expected by the specific implementation
		*/
		handlePageView: function(obj) {
			
		},
		
		/**
		 *  Handler for ProductView events .This is the method called when a ProductView event is triggered via the "/wc/analytics/productview" topic.
		 *  	This is an empty placeholder that should be extended by the implementation.
		 *@param{Object} obj JSON object containing field names as expected by the specific implementation
		*/
		handleProductView: function(obj) {
			
		},
		
		/**
		 *  Handler for CartView events.This is the method called when a CartView event is triggered via the "/wc/analytics/cartview" topic.
		 *  	This is an empty placeholder that should be extended by the implementation.
		 *@param{Object} obj JSON object with a single 'cart' array of objects that contain field names for each item
		*		as defined by the specific implementation.
		*/
		handleCartView: function(obj) {
			
		},
		
		/**
		 *  Handler for AddCart events.This is the method called when an AddCart event is triggered via the "/wc/analytics/addcart" topic.
		 *  	This is an empty placeholder that should be
		 *		extended by the implementation.
		*@param{Object} obj JSON object with a single 'cart' array of objects that contain field names for each item
		*		as defined by the specific implementation.
		*/
		handleAddCart: function(obj) {
			
		},
		
		/**
		 *  Handler for Element events . This is the method called when an Element event is triggered via the "/wc/analytics/element" topic.
		 *  	This is an empty placeholder that should be extended by the implementation.
		 * @param{Object} obj JSON object containing field names as expected by the specific implementation              
		 */
		handleElement: function(obj) {
			
		},
		
		/**
		 *  Handler for Registation events. This is the method called when an Registration event is triggered via the "/wc/analytics/registration" topic.
		 *  	This is an empty placeholder that should be extended by the implementation.
		 * @param{Object} obj JSON object containing field names as expected by the specific implementation
		 */
		handleRegistration: function(obj) {
			
		},	
		
		/**
		 *  Handler for non e-Commerce conversion events. This is the method called when the topic "/wc/analytics/conversionevent" is published.
		 *  	This is an empty place holder that should be extended by the implementation.
		 * @param{Object} obj  JSON object containing field names as expected by the specific implementation
		 */	
		handleConversionEvent: function(obj) {
			
		}
	};
}
//-----------------------------------------------------------------
// Licensed Materials - Property of IBM
//
// WebSphere Commerce
//
// (C) Copyright IBM Corp. 2009, 2016 All Rights Reserved.
//
// US Government Users Restricted Rights - Use, duplication or
// disclosure restricted by GSA ADP Schedule Contract with
// IBM Corp.
//-----------------------------------------------------------------

/**
 * This file is Coremetrics-specific analytics event listener 
 * @version 1.0
 * 
 **/

/**
* CoremetricsEventListener handles the page view and product view events and calls the appropriate one and only one global analyticsJS should be created.
* Therefore, we create this object only when it is not present in Coremetrics JavaScript functions to register such calls.
*
**/

if(typeof(CoremetricsEventListener) === "undefined" || !CoremetricsEventListener || !CoremetricsEventListener.topicNamespace){
	CoremetricsEventListener = $.extend(GenericEventListener, {
		
		PARAM_STORE_ID: "storeId",

		/** 
		 *  This function is the handler for PageView events .This is the method called when a PageView event is triggered via the "/wc/analytics/pageview" topic.
		 * @param{Object} obj JSON object containing the following fields;
		 * 	              pagename (optional), the name of the page, accordion panel, etc. that is being viewed.
		 * 	             If not provided, the HTML page title will be used.
		 * 	             category (optional), the category of the page that is being viewed. If not provided,
		 * 	             no category data will be sent.
		 * 	             searchTerms (optional), the terms that the user searched for and is required for search results pages.
		 * 	             searchCount (optional), the total number of results returned by the search and required when searchTerm is set.
		 * 
		 */

		handlePageView: function(obj) {
			
			// For debug purposes
			var internalDebug = false;
			if (internalDebug) {
				window.alert("handlePageView");
			}
			
			var PARAM_PAGENAME = "pagename";
			var PARAM_PAGETYPE = "pageType";
			var PARAM_CATEGORY = "category";
			var PARAM_SEARCHTERMS = "searchTerms";
			var PARAM_SEARCHCOUNT = "searchCount";

			var PARAM_OPTIONS = "options";
			var PARAM_DEBUG = "debug";
			var PARAM_EXTRA_PARAM = "extraParams";
			var PARAM_ATTRIBUTES = "attributes";
			var PARAM_VALUE_USEDDX = "useDDX";
			var PARAM_VALUE_TRUE = "true";

			// set some defaults
			var pagename = document.title;
			var pageType = null;
			var category = null;
			var searchTerms = null;
			var searchCount = null;
			
			var attributes = null;
			var extraParams = null;

			var storeId = this._getStoreId();
			var args = new Array();

			var useDDX = false;
			var debug = false;
			
			// search object for known values and save the unknown ones
			for(x in obj) {
				if(x === PARAM_OPTIONS) {
					var options = obj[x];
					if (options === PARAM_VALUE_USEDDX) {
						useDDX = true;
					}
				} else if (x === PARAM_DEBUG) {
					var debugParam = obj[x];
					if (debugParam === PARAM_VALUE_TRUE) {
						debug = true;
					}
				} else if(x === PARAM_PAGENAME) {
					pagename = obj[x];
				}
				else if(x === PARAM_PAGETYPE) {
					pageType = obj[x];	
				}
				else if(x === PARAM_CATEGORY) {
					if (obj[x] === "null" || obj[x] === "") {
						category = null;
					} else {
						category = obj[x];	
					}
				}
				else if(x === PARAM_SEARCHTERMS) {
					if (obj[x] === "null" || obj[x] === "") {
						searchTerms = null;
					} else {
						searchTerms = obj[x];	
					}
				}
				else if(x === PARAM_SEARCHCOUNT) {
					if (obj[x] === "null" || obj[x] === "") {
						searchCount = null;
					} else {
						searchCount = obj[x];	
					}
					
				}
				else if(x === this.PARAM_STORE_ID) {
					storeId = obj[x];
				}
				else {
					// Attributes and extra parameters are interpreted differently depending on DDX settings
					if (!useDDX) {
						// When not using DDX, the attributes and parameters are passed on the same entry
						args.push(obj[x]);
						if (extraParams !== null) {
							extraParams += ", ";
						} else {
							extraParams = "";
						}
						
						if (obj[x] == null || obj[x] === "null") {
							extraParams += "null";
						} else if (obj[x].charAt(0) === "\"" && obj[x].charAt(obj[x].length-1) === "\"") {
							extraParams += obj[x];
						} else {
							extraParams += "\"" + obj[x] + "\"";
						}
					} else {
						// When using DDX, the attributes and parameters are passed separately
						if(x === PARAM_EXTRA_PARAM) {
							extraParams = obj[x];
						} else if(x === PARAM_ATTRIBUTES) {
							attributes = obj[x];
						}
					}
				}
			}

			if (!useDDX) {
				/** useDDX is disabled **/
				if(!this._useHostedCMLib){
					/** put known variables at the beginning**/		
					args.unshift(pagename, category, searchTerms, searchCount, storeId);
				} else {
					/** put known variables at the beginning**/		
					args.unshift(pagename, category, searchTerms, searchCount);
				}

				/** call Coremetrics tag**/			
				cmCreatePageviewTag.apply({}, args);
			} else {
				/** useDDX is enabled **/
				if (pagename == null || pagename === "null" || pagename === "'null'") { pagename = '' };
				if (searchTerms == null || searchTerms === "null" || searchTerms === "'null'") { searchTerms = '' };
				if (searchCount == null || searchCount === "null" || searchCount === "'null'") { searchCount = '' };
				if (category == null || category === "null" || category === "'null'") { category = '' };
				if (attributes == null || attributes === "null" || attributes === "'null'") { attributes = '' };
				if (extraParams == null || extraParams === "null" || extraParams === "'null'") { extraParams = '' };
				if (pageType == null || pageType === "null" || pageType === "'null'") { pageType = '' };

				if (typeof digitalData === "undefined") {
					digitalData = {};
				}

				digitalData.page = {pageInfo:{pageID: pagename, onsiteSearchTerm: searchTerms, onsiteSearchResults: searchCount}, category:{primaryCategory: category}, attributes:{exploreAttributes: attributes ,extraFields: extraParams }};
				digitalData.pageInstanceID = pageType;
				// For debug purposes
				if (internalDebug) {
					window.alert(JSON.stringify(digitalData));
				}
			}

			var JSONtoLog = JSON.stringify(obj);
			var obj = document.getElementById('cm-pageview');
			if (debug && obj !== null) {
				if (!useDDX) {
					var toLog = "cmCreatePageviewTag(";
					if (pagename !== null && pagename !== "" && pagename !== "null") {
						toLog += "\"" + pagename + "\", ";
					} else {
						toLog += "null, ";
					}
					if (category !== null && category !== "" && category !== "null") {
						toLog += "\"" + category + "\", ";
					} else {
						toLog += "null, ";
					}	
					if (searchTerms !== null && searchTerms !== "" && searchTerms !== "null") {
						toLog += "\"" + searchTerms + "\", ";
					} else {
						toLog += "null, ";
					}		
					if (searchCount !== null && searchCount !== "" && searchCount !== "null") {
						toLog += "\"" + searchCount + "\"";
					} else {
						toLog += "null";
					}	
					if (!this._useHostedCMLib) {
						if (storeId !== null && storeId !== "" && storeId !== "null") {
							toLog += ", \"" + storeId + "\"";
						} else {
							toLog += ", null";
						}				
					}
					if (extraParams !== null) {
						toLog += ", " + extraParams;
					}			
					toLog += ");";
				} else {
					var toLog = "digitalData = { ";
					toLog += "page:{pageInfo:{pageID: '" + pagename + "', onsiteSearchTerm: '" + searchTerms + "', onsiteSearchResults: '" + searchCount + "'}, category:{primaryCategory: '" + category + "'},";
					toLog += "attributes:{exploreAttributes: '" + attributes + "' ,extraFields: '" + extraParams + "'}},";
					toLog += "pageInstanceID: '" + pageType + "' };";
					// For debug purposes
					if (internalDebug) {
						window.alert(toLog);
					}
				}
				
				var JSONtoLogNode = document.createTextNode(JSONtoLog);
				obj.appendChild(JSONtoLogNode); 
				obj.appendChild(document.createElement('br'));
				
				var toLogNode = document.createTextNode(toLog);
				obj.appendChild(toLogNode); 
				obj.appendChild(document.createElement('br'));
			}
			
		},
		
		/** 
		 * Handler function for non eCommerce conversion events. Triggered when the topic "/wc/analytics/conversionevent" topic is published.
		 * @param{Object} obj JSON object containing the following fields;
		 * 		eventId		:  A unique identifier for the type of conversion, such as Account Creation or Add to Wishlist. 
		 * 		actionType	: A value of 1 or 2 depending upon whether a conversion initiation or a successful conversion 
		 * 						completion is generated. A value of 1 should be used when an event is initiated. A value of 2 should 
		 * 						be used when an event is successfully completed. Single-Step conversions should be represented by a 
		 * 						value of 2.
		 *		category	: Allows grouping of event IDs into categories. 
		*		points		: A point value used in establishing an arbitrary value for a conversion. The point value allows relative 
		*						weighting of and Events initiation and completion.
		* 
		*/
		handleConversionEvent: function(obj) {

			// For debug purposes
			var internalDebug = false;
			if (internalDebug) {
				window.alert("handleConversionEvent");
			}

			var PARAM_EVENTID = "eventId";
			var PARAM_CATEGORY = "category";
			var PARAM_ACTIONTYPE = "actionType";
			var PARAM_POINTS = "points";

			var PARAM_OPTIONS = "options";
			var PARAM_DEBUG = "debug";
			var PARAM_EXTRA_PARAM = "extraParams";
			var PARAM_ATTRIBUTES = "attributes";
			var PARAM_VALUE_USEDDX = "useDDX";
			var PARAM_VALUE_TRUE = "true";

			// set some defaults
			var eventId = null;
			var category = null;
			var actionType = null;
			var points = null;

			var attributes = null;
			var extraParams = null;

			var storeId = this._getStoreId();
			var args = new Array();
			
			var useDDX = false;
			var debug = false;

			// search object for known values and save the unknown ones
			for(x in obj) {
				if(x === PARAM_OPTIONS) {
					var options = obj[x];
					// useDDX is NOT supported for this case by Digital Analytics
					// Enable the three lines below when DDX is supported for this case
					// if (options === PARAM_VALUE_USEDDX) {
					//	useDDX = true;
					// }
				} else if (x === PARAM_DEBUG) {
					var debugParam = obj[x];
					if (debugParam === PARAM_VALUE_TRUE) {
						debug = true;
					}
				} else if(x === PARAM_EVENTID) {
					eventId = obj[x];
				}
				else if(x === PARAM_CATEGORY) {
					category = obj[x];
				}
				else if(x === PARAM_ACTIONTYPE) {
					actionType = obj[x];
				}
				else if(x === PARAM_POINTS) {
					points = obj[x];
				}
				else {
					// Attributes and extra parameters are interpreted differently depending on DDX settings
					if (!useDDX) {
						// When not using DDX, the attributes and parameters are passed on the same entry
						args.push(obj[x]);
					} else {
						// When using DDX, the attributes and parameters are passed separately
						if(x === PARAM_EXTRA_PARAM) {
							extraParams = obj[x];
						} else if(x === PARAM_ATTRIBUTES) {
							attributes = obj[x];
						}
					}
				}
			}
			
			if (!useDDX) {
				/** useDDX is disabled **/
				/** put known variables at the beginning**/
				args.unshift(eventId, actionType, category, points);
		
				/** call Coremetrics tag**/
				cmCreateConversionEventTag.apply({}, args);
			} else {
				/** useDDX is enabled **/
				if (eventId == null || eventId === "null" || eventId === "'null'") { eventId = '' };
				if (actionType == null || actionType === "null" || actionType === "'null'") { actionType = '' };
				if (points == null || points === "null" || points === "'null'") { points = '' };
				if (category == null || category === "null" || category === "'null'") { category = '' };
				if (attributes == null || attributes === "null" || attributes === "'null'") { attributes = '' };
				if (extraParams == null || extraParams === "null" || extraParams === "'null'") { extraParams = '' };
				
				if (typeof digitalData === "undefined") {
					digitalData = {};
					digitalData.pageInstanceID = 'wcs-standardpage_wcs-conversionevent';
				}

				digitalData.event = [{eventInfo:{eventName: eventId, eventAction: actionType, eventPoints: points}, category:{primaryCategory: category}, attributes:{exploreAttributes: attributes, extraFields: extraParams}}];
				// For debug purposes
				if (internalDebug) {
					window.alert(JSON.stringify(digitalData));
				}
			}
			
			var JSONtoLog = JSON.stringify(obj);
			var obj = document.getElementById('cm-conversionevent');
			if (debug && obj !== null) {
				if (!useDDX) {
					var toLog = "cmCreateConversionEventTag(";
					if (eventId !== null && eventId !== "") {
						toLog += "\"" + eventId + "\", ";
					} else {
						toLog += "null, ";
					}
					if (actionType !== null && actionType !== "") {
						toLog += "\"" + actionType + "\", ";
					} else {
						toLog += "null, ";
					}		
					if (category !== null && category !== "") {
						toLog += "\"" + category + "\", ";
					} else {
						toLog += "null, ";
					}	
					if (points !== null && points !== "") {
						toLog += "\"" + points + "\"";
					} else {
						toLog += "null";
					}	
					toLog += ");";
				} else {
					var toLog = "digitalData = { ";
					if (digitalData.pageInstanceID !== null && digitalData.pageInstanceID !== "") {
							toLog += "pageInstanceID:'" + digitalData.pageInstanceID + "', ";
					}
						toLog += "event:[{eventInfo:{eventName: '" + eventId + "', eventAction: '" + actionType + "', eventPoints: '" + points + "'}, category:{primaryCategory: '" + category + "'}, attributes:{exploreAttributes: '" + attributes + "', extraFields: '" + extraParams + "'}}]}";
					// For debug purposes
					if (internalDebug) {
						window.alert(toLog);
					}
				}
				
				var JSONtoLogNode = document.createTextNode(JSONtoLog);
				obj.appendChild(JSONtoLogNode); 
				obj.appendChild(document.createElement('br'));

				var toLogNode = document.createTextNode(toLog);
				obj.appendChild(toLogNode); 
				obj.appendChild(document.createElement('br'));
			}
			
		},	
		
		/** 
		 *  This function is the handler for ProductView events .This is the method called when a ProductView event is triggered via the "/wc/analytics/productview" topic.
		 * @param{Object} obj JSON object containing the following fields;
		 * 	                productId (required), the product identifier for the product being viewed. Typically contains the SKU.
		 *                  name (required), the name of the product.
		 *                  category (required), the catalog category of the product being viewed or virtual category
		 *                  such as "Search" or "Cross-sell".
		 *                  masterCategory (required), the catalog category of the product being viewed from the store's master catalog
		 * 
		 */
		handleProductView: function(obj) {

			// For debug purposes
			var internalDebug = false;
			if (internalDebug) {
				window.alert("handleProductView");
			}

			var PARAM_PRODUCTID = "productId";
			var PARAM_PRODUCTNAME = "name";
			var PARAM_CATEGORY = "category";
			var PARAM_MASTERCATEGORY = "masterCategory";
			var PARAM_VIRTUAL_CATEGORY = "virtualCategory";
			var PARAM_ATTRIBUTES = "attributes";
			var PARAM_VALUE_USEDDX = "useDDX";
			var PARAM_VALUE_TRUE = "true";
		
			/** set some defaults**/
			var productId = null;
			var productName = null;
			var category = null;
			var masterCategory = null;

			var attributes = null;
			var virtualCategory = null;
		
			var storeId = this._getStoreId();
			var extraParams = null;

			var useDDX = false;
			var debug = false;

			if(obj.options === PARAM_VALUE_USEDDX) {
				useDDX = true;
			}
			
			if (obj.debug === PARAM_VALUE_TRUE) {
				debug = true;
			}

			if(obj.product && $.isArray(obj.product)) {
				if (useDDX) {
					if (typeof digitalData === "undefined") {
						digitalData = {};
						digitalData.pageInstanceID='wcs-standardpage_wcs-productdetail';
					}
					digitalData.product = new Array();
				}

				var product = obj.product;
				for(var i = 0; i < product.length; i++) {
					var values = product[i];
					var args = new Array();
					
					/** search object for known values and save the unknown ones **/
					for(x in values) {
						if(x === PARAM_PRODUCTID) {
							productId = values[x];
						}
						else if(x === PARAM_PRODUCTNAME) {
							productName = values[x];
						}
						else if(x === PARAM_CATEGORY) {
							category = values[x];
						}
						else if(x === PARAM_MASTERCATEGORY) {
							masterCategory = values[x];
						}
						else if(x === this.PARAM_STORE_ID) {
							storeId = values[x];
						}
						else {
							// Attributes and extra parameters are interpreted differently depending on DDX settings
							if (!useDDX) {
								// When not using DDX, the attributes and parameters are passed on the same entry
								args.push(values[x]);
								if (extraParams !== null) {
									extraParams += ", ";
								} else {
									extraParams = "";
								}
							
								if (values[x] == null || values[x] === "null") {
									extraParams += "null";
								} else if (values[x].charAt(0) === "\"" && values[x].charAt(values[x].length-1) === "\"") {
									extraParams += values[x];
								} else {
									extraParams += "\"" + values[x] + "\"";
								}
							} else {
								// When using DDX, the attributes and virtual category are passed separately
								if(x === PARAM_ATTRIBUTES) {
									attributes = values[x];
								} else if(x === PARAM_VIRTUAL_CATEGORY) {
									virtualCategory = values[x];
								}
							}
						}
					}
					
					/** enforce required parameters **/
					if((productId == null) || (productName == null) || (category == null) || (masterCategory == null)) {

					}
					else {
						if (!useDDX) {
							if(!this._useHostedCMLib){
								/** put known variables at the beginning **/
								args.unshift(null, productId, productName, category, storeId, "N", masterCategory);
							} else {
								/** put known variables at the beginning **/
								args.unshift(productId, productName, category);
							}
						
							/** call Coremetrics tag **/
							cmCreateProductviewTag.apply({}, args);
						} else {
							/** useDDX is enabled **/
							if (productId == null || productId === "null" || productId === "'null'") { productId = '' };
							if (productName == null || productName === "null" || productName === "'null'") { productName = '' };
							if (category == null || category === "null" || category === "'null'") { category = '' };
							if (virtualCategory == null || virtualCategory === "null" || virtualCategory === "'null'") { virtualCategory = '' };
							if (attributes == null || attributes === "null" || attributes === "'null'") { attributes = '' };
							
							digitalData.product[i] = {productInfo:{productID: productId, productName: productName}, category:{primaryCategory: category, virtualCategory: virtualCategory}, attributes:{exploreAttributes: attributes}};
							// For debug purposes
							if (internalDebug) {
								window.alert(JSON.stringify(digitalData));
							}
						}
						
						var JSONtoLog = JSON.stringify(obj);
						var obj = document.getElementById('cm-productview');
						if (debug && obj !== null) {
							if (!useDDX) {
								var toLog = "";
								if(!this._useHostedCMLib){
									toLog = "cmCreateProductviewTag(null, ";
								} else {
									toLog = "cmCreateProductviewTag(";
								}
								if (productId !== null && productId !== "") {
									toLog += "\"" + productId + "\", ";
								} else {
									toLog += "null, ";
								}
								if (productName !== null && productName !== "") {
									productName = productName.replace(/\"/g, '\\\"');
									toLog += "\"" + productName + "\", ";
								} else {
									toLog += "null, ";
								}	
								if (category !== null && category !== "") {
									toLog += "\"" + category + "\"";
								} else {
									toLog += "null";
								}	
								if(!this._useHostedCMLib){
									if (storeId !== null && storeId !== "") {
										toLog += ", \"" + storeId + "\", \"N\", ";
									} else {
										toLog += ", null, \"N\", ";
									}		
									if (masterCategory !== null && masterCategory !== "") {
										toLog += "\"" + masterCategory + "\"";
									} else {
										toLog += "null";
									}				
								}
								if (extraParams !== null) {
									toLog += ", " + extraParams;
								}
								toLog += ");";
							} else {
								// TODO: For simplicitly, we are only logging the contents of digitalData.product
								// And not digitalData.pageInstanceID
								
								var toLog = "digitalData.product[" + i + "] = { ";
								toLog += "productInfo:{productID: '" + productId + "', productName: '" + productName + "'},category:{primaryCategory: '" + category + "', virtualCategory: '" + virtualCategory + "'},attributes:{exploreAttributes: '" + attributes + "'}};";
								// For debug purposes
								if (internalDebug) {
									window.alert(toLog);
								}
							}

							var JSONtoLogNode = document.createTextNode(JSONtoLog);
							obj.appendChild(JSONtoLogNode); 
							obj.appendChild(document.createElement('br'));
				
							var toLogNode = document.createTextNode(toLog);
							obj.appendChild(toLogNode); 
							obj.appendChild(document.createElement('br'));
						}			
					}
				}
			}
		},

		/**
		 *  This function is a handler for CartView events.This is the method called when a CartView event is triggered via the "/wc/analytics/cartview" topic.
		 * @param{Object} obj  JSON object with a single 'cart' array where each element is an Object containing the following fields;
			*       productId (required), the product identifier for the product being viewed. Typically contains the SKU.
			*       name (required), the name of the product.
			*       category (required), the catalog category of the product being viewed or virtual category
			*       such as "Search" or "Cross-sell".
			*       masterCategory (required), the catalog category of the product being viewed from the store's master catalog.
			*       quantity (required), the number of units ordered.
			*       price (required), the selling price fo the product.
			*       currency (required), the currency of the price.
		*/

		handleCartView: function(obj) {

			// For debug purposes
			var internalDebug = false;
			if (internalDebug) {
				window.alert("handleCartView");
			}

			var PARAM_PRODUCTID = "productId";
			var PARAM_PRODUCTNAME = "name";
			var PARAM_CATEGORY = "category";
			var PARAM_MASTERCATEGORY = "masterCategory";
			var PARAM_QTY = "quantity";
			var PARAM_PRICE = "price";
			var PARAM_CURRENCY = "currency";
			var PARAM_EXTRA_PARAM = "extraParams";
			var PARAM_ATTRIBUTES = "attributes";
			var PARAM_VALUE_USEDDX = "useDDX";
			var PARAM_VALUE_TRUE = "true";
			var PARAM_VALUE_FALSE = "false";

			var attributes = null;
			var extraParams = null;
			// virtualCategory is not used
			var virtualCategory = null;

			var useDDX = false;
			// By default, we must use cmSetupOther
			var useCMSetupOther = true;
			var debug = false;

			if(obj.options === PARAM_VALUE_USEDDX) {
				useDDX = true;
			}

			if (obj.useCMSetupOther === PARAM_VALUE_TRUE) {
				useCMSetupOther = true;
			} else if (obj.useCMSetupOther === PARAM_VALUE_FALSE) {
				useCMSetupOther = false;
			}
			
			if (obj.debug === PARAM_VALUE_TRUE) {
				debug = true;
			}

			var shop5created = false;

			if(obj.cart && $.isArray(obj.cart)) {
				if (useDDX) {
					if (typeof digitalData === "undefined") {
						digitalData = {};
						digitalData.pageInstanceID='wcs-standardpage_wcs-cart';
					}
					digitalData.cart = {};
					digitalData.cart.item = new Array();
				}

				var cart = obj.cart;
				for(var i = 0; i < cart.length; i++) {
					// set some defaults
					var productId = null;
					var productName = null;
					var category = null;
					var masterCategory = null;
					var quantity = null;
					var price = null;
					var currency = null;
				
					var storeId = this._getStoreId();
					var args = new Array();
					var extraParams = null;
					
					var values = cart[i];

					/** search object for known values and save the unknown ones **/
					for(x in values) {
						if(x === PARAM_PRODUCTID) {
							productId = values[x];
						}
						else if(x === PARAM_PRODUCTNAME) {
							productName = values[x];
						}
						else if(x === PARAM_CATEGORY) {
							category = values[x];
						}
						else if(x === PARAM_MASTERCATEGORY) {
							masterCategory = values[x];
						}
						else if(x === PARAM_QTY) {
							quantity = values[x];
						}
						else if(x === PARAM_PRICE) {
							price = values[x];
						}
						else if(x === PARAM_CURRENCY) {
							currency = values[x];
						}
						else if(x === this.PARAM_STORE_ID) {
							storeId = values[x];
						}
						else {
							// Attributes and extra parameters are interpreted differently depending on DDX settings
							if (!useDDX) {
								args.push(values[x]);
								if (extraParams !== null) {
									extraParams += ", ";
								} else {
									extraParams = "";
								}
							
								if (values[x] == null || values[x] === "null") {
									extraParams += "null";
								} else if (values[x].charAt(0) === "\"" && values[x].charAt(values[x].length-1) === "\"") {
									extraParams += values[x];
								} else {
									extraParams += "\"" + values[x] + "\"";
								}
							} else {
								// When using DDX, the attributes and parameters are passed separately
								if(x === PARAM_ATTRIBUTES) {
									attributes = values[x];
								} else if(x === PARAM_EXTRA_PARAM) {
									extraParams = values[x];
								}
							}
						}
					}

					/**enforce required parameters**/
					if((productId == null) || (productName == null) || (category == null) || (masterCategory == null) ||
							(quantity == null) || (price == null) || (currency == null)) {

					}
					else {
						if (!useDDX) {
							shop5created = true;
						
							/** put known variables at the beginning**/
							if (!this._useHostedCMLib) {
								args.unshift(productId, productName, quantity, price, category, storeId, currency, masterCategory);
								/**
								*  call Coremetrics tag
								*/
								cmCreateShopAction5Tag.apply({}, args);
							} else {
								cmSetCurrencyCode(currency);
								var logObj = document.getElementById('cm-shopAction');
								if (debug && logObj !== null) {
									var tlog = "cmSetCurrencyCode(\"" + currency + "\");";
									var tNode = document.createTextNode(tlog);
									logObj.appendChild(tNode); 
									logObj.appendChild(document.createElement('br'));
								}
							
								args.unshift(productId, productName, quantity, price, category);	
								cmCreateShopAction5Tag.apply({}, args);
							}
						} else {
							/** useDDX is enabled **/
							if (productId == null || productId === "null" || productId === "'null'") { productId = '' };
							if (productName == null || productName === "null" || productName === "'null'") { productName = '' };
							if (quantity == null || quantity === "null" || quantity === "'null'") { quantity = '' };
							if (price == null || price === "null" || price === "'null'") { price = '' };
							if (currency == null || currency === "null" || currency === "'null'") { currency = '' };
							if (category == null || category === "null" || category === "'null'") { category = '' };
							if (virtualCategory == null || virtualCategory === "null" || virtualCategory === "'null'") { virtualCategory = '' };
							if (attributes == null || attributes === "null" || attributes === "'null'") { attributes = '' };
							if (extraParams == null || extraParams === "null" || extraParams === "'null'") { extraParams = '' };

							digitalData.cart.item[i] = {};
							digitalData.cart.item[i] = {productInfo:{productID: productId, productName: productName}, quantity: quantity, price: price, currency: currency, category:{primaryCategory: category, virtualCategory: virtualCategory}, attributes:{exploreAttributes: attributes, extraFields: extraParams}};

							if (useCMSetupOther) {
								cmSetupOther({"cm_currencyCode":"\"" + currency + "\""});
							}

							// For debug purposes
							if (internalDebug) {
								window.alert(JSON.stringify(digitalData));
							}
						}
						
						var JSONtoLog = JSON.stringify(obj);
						var obj = document.getElementById('cm-shopAction');
						if (debug && obj !== null) {
							if (!useDDX) {
								var toLog = "cmCreateShopAction5Tag(";
								if (productId !== null && productId !== "") {
									toLog += "\"" + productId + "\", ";
								} else {
									toLog += "null, ";
								}
								if (productName !== null && productName !== "") {
									productName = productName.replace(/\"/g, '\\\"');
									toLog += "\"" + productName + "\", ";
								} else {
									toLog += "null, ";
								}	
								if (quantity !== null && quantity !== "") {
									toLog += "\"" + quantity + "\", ";
								} else {
									toLog += "null, ";
								}
								if (price !== null && price !== "") {
									toLog += "\"" + price + "\", ";
								} else {
									toLog += "null, ";
								}	
								if (category !== null && category !== "") {
									toLog += "\"" + category + "\"";
								} else {
									toLog += "null";
								}
								if (!this._useHostedCMLib) {
									if (storeId !== null && storeId !== "") {
										toLog += ", \"" + storeId + "\", ";
									} else {
										toLog += ", null, ";
									}
									if (currency !== null && currency !== "") {
										toLog += "\"" + currency + "\", ";
									} else {
										toLog += "null, ";
									}								
									if (masterCategory !== null && masterCategory !== "") {
										toLog += "\"" + masterCategory + "\"";
									} else {
										toLog += "null";
									}				
								}
								if (extraParams !== null) {
									toLog += ", " + extraParams;
								}
								toLog += ");";
							} else {
								// TODO: For simplicitly, we are only logging the contents of digitalData.cart
								// And not digitalData.pageInstanceID
								
								var toLog = "digitalData.cart.item[" + i + "] = { ";
								toLog += "productInfo:{productID: '" + productId + "', productName: '" + productName + "'}, quantity: '" + quantity + "', price: '" + price + "', currency: '" + currency + "', category:{primaryCategory: '" + category + "', virtualCategory: '" + virtualCategory + "'}, attributes:{exploreAttributes: '" + attributes + "', extraFields: '" + extraParams + "'}};";

								if (useCMSetupOther) { 
									toLog += "cmSetupOther({\"cm_currencyCode\":\"" + currency + "\"});";
								}

								// For debug purposes
								if (internalDebug) {
									window.alert(toLog);
								}
							}
							
							var JSONtoLogNode = document.createTextNode(JSONtoLog);
							obj.appendChild(JSONtoLogNode); 
							obj.appendChild(document.createElement('br'));
				
							var toLogNode = document.createTextNode(toLog);
							obj.appendChild(toLogNode); 
							obj.appendChild(document.createElement('br'));
						}
					}
				}
			}
			else {

			}
			
			if(shop5created) {
				cmDisplayShop5s();
				var logObj = document.getElementById('cm-shopAction');
				if (debug && logObj !== null) {
					var tlog = "cmDisplayShop5s();";
					var tNode = document.createTextNode(tlog);
					logObj.appendChild(tNode); 
					logObj.appendChild(document.createElement('br'));
				}
			}
			
		},

		/**
		 *  This function is a handler for AddCart events.This is the method called when an AddCart event is triggered via the "/wc/analytics/addcart" topic.
		 * @param{Object} obj  JSON object with a single 'cart' array where each element is an Object containing the following fields;
			*       productId (required), the product identifier for the product being viewed. Typically contains the SKU.
			*       name (required), the name of the product.
			*       category (required), the catalog category of the product being viewed or virtual category
			*       such as "Search" or "Cross-sell".
			*       masterCategory (required), the catalog category of the product being viewed from the store's master catalog.
			*       quantity (required), the number of units ordered.
			*       price (required), the selling price fo the product.
			*       currency (required), the currency of the price.
		*/

		handleAddCart: function(obj) {

			// For debug purposes
			var internalDebug = false;
			if (internalDebug) {
				window.alert("handleAddCart");
			}

			var PARAM_PRODUCTID = "productId";
			var PARAM_PRODUCTNAME = "name";
			var PARAM_CATEGORY = "category";
			var PARAM_MASTERCATEGORY = "masterCategory";
			var PARAM_QTY = "quantity";
			var PARAM_PRICE = "price";
			var PARAM_CURRENCY = "currency";
			var PARAM_EXTRA_PARAM = "extraParams";
			var PARAM_ATTRIBUTES = "attributes";
			var PARAM_VALUE_USEDDX = "useDDX";
			var PARAM_VALUE_TRUE = "true";
			var PARAM_VALUE_FALSE = "false";

			var attributes = null;
			var extraParams = null;
			// virtualCategory is not used
			var virtualCategory = null;

			var useDDX = false;
			// By default, we must use cmSetupOther
			var useCMSetupOther = true;
			var debug = false;

			// useDDX is NOT supported for this case by Digital Analytics
			// Enable the three lines below when DDX is supported for this case
			// if(obj.options === PARAM_VALUE_USEDDX) {
			//	useDDX = true;
			// }

			if (obj.useCMSetupOther === PARAM_VALUE_TRUE) {
				useCMSetupOther = true;
			} else if (obj.useCMSetupOther === PARAM_VALUE_FALSE) {
				useCMSetupOther = false;
			}
			
			if (obj.debug === PARAM_VALUE_TRUE) {
				debug = true;
			}

			var shop5created = false;

			if(obj.cart && $.isArray(obj.cart)) {
				if (useDDX) {
					if (typeof digitalData === "undefined") {
						digitalData = {};
						digitalData.pageInstanceID='wcs-standardpage_wcs-cart';
					}
					digitalData.cart = {};
					digitalData.cart.item = new Array();
				}

				var cart = obj.cart;
				for(var i = 0; i < cart.length; i++) {
					// set some defaults
					var productId = null;
					var productName = null;
					var category = null;
					var masterCategory = null;
					var quantity = null;
					var price = null;
					var currency = null;
				
					var storeId = this._getStoreId();
					var args = new Array();
					var extraParams = null;
					
					var values = cart[i];

					/** search object for known values and save the unknown ones **/
					for(x in values) {
						if(x === PARAM_PRODUCTID) {
							productId = values[x];
						}
						else if(x === PARAM_PRODUCTNAME) {
							productName = values[x];
						}
						else if(x === PARAM_CATEGORY) {
							category = values[x];
						}
						else if(x === PARAM_MASTERCATEGORY) {
							masterCategory = values[x];
						}
						else if(x === PARAM_QTY) {
							quantity = values[x];
						}
						else if(x === PARAM_PRICE) {
							price = values[x];
						}
						else if(x === PARAM_CURRENCY) {
							currency = values[x];
						}
						else if(x === this.PARAM_STORE_ID) {
							storeId = values[x];
						}
						else {
							// Attributes and extra parameters are interpreted differently depending on DDX settings
							if (!useDDX) {
								args.push(values[x]);
								if (extraParams !== null) {
									extraParams += ", ";
								} else {
									extraParams = "";
								}
							
								if (values[x] == null || values[x] === "null") {
									extraParams += "null";
								} else if (values[x].charAt(0) === "\"" && values[x].charAt(values[x].length-1) === "\"") {
									extraParams += values[x];
								} else {
									extraParams += "\"" + values[x] + "\"";
								}
							} else {
								// When using DDX, the attributes and parameters are passed separately
								if(x === PARAM_ATTRIBUTES) {
									attributes = values[x];
								} else if(x === PARAM_EXTRA_PARAM) {
									extraParams = values[x];
								}
							}
						}
					}

					/**enforce required parameters**/
					if((productId == null) || (productName == null) || (category == null) || (masterCategory == null) ||
							(quantity == null) || (price == null) || (currency == null)) {

					}
					else {
						if (!useDDX) {
							shop5created = true;
						
							/** put known variables at the beginning**/
							if (!this._useHostedCMLib) {
								args.unshift(productId, productName, quantity, price, category, storeId, currency, masterCategory);
								/**
								*  call Coremetrics tag
								*/
								cmCreateShopAction5Tag.apply({}, args);
							} else {
								cmSetCurrencyCode(currency);
								var logObj = document.getElementById('cm-shopAction');
								if (debug && logObj !== null) {
									var tlog = "cmSetCurrencyCode(\"" + currency + "\");";
									var tNode = document.createTextNode(tlog);
									logObj.appendChild(tNode); 
									logObj.appendChild(document.createElement('br'));
								}
							
								args.unshift(productId, productName, quantity, price, category);	
								cmCreateShopAction5Tag.apply({}, args);
							}
						} else {
							/** useDDX is enabled **/
							if (productId == null || productId === "null" || productId === "'null'") { productId = '' };
							if (productName == null || productName === "null" || productName === "'null'") { productName = '' };
							if (quantity == null || quantity === "null" || quantity === "'null'") { quantity = '' };
							if (price == null || price === "null" || price === "'null'") { price = '' };
							if (currency == null || currency === "null" || currency === "'null'") { currency = '' };
							if (category == null || category === "null" || category === "'null'") { category = '' };
							if (virtualCategory == null || virtualCategory === "null" || virtualCategory === "'null'") { virtualCategory = '' };
							if (attributes == null || attributes === "null" || attributes === "'null'") { attributes = '' };
							if (extraParams == null || extraParams === "null" || extraParams === "'null'") { extraParams = '' };

							digitalData.cart.item[i] = {};
							digitalData.cart.item[i] = {productInfo:{productID: productId, productName: productName}, quantity: quantity, price: price, currency: currency, category:{primaryCategory: category, virtualCategory: virtualCategory}, attributes:{exploreAttributes: attributes, extraFields: extraParams}};

							if (useCMSetupOther) {
								cmSetupOther({"cm_currencyCode":"\"" + currency + "\""});
							}

							// For debug purposes
							if (internalDebug) {
								window.alert(JSON.stringify(digitalData));
							}
						}
						
						var JSONtoLog = JSON.stringify(obj);
						var obj = document.getElementById('cm-shopAction');
						if (debug && obj !== null) {
							if (!useDDX) {
								var toLog = "cmCreateShopAction5Tag(";
								if (productId !== null && productId !== "") {
									toLog += "\"" + productId + "\", ";
								} else {
									toLog += "null, ";
								}
								if (productName !== null && productName !== "") {
									productName = productName.replace(/\"/g, '\\\"');
									toLog += "\"" + productName + "\", ";
								} else {
									toLog += "null, ";
								}	
								if (quantity !== null && quantity !== "") {
									toLog += "\"" + quantity + "\", ";
								} else {
									toLog += "null, ";
								}
								if (price !== null && price !== "") {
									toLog += "\"" + price + "\", ";
								} else {
									toLog += "null, ";
								}	
								if (category !== null && category !== "") {
									toLog += "\"" + category + "\"";
								} else {
									toLog += "null";
								}
								if (!this._useHostedCMLib) {
									if (storeId !== null && storeId !== "") {
										toLog += ", \"" + storeId + "\", ";
									} else {
										toLog += ", null, ";
									}
									if (currency !== null && currency !== "") {
										toLog += "\"" + currency + "\", ";
									} else {
										toLog += "null, ";
									}								
									if (masterCategory !== null && masterCategory !== "") {
										toLog += "\"" + masterCategory + "\"";
									} else {
										toLog += "null";
									}				
								}
								if (extraParams !== null) {
									toLog += ", " + extraParams;
								}
								toLog += ");";
							} else {
								// TODO: For simplicitly, we are only logging the contents of digitalData.cart
								// And not digitalData.pageInstanceID
								
								var toLog = "digitalData.cart.item[" + i + "] = { ";
								toLog += "productInfo:{productID: '" + productId + "', productName: '" + productName + "'}, quantity: '" + quantity + "', price: '" + price + "', currency: '" + currency + "', category:{primaryCategory: '" + category + "', virtualCategory: '" + virtualCategory + "'}, attributes:{exploreAttributes: '" + attributes + "', extraFields: '" + extraParams + "'}};";

								if (useCMSetupOther) { 
									toLog += "cmSetupOther({\"cm_currencyCode\":\"" + currency + "\"});";
								}

								// For debug purposes
								if (internalDebug) {
									window.alert(toLog);
								}
							}
							
							var JSONtoLogNode = document.createTextNode(JSONtoLog);
							obj.appendChild(JSONtoLogNode); 
							obj.appendChild(document.createElement('br'));
				
							var toLogNode = document.createTextNode(toLog);
							obj.appendChild(toLogNode); 
							obj.appendChild(document.createElement('br'));
						}
					}
				}
			}
			else {

			}
			
			if(shop5created) {
				cmDisplayShop5s();
				var logObj = document.getElementById('cm-shopAction');
				if (debug && logObj !== null) {
					var tlog = "cmDisplayShop5s();";
					var tNode = document.createTextNode(tlog);
					logObj.appendChild(tNode); 
					logObj.appendChild(document.createElement('br'));
				}
			}
			
		},

		/**
		* This function is a handler for Element events.This is the method called when an Element event is triggered via the "/wc/analytics/element" topic. This is an empty placeholder that should be extended by the implementation.
		* @param{Object} obj JSON object containing the following fields;
		*    elementId (required), the identifier for the element being interacted with.
		*       category (optional), the category of the element.
		*       pageId (optional), the ID of the associated page that the element is on.
		*       pageCategory (optional), the category of the associated page that the element is on.
		*       location (optional), the location of the element on the page. For example, "top navigation" or "footer". 
		*/

		handleElement: function(obj) {
			
			// For debug purposes
			var internalDebug = false;
			if (internalDebug) {
				window.alert("handleElement");
			}

			var PARAM_ELEMENTID = "elementId";
			var PARAM_CATEGORY = "category";
			var PARAM_PAGEID = "pageId";
			var PARAM_PAGECATEGORY = "pageCategory";
			var PARAM_LOCATION = "location";
		
			var PARAM_OPTIONS = "options";
			var PARAM_DEBUG = "debug";
			var PARAM_EXTRA_PARAM = "extraParams";
			var PARAM_VALUE_USEDDX = "useDDX";
			var PARAM_VALUE_TRUE = "true";

			/** set some defaults**/
			var elementId = null;
			var category = null;
			var pageId = null;
			var pageCategory = null;
			var elementLocation = null;
		
			var extraParams = null;

			var storeId = this._getStoreId();
			var args = new Array();
		
			var useDDX = false;
			var debug = false;

			/** search object for known values and save the unknown ones**/
			for(x in obj) {
				if(x === PARAM_OPTIONS) {
					var options = obj[x];
					if (options === PARAM_VALUE_USEDDX) {
						useDDX = true;
					}
				} else if (x === PARAM_DEBUG) {
					var debugParam = obj[x];
					if (debugParam === PARAM_VALUE_TRUE) {
						debug = true;
					}
				} else if(x === PARAM_ELEMENTID) {
					elementId = obj[x];
				}
				else if(x === PARAM_CATEGORY) {
					category = obj[x];
				}
				else if(x === PARAM_PAGEID) {
					pageId = obj[x];
				}
				else if(x === PARAM_PAGECATEGORY) {
					pageCategory = obj[x];
				}
				else if(x === PARAM_LOCATION) {
					elementLocation = obj[x];
				}
				else if(x === this.PARAM_STORE_ID) {
					storeId = obj[x];
				}
				else {
					// Attributes and extra parameters are interpreted differently depending on DDX settings
					if (!useDDX) {
						// When not using DDX, the parameters are passed on the same entry
						args.push(obj[x]);
					} else {
						// When using DDX, the parameters are passed separately
						// Notice that in this case, the explore attributes are stored under extraParams
						// This is for consistency with the non-DDX scenario	
						if(x === PARAM_EXTRA_PARAM) {
							extraParams = obj[x];
						}
					}
				}
			}
			
			/** enforce required parameters**/
			if(elementId == null) {
			}
			else {
				if (!useDDX) {
					/** useDDX is disabled **/
					/** put known variables at the beginning**/
				
					if (!this._useHostedCMLib) {
						args.unshift(elementId, category, pageId, pageCategory, elementLocation, storeId);
						/** call Coremetrics tag**/
						cmCreatePageElementTag.apply({}, args);

					} else {
						args.unshift(elementId, category);
						/** call Coremetrics tag**/
						cmCreateElementTag.apply({}, args);
					}
				} else {
					/** useDDX is enabled **/
					if (elementId == null || elementId === "null" || elementId === "'null'") { elementId = '' };
					if (category == null || category === "null" || category === "'null'") { category = '' };
					if (extraParams == null || extraParams === "null" || extraParams === "'null'") { extraParams = '' };
			
					// Notice that in this case, the explore attributes are stored under extraParams
					// This is for consistency with the non-DDX scenario	
					if (typeof digitalData === "undefined") {
						digitalData = {};
						digitalData.pageInstanceID = 'wcs-standardpage_wcs-element';
					}

					digitalData.component = [{componentInfo:{componentID: elementId},category:{primaryCategory: category},attributes:{exploreAttributes: extraParams}}];	
					// For debug purposes
					if (internalDebug) {
						window.alert(JSON.stringify(digitalData));
					}
				}
					
				var JSONtoLog = JSON.stringify(obj);
				var obj = document.getElementById('cm-element');
				if (debug && obj !== null) {
					if (!useDDX) {
						var toLog = "";
						if (!this._useHostedCMLib) {
							toLog = "cmCreatePageElementTag("; 
						} else {
							toLog = "cmCreateElementTag(";
						}
					
						if (elementId !== null && elementId !== "") {
							toLog += "\"" + elementId + "\", ";
						} else {
							toLog += "null, ";
						}
						if (category !== null && category !== "") {
							toLog += "\"" + category + "\"";
						} else {
							toLog += "null";
						}	
					
						if (!this._useHostedCMLib) {
							if (pageId !== null && pageId !== "") {
								toLog += ", \"" + pageId + "\", ";
							} else {
								toLog += ", null, ";
							}	
							if (pageCategory !== null && pageCategory !== "") {
								toLog += "\"" + pageCategory + "\", ";
							} else {
								toLog += "null, ";
							}
							if (elementLocation !== null && elementLocation !== "") {
								toLog += "\"" + elementLocation + "\", ";
							} else {
								toLog += "null, ";
							}	
							if (storeId !== null && storeId !== "") {
								toLog += "\"" + storeId + "\"";
							} else {
								toLog += "null";
							}									
						}
						toLog += ");";
					} else {
						var toLog = "digitalData = { ";
						if (digitalData.pageInstanceID !== null && digitalData.pageInstanceID !== "") {
								toLog += "pageInstanceID:'" + digitalData.pageInstanceID + "', ";
						}
						toLog += "component:[{componentInfo:{componentID: '" + elementId + "'},category:{primaryCategory: '" + category + "'},attributes:{exploreAttributes: '" + extraParams + "'}}]}";	
						// For debug purposes
						if (internalDebug) {
							window.alert(toLog);
						}
					}
					
					var JSONtoLogNode = document.createTextNode(JSONtoLog);
					obj.appendChild(JSONtoLogNode); 
					obj.appendChild(document.createElement('br'));

					var toLogNode = document.createTextNode(toLog);
					obj.appendChild(toLogNode); 
					obj.appendChild(document.createElement('br'));
				}
				
			}
		},
		/**
		 * This function is a handler for Registration events
		 * @param obj JSON object containing the following fields:
		 *            userId,userEmail,userCity,userState,userZip,newsletterName,subscribedFlag,storeId,userCountry,age,gender,maritalStatus,numChildren,numInHousehold
		 *            companyName,hobbies,income
		 */
		handleRegistration: function(obj) {

			// For debug purposes
			var internalDebug = false;
			if (internalDebug) {
				window.alert("handleRegistration");
			}

			// known parameters
			var PARAM_USERID = "userId";
			var PARAM_USEREMAIL = "userEmail";
			var PARAM_USERCITY = "userCity";
			var PARAM_USERSTATE = "userState";
			var PARAM_USERZIP = "userZip";
			var PARAM_NEWSLETTERNAME = "newsletterName";
			var PARAM_SUBSCRIBEDFLAG = "subscribedFlag";
			var PARAM_STOREID = "storeId";
			var PARAM_USERCOUNTRY = "userCountry";
			var PARAM_AGE = "age";
			var PARAM_GENDER = "gender";
			var PARAM_MARITALSTATUS = "maritalStatus";
			var PARAM_NUMCHILDREN = "numChildren";
			var PARAM_NUMINHOUSEHOLD = "numInHousehold";
			var PARAM_COMPANYNAME = "companyName";
			var PARAM_HOBBIES = "hobbies";
			var PARAM_INCOME = "income";
			// For registration tag we only use extraParams 0
			var PARAM_ATTRIBS = "extraParams0";

			var PARAM_OPTIONS = "options";
			var PARAM_DEBUG = "debug";
			var PARAM_EXTRA_PARAM = "extraParams";
			var PARAM_VALUE_USEDDX = "useDDX";
			var PARAM_VALUE_TRUE = "true";

			var userId = null;
			var userEmail = null;
			var userCity = null;
			var userState = null;
			var userZip = null;
			var newsletterName = null;
			var subscribedFlag = null;
			var userCountry = null;
			var age = null;
			var gender = null;
			var maritalStatus = null;
			var numChildren = null;
			var numInHousehold = null;
			var companyName = null;
			var hobbies = null;
			var income = null;
			var attribs = null;
			var storeId = this._getStoreId();
			var args = new Array();
			var extraParams = null;

			var useDDX = false;
			var debug = false;
			
			/** search object for known values and save the unknown ones**/
			for(x in obj) {
				if(x === PARAM_OPTIONS) {
					var options = obj[x];
					if (options === PARAM_VALUE_USEDDX) {
						useDDX = true;
					}
				} else if (x === PARAM_DEBUG) {
					var debugParam = obj[x];
					if (debugParam === PARAM_VALUE_TRUE) {
						debug = true;
					}
				} else if(x === PARAM_USERID) {
					userId = obj[x];
				}
				else if(x === PARAM_USEREMAIL ) {
					userEmail = obj[x];
				}
				else if(x === PARAM_USERCITY) {
					userCity = obj[x];
				}
				else if(x === PARAM_USERSTATE) {
					userState = obj[x];
				}
				else if(x === PARAM_USERZIP) {
					userZip = obj[x];
				}
				else if(x === PARAM_NEWSLETTERNAME ) {
					newsletterName = obj[x];
				}
				else if(x === PARAM_SUBSCRIBEDFLAG) {
					subscribedFlag = obj[x];
				}
				else if(x === PARAM_STOREID) {
					storeId = obj[x];
				}
				else if(x === PARAM_USERCOUNTRY) {
					userCountry = obj[x];
				}
				else if(x === PARAM_AGE) {
					
					var temp = obj[x];
					if(temp === "0" || temp === ""){
						age = "null"
					}else{
						age = temp;
					}
					
				}
				else if(x === PARAM_GENDER ) {
					var temp = obj[x];
					if(temp === ""){
						gender = "null"
					}else{
						gender = temp;
					}
								
				}
				else if(x === PARAM_MARITALSTATUS) {
					var temp = obj[x];
					if(temp === ""){
						maritalStatus = "null"
					}else{
						maritalStatus = temp;
					}
					
				}
				else if(x === PARAM_NUMCHILDREN) {
					
					var temp = obj[x];
					if(temp === "0" || temp === ""){
						numChildren = "null"
					}else{
						numChildren = temp;
					}
					
					
				}
				else if(x === PARAM_NUMINHOUSEHOLD) {
					var temp = obj[x];
					if(temp === "0" || temp === ""){
						numInHousehold = "null"
					}else{
						numInHousehold = temp;
					}
					
					
				}			
				else if(x === PARAM_COMPANYNAME) {
					var temp = obj[x];
					if(temp === ""){
						companyName = "null"
					}else{
						companyName = temp;
					}
					
				}
				else if(x === PARAM_HOBBIES) {
					var temp = obj[x];
					if(temp === ""){
						hobbies = "null"
					}else{
						hobbies = temp;
					}
					
				}
				else if(x === PARAM_INCOME ) {
					var temp = obj[x];
					if(temp === "0" || temp === ""){
						income = "null"
					}else{
						income = temp;
					}

					
				}
				else if (x === PARAM_ATTRIBS) {
					var temp = obj[x];
					if(temp === "0" || temp === ""){
						attribs = "null"
					}else{
						attribs = temp;
					}
					
				}
				else {
					// Attributes and extra parameters are interpreted differently depending on DDX settings
					if (!useDDX) {
						args.push(obj[x]);
						if (extraParams == null) {
							extraParams = "\"" + obj[x] + "\"";
						} else {
							extraParams = ", \"" + obj[x] + "\"";
						}
					} else {
						// When using DDX, the parameters are passed separately
						if(x === PARAM_EXTRA_PARAM) {
							extraParams = obj[x];
						}
					}
				}
			}

			/** put known variables at the beginning**/
			
			var attribString = "";
			// Form the string for explore attributes if using hosted libraries or if we are using DDX
			if (this._useHostedCMLib || useDDX) {
				if (age == null || age === "null") {
					age = "";
				}			
				if (gender == null || gender === "null") {
					gender = "";
				}
				if (maritalStatus == null || maritalStatus === "null") {
					maritalStatus = "";
				}
				if (numChildren == null || numChildren === "null") {
					numChildren = "";
				}
				if (numInHousehold == null || numInHousehold === "null") {
					numInHousehold = "";
				}
				if (companyName == null || companyName === "null") {
					companyName = "";
				}
				if (hobbies == null || hobbies === "null") {
					hobbies = "";
				}
				if (income == null || income === "null") {
					income = "";
				}
				attribString = age + "-_-" + gender + "-_-" + maritalStatus + "-_-" + numChildren + "-_-" + numInHousehold + "-_-" + companyName + "-_-" + hobbies + "-_-" + income;
				if (attribs !== null && attribs !== "null") {
					attribString += "-_-" + attribs;
				}
				args.unshift(userId, userEmail, userCity, userState, userZip, userCountry, attribString);
			} else {
				args.unshift(userId, userEmail, userCity, userState, userZip, newsletterName, subscribedFlag, storeId, userCountry, age, gender, 
						maritalStatus, numChildren, numInHousehold, companyName, hobbies, income);
			}
		
			if (!useDDX) {	
				/** useDDX is disabled **/
				/** call Coremetrics tag**/
				cmCreateRegistrationTag.apply({}, args);
			} else {
				/** useDDX is enabled **/
				if (userId == null || userId === "null" || userId === "'null'") { userId = '' };
				if (userEmail == null || userEmail === "null" || userEmail === "'null'") { userEmail = '' };
				if (attribString == null || attribString === "null" || attribString === "'null'") { attribString = '' };
				if (userCity == null || userCity === "null" || userCity === "'null'") { userCity = '' };
				if (userState == null || userState === "null" || userState === "'null'") { userState = '' };
				if (userZip == null || userZip === "null" || userZip === "'null'") { userZip = '' };
				if (userCountry == null || userCountry === "null" || userCountry === "'null'") { userCountry = '' };
				
				// Notice that in this case, the explore attributes are set as attribString and extraParams are not used
				if (typeof digitalData === "undefined") {
					digitalData = {};
					digitalData.pageInstanceID = 'wcs-standardpage_wcs-registration';
				}

				digitalData.user = [{profile:[{profileInfo:{profileID: userId, profileEmail: userEmail, exploreAttributes: attribString}, address:{city: userCity, state_province: userState ,postalcode: userZip, country: userCountry}}]}];	

				// For debug purposes
				if (internalDebug) {
					window.alert(JSON.stringify(digitalData));
				}
			}
			
			var JSONtoLog = JSON.stringify(obj);
			var obj = document.getElementById('cm-registration');
			if (debug && obj !== null) {
				if (!useDDX) {
					var toLog = "cmCreateRegistrationTag(";
					if (userId !== null && userId !== "" && userId !== "null") {
						toLog += "\"" + userId + "\", ";
					} else {
						toLog += "null, ";
					}
					if (userEmail !== null && userEmail !== "" && userEmail !== "null") {
						toLog += "\"" + userEmail + "\", ";
					} else {
						toLog += "null, ";
					}	
					if (userCity !== null && userCity !== "" && userCity !== "null") {
						toLog += "\"" + userCity + "\", ";
					} else {
						toLog += "null, ";
					}	
					if (userState !== null && userState !== "" && userState !== "null") {
						toLog += "\"" + userState + "\", ";
					} else {
						toLog += "null, ";
					}
					if (userZip !== null && userZip !== "" && userZip !== "null") {
						toLog += "\"" + userZip + "\", ";
					} else {
						toLog += "null, ";
					}	
				
					if (!this._useHostedCMLib) {
						if (newsletterName !== null && newsletterName !== "" && newsletterName !== "null") {
							toLog += "\"" + newsletterName + "\", ";
						} else {
							toLog += "null, ";
						}
						if (subscribedFlag !== null && subscribedFlag !== "" && subscribedFlag !== "null") {
							toLog += "\"" + subscribedFlag + "\", ";
						} else {
							toLog += "null, ";
						}
						if (storeId !== null && storeId !== "" && storeId !== "null") {
							toLog += "\"" + storeId + "\", ";
						} else {
							toLog += "null, ";
						}	
					}
					if (userCountry !== null && userCountry !== "" && userCountry !== "null") {
						toLog += "\"" + userCountry + "\", ";
					} else {
						toLog += "null, ";
					}
					
					if (this._useHostedCMLib) {
						toLog += "\"" + attribString + "\"";
					} else {
						if (age !== null && age !== "" && age !== "null") {
							toLog += "\"" + age + "\", ";
						} else {
							toLog += "null, ";
						}	
						
						if (gender !== null && gender !== "" && gender !== "null") {
							toLog += "\"" + gender + "\", ";
						} else {
							toLog += "null, ";
						}
						if (maritalStatus !== null && maritalStatus !== "" && maritalStatus !== "null") {
							toLog += "\"" + maritalStatus + "\", ";
						} else {
							toLog += "null, ";
						}	
						if (numChildren !== null && numChildren !== "" && numChildren !== "null") {
							toLog += "\"" + numChildren + "\", ";
						} else {
							toLog += "null, ";
						}	
						if (numInHousehold !== null && numInHousehold !== "" && numInHousehold !== "null") {
							toLog += "\"" + numInHousehold + "\", ";
						} else {
							toLog += "null, ";
						}
						if (companyName !== null && companyName !== "" && companyName !== "null") {
							toLog += "\"" + companyName + "\", ";
						} else {
							toLog += "null, ";
						}				
						if (hobbies !== null && hobbies !== "" && hobbies !== "null") {
							toLog += "\"" + hobbies + "\", ";
						} else {
							toLog += "null, ";
						}				
						if (income !== null && income !== "" && income !== "null") {
							toLog += "\"" + income + "\"";
						} else {
							toLog += "null";
						}				
					}
					if (extraParams !== null) {
						toLog += ", " + extraParams;
					}
					toLog += ");";
				} else {
					var toLog = "digitalData = { ";
					if (digitalData.pageInstanceID !== null && digitalData.pageInstanceID !== "") {
							toLog += "pageInstanceID:'" + digitalData.pageInstanceID + "', ";
					}
					toLog += "user:[{profile:[{profileInfo:{profileID: '" + userId + "', profileEmail: '"+ userEmail + "', exploreAttributes: '" + attribString + "'}, address:{city: '" + userCity + "', state_province: '" + userState + "',postalcode: '" + userZip + "', country: '" + userCountry + "'}}]}]}";
					// For debug purposes
					if (internalDebug) {
						window.alert(toLog);
					}
				}
				
				var JSONtoLogNode = document.createTextNode(JSONtoLog);
				obj.appendChild(JSONtoLogNode); 
				obj.appendChild(document.createElement('br'));

				var toLogNode = document.createTextNode(toLog);
				obj.appendChild(toLogNode); 
				obj.appendChild(document.createElement('br'));
			}
		},
		
		/**
		 * _getStoreId This function returns the store identifier of the page currently being viewed
		 * @return{String} returns the store identifier of the page currently being viewed
		 */
		_getStoreId: function() {
			
			var pairs = window.location.search.substr(1).split("&");
			for(var i = 0; i < pairs.length; i++) {
				var nvp = pairs[i].split("=");
				if((nvp.length === 2) && (nvp[0] === this.PARAM_STORE_ID)) {
					return nvp[1];
				}
			}
			return null;
		}
	});
}
//-----------------------------------------------------------------
// Licensed Materials - Property of IBM
//
// WebSphere Commerce
//
// (C) Copyright IBM Corp. 2016 All Rights Reserved.
//
// US Government Users Restricted Rights - Use, duplication or
// disclosure restricted by GSA ADP Schedule Contract with
// IBM Corp.
//-----------------------------------------------------------------

/* global $, window */

var arrayUtils = arrayUtils || {

    /**
     * Given an array and a comparison function, performs stable sort on the given array.
     * The comparison function must return 0 (and not just any falsy value) if the elements 
     * are equal for this function to work as expected. The given array and its elements are 
     * not modified. Returns a new array. This function was written since the built-in 
     * JavaScript [].sort is not guaranteed to be stable.
     */
    stableSort: function (arr, cmp) {
        // Create a new array that also has the index of each element
        var newArr = arr.map(function (e, i) {
            return {
                element: e,
                index: i
            };
        });

        // Uses the JavaScript built-in sort, but if two elements are equal, compare
        // by their index
        return newArr.sort(function (a, b) {
            var cmpResult = cmp(a.element, b.element);
            if (cmpResult === 0) {
                return a.index - b.index;
            } else {
                return cmpResult;
            }
        }).map(function(e) {
            return e.element;
        });
    },
    
    /**
    * Returns true if the given array holds a transitive property defined by the given predicate. 
    * For instance, to check if an array is sorted, it suffices to check whether the sorted property
    * holds for each consecutive elements. If an array has zero or one element, this function 
    * vacuously returns true.
    *
    * @param arr an array
    * @param predicate a function that takes two arguments and trues if the two arguments satisfy some
    * relationship and false otherwise. 
    */
    verifyTransitiveProperty: function(arr, predicate) {
        var i;
        for (i = 0; i < arr.length - 1; i++) {
            if (!predicate(arr[i], arr[i+1])) {
                return false;
            }
        }
        return true;
    },
    
    /**
    * Returns true if the given array is empty.
    */
    isEmpty: function(arr) {
        return arr.length === 0;
    },
    
    /**
    * Returns the last element in an array. Returns undefined if the array is empty.
    */
    last: function(arr) {
        if (this.isEmpty(arr)) {
            return undefined;
        }
        return arr[arr.length - 1];
    },
    
    /**
    * Given an array returns a new array where the elements of the given array are divided into
    * subarrays. Each subarray contains up to the given count.  
    *
    * Example:
    * arrTo2D([1,2,3,4,5,6,7,8,9], 3) -> [[1,2,3],[4,5,6],[7,8,9]]
    * arrTo2D([1,2,3,4,5,6,7,8,9,10], 3) -> [[1,2,3],[4,5,6],[7,8,9],[10]]
    */
    arrTo2D: function(arr, count) {
        if (typeof count === 'undefined') {
            throw "The number of columns to divide the array into is undefined";
        }
        var newArr = [];
        while(arr.length) {
            newArr.push(arr.splice(0,count));
        }
        return newArr;
    }
}//-----------------------------------------------------------------
// Licensed Materials - Property of IBM
//
// WebSphere Commerce
//
// (C) Copyright IBM Corp. 2016 All Rights Reserved.
//
// US Government Users Restricted Rights - Use, duplication or
// disclosure restricted by GSA ADP Schedule Contract with
// IBM Corp.
//-----------------------------------------------------------------

/* An dictionary of commonly used key codes, listed numerically by key code */
var KeyCodes = KeyCodes || {
    TAB: 9,
    /* Carriage return, or enter key */
    RETURN: 13,
    SHIFT: 16,
    SPACE: 32,
    ESCAPE: 27,
	LEFT_ARROW: 37,
    UP_ARROW: 38,
	RIGHT_ARROW: 39,	
    DOWN_ARROW: 40
};//-----------------------------------------------------------------
// Licensed Materials - Property of IBM
//
// WebSphere Commerce
//
// (C) Copyright IBM Corp. 2016 All Rights Reserved.
//
// US Government Users Restricted Rights - Use, duplication or
// disclosure restricted by GSA ADP Schedule Contract with
// IBM Corp.
//-----------------------------------------------------------------

/* global jQuery, $, console */

// Adds publish/subscribe functionality to jQuery using callbacks
// Source: https://api.jquery.com/jQuery.Callbacks/

/*
// Publisher
wcTopic.publish( "mailArrived", "hello world!" );
wcTopic.publish( "event1", {"key1":"value1", "key2":"value2"});

// Subscribe
wcTopic.subscribe( "mailArrived", fn1 );
wcTopic.subscribe( ["event1", "event2"], function test(returnData) {
    if (returnData) {
        alert("data: " + returnData["key1"]);
    }
});
wcTopic.subscribe({"event1":"event1", "event2":"event2"}, fn1);

*/

wcTopic = {
    _topics: {},

    _getIdArray: function(ids) {
        var idArray = new Array();
        if ($.type(ids) === "array" || $.type(ids) === "object") {
            for (var key in ids) {
                idArray.push(ids[key]);
            }
        } else if ($.type(ids) === "string"){
            idArray.push(ids);
        } else {
            console.error("jQuery.Topic - ids has an unsupported type: " + $.type(ids));
        }
        return idArray;
    },

    _processIds: function(ids) {
        var idArray = this._getIdArray(ids);
        for (var key in idArray) {
            var id = idArray[key];
            if (!this._topics[id]) {
                // declare new topic
                this._topics[id] = $.Topic(id);
            }
        }
        return idArray;
    },

    /**
     * @param ids Event ids (type can be string for single ID, or array of ids in string, or object containing ids in string)
     * @param fcn The function to invoke
     */
    subscribe: function(ids, fcn) {
        var idArray = this._processIds(ids);
        for (var key in idArray) {
            this._topics[idArray[key]].subscribe(fcn);
        }
    },

    /**
     * @param ids Event ids (type can be string for single ID, or array of ids in string, or object containing ids in string)
     * @param obj The data to pass back to the callback list
     */
    publish: function(ids, obj) {
        var idArray = this._processIds(ids),
            args;
        for (var key in idArray) {
            // Grab all but the first argument
            args = Array.prototype.slice.call(arguments, 1);
            this._topics[idArray[key]].publish.apply(null, args);
        }
    },

    subscribeOnce: function(ids, fcn, context) {
        var idArray = this._processIds(ids);
        for (var key in idArray) {
            this._topics[idArray[key]].subscribeOnce(fcn, context);
        }
    }
}

jQuery.Topic = function (id) {
    var callbacks = jQuery.Callbacks("unique");

    var topic = {
        id: id,
        publish: callbacks.fire,
        subscribe: callbacks.add,
        /**
        * Same as subscribe except the given function or array of functions
        * only execute once (and then the function is removed from this callback).
        */
        subscribeOnce: function (fcns, context) {
            if ($.isFunction(fcns)) {
                var newFcn = function () {
                    fcns.apply(context || this, arguments);
                    callbacks.remove(newFcn);
                };
                callbacks.add(newFcn);
            } else {
                fcns.forEach(function (a_fcn) {
                    if ($.isFunction(a_fcn)) {
                        var newFcn = function () {
                            a_fcn.apply(context || this, arguments);
                            callbacks.remove(newFcn);
                        };
                        callbacks.add(newFcn);
                    } else {
                        console.err(a_fcn + " is not a function");
                    }
                });
            }
        },
        unsubscribe: callbacks.remove
    };

    return topic;
};//-----------------------------------------------------------------
// Licensed Materials - Property of IBM
//
// WebSphere Commerce
//
// (C) Copyright IBM Corp. 2016 All Rights Reserved.
//
// US Government Users Restricted Rights - Use, duplication or
// disclosure restricted by GSA ADP Schedule Contract with
// IBM Corp.
//-----------------------------------------------------------------

/* global $, window */

var Utils = Utils || {
    /*
     * Returns a function that can only be executed once. 
     */
    once: function(fn, context) {
        var result;

        return function() {
            if (fn) {
                result = fn.apply(context || this, arguments);
                fn = null;
            }

            return result;
        };
    },

    /*
     * Stops an event (same as Dojo's event.stop(e)).
     */
    stopEvent: function(event) {
        event.preventDefault();
        event.stopPropagation();
    },

    /**
     * Returns the text direction (one of rtl or ltr) of the given element.
     */
    getTextDirection: function(element) {
        var result = null;
        if (window.getComputedStyle) {
            result = window.getComputedStyle(element, null).direction;
        } else if (element.currentStyle) {
            result = element.currentStyle.direction;
        }

        return result;
    },

    /**
     * Returns true if the browser is Opera, false otherwise.
     */
    isOpera: function() {
        return (navigator.userAgent.match(/Opera|OPR\//) ? true : false);
    },
    /**
     * Detect ios devices
     * return true if ios devies
     */
    has_ios: function() {
        return navigator.userAgent.match(/(iPod|iPhone|iPad)/)

    },

    /**
     * Returns true if the browser is Chrome, false otherwise.
     */
    isChrome: function() {
        return /chrom(e|ium)/.test(navigator.userAgent.toLowerCase());
    },

    /**
     * Detect touch devices
     * return true for touch devies
     */
    hasTouch: function() {
        return (('ontouchstart' in window) || (navigator.MaxTouchPoints > 0) || (navigator.msMaxTouchPoints > 0));
    },
    /**
     * Detect IE
     * returns the version of IE or undefined, if browser is not Internet Explorer
     */
    get_IE_version: function() {
        var ua = window.navigator.userAgent,
            msie = ua.indexOf('MSIE ');
        if (msie > 0) {
            // IE 10 or older => return version number
            return parseInt(ua.substring(msie + 5, ua.indexOf('.', msie)), 10);
        }

        var trident = ua.indexOf('Trident/');
        if (trident > 0) {
            // IE 11 => return version number
            var rv = ua.indexOf('rv:');
            return parseInt(ua.substring(rv + 3, ua.indexOf('.', rv)), 10);
        }

        var edge = ua.indexOf('Edge/');
        if (edge > 0) {
            // Edge (IE 12+) => return version number
            return parseInt(ua.substring(edge + 5, ua.indexOf('.', edge)), 10);
        }

        // other browser
        return undefined;
    },

    /**
     * Returns the keys of a JavaScript object as an array. 
     */
    keys: function(obj) {
        var keys = [],
            k;
        for (k in obj) {
            if (obj.hasOwnProperty(k)) {
                keys.push(k);
            }
        }
        return keys;
    },

    /**
     * Iterate over the key-value pairs of the given object
     * in the order returned by the given comparator function.
     * 
     * Parameters:
     * obj - an object to iterate over
     * cmp - the comparator function. Accepts two objects (a, b) 
     *       and returns an integer greater than 0 if a > b, returns
     *       an integer less than 0 if a < b, returns 0 if a equals b.
     * fcn - the callback to execute for each key-value pair in the
     *       object. Shouldaccepts two arguments, a key and a
     *       value. Return true to break out of the loop early.
     */
    iterate_obj_in_order: function(obj, cmp, fcn) {
        var keys = this.keys(obj),
            len = keys.length,
            i, k;

        keys.sort(cmp);

        for (i = 0; i < len; i++) {
            k = keys[i];
            if (fcn(k, obj[k])) {
                break;
            }
        }
    },

    /*
     * Returns true if the given value is NOT null or undefined
     */
    varExists: function(val) {
        return val !== null && (typeof val !== 'undefined');
    },

    /**
     * Returns true if the given value is not null, undefined or empty (i.e. length === 0).
     * Only works on values that have a length property. 
     */
    existsAndNotEmpty: function(val) {
        return this.varExists(val) && val.length;
    },

    /*
     * Returns true if the given value is null or undefined
     TODO: remove this, since it's not following our JavaScript convention, use isNullOrUndefined instead
     */
    is_null_or_undefined: function(val) {
        return val === null || (typeof val === 'undefined');
    },

    /*
     * Returns true if the given value is null or undefined
     */
    isNullOrUndefined: function(val) {
        return val === null || (typeof val === 'undefined');
    },

    /*
     * Returns true if the given value is undefined.
     */
    isUndefined: function(val) {
        return typeof val === 'undefined';
    },

    /*
     * Returns true if the given value is undefined or empty (i.e. length === 0),
     * assumes the given value will have a length property if it's not undefined.
     */
    isUndefinedOrEmpty: function(val) {
        return (typeof val === 'undefined') || (val.length === 0);
    },

    /**
     * Returns true if the given value is an Object
     */
    isObject: function(val) {
        return (val !== null) && (typeof val === "object");
    },

    isString: function(val) {
        return typeof val === 'string';
    },

    /**
     * Converts a URI query into a JavaScript Object
     */
    queryToObject: function(query) {
        var json = '{"' + query.split("&").map(function(str) {
            // important, only replace the first occurrence, don't use a regex
            // to replace all occurence, because the value might have an '=' sign
            // (e.g. if it's a url)
            return str.replace("=", '":"');
        }).join('","') + '"}';

        return query ? JSON.parse(json,
            function(key, value) {
                return key === "" ? value : decodeURIComponent(value);
            }) : {};
    },

    /**
     * Updates the given URL with the given query parameter(s). Modifies the query parameter if it
     * already exists in the URL, otherwise adds the query parameters. 
     * 
     * @param uri the URL to modify
     * @param keys {string, Object} the name of the parameter (must also specify the val parameter) or
     * an Object where the property names are the parameter names and the property values are the 
     * parameter values.
     * @param val {string} the value of the parameter, if keys is an Object, val will be ignored.
     */
    updateQueryStringParameter: function(uri, keys, val) {
        var parameters = {};

        // Parameter checks
        if (this.isString(keys)) {
            parameters[keys] = val;
        } else if (this.isObject(keys)) {
            if (!this.isUndefined(val)) {
                console.warn("Value parameter passed, but will not be used: " + val);
            } else if ($.isEmptyObject(keys)) {
                console.warn("The given parameters are empty");
                return uri;
            }
            parameters = keys;
        } else {
            throw "Invalid key parameter, expected a String or an Object, got: " + keys;
        }

        $.each(parameters, function(key, value) {
            var re = new RegExp("([?|&])" + key + "=.*?(&|#|$)", "i");
            if (uri.match(re)) {
                uri = uri.replace(re, '$1' + key + "=" + value + '$2');
            } else {
                var hash = '';
                if (uri.indexOf('#') !== -1) {
                    hash = uri.replace(/.*#/, '#');
                    uri = uri.replace(/#.*/, '');
                }
                var separator = uri.indexOf('?') !== -1 ? "&" : "?";
                uri = uri + separator + key + "=" + value + hash;
            }
        });
        return uri;
    },

    /**
     * Returns a new Date object with the same date as the given date plus the given number of days.
     *
     * @param date {Date} a JavaScript Date object
     * @param days {integer} the number of days to add (if negative will subtract the given 
     * number of days)
     * @returns {Date} a new Date object
     */
    addDays: function(date, days) {
        var result = new Date(date);
        result.setDate(result.getDate() + days);
        return result;
    },

    /**
     * Returns a new Date object with the same date as the given date plus the given number of milliseconds.
     *
     * @param date {Date} a JavaScript Date object
     * @param milliseconds {integer} the milliseconds to add (if negative will subtract the given 
     * number of milliseconds)
     * @returns {Date} a new Date object
     */
    addMilliseconds: function(date, milliseconds) {
        return new Date(date.getTime() + milliseconds);
    },

    /* ----- USES JQUERY ----- */
    /*
     * Set the option of the given widget with data from the DOM if the option is currently
     * null or undefined. If the data from the DOM could not be found, then assign the 
     * given default value.
     * 
     * Parameters: 
     * widget - a jQuery widget
     * option_name - name of the option
     * data_name - name of the data in the DOM
     * default_val - the default value to assign if the data could not be found
     *               in the DOM.
     */
    set_option: function(widget, option_name, data_name, default_val) {
        if (this.is_null_or_undefined(widget.options[option_name])) {
            var data_val = $(widget.element).data(data_name);
            if (this.is_null_or_undefined(data_val)) {
                widget.option(option_name, default_val);
            } else {
                widget.option(option_name, data_val);
            }

        }
    },

    /**
     * Toggle the given hyperlink
     *
     * @param enable true if the hyperlink should be enabled (i.e. the browser will following the link
     * when the user clicks on it), false otherwise (i.e. browser will NOT follow the link when the user
     * clicks on it).
     */
    toggleHyperlink: function($link, enable) {
        if ($link.is("a")) {
            if (enable) {
                // Remove the click handler we added that prevents the default behaviour
                // from occurring
                $link.off("click.utils");
                // Restore the original onclick attribute
                var data = $link.data("utils.toggleHyperlink");
                $link.attr("onclick", data.onclick);
            } else {
                // Stop default href behaviour (note this does not stop other click
                // handlers attached to this link
                $link.on("click.utils", function(evt) {
                    evt.preventDefault();
                });
                // Remove the onclick attribute (evt.preventDefault does not appear to stop
                // browser from following the link). Store it in a data field so when we want
                // to re-enable it we add add the onclick attribute back
                $link.data("utils.toggleHyperlink", {
                    onclick: $link.attr("onclick")
                });
                $link.removeAttr("onclick");
            }

        } else {
            console.err("not a hyperlink: " + $link);
        }
    },

    /**
     * Returns the absolute position of the given element as well as it's 
     * width and height (same as Dojo's domGeometry.position)
     * 
     * @param element {string || jQuery Object || node}
     * Returns:
     * {
     *   x: x coordinate of the element in the document
     *   y: y coordinate of the element in the document
     *   width: width of the element
     *   height: height of the element
     * }
     */
    position: function(element) {
        var $e = $(element),
            offset = $e.offset();
        return {
            x: offset.left,
            y: offset.top,
            w: $e.width(),
            h: $e.height()
        };
    },

    /**
     * Returns true if the given String is empty or whitespace
     */
    isEmptyOrWhiteSpace: function(str) {
        return $.trim(str) === '';
    },

    /**
     * Returns true if the given value is a boolean
     */
    isBoolean: function(value) {
        return $.type(value) === "boolean";
    },

    /*
     * Given an array of jQuery selectors, returns a jQuery object
     * selecting all elements that match the given selectors. 
     */
    selectAll: function(selectors) {
        if (selectors.length > 0) {
            var elements = $(selectors[0]),
                i;
            for (i = 1; i < selectors.length; i++) {
                elements = elements.add(selectors[i]);
            }
            return elements;
        }
        // Return an empty jQuery object if we're given
        // an empty selector
        return $();
    },

    /* ----- JQUERY HELPERS ----- */
    /**
     * Returns true if the given element exists, false otherwise.
     *
     * @param selector {string} the jQuery selector of the element
     */
    elementExists: function(selector) {
        return $(selector).length > 0;
    },

    /**
     * Executes the given function on the jQuery object matched by the given
     * selector if the jQuery object exists. Does nothing otherwise. The return value
     * of this function will be the same as the given function (or undefined if the
     * function is not executed or does not return anything).
     *
     * @param selector {string} jQuery selector 
     * @param fcn {function($obj)} function that accepts a jQuery object as parameter
     * @param context {object} {optional} an optional context object to proxy onto the given
     * function
     */
    ifSelectorExists: function(selector, fcn, context) {
        var $obj = $(selector);
        if ($obj.length) {
            if (context) {
                return $.proxy(fcn, context)($obj);
            } else {
                return fcn($obj);
            }
        }
    },

    /**
     * Given an array of selectors, return the first jQuery object that exists (i.e. length > 0).
     */
    selectExistingElement: function(selectors) {
        return selectors.map(function(s) {
            return $(s);
        }).find(function($e) {
            return $e.length;
        });
    },

    /**
     * Replaces the given attribute
     *
     * @param $obj {jQuery object} the jQuery object to modify the attributes on
     * @param attrName {string} the name of the attribute 
     * @param transform {function} a function that takes the old attribute as argument
     * and returns the new attribute
     */
    replaceAttr: function($obj, attrName, transform) {
        $obj.attr(attrName, transform($obj.attr(attrName)));
    },

    /**
     * Scroll the dom element into view if it's not
     */
    scrollIntoView: function(node) {
        var nodeTop = $(node).offset().top;
        var docViewTop = $(window).scrollTop();
        if (nodeTop < docViewTop) {
            $(node)[0].scrollIntoView(true);
        } else if (nodeTop + $(node).height() > docViewTop + $(window).height()) {
            $(node)[0].scrollIntoView(false);
        }
    },

    /**
     * Binds the given event only once (unbinds all previous instances of this event).
     * 
     * @param $node {jQuery object} the jQuery object to bind the event to 
     * @param eventName {string} the name of the event (e.g. "click" or "keydown")
     * @param namespace {string} namespace for this event, must be unique, otherwise other 
     *                           events with the same namespace will be removed as well
     * @param childSelector {string} {optional} the child selector for this event
     * @param handler {function} the handler for this event
     */
    onOnce: function($node, eventName, namespace, childSelector, handler) {
        var fullEventName = eventName + "." + namespace;
        if (this.isString(childSelector)) {
            $node.off(fullEventName).on(fullEventName, childSelector, handler);
        } else {
            handler = childSelector;
            $node.off(fullEventName).on(fullEventName, handler);
        }

    },

    /**
     * Replaces {obj.attr} param in a string with string specified in an object
     * @param origString {string} original string with param to be replaced
     * @param targObject {object} contains required attributes for the string substitution
     * 
     * Example usage: substituteStringWithObj("<p>{address.city}, {address.postalCode}</p>", {"address": {"city": "toronto", "postalCode": "12345"}}) will return
     * "<p>toronto, 12345</p>"
     */
    substituteStringWithObj: function(origString, targObject) {
        return origString.replace(/{(\w+(\.*\w*)*)}/g, function(match, key) {
            if (typeof targObject !== 'undefined') {
                var subArgs = targObject;
                var subObject = key.substr(0, key.indexOf("."));
                key = key.substr(key.indexOf(".") + 1, key.length);
                while (subObject !== "") {
                    subArgs = subArgs[subObject];
                    subObject = key.substr(0, key.indexOf("."));
                    key = key.substr(key.indexOf(".") + 1, key.length);
                }
                if (key !== "") {
                    subArgs = subArgs[key];
                }

                return typeof subArgs !== 'undefined' ? subArgs : match;
            } else {
                return match;
            }
        });
    },

    /**
     * Replaces {i} param in a string with string specified in substituteMap
     * @param origString the original string that contains {i} to be substitute
     * @param substituteMap a map containing strings to substitute into original string
     * 
     * Example usage: substituteStringWithMap("hi {0}, this is {1}!", {0: "Aurora", 1: "jQuery"}) will return
     * "hi Aurora, this is jQuery!"
     */
    substituteStringWithMap: function(origString, substituteMap) {
        origString = origString.replace(/\{([0-9])\}/g, function(match, key) {
            return substituteMap[key];
        });
        return origString;
    },

    /**
     * Get Localization Messages from nls
     * example: Utils.getLocalizationMessage(message, {0: arg1, 1: arg2})
     */
    getLocalizationMessage: function(message, /* optional*/ params) {
        if (GlobalizeLoaded) {
            return Globalize.formatMessage(message, params);
        }
    },

    /**
     * Get localized currency display
     * example: Utils.formatCurrency("123.4", {
     *                  minimumFractionDigits: 2,
     *                  maximumFractionDigits: 2,
     *                  currency: "USD"
     *          })
     * 
     * @param amount {string}
     * @param options {object} may include currency, minimumFractionDigits, maximumFractionDigits, etc.
     */
    formatCurrency: function(amount, options) {
        amount = amount.replace(/[^0-9\.\,]/g, '');
        if (options) {
            var currency = options["currency"];
            var locale = options["locale"];
        }
        if (!currency) {
            currency = WCParamJS.commandContextCurrency;
        }
        if (GlobalizeLoaded) {
            if (locale) {
                amount = Globalize(locale).parseNumber(amount);
                return Globalize(locale).formatCurrency(amount, currency, options);
            } else {
                amount = Globalize.parseNumber(amount);
                return Globalize.formatCurrency(amount, currency, options);
            }
        }
    },

    /**
     * Parse numbers according to localized information
     * example: Utils.parseNumber("123.4")
     * 
     * @param amount {string}
     */
    parseNumber: function(amount) {
        amount = amount.replace(/[^0-9\.\,]/g, '');
        if (GlobalizeLoaded) {
            return Globalize.parseNumber(amount);
        }
    },

    /**
     * Format numbers according to localized information
     * example: Utils.formatNumber("123.4", {maximumFractionDigits: 2, minimumFractionDigits: 2})
     * 
     * @param amount {string}
     * @param options {object} may include minimumFractionDigits, maximumFractionDigits, etc.
     */
    formatNumber: function(amount, options) {
        amount = amount.replace(/[^0-9\.\,]/g, '');
        if (GlobalizeLoaded) {
            amount = Globalize.parseNumber(amount);
            return Globalize.formatNumber(amount, options);
        }
    },

    /**
     * Returns the locale.
     */
    getLocale: function() {
        return navigator.languages ? navigator.languages[0] : (navigator.language || navigator.userLanguage);
    },

    /**
     * Round the given value to the given number of decimals.
     */
    round: function(value, decimals) {
        return Number(Math.round(value + 'e' + decimals) + 'e-' + decimals);
    },

    /**
     * Converts any value to true/false depending on it's truthy value (e.g. undefined, 0, null 
     * returns false, 1, objects return true). 
     */
    toBoolean: function(value) {
        // First ! converts it to a boolean, second ! reverts the value back (i.e. false to true and
        // vice-versa)
        return !!value;
    },

    /**
     * Returns true if the given array contains the given value, false otherwise.
     */
    arrContains: function(arr, value) {
        return $.inArray(value, arr) !== -1;
    },

    /**
     * Returns true if the given string is not null or white space.
     */
    notNullOrWhiteSpace: function(str) {
        return str !== null && $.trim(str).length !== 0;
    },

    /**
     * Returns the name of the first property in the object that satisfies the given predicate.
     *
     * @param obj a JavaScript Object
     * @param predicate a function that takes two arguments: the property name and property value
     */
    findInObj: function(obj, predicate) {
        var target;
        $(obj).each(function(key, val) {
            if (predicate(key, val)) {
                target = key;
                return false; // breaks out of the each
            }
        });
        return target;
    },

    /**
     * Returns true if the two given elements belong to the same parent. 
     *
     * @param $e1 a jQuery Object representing zero or more elements
     * @param $e2 a jQuery Object representing zero or more elements
     */
    areSiblings: function($e1, $e2) {
        var isSibling = function(e1, e2) {
            return $(e1).siblings().is($(e2));
        };
        if (!arrayUtils.verifyTransitiveProperty($e1, isSibling) || !arrayUtils.verifyTransitiveProperty($e2, isSibling)) {
            return false;
        } else if (arrayUtils.isEmpty($e1) || arrayUtils.isEmpty($e2)) {
            return true;
        } else {
            return isSibling(arrayUtils.last($e1), $e2[0]);
        }
    },

    /**
     * Returns true if the given elements are the same parent element.
     *
     * @param jqObj a jQuery object representing elements
     */
    sameParent: function(jqObj) {},

    /**
     * Return a property from a dot-separated string, such as "A.B.C"
     *
     * @param name: {string} path to an property, in the form "A.B.C"
     */
    getObject: function(name) {
        if (name === "") return;

        var nameArray = name.split(".");
        var result = window[nameArray[0]];

        for (i = 1; i < nameArray.length; i++) {
            if (!result) break;
            result = result[nameArray[i]];
        }

        return result;
    },

    /**
     * Return a property from a dot-separated string, such as "A.B.C"
     *
     * @param name: {string} path to an property, in the form "A.B.C"
     */
    idExists: function() {
        if (arguments.length === 0) {
            console.warn("No arguments passed to idExists");
            return true;
        }
        for (var i = 0; i < arguments.length; i++) {
            if (!$(arguments[i].length)) {
                return false;
            }
        }
        return true;
    },

    /**
     * Call a function after the original function returns
     *
     * @param srcObj: {string} source object of the original function
     * @param oldFunc: {string} original function name
     * @param callback: {function} the function will be called afterwards
     */
    aop_after: function(srcObj, oldFunc, callback) {
        var old = $.proxy(srcObj[oldFunc], srcObj);
        srcObj[oldFunc] = function() {
            old.apply(this, arguments);
            return callback(arguments);
        }
    },

    /**
     * Replaces ${i} param in a string with string specified in substituteMap
     * param origString the original string that contains ${i} to be substitute
     * param substituteMap a map containing strings to substitute into original string
     * example usage: substituteString("hi ${0}, this is ${1}!", {0: "Aurora", 1: "jQuery"}) will return
     * "hi Aurora, this is jQuery!"
     */
    substituteString: function(origString, substituteMap) {
        origString = origString.replace(/\$\{([0-9])\}/g, function(match, key) {
            return subsMap[key];
        });
        return origString;
    }
};//-----------------------------------------------------------------
// Licensed Materials - Property of IBM
//
// WebSphere Commerce
//
// (C) Copyright IBM Corp. 2016 All Rights Reserved.
//
// US Government Users Restricted Rights - Use, duplication or
// disclosure restricted by GSA ADP Schedule Contract with
// IBM Corp.
//-----------------------------------------------------------------


/**
 * @fileOverview This file provides the functions needed by a refresh area
 */

jQuery(document).ready(function($) {
    $.widget("wc.refreshWidget", {
        url: undefined,
        ariaMessage: undefined,
        ariaLiveId: undefined,

        // default options
        options: {
            formId: undefined,
            renderContextChangedHandler: null,
            postRefreshHandler: null
        },
        _create: function() {
            if (this.element.attr("refreshurl")) {
                this.url = this.element.attr("refreshurl");
            }
            if (!this.url) {
                console.warn("Warning: refreshurl is not defined for refresh area: " + this.element.attr("id"));
            }
            if (this.element.attr("wcType") !== "RefreshArea") {
                console.error("Error: wcType is not set to 'RefreshArea' for refresh area: " + this.element.attr("id"));
            }
            if (!this.element.attr("declareFunction")) {
                console.error("Error: declareFunction is not set for refresh area: " + this.element.attr("id"));
            }
            if (this.element.attr("ariaMessage")) {
                this.ariaMessage = this.element.attr("ariaMessage");
            }
            if (this.element.attr("ariaLiveId")) {
                this.ariaMessage = this.element.attr("ariaLiveId");
            }
        },
        updateUrl: function(newURL) {
            this.url = newURL;
        },
        updateFormId: function(newFormId) {
            this.options.formId = newFormId;
        },
        refresh: function(parameters) {
            var domNode = this.element;
            var widget = this;

            //Obtain refreshurl which is defined in controller
            if (!this.url && this.element.attr("refreshurl")) {
                this.url = this.element.attr("refreshurl");
            }

            var formNode = null;
            if (this.options.formId) {
                formNode = $("#" + this.options.formId);
            }

            if (parameters) {
                if (!parameters.requesttype) {
                    parameters.requesttype = 'ajax';
                }
            } else {
                parameters = {requesttype: 'ajax'};
            }

            if (!this.url) {
                console.error("refreshurl is not specified for refresh area: " + domNode.attr("id"));
                return;
            }

            //Remove all instances of "amp;" in the URL which was added on the JSP by c:out
            this.url = this.url.replace(/amp;/g, "");

            var mergedParameters = parameters;

            if(typeof wcCommonRequestParameters === "object"){
                mergedParameters = {};
                $.extend(mergedParameters, parameters);

                for(var parameterName in wcCommonRequestParameters){
                    if(!this._isParameterExcluded(this.url, parameterName)){
                        mergedParameters.parameterName = wcCommonRequestParameters.parameterName;
                    } else {
                        console.debug("parameter " + parameterName + " is excluded");
                    }
                }
            }

            // deal with javascript array problem - convert to proper key/value pairs required by jquery Ajax
            if ($.isArray(mergedParameters)) {
                var keyValuePairs = {};
                for (var paramKey in mergedParameters) {
                    if ($.isArray(mergedParameters[paramKey])) {
                        if (mergedParameters[paramKey].length > 0) {
                            keyValuePairs[paramKey] = mergedParameters[paramKey];
                        }
                    } else {
                        keyValuePairs[paramKey] = mergedParameters[paramKey];
                    }
                }
                mergedParameters = keyValuePairs;
                console.debug("mergedParameters after modifying = " + JSON.stringify(mergedParameters));
            }

            var failureHandler = function(data, status) {
                console.error("failed to refresh widget " + domNode.attr("id"));
                wcTopic.publish("ajaxRequestCompleted");
            }

            var successHandler = function(data, status) {
                function getIds(idType, controllerURL) {
                    var myId = "";
                            if (mergedParameters && mergedParameters[idType]) {
                                    myId = mergedParameters[idType];
                    }
                    if (myId === "" && formNode != null && formNode[idType]) {
                        myId = formNode[idType];
                        if (formNode[idType].value != null) {
                            myId = formNode[idType].value;
                        }
                    }
                    if (myId === "" && controllerURL) {
                        var temp = controllerURL;
                        if (temp.indexOf(idType) !== -1) {
                            temp = temp.substring(temp.indexOf(idType));
                            var tokens = temp.split("&");
                            var tokens2 = tokens[0].split("=");
                            myId = tokens2[1];
                        }
                    }
                    return myId;
                }
                function parseJsonCommentFiltered(str){
                    str = str.replace('\/\*', '');
                    str = str.replace('\*\/', '');
                    var json = eval('(' + str + ')');
                    return json;
                }

                // determine storeId, catalogId and langId to use in our redirect url
                var storeId = getIds("storeId", widget.url);
                var catalogId = getIds("catalogId", widget.url);
                var langId = getIds("langId", widget.url);
                var errorCodeBegin = data.indexOf('errorCode');

                function serverErrorHandler(errorCode) {
                    console.debug('error condition encountered - error code: ' + errorCode);
                    // error code: ERR_DIDNT_LOGON
                    // This error code is returned in the scenario where logon is required and user is not logged on
                    if (errorCode.indexOf('2550') !== -1) {
                        console.debug('error type: ERR_DIDNT_LOGON - the customer did not log on to the system.');
                        console.debug("redirecting to URL: AjaxLogonForm?storeId=" + storeId + "&catalogId=" + catalogId + "&langId=" + langId + '&myAcctMain=1');
                        document.location.href = "AjaxLogonForm?storeId=" + storeId + "&catalogId=" + catalogId + "&langId=" + langId + '&myAcctMain=1';
                    }

                    // error code: ERR_SESSION_TIMEOUT
                    // This error code is returned in the scenario where user's logon session has timed out
                    else if (errorCode.indexOf('2510') !== -1) {
                        //redirect to a full page for sign in
                        console.debug('error type: ERR_SESSION_TIMEOUT - use session has timed out');
                        var serviceResponse = parseJsonCommentFiltered(data);
                        var timeoutURL = "Logoff?";
                        if (serviceResponse.exceptionData.isBecomeUser == 'true') {
                            timeoutURL = "RestoreOriginalUserSetInSession?URL=Logoff&";
                        }
                        if (serviceResponse.exceptionData.rememberMe == 'true'){
                            var myURL = timeoutURL + 'rememberMe=true&storeId=' + storeId + "&catalogId=" + catalogId + "&langId=" + langId;
                            console.debug('try to logoff, get URL='+myURL);
                            $.ajax({
                                type: "GET",
                                url: myURL,
                                data: mergedParameters,
                                success: function(data, status) {
                                  console.debug('User logged off. Reload current page to avoid data inconsistence...');
                                  document.location.reload();
                                },
                                error: function(data) {
                                    // failed to logoff, directly go to relogon form;
                                    // this should not happen, just in case.
                                    document.location.href = 'ReLogonFormView?rememberMe=true&storeId='+storeId;
                                }
                            });
                        }
                        else {
                            console.debug('redirecting to URL: ' + timeoutURL + 'URL=ReLogonFormView&storeId=' + storeId);
                            document.location.href = timeoutURL + 'URL=ReLogonFormView&storeId=' + storeId;
                        }
                    }

                    // error code: ERR_PROHIBITED_CHAR
                    // This error code is returned in the scenario where user has entered prohibited character(s) in the request
                    else if (errorCode.indexOf('2520') !== -1) {
                        console.debug('error type: ERR_PROHIBITED_CHAR - detected prohibited characters in request');
                        console.debug("redirecting to URL: ProhibitedCharacterErrorView?storeId=" + storeId + "&catalogId=" + catalogId + "&langId=" + langId);
                        document.location.href = "ProhibitedCharacterErrorView?storeId=" + storeId + "&catalogId=" + catalogId + "&langId=" + langId;
                    }

                    // error code: ERR_CSRF
                    // This error code is returned in the scenario where a cross-site request forgery attempt was caught
                    else if (errorCodeString.indexOf('2540') !== -1) {
                        console.debug('error type: ERR_CSRF - cross site request forgery attempt was detected');
                        console.debug("redirecting to URL: CrossSiteRequestForgeryErrorView?storeId=" + storeId + "&catalogId=" + catalogId + "&langId=" + langId);
                        document.location.href = "CrossSiteRequestForgeryErrorView?storeId=" + storeId + "&catalogId=" + catalogId + "&langId=" + langId;
                    }

                    // error code: _ERR_INVALID_COOKIE
                    // This error code is returned in the scenario where a cookie error occurs
                    else if (errorCodeString.indexOf('CMN1039E') !== -1) {
                        console.debug('error type: _ERR_INVALID_COOKIE - cookie error was detected');
                        console.debug("redirecting to URL: CookieErrorView?storeId=" + storeId + "&catalogId=" + catalogId + "&langId=" + langId);
                        document.location.href = "CookieErrorView?storeId=" + storeId + "&catalogId=" + catalogId + "&langId=" + langId;
                    }
                }

                if (errorCodeBegin != -1) {
                    // error code returned, get error code and handle error condition
                    var errorCodeEnd = data.indexOf(',', errorCodeBegin);
                    var errorCodeString = data.substring(errorCodeBegin, errorCodeEnd);
                    serverErrorHandler(errorCodeString);
                } else {
                    // no error from get request, refresh area and call post refresh controller
                    domNode.html(data);
                    WCWidgetParser.parse(domNode);
                    if (widget.options.postRefreshHandler != null) {
                        widget.options.postRefreshHandler(widget.element);
                    }
                }
                wcTopic.publish("ajaxRequestCompleted");
                widget._updateLiveRegion();
            }

            var ajaxParams = {
                data: (formNode)? formNode.serialize()+"&"+$.param(mergedParameters) : mergedParameters,
                url: this.url,
                type: "POST",
                traditional: true,
                success: successHandler,
                error: failureHandler
            };

            $.ajax(ajaxParams);
        },

        renderContextChanged: function(refreshAreaDiv) {
            if (this.options.renderContextChangedHandler != null) {
                this.options.renderContextChangedHandler(refreshAreaDiv);
            }
        },

        _updateLiveRegion: function () {
            $("#" + this.ariaLiveId + "_ACCE_Label").css("display", "block");

            if (this.ariaMessage !== "" && this.ariaLiveId !== "") {
                var messageNode = document.createTextNode(this.ariaMessage);
                var liveRegionNode = document.getElementById(this.ariaLiveId);
                if (liveRegionNode) {
                    while (liveRegionNode.firstChild) {
                        liveRegionNode.removeChild(liveRegionNode.firstChild);
                    }
                    liveRegionNode.appendChild(messageNode);
                }
            }
        }

    });

}(jQuery));



//-----------------------------------------------------------------
// Licensed Materials - Property of IBM
//
// WebSphere Commerce
//
// (C) Copyright IBM Corp. 2016 All Rights Reserved.
//
// US Government Users Restricted Rights - Use, duplication or
// disclosure restricted by GSA ADP Schedule Contract with
// IBM Corp.
//-----------------------------------------------------------------

wcRenderContext={
    contextArray: {},

    getRefreshAreaIds: function(id) {
        if (!this.checkIdDefined(id)) {
            console.error("wcRenderContext.getRefreshAreaIds: Common render context " + id + " is not defined");
            return;
        }
        return this.contextArray[id]["refreshAreaIds"];
    },

    getRenderContextProperties: function(id) {
        if (!this.checkIdDefined(id)) {
            console.error("wcRenderContext.getRenderContextProperties: Common render context " + id + " is not defined");
            return;
        }
        return this.contextArray[id]["contextProperties"];
    },

    addRefreshAreaId: function(id, refreshAreaId) {
        if (!this.checkIdDefined(id)) {
            console.error("wcRenderContext.addRefreshAreaId: Common render context " + id + " is not defined");
            return;
        }
        if (!Utils.arrContains(this.contextArray[id]["refreshAreaIds"], refreshAreaId)) {
            this.contextArray[id]["refreshAreaIds"].push(refreshAreaId);
        }        
    },

    declare: function(id, refreshAreaIds, initialProperties) {
        // create new context obj and add to contextArray
        if (this.checkIdDefined(id)) {
            console.error("Common render context with id =  " + id + " already exits.Please use a different id");
            return;
        } else if (!$.isArray(refreshAreaIds)) {
            console.error("refresh area ids should be an array, got: " + refreshAreaIds);
            return;
        }
        
        // if initial property is empty, create an empty object
        if (initialProperties === "") {
            initialProperties = {};
        }
        
        var context = {
            "id": id,
            "refreshAreaIds": refreshAreaIds,
            "contextProperties": initialProperties,
            // The current render context properties. This object is used to determine what properties have
            // actually changed since the last time a render context changed event was detected.
            "currentRCProperties": {}
        };
        this.contextArray[id] = context;
        this._syncRCProperties(id);
    },

    updateRenderContext: function(id, properties) {
        if (!this.checkIdDefined(id)) {
            console.error("wcRenderContext.updateRenderContext: Common render context " + id + " is not defined");
            return;
        }

        var curRenderContext = this.getRenderContextProperties(id);
        for (var name in properties) {
            var value = properties[name];
            if (value != curRenderContext[name]) {
                //contextChanged = true;

                if (Utils.isUndefined(value)) {
                    delete curRenderContext[name];
                } else {
                    curRenderContext[name] = value;
                }
            }
        }

        var curRefershAreas = this.getRefreshAreaIds(id);
        $.each(curRefershAreas, function(i, refreshDivId) {
            var refreshAreaDiv = $("#" + refreshDivId);
            refreshAreaDiv.refreshWidget("renderContextChanged", refreshAreaDiv);
        });
        
        wcTopic.publish(id + "/RenderContextChanged", {actionId: id + "/RenderContextChanged"});

        this._syncRCProperties(id);
    },

    testForChangedRC: function(id, propertyNames) {
        var change = false;
        for (var i = 0; i < propertyNames.length; i++) {
            var prop = propertyNames[i];
            if (this.contextArray[id]["currentRCProperties"][prop] != this.contextArray[id]["contextProperties"][prop]) {
                change = true;
                break;
            }
        }
        return change;
    },

    checkIdDefined: function(id) {
        return Utils.toBoolean(this.contextArray[id]);
    },

    _syncRCProperties: function(id) {        
        var rc = this.getRenderContextProperties(id),
            properties = $.extend({}, rc); // shallow copy
        this.contextArray[id]["currentRCProperties"] = properties;
    }
};



//-----------------------------------------------------------------
// Licensed Materials - Property of IBM
//
// WebSphere Commerce
//
// (C) Copyright IBM Corp. 2016 All Rights Reserved.
//
// US Government Users Restricted Rights - Use, duplication or
// disclosure restricted by GSA ADP Schedule Contract with
// IBM Corp.
//-----------------------------------------------------------------


/**
 * @fileOverview This file provides the functions needed to declare and invoke a service in Commerce
 */

(function($) {
    $.wcServicePlugin = function(options) {
        var settings = $.extend({
            id: undefined,
            actionId: undefined,
            url: undefined,
            formId: undefined,
            successHandler: undefined,
            failureHandler: undefined
        }, options);

        var validateParameters = function(parameters) {
            return true;
        };

        var validateForm = function(formNode) {
            return true;
        }

        var successTest = function(serviceResponse) {
            return !serviceResponse.errorMessage && !serviceResponse.errorMessageKey;
        };

        var _isParameterExcluded = function(url, parameterName){
            try{
                if(typeof URLConfig === 'object'){
                    if (typeof URLConfig.excludedURLPatterns === 'object'){
                        for (var urlPatternName in URLConfig.excludedURLPatterns){
                            var exclusionConfig = URLConfig.excludedURLPatterns[urlPatternName];
                            var urlPattern = urlPatternName;
                            if(typeof exclusionConfig === 'object'){
                                if(exclusionConfig.urlPattern){
                                    urlPattern = exclusionConfig.urlPattern;
                                }
                                console.debug("URL pattern to match : " + urlPattern);
                                urlPattern = new RegExp(urlPattern);

                                if(url.match(urlPattern)){
                                    var excludedParametersArray = exclusionConfig.excludedParameters;
                                    for(var excludedParameter in excludedParametersArray){
                                        if(parametername == excludedParameter){
                                            return true;
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        console.debug("The parameter " + parameterName + " is not excluded");
                    }
                } else {
                    console.debug("No URLConfig defined.")
                }
            } catch (err){
                console.debug("An error occured while trying to exclude " + err);
            }
            return false;
        }

        var output = {
            'setFormId': function(formId) {
                settings.formId = formId;
            },
            'setActionId': function(actionId) {
                settings.actionId = actionId;
            },
            'setUrl': function(url) {
                settings.url = url;
            },
            'setParam': function(paramName, value) {
            	settings[paramName] = value;
            },
            'getParam': function(paramName) {
                return settings[paramName];
            },
            'invoke': function(parameters) {
                var valid = true;
                var formNode = null;
                if (settings.formId) {
                    formNode = $("#" + settings.formId);
                }

                if (formNode) {
                    valid = validateForm(formNode);
                }

                if (valid) {
                    valid = validateParameters(parameters);
                }

                function addAuthToken(parameters){
                    try{
                        if ($("#csrf_authToken").length){
                            parameters["authToken"] = $("#csrf_authToken").val();
                        } else {
                            console.debug("auth token is missing from the HTML DOM");
                        }
                        return true;
                    } catch (err){
                        console.debug("An error occured while trying to add authToken to request " + err);
                    }
                    return false;
                }


                if (parameters) {
                    if (!parameters.requesttype) {
                        parameters.requesttype = 'ajax';
                    }
                } else {
                    parameters = {};
                    parameters.requesttype = 'ajax';
                }

                addAuthToken(parameters);

                var mergedParameters = parameters;
                if(typeof wcCommonRequestParameters === 'object'){
                    mergedParameters = {};
                    $.extend(mergedParameters, parameters);

                    for(var parameterName in wcCommonRequestParameters){
                        if(!_isParameterExcluded(this.url, parameterName)){
                            mergedParameters.parameterName = wcCommonRequestParameters.parameterName;
                        } else {
                            console.debug("parameter " + parameterName + " is excluded");
                        }
                    }
                }

                // deal with javascript array problem - convert to proper key/value pairs required by jquery Ajax
                if ($.isArray(mergedParameters)) {
                    var keyValuePairs = {};
                    for (var paramKey in mergedParameters) {
                        if ($.isArray(mergedParameters[paramKey])) {
                            if (mergedParameters[paramKey].length > 0) {
                                keyValuePairs[paramKey] = mergedParameters[paramKey];
                            }
                        } else {
                            keyValuePairs[paramKey] = mergedParameters[paramKey];
                        }
                    }
                    mergedParameters = keyValuePairs;
                    console.debug("mergedParameters after modifying = " + JSON.stringify(mergedParameters));
                }

                var successHandler = function(serviceResponse, status) {
                    function getIds(idType, controllerURL) {
                        var myId = "";
                        if (mergedParameters && mergedParameters[idType]) {
                            myId = mergedParameters[idType];
                        }
                        if (myId == "" && formNode != null && formNode[idType]) {
                            myId = formNode[idType];
                            if (formNode[idType].value != null) {
                                myId = formNode[idType].value;
                            }
                        }
                        if (myId == "" && controllerURL) {
                            var temp = controllerURL;
                            if (temp.indexOf(idType) != -1) {
                                temp = temp.substring(temp.indexOf(idType));
                                var tokens = temp.split("&");
                                var tokens2 = tokens[0].split("=");
                                myId = tokens2[1];
                            }
                        }
                        return myId;
                    }

                    // determine storeId, catalogId and langId to use in our redirect url
                    var storeId = getIds("storeId", settings.url);
                    var catalogId = getIds("catalogId", settings.url);
                    var langId = getIds("langId", settings.url);

                    function serverErrorHandler(errorCode) {
                        // error code: ERR_USER_NOT_LOGGED_ON
                        // This error code is returned in the scenario where logon is required and user is not logged on
                        if (errorCode == '2500') {
                            var myURL = serviceResponse.originatingCommand;
                            myURL = myURL.replace('?', '%3F');
                            myURL = myURL.replace(/&amp;/g, '%26');
                            myURL = myURL.replace(/&/g, '%26');
                            myURL = myURL.replace(/=/g, '%3D');

                            myURL = 'LogonForm?nextUrl=' + myURL + "&storeId=" + storeId + "&catalogId=" + catalogId + "&langId=" + langId + '&myAcctMain=1';
                            console.debug('error type: ERR_USER_NOT_LOGGED_ON - only registered user can invoke the command');
                            console.debug('redirecting to URL: ' + myURL);
                            document.location.href = myURL;
                        }

                        // error code: ERR_DIDNT_LOGON
                        // This error code is returned in the scenario where logon is required and user is not logged on
                        else if (errorCode == '2550') {
                            var myURL = serviceResponse.originatingCommand;
                            myURL = myURL.replace('?', '%3F');
                            myURL = myURL.replace(/&amp;/g, '%26');
                            myURL = myURL.replace(/&/g, '%26');
                            myURL = myURL.replace(/=/g, '%3D');
                            myURL = 'AjaxLogonForm?nextUrl=' + myURL + "&storeId=" + storeId + "&catalogId=" + catalogId + "&langId=" + langId + '&myAcctMain=1';
                            console.debug('error type: ERR_DIDNT_LOGON - the customer did not log on to the system.');
                            console.debug('redirecting to URL: ' + myURL);
                            document.location.href = myURL;
                        }

                        // error code: ERR_PASSWORD_REREQUEST
                        // This error code is returned in the scenario where password is required to proceed
                        else if (errorCode == '2530') {
                            var myURL = serviceResponse.originatingCommand;
                            myURL = myURL.replace('?', '%3F');
                            myURL = myURL.replace(/&amp;/g, '%26');
                            myURL = myURL.replace(/&/g, '%26');
                            myURL = myURL.replace(/=/g, '%3D');
                            myURL = 'PasswordReEnterErrorView?nextUrl=' + myURL + "&storeId=" + storeId + "&catalogId=" + catalogId + "&langId=" + langId;
                            console.debug('error type: ERR_PASSWORD_REREQUEST - password is required');
                            console.debug('redirecting to URL: ' + myURL);
                            document.location.href = myURL;
                        }

                        // error code: ERR_SESSION_TIMEOUT
                        // This error code is returned in the scenario where user's logon session has timed out
                        else if (errorCode == '2510') {
                            //redirect to a full page for sign in
                            console.debug('error type: ERR_SESSION_TIMEOUT - use session has timed out');
                            var timeoutURL = "Logoff?";
                            if (serviceResponse.exceptionData.isBecomeUser == 'true') {
                                timeoutURL = "RestoreOriginalUserSetInSession?URL=Logoff&";
                            }
                            if (serviceResponse.exceptionData.rememberMe == 'true'){
                                var myURL = timeoutURL + 'rememberMe=true&storeId=' + storeId + "&catalogId=" + catalogId + "&langId=" + langId;
                                console.debug('try to logoff, get URL='+myURL);

                                $.ajax({
                                    type: "GET",
                                    url: myURL,
                                    data: mergedParameters,
                                    success: function(data, status) {
                                      console.debug('User logged off. Reload current page to avoid data inconsistence...');
                                      document.location.reload();
                                    },
                                    error: function(data) {
                                        // failed to logoff, directly go to relogon form;
                                        // this should not happen, just in case.
                                        document.location.href = 'ReLogonFormView?rememberMe=true&storeId='+storeId;
                                    }
                                })
                            } else {
                                console.debug('redirecting to URL: ' + timeoutURL + 'URL=ReLogonFormView&storeId=' + storeId);
                                document.location.href = timeoutURL + 'URL=ReLogonFormView&storeId=' + storeId;
                            }
                        }

                        // error code: ERR_PROHIBITED_CHAR
                        // This error code is returned in the scenario where user has entered prohibited character(s) in the request
                        else if (errorCode == '2520') {
                            console.debug('error type: ERR_PROHIBITED_CHAR - detected prohibited characters in request');
                            console.debug("redirecting to URL: " + "ProhibitedCharacterErrorView?storeId=" + storeId + "&catalogId=" + catalogId + "&langId=" + langId);
                            document.location.href = "ProhibitedCharacterErrorView?storeId=" + storeId + "&catalogId=" + catalogId + "&langId=" + langId;
                        }

                        // error code: ERR_CSRF
                        // This error code is returned in the scenario where a cross-site request forgery attempt was caught
                        else if (errorCode == '2540') {
                            console.debug('error type: ERR_CSRF - cross site request forgery attempt was detected');
                            console.debug("redirecting to URL: " + "CrossSiteRequestForgeryErrorView?storeId=" + storeId + "&catalogId=" + catalogId + "&langId=" + langId);
                            document.location.href = "CrossSiteRequestForgeryErrorView?storeId=" + storeId + "&catalogId=" + catalogId + "&langId=" + langId;
                        }

                        // error code: _ERR_INVALID_COOKIE
                        // This error code is returned in the scenario where a cookie error occurs
                        else if (errorCode == 'CMN1039E') {
                            console.debug('error type: _ERR_INVALID_COOKIE - cookie error was detected');
                            console.debug("redirecting to URL: " + "CookieErrorView?storeId=" + storeId + "&catalogId=" + catalogId + "&langId=" + langId);
                            document.location.href = "CookieErrorView?storeId=" + storeId + "&catalogId=" + catalogId + "&langId=" + langId;
                        }

                        else if (settings.failureHandler) {
							console.debug('calling service.failureHandler');
							settings.failureHandler(serviceResponse, status);
                        }
                        wcTopic.publish("ajaxRequestCompleted");
                    }

                    // debugging statement
                    console.debug("response from ajax call:");
                    for (var prop in serviceResponse) {
                        console.debug("  " + prop + "=" + serviceResponse[prop]);
                    }

                    if (successTest(serviceResponse)) {
                        if (settings.successHandler) {
                            var reqData = $(this).attr('data');
                            reqData = reqData?JSON.parse('{"' + reqData.replace(/&/g, '","').replace(/=/g,'":"') + '"}',
                                function(key, value) { return key===""?value:decodeURIComponent(value) }):{}
                            settings.successHandler(serviceResponse, reqData);

                            console.debug("success: publishing modelChanged event")
                        }
						if (settings.actionId) {
							console.debug('triggering action: ' + settings.actionId);
							wcTopic.publish(settings.actionId, {actionId: settings.actionId, data:serviceResponse});
						}
                    }
					else {
                        // error returned from server
                        console.debug('error condition encountered - error code: ' + serviceResponse.errorCode);
                        serverErrorHandler(serviceResponse.errorCode);
                    }
                };

                // when the AJAX method returns failed status
                var failureHandler = function(serviceResponse, status) {
                    console.debug("Warning: communication error while making the service call"); // Communication error.
                    var message = serviceResponse.errorMessage;
                    if (message) {
                        alert(message);
                    }
                    else {
                        message = serviceResponse.errorMessageKey;
                        if (message) {
                            alert(message);
                        }
                        else {
                            alert("Service request error.");
                        }
                    }
                };

                console.debug("service formId = " + settings.formId);

                if (!valid) return;

                wcTopic.publish("ajaxRequestInitiated");

                var stripComment = function(str, startString, endString) {
                    // remove <startString> <endString> pair. e.g. <!-- and -->
                    var beginIndex = str.indexOf(startString);
                    var endIndex = -1;
                    var part1 = "";
                    var part2 = "";
                    if (beginIndex != -1) {
                        endIndex = str.indexOf(endString);
                    }
                    if (endIndex != -1) {
                        part1 = str.substr(0,beginIndex);
                        part2 = str.substr(endIndex + endString.length);
                        str = part1 + part2;
                    }
                    // removes comments recursively
                    if (str.indexOf(startString) != -1) {
                        str = stripComment(str, startString, endString);
                    }
                    return str;
                };

                var ajaxParams = {
                    url: settings.url,
                    type: "POST",
                    data: (formNode)? formNode.serialize()+"&"+$.param(mergedParameters,true) : mergedParameters,
                    traditional: true,
                    dataFilter: function (str) {
                        // remove /* */ pair
                        str = str.replace('\/\*', '');
                        str = str.replace('\*\/', '');

                        if (str.indexOf("<!--") != -1) {
                            str = stripComment(str, "<!--", "-->");
                        }

                        if (str.indexOf("<%--") != -1) {
                            str = stripComment(str, "<%--", "--%>");
                        }

                        var json = eval('(' + str + ')');
                        return json;
                    },
                    success: successHandler,
                    error: failureHandler
                };

                $.ajax(ajaxParams);
            }

        };

        return output;
    }
}(jQuery));


wcService={
    wcServices: {},

    getServiceById:function(serviceId) {
        return this.wcServices[serviceId];
    },

    declare: function(initProperties) {
        if (!initProperties.id) {
            return;
        }
        this.wcServices[initProperties.id] = $.wcServicePlugin(initProperties);
    },

    invoke: function(serviceId, parameters) {
        var service = this.getServiceById(serviceId);
        if (service) {
            service.invoke(parameters);
        }
        else {
            console.error("Attempt to invoke an unregistered service: " + serviceId);
        }
    }
}


//-----------------------------------------------------------------
// Licensed Materials - Property of IBM
//
// WebSphere Commerce
//
// (C) Copyright IBM Corp. 2016 All Rights Reserved.
//
// US Government Users Restricted Rights - Use, duplication or
// disclosure restricted by GSA ADP Schedule Contract with
// IBM Corp.
//-----------------------------------------------------------------
/* global Utils, document, jQuery */

var WCWidgetParser;
(function ($) {
    WCWidgetParser = WCWidgetParser || {
        widgetDefinitions: {
            // jQuery UI Widgets
            dialog: {
                fcnName: "Dialog"
            },
            autocomplete: {
                fcnName: "autocomplete"
            },
            tabs: {
                fcnName: "tabs"
            },
            datepicker: {
                fcnName: "datepicker",
                defaultOptions: {
                    showOtherMonths: true,
                    changeYear: true,
                    dayNamesMin: ['S', 'M', 'T', 'W', 'T', 'F', 'S'],
                    altFormat: "yy-mm-dd",
                    dateFormat: "mm/dd/yy"
                }
            },
            // Custom widgets
            "wc.WCDialog": {
                fcnName: "WCDialog"
            }, 
            "wc.Carousel": {
                fcnName: "Carousel"
            },
            "wc.Grid": {
                fcnName: "Grid"
            },
            "wc.tooltip": {
                fcnName: "wcToolTip"
            },
            "wc.Select": {
                fcnName: "Select"
            },
            "wc.ValidationTextbox": {
                fcnName: "ValidationTextbox"
            }
        },

        /*
        */
        _parse_widget: function ($element, widgetName, htmlOptions) {
            var entry = this.widgetDefinitions[widgetName];
            if (!entry) {
                console.error("Widget type: " + widgetName + " not registered");
                return;
            }
            
            var fcn_name = entry.fcnName,
                default_options = entry.default_options || {};
            htmlOptions = htmlOptions || {};
            
            if (Utils.isObject(htmlOptions) || $.isArray(htmlOptions)) {
                /*
                Grab options declared in the html (if any). Merge it with the passed in 
                default_options (if any). The options declared in the html takes higher precedence
                than the given default_options. I.e.
                If these options where declared in the html:
                {
                    abc: 123,
                    efg: 456
                }
                These were the default options:
                {
                    abc: 789,
                    hij: 567
                }
                Then this would be passed to widget constructor:
                {
                    abc: 123, // from options declared in the html, which overwrites the default options
                    efg: 456, // from options declared in the html
                    hij: 567 // from the default options
                }
                */
                var options = $.extend({}, default_options, htmlOptions);
                if ($element[fcn_name]) {
                    $element[fcn_name](options);
                } else {
                    console.error("Function: " + fcn_name + " does not exist");
                }
                
                
            } else {
                $element[fcn_name](default_options);
                console.error("The given html option is neither an Object nor an array (the default options will be used instead): " + htmlOptions);
            }
        },

        /*
         * Declare widget in html like so:
         * <div data-widget-type="declare_name" />
         *
         * @param context the DOM Node to parse under, can be undefined in which case the entire page is
         *                parsed
         */
        parse: function (context) {
            // An array of Objects, each Object has the following fields:
            // element: the jQuery element to parse
            // widgetName: the name of the widget (specified by the "widget-type" data field)
            // widgetOptions: the options passed to the widget, if any (specified by the "widget-options"
            //                data field)
            var widgetsToParse = [];
            $("[data-widget-type]", context).each($.proxy(function (i, element) {
                var $element = $(element),
                    widgetName = $element.data("widget-type"),
                    widgetOptions = $element.data("widget-options");

                if ($.isArray(widgetName)) { // Multiple widgets defined
                    if (Utils.varExists(widgetOptions) && !$.isArray(widgetOptions)) {
                        console.error("widgetName is an array but widgetOptions is not: " + widgetOptions);

                    } else if (widgetName.length !== widgetOptions.length) {
                        console.error("widgetName and widgetOptions have different lengths");

                    } else {
                        widgetName.forEach(function (name, i) {
                            widgetsToParse.push({
                                element: $element,
                                widgetName: name,
                                widgetOptions: widgetOptions[i]
                            });                          
                        });
                    }

                } else {
                    widgetsToParse.push({
                        element: $element,
                        widgetName: widgetName,
                        widgetOptions: widgetOptions
                    });                    
                }
            }, this));
            
            var sortByParseOrder = function(w1, w2) {
                if (w1.widgetOptions && w1.widgetOptions.parseOrder) {
                    if (w2.widgetOptions && w2.widgetOptions.parseOrder) {
                        return w1.widgetOptions.parseOrder - w2.widgetOptions.parseOrder;
                    } else {
                        // Only w1 has parseOrder specified
                        return -1; 
                    }
                } else if (w2.widgetOptions && w2.widgetOptions.parseOrder) {
                    // Only w2 has parseOrder specified
                    return 1;
                } else {                    
                    // Neither has parseOrder defined, stable sort will leave the elements
                    // in the order they appear in the original array
                    return 0; 
                }
            },
                sortByVisibility = function(w1, w2) {
                    if (w1.element.is(":visible")) {
                        if (w2.element.is(":visible")) {
                            // Both visible
                            return 0;
                        } else {
                            // Only w1 visible
                            return -1;
                        }
                    } else if (w2.element.is(":visible")) {
                        // Only w2 is visible
                        return 1;
                    } else {
                        // Both not visible
                        return 0;
                    }
                };
            
            
            // Sorts widgets by their parseOrder, the widget with the lower parseOrder will be
            // parsed first. If the parseOrder is unspecified, then just parse in the order in
            // which they appeared in the array (i.e. stable sort).
            widgetsToParse = arrayUtils.stableSort(widgetsToParse, function(w1, w2) {
                var result = sortByParseOrder(w1, w2);
                if (result === 0) {
                    result = sortByVisibility(w1, w2);
                }
                return result;
            });
            $.each(widgetsToParse, $.proxy(function(i, widgetToParse) {
                this._parse_widget(widgetToParse.element, widgetToParse.widgetName, widgetToParse.widgetOptions);
            }, this));
        },
        
        /** 
        * @param context the DOM Node to parse under, can be undefined in which case the entire page is
         *                parsed
         */
        parseRefreshArea: function(context) {
            $("[wcType='RefreshArea']", context).each(function (i, e) {
                var declareFunc = $(e).attr("declareFunction");
                
                // find out namepace, function name and params to the function call
                var nameSpace, functionName, argArray = null;
                
                if (declareFunc) {
                    var indexDot = declareFunc.indexOf(".");
                    if (indexDot > 0) {
                        nameSpace = declareFunc.substr(0, indexDot);
                    }
                    var indexFunc = declareFunc.indexOf("(");
                    if (indexFunc > 0) {
                        functionName = declareFunc.substr(indexDot+1, indexFunc-indexDot-1);
                        var argString = declareFunc.slice(indexFunc+1, declareFunc.length-1);
                        // trim single quote, double quote and spaces
                        argString = argString.replace(/"/g, "").replace(/'/g, "").replace(/ /g, "");
                        argArray = argString.split(",");
                    } else {
                        functionName = declareFunc.substr(indexDot+1);
                    }
                }
               
                if (functionName) {
                    if (nameSpace) {
                        if (Utils.isUndefined(window[nameSpace])) {
                            console.error("Namespace " + nameSpace + " is not defined");
                        } else if (Utils.isUndefined(window[nameSpace][functionName])) {
                            console.error("Function " + functionName + " is not defined under namespace " + nameSpace);
                        } else {
                            window[nameSpace][functionName](argArray);
                        }
                        
                    } else {
                        if (Utils.isUndefined(window[functionName])) {
                            console.error(functionName + " is not defined!");
                        } else if (!$.isFunction(window[functionName])) {
                            console.error(window[functionName] + " is not a function!");
                        } else {
                            window[functionName](argArray);                            
                        }                        
                    }
                }
            });
        }
    };

    $(document).ready(function () {
        WCWidgetParser.parse();
        WCWidgetParser.parseRefreshArea();
    });
}(jQuery));//-----------------------------------------------------------------
// Licensed Materials - Property of IBM
//
// WebSphere Commerce
//
// (C) Copyright IBM Corp. 2016 All Rights Reserved.
//
// US Government Users Restricted Rights - Use, duplication or
// disclosure restricted by GSA ADP Schedule Contract with
// IBM Corp.
//-----------------------------------------------------------------

/*global jQuery, $, window, setTimeout, clearTimeout, Utils */

/*
 * Carousel (extends $.Widget)
 * Wraps around a third party plugin - Owl Carousel. Owl Carousel is just a jQuery plugin
 * so it's not written as a jQuery UI Widget, otherwise we would extend the Owl Carousel Widget.
 *
 */
(function () {

    /*
     * New options (in addition to ones inherited from $.Widget):
     *
     * OPTIONAL:
     * prevButton: {string}
     *             jQuery selector for the previous button, can have falsy 
     *             value if there is no previous button.
     * nextButton: {string} 
     *             jQuery selector for the next button, can have falsy value
     *             if there is no previous button.
     * paginationButtons: {string}
     *             jQuery selector for the previous button, can have falsy 
     *             value if there are no pagination buttons.
     * overflowVisible: {boolean} 
     *             true if content that overflows the container should be shown,
     *             false otherwise.
     * REQUIRED:
     * (None)
     */
    $.widget("wc.Carousel", $.Widget, {
        options: {
            prevButton: null,
            nextButton: null,
            paginationButtons: null,
            contentContainer: "div.content",
            overflowVisible: false,
            owlCarouselOptions: {
                autoHeight: false,
                autoWidth: true,
                pagination: false, // We're generating our own pagination control
                slideSpeed: 2000,
                //touchDrag: false, // Need to disable touch drag if we want this to work
                // with gridster
                //mouseDrag: false,
                afterMove: function (elem) {                    
                    if (this.options.paginationButtons) {                        
                        this.paginationButtons.removeClass("selected")
                        // Highlight the selected element after pagination move
                        .eq(this.owlCarousel.currentItem).attr("class", "selected");
                    }                    
                },
                afterUpdate: function() {
                    // Only hide/show next/prev buttons after update has finished
                    this._togglePrevNextButtons();
                }
            }
        },

        /**
        * Attach "this" to a function passed to the owlCarousel option
        */
        _proxyFunction: function(optionName) {
            if ($.isFunction(this.options.owlCarouselOptions[optionName])) {
                this.options.owlCarouselOptions[optionName] = $.proxy(this.options.owlCarouselOptions[optionName], this);
            }
        },
        
        _create: function () {
            this._super(this);

            // Stores a handle to the underlying Owl Carousel
            this.content = $(this.options.contentContainer, this.element);
            this._proxyFunction("afterMove");
            this._proxyFunction("afterUpdate");
            
            if (this.options.columnCountByWidth) {
                var columnCountByWidth = this.options.columnCountByWidth;
                if (Utils.isObject(columnCountByWidth)) {
                    var windowWidth = $(window).width(),
                        // Grab all the screen sizes and sort them
                        screenSizes = Object.keys(columnCountByWidth)
                                            .map(function(str) {
                                                return parseInt(str, 10);
                                            });
                    screenSizes.sort(function(a, b) { return a - b });
                    screenSizes = screenSizes.map(function(size) {
                        return [size, columnCountByWidth[size.toString()]];
                    });
                    this.options.owlCarouselOptions.itemsCustom = screenSizes;
                } else {
                    console.error("columnCountByWidth is not an object: " + this.options.columnCountByWidth);
                }
            }
            
            this.owlCarousel = this.content.owlCarousel(this.options.owlCarouselOptions).data('owlCarousel');

            if (this.options.overflowVisible) {
                $(".owl-wrapper-outer", this.element).addClass("overflow-visible");
            }
            
            $(window).resize($.proxy(function() {
                this.owlCarousel.reload();
                this._togglePrevNextButtons();
            }, this));
            
            
            
//            $(window).resize($.proxy(function () {
//                // Reposition the dialog after window resize, otherwise
//                // the dialog will stay in the same position
//                this.reposition();
//            }, this));

            this._add_event_handlers();
            this._togglePrevNextButtons();
        },

        /**
        * Show/hide custom pagination buttons depending on the number of items 
        * being shown
        */
        _togglePrevNextButtons: function() {
            // Require pagination if the total number of items is greater than
            // the number of items being shown
            var requirePagination = (this.owlCarousel.itemsAmount > this.owlCarousel.options.items);
            
            if (requirePagination) {
                if (this.options.nextButton) {
                    this.$nextButton.show();
                }      
                if (this.options.prevButton) {
                    this.$prevButton.show();
                }  
            } else {
                if (this.options.nextButton) {
                    this.$nextButton.hide();
                }      
                if (this.options.prevButton) {
                    this.$prevButton.hide();
                }  
            }
        },
        
        _add_event_handlers: function () {
            var carousel = this.owlCarousel;

            this.element.on("resized.owl.carousel", function() {
                console.log("resized");
            });
            // Pagination Controls
            // Previous button
            if (this.options.prevButton) {
                this.$prevButton = $(this.options.prevButton, this.element);
                this.$prevButton.click(function (e) {
                    carousel.prev();
                    e.preventDefault();
                });           
            }

            // Next button
            if (this.options.nextButton) {
                this.$nextButton = $(this.options.nextButton, this.element);
                this.$nextButton.click(function (e) {
                    carousel.next();
                    e.preventDefault();
                });
            }           

            // Pagination buttons (either dots or numbers)
            // Highlight the first element on startup
            if (this.options.paginationButtons) {
                this.paginationButtons = $(this.options.paginationButtons, this.element);
                this.paginationButtons.first().attr("class", "selected");
                this.paginationButtons.each(function(i, button) {
                    $(button).click(function(e) {
                        carousel.goTo(i);
                        e.preventDefault();
                    });                    
                });
            }            
        },
        
        _destroy: function () {
            this.owlCarousel.destroy();
            
            // remove the event handlers
            //this.element.off("mouseenter.wcToolTip");  
            //this.element.off("mouseleave.wcToolTip");  
        }

    });

}());//-----------------------------------------------------------------
// Licensed Materials - Property of IBM
//
// WebSphere Commerce
//
// (C) Copyright IBM Corp. 2016 All Rights Reserved.
//
// US Government Users Restricted Rights - Use, duplication or
// disclosure restricted by GSA ADP Schedule Contract with
// IBM Corp.
//-----------------------------------------------------------------

/*global jQuery, Utils, window, document */

/* 
 * WCGrid (extends $.ui.dialog) 
 *
 */
(function ($) {

    /*
     * New options (in addition to ones inherited from $.Widget):
     * columnCount: the number of columns (can be empty if rowCount is specified)
     * rowCount: the number of rows (can be empty if columnCount is specified)
     * elementSelector: the elements in the grid
     * useColumnWrapper: true if column wrappers should be used, false otherwise
     * columnWrapperClass: the CSS class to add to the column wrapper divs
     */
    $.widget("wc.Grid", $.Widget, {
        
        options: {            
            columnCount: 1,
            rowCount: null,
            elementSelector: "div.grid-element",
            useColumnWrapper: false,
            columnWrapperClass: "grid-column-wrapper"
        },
        
        /**
        * Handlers to be called when options are changed. Key corresponds to the option name, 
        * value corresponds to the handler.
        */
        optionChangedHandlers: {
            columnCount: function() {
                this._columnCountUpdated();
            },
            columnCountByWidth: function() {
                this.resize();                
            },
            elementSelector: function() {
                this.$elements = undefined;
            }
        },
        
        /**
        * The CSS class to add to the column container depending on the number of
        * columns.
        * Example: a grid with 3 columns will receive have the class "ui-grid-b" added.
        */
        columnContainerClass: {
            "1": "ui-grid-solo",
            "2": "ui-grid-a",
            "3": "ui-grid-b",
            "4": "ui-grid-c",
            "5": "ui-grid-d",
            "6": "ui-grid-e",
            "7": "ui-grid-f",
            "8": "ui-grid-g",
            "9": "ui-grid-h"
        },
        
        /** The current column container class */
        currentColumnContainerClass: null,
        
        /**
        * The CSS class to add to a column depending on it's column index. 
        * Example: the 4th column will have the class "ui-class-d" added.
        */
        columnClass: {
            "1": "ui-block-a",
            "2": "ui-block-b",
            "3": "ui-block-c",
            "4": "ui-block-d",
            "5": "ui-block-e",
            "6": "ui-block-f",
            "7": "ui-block-g",
            "8": "ui-block-h",
            "9": "ui-block-i"
        },
        
        _setOption: function (key, value) {
            this._super(key, value);
            
            if (this.optionChangedHandlers[key]) {
                this.optionChangedHandlers[key].call(this);
            }
        },

        _getColumnContainerClass: function(columnCount) {
            var val = this.columnContainerClass[String(columnCount)];
            if (val) {
                return val;
            }
            throw "Unsupported, too many columns: " + columnCount;
        },
        
        _columnCountUpdated: function() {
            this.$elements = this.$elements || $(this.options.elementSelector, this.element)
            var $elements = this.$elements,
                $parent = $elements.parent(),
                columnCount = this.options.columnCount,
                rowCount = this.options.rowCount;
            
            if (columnCount) {
                if (columnCount === 0) {
                    throw "Column count must be greater than 0!"
                    
                } else if (rowCount) {
                    // Make sure the number of elements in this grid can fit into a grid 
                    // defined by columnCount and rowCount
                     if (rowCount === 0) {
                        throw "rowCount must be greater than 0!";
                     } else if ($elements.length > columnCount * rowCount) {
                        throw "The number of elements (" + $elements.length + ") cannot fit into a " + columnCount + " by " + rowCount + " grid";
                     } 
                } else {
                    // Only column count defined, calculate row count
                    rowCount = Math.ceil($elements.length / columnCount);
                }
            } else if (rowCount) {
                if (rowCount === 0) {
                    throw "rowCount must be greater than 0!";
                    
                } else {
                    // Only row count defined, calculate column count
                    columnCount = Math.ceil($elements.length / rowCount);
                }
            } else {
                // Should not get here since default value provided for at least
                // one of columnCount or rowCount, but might reach here if user
                // accidentially sets both columnCount and rowCount to a falsy value
                throw "Row count and column count not defined!";
            }

            if (this.options.useColumnWrapper && $parent.hasClass(this.options.columnWrapperClass)) {
                // Unwrap previous column wrappers if any
                $elements.unwrap();
                $parent = $elements.parent();                
            }
            if (this.currentColumnContainerClass) {
                $parent.removeClass(this.currentColumnContainerClass);
            }
            this.currentColumnContainerClass = this._getColumnContainerClass(columnCount);
            $parent.addClass(this.currentColumnContainerClass);
        
            var rows = arrayUtils.arrTo2D($.makeArray($elements), columnCount),
                c;
            for (c = 0; c < columnCount; c++) {
                var $cols = $(rows.filter(function(a_row) {
                                return a_row.length > c;
                            }).map(function(a_row) {
                                return a_row[c];
                            }));
                if (this.options.useColumnWrapper) {
                    $cols = $cols.detach();              
                    $wrapper = $("<div class=\"" + this.options.columnWrapperClass + " " + this.columnClass[c + 1] + "\"></div>");
                    $parent.append($wrapper);
                    $wrapper.append($cols);
                } else {
                    $cols.removeClass(this.allColumnClass)
                         .addClass(this.columnClass[c + 1]);
                }                
            }
        },
        
        _validateElements: function() {
            if (!Utils.areSiblings($(this.options.elementSelector, this.element), $([]))) {
                throw "Grid elements must all be under the same parent";
            }
        },
        
        _create: function () {
            this._super(this);
            
            /**
             * Grab all the CSS class as a space separated string. Passed to $.removeClass to help remove all
             * column class from an element. 
             */
            this.allColumnClass = $.map(this.columnClass, function(val, key) {return val;}).join(" ");

            this._validateElements();
            this.option("columnCount", this._calculateColumnBasedOnClientWidth());
                                    
            $(window).resize($.proxy(function () {
                this.resize();
            }, this));
        },

        /**
         * Calculates the number of columns based on the columnCountByWidth option and client width
         * (if no such option is provided, returns 1). E.g. if client width is: 1000 px and columnCountByWidth
         * is: {"300": 2, "500": 3: "800": 4} then this will return 4 since the screen width is
         * greater than 800.  
         */
        _calculateColumnBasedOnClientWidth: function() {
            var columnCount = 1,
                clientWidth = this.element.get(0).clientWidth;
            
            if (this.options.columnCountByWidth) {
                Utils.iterate_obj_in_order(this.options.columnCountByWidth, function(a, b) {
                    return parseInt(b) - parseInt(a);
                },
                function(width, colWidth) {
                    if (clientWidth >= parseInt(width)) {
						columnCount = colWidth;
                        return true; // breaks out of the loop
					}
                });
            }
            return columnCount;
        },
        
        /**
         * Recalculates the column width on window resize and rearrange the elements 
         * accordingly.
         */
        resize: function () {
            var columnCount = this._calculateColumnBasedOnClientWidth();
            if (columnCount !== this.options.columnCount) {
                this.option("columnCount", columnCount);
            }
        }

    });

}(jQuery));//-----------------------------------------------------------------
// Licensed Materials - Property of IBM
//
// WebSphere Commerce
//
// (C) Copyright IBM Corp. 2016 All Rights Reserved.
//
// US Government Users Restricted Rights - Use, duplication or
// disclosure restricted by GSA ADP Schedule Contract with
// IBM Corp.
//-----------------------------------------------------------------

/*global jQuery, Utils, window, document */

/* 
 * Select (extends $.ui.selectmenu) 
 *
 * Options:
 * useValueAsLink: true if the value of the select menu items should be treated as a link (defaults to false). The onChange element will be ignored. 
 */
(function ($) {
    $.widget("wc.Select", $.ui.selectmenu, {
        options: {
            wcMenuClass: "",
            useValueAsLink: false
        },
        
        _create: function() {
            this._super(this);
            
            if (this.options.useValueAsLink) {
                if (!Utils.isUndefined(this.element.attr("onChange"))) {
                    console.warn("onChange defined for select menu, but it will be ignored since useValueAsLink is set to true");
                }                 
                this.options.change = function() {
                    var url = $(this).val();
                    if(Utils.existsAndNotEmpty(url)) {
                        window.location = url;
                    } else {
                        console.error("the url is not defined");
                    }
                }
            } else if(this.element.attr("onChange") !== undefined) {
                //pick up the onChange parameters
    			var onChange = this.element.attr("onChange").replace(/javascript:/i, '')
	    		this.options.change = function(event, data) {
	    			eval(onChange);
	    		}
    		}
            
            // Get index of the selected element (if any)
            var selectedOption = $(this.element).find("[selected='selected']");
            if (selectedOption.length) {
                $(this.element[0]).prop('selectedIndex', selectedOption.index());
            }            
    	},
    	
    	open: function( event ) {
    		this._super(this);
    		
    		// If this is not the first time the menu is being opened, reset focused and selected item
    		if ( this.menuItems ) {
    			this._removeClass( this.menu.find( ".ui-state-select" ), null, "ui-state-select" );
    			this._addClass( this._getSelectedItem().children(), null, "ui-state-select" );
    			this.menuInstance.focus( null, this._getSelectedItem() );
    		}
    	},
    	
    	close: function( event ) {
    		this._super(this);
			
    		//re-identify the selected items
    		this._removeClass( this.menu.find( ".ui-state-select" ), null, "ui-state-select" );
    		this._addClass( this._getSelectedItem().children(), null, "ui-state-select" );
    	},
    	
    	_drawButton: function() {
    		this._super(this);
    		
    		//pass classes from select element to new select button
    		this.button.addClass(this.element.attr("class"));
    		this.button.addClass(this.element.attr("baseclass"));
    		this.button.attr("style", "");
    	},
    	
    	_drawMenu: function() {
    		var that = this;
    		
    		this._super(this);
    		this.menu.menu({
    			focus: function( event, ui ) {
    				var item = ui.item.data( "ui-selectmenu-item" );
    				if(item) {
    					that.menuItems.eq( item.index ).focus();
    				}
    			}
    		}).css("font-size", this.buttonItem.css("font-size"));
    		
    		//the class to add to DropDown popup menu for css styling
			var wcMenuClass = this.options.wcMenuClass;
			if (wcMenuClass !== undefined && wcMenuClass !== null && wcMenuClass !== ''){
				this.menu.addClass(wcMenuClass);
			}
    	},
    	
    	_position: function() {
    		this._super(this);
    		this.reposition(this.menuWrap, this.button);
    	},
    	
    	//reposition the drop down menu if there's not enough space
    	reposition: function (menuWrap, button) {
    		//synchronize the z index of drop down menu and the button
    		this.menuWrap.css("z-index", 1000);
			
    		//reset menu height to auto
    		this.menu.css("height", "auto");
    		var menuHeight = menuWrap.height();
    		var disToTop = menuWrap.position().top - $(window).scrollTop();
    		var disToBottom = $(window).height() - disToTop;
    		if(disToTop > $(window).height()/2 && menuHeight > disToBottom) {
    			if(disToTop > menuHeight) {
    				//If there's enough space on top, align the menu to select button
    				this.menuWrap.css("top", menuWrap.position().top - menuHeight - button.outerHeight());
    			} else {
    				//Align the menu to window top
    				this.menuWrap.css("top", menuWrap.position().top - disToTop);
    				//adjust menu height accordingly
    				this.menu.css("height", disToTop - button.outerHeight());
    			}
    		} else if(menuHeight > disToBottom) {
    			//adjust menu height accordingly
    			this.menu.css("height", disToBottom);
    		}
        },
        
        _renderItem: function( ul, item ) {
        	this._super(ul, item);
        	
        	//pick up the value and style attributes from options
        	ul.children().last().attr("value", item.value);
        	ul.children().children().last().attr("style", item.element[0].style.cssText);

    		return ul.children().last();
    	},
    	
    	refresh_noResizeButton: function() {
    		this._refreshMenu();
			if($(this.element[0]).prop('selectedIndex') > -1) {
				this._setText( this.buttonItem, this._getSelectedItem().text() );
			}
    	}
        
    });

}(jQuery));//-----------------------------------------------------------------
// Licensed Materials - Property of IBM
//
// WebSphere Commerce
//
// (C) Copyright IBM Corp. 2016 All Rights Reserved.
//
// US Government Users Restricted Rights - Use, duplication or
// disclosure restricted by GSA ADP Schedule Contract with
// IBM Corp.
//-----------------------------------------------------------------

/*global jQuery, $, window, setTimeout, clearTimeout, Utils */

/* 
 * ValidationTextbox
 * 
 * IMPORTANT: REQUIRES "custom.wcToolTip" to work
 *
 */
(function () {

    /*
     * New options (in addition to ones inherited from $.Widget):
     * 
     * OPTIONAL:
     * regExp: {string} a JavaScript regular expression String for the valid input
     * canBeEmpty: {boolean} {default: true} true if the textbox is allowed to be empty, false otherwise
     * trimBeforeValidation: {boolean} {default: true} true if the textbox value should be trimmed before
     *                       validation, false otherwise.
     * invalidMessage: {string} the message to display as tooltip if the input is invalid
     * submitButton: {string} a jQuery selector of the button that will submit the form that contains 
     *               this ValidationTextbox. Will disable the button if the contents of this ValidationTextbox
     *               is invalid. 
     * submitButtonDisabledClass: {string} {default: disable} the CSS class to add to the submit button
     *                           if it is disabled
     * errorClass: {string} {default: "error"} the CSS class to add to this ValidationTextbox if the 
     *             input is invalid
     * customValidateFunction: {function} Customized validate function, return error message
     * onValidInput: {function(string)} a function that gets called each time the user enters a valid input (if 
     *                          the user enters invalid input, this function is not called). The text in the textbox
     *                          is passed to the function.
     * REQUIRED: 
     * (None)
     */
    $.widget("wc.ValidationTextbox", $.Widget, {
        options: {
            canBeEmpty: true,
            trimBeforeValidation: true,
            errorClass: "error",
            submitButtonDisabledClass: "disabled",
            invalidMessage: null
        },

        _create: function () {
            this._super(this);

            if (this.options.regExp) {
                this.regExp = new RegExp(this.options.regExp);
            }
            
            this.element.addClass("wcValidationTextbox");
            
            if (this.options.submitButton) {
                this.submitButton = $(this.options.submitButton);
            }
            this.element.bind("input propertychange", $.proxy(function(evt) {
                // Validate the value in text box and create error message tooltip when necessary
                if (this.validationAndErrorHandler() && this.options.onValidInput) {
                    this.options.onValidInput($(this.element).prop("value"));
                }
            }, this));
        },
        
        /**
        * Toggle the submit button associated with this Validation Textbox
        *
        * @param enable true if the submit button should be enabled, false otherwise
        */
        toggleSubmitButton: function(enable) {
            if (this.options.submitButton && this.submitButton.length) {
                if (enable) {
                    this.submitButton.removeClass(this.options.submitButtonDisabledClass);
                } else {
                    this.submitButton.addClass(this.options.submitButtonDisabledClass);
                }
                if (this.submitButton.is("a")) {
                    Utils.toggleHyperlink(this.submitButton, enable);
                    
                } else if (this.submitButton.is("input")) {
                    this.submitButton.prop('disabled', !enable);
                    
                } else {
                    console.err("don't know how to disable: " + this.submitButton);
                }
                
            }
        },
        
        /**
        * Returns true if the given value matches format defined in regExp, false otherwise.
        */
        validateFormat: function(value) {
            if (Utils.isBoolean(this.options.canBeEmpty) && value === "") {
                return this.options.canBeEmpty;
            } else if (this.options.regExp && !this.regExp.test(value)){
                return false;
            }
            return true;
        },

        /**
        * Create error message tooltip and return false when the value in text box fails in format validation and 
        * customized validation check (if customValidateFunction is specified).
        * Remove tooltip and return true when the value is valid.
        */
        validationAndErrorHandler: function() {
            var $textbox = $(this.element),
                value = this.element.val();

            if (this.options.trimBeforeValidation) {
                value = $.trim(value);
            }

            var errorMessage = null;
            if (!this.validateFormat(value)) {
                errorMessage = this.options.invalidMessage;
            }
            if (errorMessage == null && this.options.customValidateFunction != null && this.options.customValidateFunction != undefined) {
                errorMessage = this.options.customValidateFunction();
            }

            if (errorMessage == null) {
                // Remove tooltip and return true when no error
                if ($textbox.hasClass(this.options.errorClass)) {
                    $textbox.removeClass(this.options.errorClass);
                    if (this.tooltip) {
                        this.tooltip.destroy();
                        this.tooltip = null;
                    }
                    this.toggleSubmitButton(true);
                }

                return true;
            } else if (this.tooltip && this.element.data("tooltip-content") && this.element.data("tooltip-content") != errorMessage) {
                // Change error message if necessary
                this.element.data("tooltip-content", errorMessage);
                this.tooltip.tooltip.find(".content").text(errorMessage);
                this.tooltip.show_popup();
            } else if (this.tooltip) {
                // Show error message tooltip if there's already one
                this.tooltip.show_popup();
            } else {
                // Create tooltip when error message is not null
                if (!$textbox.hasClass(this.options.errorClass)) {
                    $textbox.addClass(this.options.errorClass);
                    this.element.data("tooltip-content", errorMessage);
                    this.tooltip = this.element.wcToolTip().data("custom-wcToolTip");
                    this.tooltip.show_popup();
                    this.toggleSubmitButton(false);
                }
            }

            // Return false if there's error
            return false;
        }
    });

}());//-----------------------------------------------------------------
// Licensed Materials - Property of IBM
//
// WebSphere Commerce
//
// (C) Copyright IBM Corp. 2016 All Rights Reserved.
//
// US Government Users Restricted Rights - Use, duplication or
// disclosure restricted by GSA ADP Schedule Contract with
// IBM Corp.
//-----------------------------------------------------------------

/*global jQuery, $, window, setTimeout, clearTimeout, Utils */

/*
 * WCDialog (extends $.ui.dialog)
 *
 */
(function () {

    /*
     * New options (in addition to ones inherited from $.ui.dialog):
     *
     * OPTIONAL:
     * show_title: {boolean}
     *             true if the title should be shown, false otherwise
     * close_button_selector: {string} {default: "a.closeButton"}
     *                        jQuery selector for the close button,
     *                        can have falsy value if there is no
     *                        close button.
     * primary_button_selector: {string}
     *                     jQuery selector for the ok button, can have falsy
     *                     value if there is no ok button.
     * close_on_primary_click: {boolean} {default: true}
     *                     true if the dialog should be closed when the primary 
     *                     button is clicked, false otherwise.
     * secondary_button_selector: {string}
     *                     jQuery selector for the cancel button,
     *                     can have falsy value if there is no
     *                     cancel button.
     * related_source: {string}
     *                 jQuery selector of an element to position the dropdown relative to
     * title: {string}
     *        title to display
     * in_iframe: {boolean}
     *            truthy value if this dialog is in an iframe, false otherwise
     *
     * REQUIRED:
     * (None)
     */
    $.widget("wc.WCDialog", $.ui.dialog, {
        options: {
            show_title: false,

            autoOpen: false,

            /*
             * Closes the dialog after the given timeout seconds
             */
            timeout: null,
            /*
             * Auto close the dialog when the mouse leaves the
             * dialog or the relatedSource (if it is specified)
             */
            autoClose: false,

            close_button_selector: "a.closeButton",

            /**
            * Close the dialog when the primary button is clicked
            */
            close_on_primary_click: true,
            
            /**
            * The selector of an element to position the dropdown relative to
            */
            relatedSource: null,

            modal: true,

            /*
            * Required otherwise a default width of 300px will be assigned
            */
            width: "auto"
            
            
        },

        _create: function () {
            this._super(this);

            if (!this.options.show_title) {
                this.element.siblings("div.ui-dialog-titlebar").hide();
            }

            // Add the data-widget-type attribute in case the element doesn't
            // already have it. Useful for finding all WCDialog widgets
            this.element.attr("data-widget-type", "wc.WCDialog");

            $(window).resize($.proxy(function () {
                // Reposition the dialog after window resize, otherwise
                // the dialog will stay in the same position
                this.reposition();
            }, this));

            this._add_event_handlers();
        },
        
        _add_event_handlers: function () {
            // Add click handler for all close buttons within the dialog
            if (this.options.close_button_selector) {
                this.close_button = $(this.options.close_button_selector, this.element)
                    .on("click.WCDialog", $.proxy(function () {
                        this.close();
                    }, this));
            }

            // Add click handler for all OK buttons within the dialog
            if (this.options.primary_button_selector) {
                this.primary_button = $(this.options.primary_button_selector, this.element)
                    .on("click.WCDialog", $.proxy(function () {
                        if (this.options.close_on_primary_click) {
                            this.close();
                        }                        
                    }, this));
            }

            // Add click handler for all cancel buttons within the dialog
            if (this.options.secondary_button_selector) {
                this.secondary_button = $(this.options.secondary_button_selector, this.element)
                    .on("click.WCDialog", $.proxy(function () {
                        this.close();
                    }, this));
            }

//            var obj = this.options.position;
//            obj.collision = "none";
//            this.option("position", obj);

//            this.element.on("wcdialogopen", $.proxy(function(){
//                 $('html, body').scrollTo(this.options.position.of);
//            }, this));

            if (this.options.timeout || this.options.autoClose) {
                var self = this,
                    timeoutObj,
                    clearAndDeleteTimer = function () {
                        if (timeoutObj) {
                            clearTimeout(timeoutObj);
                            timeoutObj = null;
                        }
                    },
                    startTimer = function () {
                        if (timeoutObj) {
                            // Resets the previous one if it exists
                            clearAndDeleteTimer();
                        }
                        timeoutObj = setTimeout(function () {
                            self.close();
                        }, self.options.timeout);
                    };

                if (this.option.timeout) {
                    this.element.on("wcdialogopen", startTimer);

                    this.element.on("wcdialogclose", clearAndDeleteTimer);

                    // Delete the timer when the mouse overs over the
                    // dialog, only reset it once the mouse leaves
                    this.element.on("mouseover", function (event) {
                        // Resets the timer count down if the mouse
                        // moves over the dialog
                        clearAndDeleteTimer();

                        // Start the timer again once the mouse leaves
                        self.element.on("mouseleave", startTimer);
                    });
                }

                if (this.options.autoClose) {
                    self.element.add($(self.options.relatedSource)).on("mouseleave", function (event) {
                        if (!$.contains(self.element.get(0), event.toElement) && !$.contains($(self.options.relatedSource).get(0), event.toElement)) {
                            self.close();
                        }
                    });
                }

            }

        },

        reposition: function () {
            // Find the dialog wrapper
            var wrapper = this.element.parent("div.ui-widget-content:first[role='dialog']");
            // For some reason in Store Preview mode, jQuery returns 0 when getting the
            // height of the dialog wrapper even though this.element.height() returns the correct
            // value. So we set the dialog wrapper's height manually so jQuery can retrieve it 
            // correctly.
            if (wrapper.height() === 0) {
                wrapper.height(this.element.height());
            }
            if (wrapper.width() === 0) {
                wrapper.width(this.element.width());
            }
            
            var pos = this.option("position");
            this.option("position", pos);
        },

        /** 
        * Bring this WCDialog on top of all other WCDialogs.
        *
        * @param elements <optional> a jQuery Object, HTML Node collection, or jQuery selector 
        *        representing the elements on the page that this WCDialog should be on top of.
        *        If not defined ".ui-dialog" will be used instead which will bring this WCDialog
        *        on top of all other WCDialogs.
        */
        bringToFront: function(elements) {
            // Find max z-index
            var maxZIndex = 0;
            elements = $(elements || ".ui-dialog");
            elements.each(function(i, e) {
                var zIndex = $(e).css("z-index");
                if ($.isNumeric(zIndex)) {
                    zIndex = parseInt(zIndex);
                    if (zIndex > maxZIndex) {
                        maxZIndex = zIndex;
                    }
                }
            });
            // This could overflow eventually, but very unlikely
            this.element.parent(".ui-dialog").css("z-index", parseInt(maxZIndex) + 1);
        },
        
        /*
         * Updates the content of the WCDialog with the content from
         * the given selector (note the selector will be detached
         * from it's current DOM location).
         *
         * Parameters:
         * selector - selector for the new content
         */
        update_content: function (selector) {
            var content = $(selector).detach();
            this.element.html(content.html());
            // Reset the position element after updating content
            this.reposition();
            this._add_event_handlers();
        }

    });

}());//-----------------------------------------------------------------
// Licensed Materials - Property of IBM
//
// WebSphere Commerce
//
// (C) Copyright IBM Corp. 2016 All Rights Reserved.
//
// US Government Users Restricted Rights - Use, duplication or
// disclosure restricted by GSA ADP Schedule Contract with
// IBM Corp.
//-----------------------------------------------------------------

(function ($) {
    $.widget("custom.wcToolTip", {

        options: {
            /* 
            * The key the user can press to open the tooltip if the element the tooltip
            * is anchored on is in focus. Disable this feature by setting the value to null.
            */
            accessibilityKey: null            
        },
        
        _create: function () {
            var self = this;
            this.element.on("mouseenter.wcToolTip", function() {
                self.show_popup();
            });
            this.element.on("mouseleave.wcToolTip", function() {
                self.hide_popup();
            });
            if (this.options.accessibilityKey !== null) {
                this.element.on("keydown.wcToolTip", function(event) {
                    if (event.keyCode === self.options.accessibilityKey) {
                        self.show_popup();    
                    }
                });                    
            }
        },
        show_popup: function () {
            if (this.tooltip) {
                this.tooltip.show();

            } else {
                var header = $(this.element).data("tooltip-header"),
                    content = $(this.element).data("tooltip-content");
                if (content && header) {
                    this.tooltip = $("<div class='WCTooltip'><div class='container'><div class='connector'></div><div class='header'>" + header + "</div><div class='content' >" + content + "</div></div></div>");

                } else if (header) {
                    this.tooltip = $("<div class='WCTooltip'><div class='container' style='padding:8px;' ><div class='connector'></div>" + header + "</div></div>");
                    
                } else if (content) {
                    this.tooltip = $("<div class='WCTooltip'><div class='container'><div class='connector'></div><div class='content' >" + content + "</div></div></div>");
                    
                } else {
                    // both undefined
                    this.tooltip = $("");
                }
                this.element.after(this.tooltip);
            }
            this.tooltip.position({
                my: "center top",
                at: "center bottom",
                of: this.element,
                collision: "none"
            });


        },
        hide_popup: function () {
            if (this.tooltip) {
                this.tooltip.hide();
            }
        },
        _destroy: function () {
            if (this.tooltip) {
                this.tooltip.hide();
                this.tooltip.remove(); // remove from DOM
            }            
            // remove the event handlers
            this.element.off("mouseenter.wcToolTip");  
            this.element.off("mouseleave.wcToolTip");  
        }
    });
}(jQuery));
//-----------------------------------------------------------------
// Licensed Materials - Property of IBM
//
// WebSphere Commerce
//
// (C) Copyright IBM Corp. 2017 All Rights Reserved.
//
// US Government Users Restricted Rights - Use, duplication or
// disclosure restricted by GSA ADP Schedule Contract with
// IBM Corp.
//-----------------------------------------------------------------

AddressBookDetailJS = {

    /**
     * This function updates an address in the address book.
     * This function takes a form containing the address information and invokes 'updateAddressBook' service. 
     * After the address is updated, this function will refresh the address
     * display area using the given URL.
     * @param {string} formName The name of the form containing the address information.
     * @param {string} editSectionId The div ID of the edit section.
     */
    updateAddress: function(formName, editSectionId){

        var form = document.forms[formName];

        for (var i = 0; i < form.sbAddress.length; i++) {
            if (form.sbAddress[i].checked) {
                form.addressType.value = form.sbAddress[i].value;
            }
        }

        if(form.addressType.value == "") {
            MessageHelper.displayErrorMessage(MessageHelper.messages["AB_SELECT_ADDRTYPE"]);
            return;
        }
        /* Validate the form input fields. */
        if (this.validateAddressForm(form)) {
            console.debug("creating with form id = "+formName);

            wcService.declare({
                id: "updateAddressBook",
                actionId: "updateAddressBook",
                url: "AjaxRESTPersonChangeServiceAddressAdd",
                formId: formName,
                successHandler: function(serviceResponse) {
                    MessageHelper.displayStatusMessage(MessageHelper.messages["AB_UPDATE_SUCCESS"]);
                    cursor_clear();
                },
                failureHandler: function(serviceResponse) {
                    if (serviceResponse.errorMessage) {
                        MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
                    }
                    else {
                        if (serviceResponse.errorMessageKey) {
                        MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
                        }
                    }
                    cursor_clear();
                }
            });

            /*For Handling multiple clicks. */
            if(!submitRequest()){
                return;
            }
            cursor_wait();
            wcService.invoke("updateAddressBook");

            // Close Edit Section and display readOnly section.
            widgetCommonJS.toggleReadEditSection(editSectionId, 'read');
        }
    },

    validateAddressForm: function(form,prefix){
        reWhiteSpace = new RegExp(/^\s+$/);
        if(prefix == null){prefix = ""};
        if(prefix){this.setStateDivName(prefix + "stateDiv")};
        if(form != null){
            var fields="";
            if(form["UserDetailsForm_FieldsOrderByLocale"] != null && form["UserDetailsForm_FieldsOrderByLocale"].value != null && form["UserDetailsForm_FieldsOrderByLocale"].value != ""){
                fields = form["UserDetailsForm_FieldsOrderByLocale"].value.split(",");
            }
            else if(form["UserAddressForm_FieldsOrderByLocale"] != null && form["UserAddressForm_FieldsOrderByLocale"].value != null && form["UserAddressForm_FieldsOrderByLocale"].value != ""){
                fields = form["UserAddressForm_FieldsOrderByLocale"].value.split(",");
            }
            else if(form[prefix + "AddressForm_FieldsOrderByLocale"] != null && form[prefix + "AddressForm_FieldsOrderByLocale"].value != null && form[prefix + "AddressForm_FieldsOrderByLocale"].value != ""){
                fields = form[prefix + "AddressForm_FieldsOrderByLocale"].value.split(",");
            }
            else if(form["AddressForm_FieldsOrderByLocale"] != null && form["AddressForm_FieldsOrderByLocale"].value != null && form["AddressForm_FieldsOrderByLocale"].value != ""){
                fields = form["AddressForm_FieldsOrderByLocale"].value.split(",");
            }
            else if(document.getElementById("AddressForm_FieldsOrderByLocale").value!= null && document.getElementById("AddressForm_FieldsOrderByLocale").value!= ""){
                fields=document.getElementById("AddressForm_FieldsOrderByLocale").value.split(",");
            }
            var nickName = prefix + "nickName";
            var lastName = prefix + "lastName";
            var firstName = prefix + "firstName";
            var middleName = prefix + "middleName";
            var address1 = prefix + "address1";
            var address2 = prefix + "address2";
            var city = prefix + "city";
            var state = prefix + "state";
            var country = prefix + "country";
            var zipCode = prefix + "zipCode";
            var email1 = prefix + "email1";
            var phone1 = prefix + "phone1";

            for(var i=0; i<fields.length; i++){
                var field = fields[i];
                if(field == "NICK_NAME" || field == "nick_name"){
                    form[nickName].value = trim(form[nickName].value);
                    if(field == "NICK_NAME" && (form[nickName].value == "" || reWhiteSpace.test(form[nickName].value))){
                        MessageHelper.formErrorHandleClient(form[nickName].id, MessageHelper.messages["ERROR_RecipientEmpty"]);
                        return false;
                    }
                    if(!MessageHelper.isValidUTF8length(form[nickName].value, 254)){ 
                        MessageHelper.formErrorHandleClient(form.nickName.id, MessageHelper.messages["ERROR_RecipientTooLong"]); 
                        return false;
                    }
                }else if(field == "LAST_NAME" || field == "last_name"){
                    form[lastName].value = trim(form[lastName].value);
                    if(field == "LAST_NAME" && (form[lastName].value == "" || reWhiteSpace.test(form[lastName].value))){ 
                        MessageHelper.formErrorHandleClient(form[lastName].id, MessageHelper.messages["ERROR_LastNameEmpty"]);
                        return false;
                    }
                    if(!MessageHelper.isValidUTF8length(form[lastName].value, 128)){ 
                        MessageHelper.formErrorHandleClient(form[lastName].id, MessageHelper.messages["ERROR_LastNameTooLong"]);
                        return false;
                    }
                }else if(field == "FIRST_NAME" || field == "first_name"){
                    form[firstName].value = trim(form[firstName].value);
                    if(field == "FIRST_NAME" && (form[firstName].value == "" || reWhiteSpace.test(form[firstName].value))){ 
                        MessageHelper.formErrorHandleClient(form[firstName].id, MessageHelper.messages["ERROR_FirstNameEmpty"]);
                        return false;
                    }
                    if(!MessageHelper.isValidUTF8length(form[firstName].value, 128)){ 
                        MessageHelper.formErrorHandleClient(form[firstName].id, MessageHelper.messages["ERROR_FirstNameTooLong"]); 
                        return false;
                    }
                }else if(field == "MIDDLE_NAME" || field == "middle_name"){
                    form[middleName].value = trim(form[middleName].value);
                    if(field == "MIDDLE_NAME" && (form[middleName].value == "" || reWhiteSpace.test(form[middleName].value))){ 
                        MessageHelper.formErrorHandleClient(form[middleName].id, MessageHelper.messages["ERROR_MiddleNameEmpty"]);
                        return false;
                    }
                    if(!MessageHelper.isValidUTF8length(form[middleName].value, 128)){ 
                        MessageHelper.formErrorHandleClient(form[middleName].id, MessageHelper.messages["ERROR_MiddleNameTooLong"]); 
                        return false;
                    }
                }else if(field == "use_org_address" || field == 'new_line'|| field == "PASSWORD" || field == "PASSWORD_VERIFY"){
                }else if(field == "ADDRESS" || field == "address"){
                    form[address1].value = trim(form[address1].value);
                    form[address2].value = trim(form[address2].value);
                    if(field == "ADDRESS" && ((form[address1].value == "" || reWhiteSpace.test(form[address1].value)) && (form[address2].value=="" || reWhiteSpace.test(form[address2].value)))){ 
                        MessageHelper.formErrorHandleClient(form[address1].id, MessageHelper.messages["ERROR_AddressEmpty"]);
                        return false;
                    }
                    if(!MessageHelper.isValidUTF8length(form[address1].value, 100)){ 
                        MessageHelper.formErrorHandleClient(form[address1].id, MessageHelper.messages["ERROR_AddressTooLong"]); 
                        return false;
                    }
                    if(!MessageHelper.isValidUTF8length(form[address2].value, 50)){ 
                        MessageHelper.formErrorHandleClient(form[address2].id, MessageHelper.messages["ERROR_AddressTooLong"]);
                        return false;
                    }
                }else if(field == "CITY" || field == "city"){
                    form[city].value = trim(form[city].value);
                    if(field == "CITY" && (form[city].value == "" || reWhiteSpace.test(form[city].value))){ 
                        MessageHelper.formErrorHandleClient(form[city].id, MessageHelper.messages["ERROR_CityEmpty"]);
                        return false;
                    }
                    if(!MessageHelper.isValidUTF8length(form[city].value, 128)){
                        MessageHelper.formErrorHandleClient(form[city].id, MessageHelper.messages["ERROR_CityTooLong"]);
                        return false;
                    }
                }else if(field == "STATE/PROVINCE" || field == "state/province"){
                    var state = form[state];
                    if(state == null || state == ""){
                        state = document.getElementById(this.stateDivName).firstChild;
                    }
                    state.value = trim(state.value);
                    if(field == "STATE/PROVINCE" && (state.value == null || state.value == "" || reWhiteSpace.test(state.value))){
                        if(state.tagName == "SELECT" || state.tagName == "select") {
                            MessageHelper.formErrorHandleClient(state.id + "-button", MessageHelper.messages["ERROR_StateEmpty"]);
                        } else {
                            MessageHelper.formErrorHandleClient(state.id, MessageHelper.messages["ERROR_StateEmpty"]);
                        }
                        return false;
                    }
                    if(!MessageHelper.isValidUTF8length(state.value, 128)){
                        if(state.tagName == "SELECT" || state.tagName == "select") {
                            MessageHelper.formErrorHandleClient(state.id + "-button", MessageHelper.messages["ERROR_StateTooLong"]);
                        } else {
                            MessageHelper.formErrorHandleClient(state.id, MessageHelper.messages["ERROR_StateTooLong"]);
                        }
                        return false;
                    }
                }else if(field == "COUNTRY/REGION" || field == "country/region"){
                    console.log(form[country].value);
                    form[country].value = trim(form[country].value);
                    if(field == "COUNTRY/REGION" && (form[country].value == "" || reWhiteSpace.test(form[country].value))){ 
                        MessageHelper.formErrorHandleClient(form[country].id + "-button", MessageHelper.messages["ERROR_CountryEmpty"]);
                        return false;
                    }
                    if(!MessageHelper.isValidUTF8length(form[country].value, 128)){ 
                        MessageHelper.formErrorHandleClient(form[country].id + "-button", MessageHelper.messages["ERROR_CountryTooLong"]);
                        return false;
                    }
                }else if(field == "ZIP" || field == "zip"){
                    form[zipCode].value = trim(form[zipCode].value);
                    //check zip code for validation
                    if(field == "ZIP" && (form[zipCode].value=="" || reWhiteSpace.test(form[zipCode].value))){ 
                        MessageHelper.formErrorHandleClient(form[zipCode].id, MessageHelper.messages["ERROR_ZipCodeEmpty"]);
                        return false;
                    }
                    if(!MessageHelper.isValidUTF8length(form[zipCode].value, 40)){ 
                        MessageHelper.formErrorHandleClient(form[zipCode].id, MessageHelper.messages["ERROR_ZipCodeTooLong"]);
                        return false;
                    }
                }else if(field == "EMAIL1" || field == "email1"){
                    form[email1].value = trim(form[email1].value);
                    if(field == "EMAIL1" && (form[email1].value == "" || reWhiteSpace.test(form[email1].value))){
                        MessageHelper.formErrorHandleClient(form[email1].id, MessageHelper.messages["ERROR_EmailEmpty"]);
                        return false;
                    }
                    if(!MessageHelper.isValidUTF8length(form[email1].value, 256)){ 
                        MessageHelper.formErrorHandleClient(form[email1].id, MessageHelper.messages["ERROR_EmailTooLong"]);
                        return false;
                    }
                    if(!MessageHelper.isValidEmail(form[email1].value)){
                        MessageHelper.formErrorHandleClient(form[email1].id, MessageHelper.messages["ERROR_INVALIDEMAILFORMAT"]);
                        return false;
                    }
                }else if(field == "PHONE1" || field == "phone1"){
                    form[phone1].value = trim(form[phone1].value);
                    if(field == "PHONE1" && (form[phone1].value == "" || reWhiteSpace.test(form[phone1].value))){
                        MessageHelper.formErrorHandleClient(form[phone1].id, MessageHelper.messages["ERROR_PhonenumberEmpty"]);
                        return false;
                    }
                    if(!MessageHelper.isValidUTF8length(form[phone1].value, 32)){ 
                        MessageHelper.formErrorHandleClient(form[phone1].id, MessageHelper.messages["ERROR_PhoneTooLong"]);
                        return false;
                    }
                    if(!MessageHelper.IsValidPhone(form[phone1].value)){
                        MessageHelper.formErrorHandleClient(form[phone1].id, MessageHelper.messages["ERROR_INVALIDPHONE"]);
                        return false;
                    }
                }else{
                    console.debug("error: mandatory field name " + mandatoryField + " is not recognized.");
                    return false;
                }
            }
            if (form[address1] && form[address1].value == "" && form[address2].value != "") {

            form[address1].value = form[address2].value;
            form[address2].value = "";
            }
            return true;
        }
        return false;
    },

    resetFormValue: function(target_name){
        var target = $("#" + target_name);
        target.find("form").each(function(index, form){
            $(form)[0].reset();
            $(form).find("select.wcSelect").each(function(index, select){
                $(select).Select("refresh_noResizeButton");
            })
        });
    }
};

var declareAccountaddressDetailRefreshArea = function() {
    // ============================================
    // div: addressDetailRefreshArea refresh area
    var myWidgetObj = $("#addressDetailRefreshArea");

    // common render context
    if (!wcRenderContext.checkIdDefined("myAcctAddressDetailContext")) {
        wcRenderContext.declare("myAcctAddressDetailContext", ["addressDetailRefreshArea"], {addressId: "0", type: "0"});
    }
    
    var myRCProperties = wcRenderContext.getRenderContextProperties("myAcctAddressDetailContext");

    // render content changed handler
    var renderContextChangedHandler = function() {
        if (wcRenderContext.testForChangedRC("myAcctAddressDetailContext", ["addressId"]) && myRCProperties["addressId"] != "0") {
            myWidgetObj.refreshWidget("refresh", myRCProperties);
        }
    };

    // post refresh handler
    var postRefreshHandler = function() {
        myRCProperties["addressId"] = "0";
        myRCProperties["type"] = "0";
    };

    // initialize widget
    myWidgetObj.refreshWidget({renderContextChangedHandler: renderContextChangedHandler, postRefreshHandler: postRefreshHandler});
};//-----------------------------------------------------------------
// Licensed Materials - Property of IBM
//
// WebSphere Commerce
//
// (C) Copyright IBM Corp. 2017 All Rights Reserved.
//
// US Government Users Restricted Rights - Use, duplication or
// disclosure restricted by GSA ADP Schedule Contract with
// IBM Corp.
//-----------------------------------------------------------------

AddressBookListJS = {

    /** 
     * This variable stores the ID of the language that the store currently uses. Its default value is set to -1, which corresponds to United States English.
     * @private
     */
    langId: "-1",
    /** 
     * This variable stores the ID of the current store. Its default value is empty.
     * @private
     */
    storeId: "",
    /** 
     * This variable stores the ID of the catalog. Its default value is empty.
     * @private
     */
    catalogId: "",
    authToken: "",
    addAddressURL: "",
    addressBookURL: "",

    /**
     * Sets the common parameters for the current page. 
     * For example, the language ID, store ID, and catalog ID.
     *
     * @param {Integer} langId The ID of the language that the store currently uses.
     * @param {Integer} storeId The ID of the current store.
     * @param {Integer} catalogId The ID of the catalog.
     * @param {Integer} authToken The authToken for current user to perform operation on server.
     * @param {String} addAddressURL The URL for adding an address.
     * @param {String} addressBookURL The URL for address book view.
     */
    setCommonParameters:function(langId,storeId,catalogId,authToken,addAddressURL,addressBookURL){
        this.langId = langId;
        this.storeId = storeId;
        this.catalogId = catalogId;
        this.authToken = authToken;
        this.addAddressURL = addAddressURL;
        this.addressBookURL = addressBookURL;
        cursor_clear();
    },

    /**
     * Redirect to add address page.
     */
    addAddress:function(){
        setPageLocation(this.addAddressURL);
    },

    /*
     * This function creates a new address in the address book.
     * This function takes a form containing the address information and invokes 'updateAddress' service.
     * After the address is created, this function will refresh the address display area using the given URL.
     * @param {string} formName The name of the form containing the address information. 
     */
    newUpdateAddressBook: function(formName){

        var form = document.forms[formName];

        for (var i=0; i<form.sbAddress.length; i++) {
            if (form.sbAddress[i].checked) {
                form.addressType.value=form.sbAddress[i].value;
            }
        }

        if(form.addressType.value == "") {
            MessageHelper.displayErrorMessage(MessageHelper.messages["AB_SELECT_ADDRTYPE"]);
            return;
        }
        /*Validate the form input fields. */
        if (AddressBookDetailJS.validateAddressForm(form)) {
            console.debug("creating with form id = "+formName);
            wcService.declare({
                id: "updateAddress",
                actionId: "updateAddress",
                url: "AjaxPersonChangeServiceAddressAdd",
                formId: formName,
                successHandler: function(serviceResponse) {
                    cursor_clear();
                    widgetCommonJS.redirect(AddressBookListJS.addressBookURL);
                },
                failureHandler: function(serviceResponse) {
                    if (serviceResponse.errorMessage) {
                        MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
                    } else if (serviceResponse.errorMessageKey) {
                        MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
                    }
                    cursor_clear();
                }
            });

            /*For Handling multiple clicks. */
            if(!submitRequest()){
                return;
            }
            cursor_wait();

            wcService.invoke("updateAddress");
        }
    },

    /*
     * This function deletes an address from the addressbook.
     * This function deletes an address currently selected and refreshes the address display area using the specified url.
    * @param {string} selectionName The id of the address dropdown box.
     * @param {string} addressDeleteUrl The url used to delete the address.
     * @param {string} addressUrl The url used to refresh the address display area.
     */

    newDeleteAddress: function(selectionName,addressDeleteUrl,addressUrl){

        var addressBox = $("#" + selectionName);
        if(addressBox.val() == $("#" + selectionName + " option:nth-child(1)").val()) {
            MessageHelper.formErrorHandleClient(selectionName + "-button",MessageHelper.messages["ERROR_DEFAULTADDRESS"]);
            return;
        }
        if(addressBox.val() =='') {
            MessageHelper.formErrorHandleClient(selectionName + "-button",MessageHelper.messages["ERROR_SELECTADDRESS"]);
            return;
        }
        var params = [];
        params.storeId = this.storeId;
        params.catalogId = this.catalogId;
        params.addressId = addressBox.val();
        params.URL = addressUrl;
        params.nickName = $.trim($("#" + selectionName + "-button span:nth-child(2)").text());
        wcService.declare({
            id: "AddressDelete",
            actionId: "AddressDelete",
            url: addressDeleteUrl,
            successHandler: function(serviceResponse) {
                MessageHelper.displayStatusMessage(MessageHelper.messages["AB_DELETE_SUCCESS"]);
                cursor_clear();
            },
            failureHandler: function(serviceResponse) {
                if (serviceResponse.errorMessage) {
                    MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
                } else {
                    if (serviceResponse.errorMessageKey) {
                    MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
                    }
                }
                cursor_clear();
            }
        });

        /*For Handling multiple clicks. */
        if(!submitRequest()){
            return;
        }
        cursor_wait();
        wcService.invoke("AddressDelete",params);
    }
};

var declareAccountAddressBookRefreshArea = function() {
    // ============================================
    // div: addressBookListDiv refresh area
    var myWidgetObj = $("#addressBookListDiv");

    // common render context
    if (!wcRenderContext.checkIdDefined("myAcctAddressBookContext")) {
        wcRenderContext.declare("myAcctAddressBookContext", ["addressBookListDiv"], {addressId: "0", type: "0"});
    }
    var myRCProperties = wcRenderContext.getRenderContextProperties("myAcctAddressBookContext");

    // model change
    wcTopic.subscribe(["updateAddressBook", "AddressDelete"], function() {
        myWidgetObj.refreshWidget("refresh");
    });

    // render content changed handler
    var renderContextChangedHandler = function() {
        if (wcRenderContext.testForChangedRC("myAcctAddressBookContext", ["addressId"])) {
            myWidgetObj.refreshWidget("refresh", myRCProperties);
        }
    };

    var postRefreshHandler = function() {
        myRCProperties["addressId"] = "0";
        myRCProperties["type"] = "0";
        declareAccountaddressDetailRefreshArea();
        wcRenderContext.updateRenderContext('myAcctAddressDetailContext', {'addressId':"0", 'type':"0"});
    }
    
    // initialize widget
    myWidgetObj.refreshWidget({renderContextChangedHandler: renderContextChangedHandler, postRefreshHandler: postRefreshHandler});
}//-----------------------------------------------------------------
// Licensed Materials - Property of IBM
//
// WebSphere Commerce
//
// (C) Copyright IBM Corp. 2007, 2016 All Rights Reserved.
//
// US Government Users Restricted Rights - Use, duplication or
// disclosure restricted by GSA ADP Schedule Contract with
// IBM Corp.
//-----------------------------------------------------------------

/**
 *@fileOverview This javascript file defines all the javascript functions used by approval comment widget
 */

	ApprovalCommentJS = {
			
		/** 
		 * This variable stores the ID of the language that the store currently uses. Its default value is set to -1, which corresponds to United States English.
		 * @private
		 */
		langId: "-1",
		
		/** 
		 * This variable stores the ID of the current store. Its default value is empty.
		 * @private
		 */
		storeId: "",
		
		/** 
		 * This variable stores the ID of the catalog. Its default value is empty.
		 * @private
		 */
		catalogId: "",
		
		/**
		* These variables define approve or reject status in the APRVSTATUS table. 1 for approved or 2 for rejected.
		*/
		cApproveStatus: 1,
		cRejectStatus: 2,
		
		/**
		 * Sets the common parameters for the current page. 
		 * For example, the language ID, store ID, and catalog ID.
		 *
		 * @param {Integer} langId The ID of the language that the store currently uses.
		 * @param {Integer} storeId The ID of the current store.
		 * @param {Integer} catalogId The ID of the catalog.
		 */
		setCommonParameters: function(langId,storeId,catalogId){
			this.langId = langId;
			this.storeId = storeId;
			this.catalogId = catalogId;
		},
		
		/**
		* Approves a approval record
		*/
		approveRecord: function(aprvstatus_id) {
			if(MessageHelper.utf8StringByteLength($('#approvalForm_comments').val()) > 254){ 
				MessageHelper.formErrorHandleClient($('#approvalForm_comments')[0], MessageHelper.messages["APP_COMMENT_ERR_TOO_LONG"]); 
				return false;
			}
			
			service = wcService.getServiceById('AjaxApproveRequest');
			var params = {
                storeId: this.storeId,
                catalogId: this.catalogId,
                langId: this.langId,
                aprv_act: this.cApproveStatus,
                approvalStatusId: aprvstatus_id,
                viewtask: "BuyerApprovalDetailView"
            };
			if ($("#approvalForm_comments").length) {
				params.comments = $("#approvalForm_comments").val();
			}

			/*For Handling multiple clicks. */
			if(!submitRequest()){
				return;
			}			
			cursor_wait();
			wcService.invoke('AjaxApproveRequest',params);		
		},

		/**
		* Rejects a approval record
		*/
		rejectRecord: function(aprvstatus_id) {
			if(MessageHelper.utf8StringByteLength($('#approvalForm_comments').val()) > 254){ 
				MessageHelper.formErrorHandleClient($('#approvalForm_comments')[0], MessageHelper.messages["APP_COMMENT_ERR_TOO_LONG"]); 
				return false;
			}
			
			service = wcService.getServiceById('AjaxRejectRequest');
			var params = {
                storeId: this.storeId,
                catalogId: this.catalogId,
                langId: this.langId,
                aprv_act: this.cRejectStatus,
                approvalStatusId: aprvstatus_id,
                viewtask: "BuyerApprovalDetailView"
            };
			if ($("#approvalForm_comments").length) {
				params.comments = $("#approvalForm_comments").val();
			}

			/*For Handling multiple clicks. */
			if(!submitRequest()){
				return;
			}			
			cursor_wait();
			wcService.invoke('AjaxRejectRequest',params);		
		}

	}//-----------------------------------------------------------------
// Licensed Materials - Property of IBM
//
// WebSphere Commerce
//
// (C) Copyright IBM Corp. 2014, 2016 All Rights Reserved.
//
// US Government Users Restricted Rights - Use, duplication or
// disclosure restricted by GSA ADP Schedule Contract with
// IBM Corp.
//-----------------------------------------------------------------

/**
 *@fileOverview This javascript file defines all the javascript functions used by buyer approval widget
 */
	BuyerApprovalListJS = {
			
		/** 
		 * This variable stores the ID of the language that the store currently uses. Its default value is set to -1, which corresponds to United States English.
		 * @private
		 */
		langId: "-1",
		
		/** 
		 * This variable stores the ID of the current store. Its default value is empty.
		 * @private
		 */
		storeId: "",
		
		/** 
		 * This variable stores the ID of the catalog. Its default value is empty.
		 * @private
		 */
		catalogId: "",
		
		/**
		* These variables define approve or reject status in the APRVSTATUS table. 1 for approved or 2 for rejected.
		*/
		cApproveStatus: 1,
		cRejectStatus: 2,
		
		/**
		* These variables refers to Ids of startSubmitDate and endSubmitDate element in BuyerApprovalList_ToolBar_UI.jspf.
		*/
		formStartDateId: "",
		formEndDateId: "",
		
		/**
		 * Search tool bar Id
		 */
		toolbarId: "",
		
		/**
		 * Sets the common parameters for the current page. 
		 * For example, the language ID, store ID, and catalog ID.
		 *
		 * @param {Integer} langId The ID of the language that the store currently uses.
		 * @param {Integer} storeId The ID of the current store.
		 * @param {Integer} catalogId The ID of the catalog.
		 */
		setCommonParameters: function(langId,storeId,catalogId){
			this.langId = langId;
			this.storeId = storeId;
			this.catalogId = catalogId;
		},
		
		/**
		 * Sets the common parameters for the current page. 
		 *
		 * @param {String} formStartDateId The ID of the startDate element.
		 * @param {String} formEndDateId The ID of the endDate element.
		 * @param {String} toolbarId The ID of the tool bar element.
		 */
		setToolbarCommonParameters: function(formStartDateId,formEndDateId, toolbarId){
			this.formStartDateId = formStartDateId;
			this.formEndDateId = formEndDateId;
			this.toolbarId = toolbarId;
		},
		
		/**
		* Approves a buyer record
		* @param {Long} aprvstatus_id The id of the request to be approved
		*/
		approveBuyer: function(aprvstatus_id) {
			service = wcService.getServiceById('AjaxApproveBuyerRequest');

			var params = {};
			params.storeId = this.storeId;
			params.catalogId = this.catalogId;
			params.langId = this.langId;
			params.aprv_act = this.cApproveStatus;
			params.approvalStatusId = aprvstatus_id;
			params.viewtask = "BuyerApprovalView";

			/*For Handling multiple clicks. */
			if(!submitRequest()){
				return;
			}			
			cursor_wait();
			wcService.invoke('AjaxApproveBuyerRequest',params);		
		},

		/**
		* Rejects a buyer record
		* @param {Long} aprvstatus_id The id of the request to be approved
		*/
		rejectBuyer: function(aprvstatus_id) {
			service = wcService.getServiceById('AjaxRejectBuyerRequest');

			var params = {};
			params.storeId = this.storeId;
			params.catalogId = this.catalogId;
			params.langId = this.langId;
			params.aprv_act = this.cRejectStatus;
			params.approvalStatusId = aprvstatus_id;
			params.viewtask = "BuyerApprovalView";

			/*For Handling multiple clicks. */
			if(!submitRequest()){
				return;
			}			
			cursor_wait();
			wcService.invoke('AjaxRejectBuyerRequest',params);
		},
		
		/**
		* This function is called when user selects a different page from the current page
		* @param (Object) data The object that contains data used by pagination control 
		*/
		showResultsPage:function(data){
			var pageNumber = data['pageNumber'];
			var pageSize = data['pageSize'];
			pageNumber = parseInt(pageNumber);
			pageSize = parseInt(pageSize);
			this.saveToolbarStatus();
			setCurrentId(data["linkId"]);

			if(!submitRequest()){
				return;
			}

			var beginIndex = pageSize * ( pageNumber - 1 );
			cursor_wait();

			wcRenderContext.updateRenderContext('BuyerApprovalTable_Context', {"beginIndex": beginIndex});
			MessageHelper.hideAndClearMessage();
		},
		
		/**
		 * Clear the context search term value set by search form
		 */
		reset:function(){
			this.updateContext({"beginIndex":"0", "approvalId": "", "firstName": "", "lastName":"","startDate":"","endDate":""});
		},
		
		/**
		 * Search for buyer approval requests use the search terms specified in the toolbar search form.
		 * 
		 * @param (String) formId	The id of toolbar search form element.
		 */
		doSearch:function(formId){
			var form = $("#" + formId)[0];
			var startDateValue = "";
			var endDateValue = "";
			var startDateWidgetValue = $("#" + this.formStartDateId + "_datepicker").datepicker("getDate");
			if (Utils.varExists(startDateWidgetValue)){
				startDateValue = startDateWidgetValue.toISOString().replace(/\.\d\d\dZ/, '+0000');
			}
			var endDateWidgetValue = $("#" + this.formEndDateId + "_datepicker").datepicker("getDate");
			if (Utils.varExists(endDateWidgetValue)){
				//add one day to the picked endDate.We pick a date the value for the date object
				//is yyyy-MM-dd 00:00:00(beginning of a day, we need it to be end of the a day)
				endDateWidgetValue = Utils.addDays(endDateWidgetValue, 1);
				//deduct one millisecond from the added date
				endDateWidgetValue = Utils.addMilliseconds(endDateWidgetValue, -1);
				endDateValue = endDateWidgetValue.toISOString().replace(/\.\d\d\dZ/, '+0000');
			}
			this.updateContext({
				"beginIndex":"0",
				"approvalId": form.approvalId.value.replace(/^\s+|\s+$/g, ''),
				"firstName":form.submitterFirstName.value.replace(/^\s+|\s+$/g, ''),
				"lastName":form.submitterLastName.value.replace(/^\s+|\s+$/g, ''),
				"startDate":startDateValue,
				"endDate":endDateValue
			});
		},
		
		/**
		 * Filter the buyer Approval list by status
		 * 
		 * @param (String) status The id of toolbar search form element.
		 */
		doFilter:function(status){
			this.updateContext({"beginIndex":"0", "approvalStatus": status});
		},
		
		/**
		 * Update the BuyerApprovalTable_Context context with given context object.
		 * 
		 * @param (Object)context The context object to update
		 */
		updateContext:function(context){
			this.saveToolbarStatus();
			if(!submitRequest()){
				return;
			}			
			cursor_wait();
			wcRenderContext.updateRenderContext("BuyerApprovalTable_Context", context);
			MessageHelper.hideAndClearMessage();
		},
		
		/**
		 * Save the toolbar aria-expanded attribute value
		 */
		saveToolbarStatus:function(){
			Utils.ifSelectorExists("#" + this.toolbarId, function($toolbar) {
				this.toolbarExpanded = $toolbar.attr("aria-expanded");
			}, this);
		},
		
		/**
		 * Restore the toolbar aria-expanded attribute, called by post-refresh handler
		 */
		restoreToolbarStatus:function(){
			if (Utils.varExists(this.toolbarExpanded)){
				$("#" + this.toolbarId).attr("aria-expanded", this.toolbarExpanded);
			}
		}
	}//-----------------------------------------------------------------
// Licensed Materials - Property of IBM
//
// WebSphere Commerce
//
// (C) Copyright IBM Corp. 2011, 2016 All Rights Reserved.
//
// US Government Users Restricted Rights - Use, duplication or
// disclosure restricted by GSA ADP Schedule Contract with
// IBM Corp.
//-----------------------------------------------------------------

// Declare context and refresh controller which are used in pagination controls of SearchBasedNavigationDisplay -- both products and articles+videos
wcRenderContext.declare("searchBasedNavigation_context", ["searchBasedNavigation_content_widget"], { "contentBeginIndex": "0", "productBeginIndex": "0", "beginIndex": "0", "orderBy": "", "facetId": "", "pageView": "", "resultType": "both", "orderByContent": "", "searchTerm": "", "facet": "", "facetLimit": "", "minPrice": "", "maxPrice": "", "pageSize": "" });

// Declare context and refresh controller which are used in pagination controls of SearchBasedNavigationDisplay to display content results (Products).
var searchBasedNavigation_controller_initProperties = {

    renderContextChangedHandler: function(refreshAreaDiv) {
        var rcProperties = wcRenderContext.getRenderContextProperties("searchBasedNavigation_context");
        var resultType = rcProperties["resultType"];
        rcProperties["pgl_widgetId"] = refreshAreaDiv.attr("pglwidgetid");
        if (["products", "both"].indexOf(resultType) > -1) {
            rcProperties["beginIndex"] = rcProperties["productBeginIndex"];
            refreshAreaDiv.refreshWidget("refresh", rcProperties);
        }

    },
    postRefreshHandler: function(widget) {
        // Handle the new facet counts, and update the values in the left navigation.  First parse the script, and then call the update function.        
        var rcProperties = wcRenderContext.getRenderContextProperties("searchBasedNavigation_context"),
            objectId = widget.attr("objectid"),
            facetCounts = byId("#facetCounts" + objectId);

        if (facetCounts != null) {
            var scripts = facetCounts.getElementsByTagName("script");
            var j = scripts.length;
            for (var i = 0; i < j; i++) {
                var newScript = document.createElement('script');
                newScript.type = "text/javascript";
                newScript.text = scripts[i].text;
                facetCounts.appendChild(newScript);
            }
            SearchBasedNavigationDisplayJS.resetFacetCounts();

            //uncomment this if you want tohide zero facet values and the facet itself
            //SearchBasedNavigationDisplayJS.removeZeroFacetValues();
            SearchBasedNavigationDisplayJS.validatePriceInput();
        }
        updateFacetCounts();
        SearchBasedNavigationDisplayJS.cleanUpAddedFacets();

        SearchBasedNavigationDisplayJS.removeEmptyFacet();
        var pairs = location.hash.substring(1).split(SearchBasedNavigationDisplayJS.contextValueSeparator);
        for (var k = 0; k < pairs.length; k++) {
            var pair = pairs[k].split(":");
            if (pair[0] == "facet") {
                var ids = pair[1].split(",");
                for (var i = 0; i < ids.length; i++) {
                    var e = byId(ids[i]);
                    if (e) {
                        e.checked = true;
                        if (e.title != "MORE") {
                            SearchBasedNavigationDisplayJS.appendFilterFacet(ids[i]);
                        }
                    }
                }
            }
        }


        var resultType = rcProperties["resultType"];
        if (["products", "both"].indexOf(resultType) > -1) {
            var currentIdValue = currentId;
            cursor_clear();
            SearchBasedNavigationDisplayJS.initControlsOnPage(objectId, rcProperties);
            shoppingActionsJS.updateSwatchListView();
            shoppingActionsJS.checkForCompare();
            var gridViewLinkId = "WC_SearchBasedNavigationResults_pagination_link_grid_categoryResults";
            var listViewLinkId = "WC_SearchBasedNavigationResults_pagination_link_list_categoryResults";
            var selectedFacet = $("#filter_" + currentIdValue + " > a")[0];
            var deSelectedFacet = $("li[id^='facet_" + currentIdValue + "']" + " .facetbutton")[0];

            if (selectedFacet != null && selectedFacet != 'undefined') {
                selectedFacet.focus();
            } else if (deSelectedFacet != null && deSelectedFacet != 'undefined') {
                deSelectedFacet.focus();
            } else if (currentIdValue == "orderBy") {
                $("#orderBy" + objectId).focus();
            } else {
                if ((currentIdValue == gridViewLinkId || currentIdValue != listViewLinkId) && byId(listViewLinkId)) {
                    byId(listViewLinkId).focus();
                }
                if ((currentIdValue == listViewLinkId || currentIdValue != gridViewLinkId) && byId(gridViewLinkId)) {
                    byId(gridViewLinkId).focus();
                }
            }
        }
        var pagesList = document.getElementById("pages_list_id");
        if (pagesList != null && !isAndroid() && !isIOS()) {
            $(pagesList).addClass("desktop");
        }
	
	/* APPLEPAY BEGIN */
	if (typeof(showApplePayButtons) == "function") {
		showApplePayButtons();
	}
	/* APPLEPAY END */
        wcTopic.publish("CMPageRefreshEvent");
    }
};

// Declare context and refresh controller which are used in pagination controls of SearchBasedNavigationDisplay to display content results (Articles and videos).
var declareSearchBasedNavigationContentController = function() {
    var widgetObj = $("#searchBasedNavigation_content_widget"),
        rcProperties = wcRenderContext.getRenderContextProperties("searchBasedNavigation_context");

    widgetObj.refreshWidget({
        renderContextChangedHandler: function() {
            var resultType = rcProperties["resultType"];
            if (["content", "both"].indexOf(resultType) > -1) {
                rcProperties["beginIndex"] = rcProperties["contentBeginIndex"];
                widgetObj.refreshWidget("refresh", rcProperties);
            }
        },
        postRefreshHandler: function() {
            var resultType = rcProperties["resultType"];
            if (["content", "both"].indexOf(resultType) > -1) {
                var currentIdValue = currentId;
                cursor_clear();
                SearchBasedNavigationDisplayJS.initControlsOnPage(widgetObj.objectId, rcProperties);
                //shoppingActionsJS.initCompare();
                if (currentIdValue == "orderByContent") {
                    byId("orderByContent").focus();
                }
            }
            wcTopic.publish("CMPageRefreshEvent");
        }
    });

};

if (typeof(SearchBasedNavigationDisplayJS) == "undefined" || SearchBasedNavigationDisplayJS == null || !SearchBasedNavigationDisplayJS) {

    SearchBasedNavigationDisplayJS = {

        /**
         * This variable is an array to contain all of the facet ID's generated from the initial search query.  This array will be the master list when applying facet filters.
         */
        contextValueSeparator: "&",
        contextKeySeparator: ":",
        widgetId: "",
        facetIdsArray: [],
        facetIdsParentArray: [],
        uniqueParentArray: [],
        selectedFacetLimitsArray: [],
        facetFromRest: [],

        init: function(widgetSuffix, searchResultUrl, widgetProperties) {
            $('#searchBasedNavigation_widget' + widgetSuffix).refreshWidget("updateUrl", matchUrlProtocol(searchResultUrl));
            var widgetInitProperties = {};
            $.extend(widgetInitProperties, WCParamJS, widgetProperties);
            this.initControlsOnPage(widgetSuffix, widgetInitProperties);
            this.updateContextProperties("searchBasedNavigation_context", widgetInitProperties);

            //			var currentContextProperties = wcRenderContext.getRenderContextProperties('searchBasedNavigation_context').properties;
        },

        initConstants: function(removeCaption, moreMsg, lessMsg, currencySymbol) {
            this.removeCaption = removeCaption;
            this.moreMsg = moreMsg;
            this.lessMsg = lessMsg;
            this.currencySymbol = currencySymbol;
        },

        initControlsOnPage: function(widgetSuffix, properties) {
            //Set state of sort by select box..
            $("#orderBy" + widgetSuffix).val(properties['orderBy']);

            $("#orderByContent").val(properties['orderByContent']);
        },

        initContentUrl: function(contentUrl) {
            $("#searchBasedNavigation_content_widget").refreshWidget("updateUrl", contentUrl);
        },

        findContainer: function(el) {
            //console.debug(el);
            while (el.parentNode) {
                el = el.parentNode;
                if (el.className == 'optionContainer') {
                    return el;
                }
            }
            return null;
        },

        resetFacetCounts: function() {
            for (var i = 0; i < this.facetIdsArray.length; i++) {
                var facetValue = byId("facet_count" + this.facetIdsArray[i]);
                var facetAcceValue = byId(this.facetIdsArray[i] + "_ACCE_Label_Count");
                if (facetValue != null) {
                    facetValue.innerHTML = 0;
                }
                if (facetAcceValue != null) {
                    facetAcceValue.innerHTML = 0;
                }
            }
        },

        removeEmptyFacet: function() {
            var widget = this.widgetId;
            for (var i = 0; i < this.facetIdsArray.length; i++) {
                var facetId = "facet_" + this.facetIdsArray[i];
                var facetValue = byId("facet_count" + this.facetIdsArray[i]);

                if (facetValue.innerHTML == '0') {
                    $("#" + facetId + widget).css("display", 'none');
                } else if (facetValue.innerHTML != '0') {
                    $("#" + facetId + widget).css("display", 'block');
                }
            }
        },

        removeZeroFacetValues: function() {
            var uniqueId = this.uniqueParentArray;
            var widget = this.widgetId;
            for (var i = 0; i < this.facetIdsArray.length; i++) {
                var facetId = "facet_" + this.facetIdsArray[i];
                var parentId = this.facetIdsParentArray[i];
                var facetValue = byId("facet_count" + this.facetIdsArray[i]);

                if (facetValue.innerHTML == '0') {
                    $("#" + facetId + widget).css("display", 'none');
                } else if (facetValue.innerHTML != '0') {
                    $("#" + facetId + widget).css("display", 'block');
                    uniqueId[parentId] = uniqueId[parentId] + 1;
                }
            }
            for (var key in uniqueId) {
                if (uniqueId[key] == 0) {
                    document.getElementById(key).style.display = 'none';
                    uniqueId[key] = 0; //reset the count
                } else if (uniqueId[key] != 0) {
                    document.getElementById(key).style.display = 'block';
                    uniqueId[key] = 0; //reset the count
                }
            }

        },
        updateFacetCount: function(id, count, value, label, image, contextPath, group, multiFacet) {
            var facetValue = byId("facet_count" + id);
            var widget = this.widgetId;
            if (facetValue != null) {
                var checkbox = byId(id);
                var facetAcceValue = byId(id + "_ACCE_Label_Count");
                if (count > 0) {
                    // Reenable the facet link
                    checkbox.disabled = false;
                    if (facetValue != null) {
                        facetValue.innerHTML = count;
                    }
                    if (facetAcceValue != null) {
                        facetAcceValue.innerHTML = count;
                    }
                }
            } else if (count > 0) {
                // there is no limit to the number of facets shown, and the user has exposed the show all link
                if (byId("facet_" + id) == null) {
                    // this facet does not exist in the list.  Insert it.
                    var divContainer = $("[id^='section_list_" + group + "']")[0];
                    var grouping = $(" > ul.facetSelect", divContainer)[0];
                    if (grouping) {
                        this.facetIdsArray.push(id);
                        var newFacet = document.createElement("li");
                        newFacet.setAttribute("onclick", "SearchBasedNavigationDisplayJS.triggerCheckBox(this)");
                        var newCheckBox = document.createElement("div");
                        var newCheckMark = document.createElement("div");
                        var facetClass = "";
                        var section = "";
                        if (!multiFacet) {
                            if (image !== "") {
                                facetClass = "singleFacet";
                            }
                            // specify which facet group to collapse when multifacets are not enabled.
                            section = group;
                        }
                        if (image !== "") {
                            facetClass = "singleFacet left";
                        }
                        if (image === "") {
                            $(newCheckBox).attr("class", "checkBox");
                            $(newCheckMark).attr("class", "checkmarkMulti");
                        }
                        $(newFacet).attr("id", "facet_" + id + widget);
                        $(newFacet).attr("class", facetClass);
                        newFacet.setAttribute("data-additionalvalues", "More")
                        var facetLabel = "<label for='" + id + "'>";
                        if (image !== "") {
                            facetLabel = facetLabel + "<span class='swatch'><span class='outline'><span id='facetLabel_" + id + "'><img src='" + image + "' title='" + label + "' alt='" + label + "'/></span> <div class='facetCountContainer'>(<span id='facet_count" + id + "'>" + count + "</span>)</div>";
                        } else {
                            facetLabel = facetLabel + "<span class='outline'><span id='facetLabel_" + id + "'>" + label + "</span> (<span id='facet_count" + id + "'>" + count + "</span>)</span>";
                        }
                        facetLabel = facetLabel + "<span class='spanacce' id='" + id + "_ACCE_Label'>" + label + " (" + count + ")</span></label>";
                        newFacet.innerHTML = "<input type='checkbox' aria-labelledby='" + id + "_ACCE_Label' id='" + id + "' value='" + value + "' onclick='javascript: SearchBasedNavigationDisplayJS.setEnabledShowMoreLinks(this, \"morelink_" + group + "\");SearchBasedNavigationDisplayJS.toggleSearchFilter(this, \"" + id + "\");'/>" + facetLabel;

                        var clearFloat = $(" > div.clear_float", grouping)[0];
                        if (clearFloat != undefined) {
                            grouping.removeChild(clearFloat);
                        }
                        grouping.appendChild(newFacet);
                        if (image === "") {
                            newFacet.appendChild(newCheckBox);
                            newCheckBox.appendChild(newCheckMark);
                        }
                    }
                }
            }
        },

        triggerCheckBox: function(elem) {
            var inputBox = elem.children[0];
            inputBox.click();
        },

        cleanUpAddedFacets: function() {
            for (var i = 0; i < this.facetIdsArray.length; i++) {
                var removeFacet = true;
                for (var j = 0; j < this.facetFromRest.length; j++) {
                    if (this.facetIdsArray[i] == this.facetFromRest[j]) {
                        removeFacet = false;
                        break;
                    }
                }
                if (removeFacet) {
                    var elem = byId("facet_" + this.facetIdsArray[i]);
                    if (elem != null) {
                        elem.parentNode.removeChild(elem);
                    }
                }
            }
        },

        setEnabledShowMoreLinks: function(element, section_id) {
            if (element.checked) {
                this.selectedFacetLimitsArray.push(section_id + "|" + element.id + "|" + element.value);
                this.removeShowMoreFromFacetLimitArray(section_id);
            } else {
                var index = this.selectedFacetLimitsArray.indexOf(section_id + "|" + element.id + "|" + element.value);
                if (index > -1) {
                    this.selectedFacetLimitsArray.splice(index, 1);
                }
            }
        },



        isValidNumber: function(n) {
            var valueToParse = n;
            valueToParse = valueToParse.replace(/^\s+|\s+$/g, "");
            valueToParse = valueToParse.replace(/\xa0/g, '');
            var valueToParse = valueToParse;

            if (Utils.getLocale() === 'ar_EG') {
                valueToParse = valueToParse.replace(',', '');
                var parsedAmountValue = Utils.round(valueToParse, 2);
            } else {
                var parsedAmountValue = Utils.round(valueToParse, 2);
            }
            return !isNaN(parsedAmountValue);
        },
        convertToInternalValue: function(val) {
            var valueToParse = val;
            valueToParse = valueToParse.replace(/^\s+|\s+$/g, "");
            valueToParse = valueToParse.replace(/\xa0/g, '');
            var valueToParse = valueToParse;

            if (Utils.getLocale() === 'ar_EG') {
                valueToParse = valueToParse.replace(',', '');
                var parsedAmountValue = Utils.round(valueToParse, 2);
            } else {
                var parsedAmountValue = Utils.round(valueToParse, 2);
            }
            return parsedAmountValue;
        },

        onGoButtonPress: function() {
            var low = $("#low_price_input").val(),
                high = $("#high_price_input").val();
            window.location.href = Utils.updateQueryStringParameter(window.location.href, {
                minPrice: low,
                maxPrice: high
            });
        },

        onPriceInput: function(event) {
            var enterPressed = (event.keyCode === KeyCodes.RETURN),
                inputValid = this.validatePriceInput(enterPressed);
            if (inputValid && enterPressed) {
                this.onGoButtonPress();
            } else {
                this.toggleGoButton(inputValid);
            }
        },

        toggleGoButton: function(enable) {
            var go = $("#price_range_go");
            if (go.length) {
                if (enable) {
                    go.attr("class", "go_button");
                    go.prop("disabled", false);
                } else {
                    go.attr("class", "go_button_disabled");
                    go.prop("disabled", true);
                }
            }
        },

        validatePriceInput: function(showErrorMsg) {
            if ($("#low_price_input").length && $("#high_price_input").length) {
                var low = $("#low_price_input").val();
                var high = $("#high_price_input").val();
                if (!this.isValidNumber(low)) {
                    if (showErrorMsg) {
                        MessageHelper.formErrorHandleClient("low_price_input", Utils.getLocalizationMessage('ERROR_FACET_PRICE_INVALID'));
                    }
                    return false;
                } else if (!this.isValidNumber(high)) {
                    if (showErrorMsg) {
                        MessageHelper.formErrorHandleClient("high_price_input", Utils.getLocalizationMessage('ERROR_FACET_PRICE_INVALID'));
                    }
                    return false;
                } else if (parseFloat(high) < parseFloat(low)) {
                    if (showErrorMsg) {
                        MessageHelper.formErrorHandleClient("high_price_input", Utils.getLocalizationMessage('ERROR_FACET_PRICE_INVALID'));
                    }
                    return false;
                } else {
                    return true;
                }
            }
            return false;
        },

        toggleShowMore: function(index, show) {
            var list = byId('more_' + index);
            var morelink = byId('morelink_' + index);
            if (list != null) {
                if (show) {
                    morelink.style.display = "none";
                    list.style.display = "inline-block";
                } else {
                    morelink.style.display = "inline-block";
                    list.style.display = "none";
                }
            }
        },

        toggleSearchFilterOnKeyDown: function(event, element, id) {
            if (event.keyCode === KeyCodes.RETURN) {
                //element.checked = !element.checked;
                this.toggleSearchFilter(element, id);
            }
        },

        toggleSearchFilter: function(element, id) {
            if (element.checked) {
                this.appendFilterFacet(id);
            } else {
                this.removeFilterFacet(id);
            }

            /*

            			if(section !== "") {
            				byId('section_' + section).style.display = "none";
            			}
            */
            this.doSearchFilter();
        },

        appendFilterPriceRange: function(currencySymbol) {

            var el = byId("price_range_input");
            var section = this.findContainer(el);
            if (section) {
                byId(section.id).style.display = "none";
            }
            /*
			byId("clear_all_filter").style.display = "block";
            
			var facetFilterList = byId("facetFilterList");
			// create facet filter list if it's not exist
			if (facetFilterList == null) {
				facetFilterList = document.createElement("ul");
				$(facetFilterList).attr("id", "facetFilterList");
				$(facetFilterList).attr("class", "facetSelectedCont");
				var facetFilterListWrapper = byId("facetFilterListWrapper");
				facetFilterListWrapper.appendChild(facetFilterList);
			}

			var filter = byId("pricefilter");
			if(filter == null) {
				filter = document.createElement("li");
				$(filter).attr("id", "pricefilter");
				$(filter).attr("class", "facetSelected");
				facetFilterList.appendChild(filter);
			}
			var label = currencySymbol + byId("low_price_input").value + " - " + currencySymbol + $("#high_price_input").val();
			filter.innerHTML = "<a role='button' href='#' onclick='wcTopic.publish(\"Facet_Remove\"); return false;'>" + "<div class='filter_option'><div class='close'></div><span>" + label + "</span><div class='clear_float'></div></div></a>";

			byId("clear_all_filter").style.display = "block";
            */
            if (this.validatePriceInput()) {
                // Promote the values from the input boxes to the internal inputs for use in the request.
                byId("low_price_value").value = this.convertToInternalValue(byId("low_price_input").value);
                byId("high_price_value").value = this.convertToInternalValue(byId("high_price_input").value);
            }

        },

        removeFilterPriceRange: function() {
            console.error("should not be calling this");
            /*
			if($("#low_price_value").length && $("#high_price_value").length) {
				byId("low_price_value").value = "";
				byId("high_price_value").value = "";
			}
			var facetFilterList = byId("facetFilterList");
			var filter = byId("pricefilter");
			if(filter != null) {
				facetFilterList.removeChild(filter);
			}

			if(facetFilterList.childNodes.length == 0) {
				byId("clear_all_filter").style.display = "none";
				byId("facetFilterListWrapper").innerHTML = "";
			}

			var el = byId("price_range_input");
			var section = this.findContainer(el);
			if(section) {
				byId(section.id).style.display = "block";
			}

			this.doSearchFilter(); */
        },

        appendFilterFacet: function(id) {
            var facetFilterList = byId("facetFilterList");
            // create facet filter list if it's not exist
            if (facetFilterList == null) {
                facetFilterList = document.createElement("ul");
                $(facetFilterList).attr("id", "facetFilterList");
                $(facetFilterList).attr("class", "facetSelectedCont");
                var facetFilterListWrapper = byId("facetFilterListWrapper");
                facetFilterListWrapper.appendChild(facetFilterList);
            }

            var filter = byId("filter_" + id);
            // do not add it again if the user clicks repeatedly
            if (filter == null) {
                filter = document.createElement("li");
                $(filter).attr("id", "filter_" + id);
                $(filter).attr("class", "facetSelected");
                var label = byId("facetLabel_" + id).innerHTML;
                var acceRemoveLabel = "<span class='spanacce' id='ACCE_Label_Remove'>" + MessageHelper.messages['REMOVE'] + "</span>";

                filter.innerHTML = "<a role='button' href='#' onclick='javascript:setCurrentId(\"" + id + "\");wcTopic.publish(\"Facet_Remove\", \"" + id + "\"); return false;'>" + "<div class='filter_option'><div class='close'></div><span>" + label + "</span>" + acceRemoveLabel + "<div class='clear_float'></div></div></a>";

                facetFilterList.appendChild(filter);
            }

            $("#facetLabel_" + id).parent().attr("class", "outline facetSelectedHighlight");

            var el = byId(id);
            var section = this.findContainer(el);
            if (section) {
                byId(section.id).style.display = "none";
            }
            byId("clear_all_filter").style.display = "block";

        },

        removeFilterFacet: function(id) {
            var facetFilterList = byId("facetFilterList");
            var filter = byId("filter_" + id);
            if (filter != null) {
                var value = byId(id).value;
                var section_id = value.split("%3A%22")[0];
                var index = this.selectedFacetLimitsArray.indexOf("morelink_" + section_id + "|" + id + "|" + value);

                if (index == -1) {
                    value = value.replace(/%3A/g, ":");
                    value = value.replace(/%22/g, '"');
                    index = this.selectedFacetLimitsArray.indexOf("morelink_" + section_id + "|" + id + "|" + value);
                }

                if (index > -1) {
                    this.selectedFacetLimitsArray.splice(index, 1);
                }
                facetFilterList.removeChild(filter);
                //byId(id).checked = false;
            }

            if (facetFilterList != null && facetFilterList.childNodes.length == 0) {
                byId("clear_all_filter").style.display = "none";
                byId("facetFilterListWrapper").innerHTML = "";
            }

            $("#facetLabel_" + id).parent().attr("class", "outline");

            var el = byId(id);
            var section = this.findContainer(el);
            if (section) {
                byId(section.id).style.display = "block";
            }
            this.doSearchFilter();
        },

        getEnabledProductFacets: function() {
            var facetForm = document.forms['productsFacets'] != null ? document.forms['productsFacets'] : document.forms['productsFacetsHorizontal'];
            var elementArray = facetForm.elements;

            var facetArray = [];
            var facetIds = [];
            if (_searchBasedNavigationFacetContext != 'undefined') {
                for (var i = 0; i < _searchBasedNavigationFacetContext.length; i++) {
                    facetArray.push(_searchBasedNavigationFacetContext[i]);
                    //facetIds.push();
                }
            }
            var facetLimits = [];
            for (var i = 0; i < elementArray.length; i++) {
                var element = elementArray[i];
                if (element.type != null && element.type.toUpperCase() == "CHECKBOX") {
                    if (element.title == "MORE") {
                        // scan for "See More" facet enablement.
                        if (element.checked) {
                            facetLimits.push(element.value);
                        }
                    } else {
                        // disable the checkbox while the search is being performed to prevent double clicks
                        //element.disabled = true;
                        if (element.checked) {
                            facetArray.push(element.value);
                            facetIds.push(element.id);
                        }
                    }
                }
            }
            // disable the price range button also
            if ($("#price_range_go").length) {
                byId("price_range_go").disabled = true;
            }

            var results = [];
            results.push(facetArray);
            results.push(facetLimits);
            results.push(facetIds);
            return results;
        },

        /**
         * @param clickedFacet the facet that was clicked
         */
        onFacetClick: function(clickedFacet) {
            console.error("deprecated: should not call this function");
            /*
			var minPrice = "",
                maxPrice = "";

			if(Utils.idExists("low_price_value", "high_price_value")) {
				minPrice = $("#low_price_value").val();
				maxPrice = $("#high_price_value").val();
			}
			if(minPrice === '' && maxPrice === '')
			{
				minPrice = window.initialMinPrice;
				maxPrice = window.initialMaxPrice;
			}
			
            var facetArray = this.getEnabledProductFacets(),
                $clickedFacet = $(clickedFacet),
                url = $clickedFacet.attr('href')
            url = Utils.updateQueryStringParameter(url, {
                "productBeginIndex": "0", 
                "facet": [$("input[type='checkbox']", $clickedFacet.parent()).val()], 
                "facetLimit": [], 
                "facetId": [$clickedFacet.data("for")], 
                "resultType":"products", 
                "minPrice": minPrice, 
                "maxPrice": maxPrice
            });
            $clickedFacet.attr('href', url)
            console.log(url);*/
            /*
			wcRenderContext.updateRenderContext('searchBasedNavigation_context', );
			*/

        },

        addShowMoreToFacetLimitArray: function(id) {
            // only add if no child facet is selected (i.e. no child is found in selectedFacetLimitsArray
            var childExist = false;
            for (var i = 0; i < this.selectedFacetLimitsArray; i++) {
                if (this.selectedFacetLimitsArray[i].indexOf(id) !== -1) {
                    childExist = true;
                    break;
                }
            }
            if (!childExist) {
                var index = id.indexOf(":");
                if (index != -1) {
                    id = id.substr(0, index);
                }
                this.selectedFacetLimitsArray.push("morelink_" + id);
            }
        },

        removeShowMoreFromFacetLimitArray: function(id) {
            var cIndex = id.indexOf(":");
            if (cIndex != -1) {
                id = id.substr(0, cIndex);
            }
            if (id.indexOf("morelink_") === -1) {
                id = "morelink_" + id;
            }
            var index = this.selectedFacetLimitsArray.indexOf(id);
            if (index != -1) {
                this.selectedFacetLimitsArray.splice(index, 1);
            }
        },

        toggleShowMore: function(element, id) {
            var label = byId("showMoreLabel_" + id);
            var divContainer = $("[id^='section_list_" + id + "']")[0];
            var grouping = $(" > ul.facetSelect > li[data-additionalvalues]", divContainer);
            if (element.checked) {
                this.addShowMoreToFacetLimitArray(element.value);
                label.innerHTML = this.lessMsg;
                var group = $(" > ul.facetSelect", divContainer)[0];
                var clearFloat = $(" > div.clear_float", group)[0];
                if (clearFloat != undefined) {
                    group.removeChild(clearFloat);
                }
                grouping.css("display", "");
            } else {
                this.removeShowMoreFromFacetLimitArray(element.value);
                grouping.css("display", "none");
                label.innerHTML = this.moreMsg;
            }
            this.doSearchFilter();
        },


        clearAllFacets: function(execute) {
            console.error("deprecated: do not call this function");
            /*
			byId("clear_all_filter").style.display = "none";
			byId("facetFilterListWrapper").innerHTML = "";
			if($("#low_price_value").length && $("#high_price_value").length) {
				byId("low_price_value").value = "";
				byId("high_price_value").value = "";
			}

			var facetForm = document.forms['productsFacets'] != null ? document.forms['productsFacets'] : document.forms['productsFacetsHorizontal'];
			var elementArray = facetForm.elements;
			for (var i=0; i < elementArray.length; i++) {
				var element = elementArray[i];
				if(element.type != null && element.type.toUpperCase() == "CHECKBOX" && element.checked && element.title != "MORE") {
					//element.checked = false;
				}
			}

			var elems = document.getElementsByTagName("*");
			for (var i=0; i < elems.length; i++) {
				// Reset all hidden facet sections (single selection facets are hidden after one facet is selected from that facet grouping)
				// and clear all selected facet highlights.
				var element = elems[i];
				if (element.id != null) {
					if (element.id.indexOf("section_") == 0 && !(element.id.indexOf("section_list") == 0)) {
						element.style.display = "block";
					}
					if (element.id.indexOf("facetLabel_") == 0) {
						$(element).parent().attr("class", "outline");
					}
				}
			}

			if(execute) {
				this.doSearchFilter();
				this.selectedFacetLimitsArray = [];
			}*/
        },

        updateContextProperties: function(contextId, properties) {
            //Set the properties in context object..
            for (key in properties) {
                wcRenderContext.getRenderContextProperties(contextId)[key] = properties[key];
            }
        },

        toggleView: function(data) {

            console.error("deprecated: do not call this function");
            /*
			var pageView = data["pageView"];
			setCurrentId(data["linkId"]);
			if(!submitRequest()){
				return;
			}
			cursor_wait();
			//console.debug("pageView = "+pageView+" controller = +searchBasedNavigation_controller");
			wcRenderContext.updateRenderContext('searchBasedNavigation_context', {"pageView": pageView,"resultType":"products", "enableSKUListView":data.enableSKUListView});
			MessageHelper.hideAndClearMessage();*/
        },

        toggleExpand: function(id) {
            var icon = byId("icon_" + id);
            var section_list = byId("section_list_" + id);
            if (icon.className == "arrow") {
                icon.className = "arrow arrow_collapsed";
                $(section_list).attr("aria-expanded", "false");
                section_list.style.display = "none";
            } else {
                icon.className = "arrow";
                $(section_list).attr("aria-expanded", "true");
                section_list.style.display = "block";
            }
        },

        sortResults: function(orderBy) {
            console.error("should not be calling this");
        },

        swatchImageClicked: function(id) {
            // This is a workaround for IE's bug for non-clickable label images.
            var e = byId(id);
            if (!e.checked) {
                e.click();
            }
        },

        clone: function(masterObj) {
            console.error("should not be calling this");
        }
    };
}
//-----------------------------------------------------------------
// Licensed Materials - Property of IBM
//
// WebSphere Commerce
//
// (C) Copyright IBM Corp. 2013 All Rights Reserved.
//
// US Government Users Restricted Rights - Use, duplication or
// disclosure restricted by GSA ADP Schedule Contract with
// IBM Corp.
//-----------------------------------------------------------------

/**
 *  Video display widget
 */	

window.onload=function() {   
	var video = document.getElementById("videoScreen");
	if (video) {
		if(video.canPlayType && (video.canPlayType('video/mp4') || video.canPlayType('video/ogg'))) {
			
			function startVideo() {
				this.removeEventListener('play', startVideo, false);
				document.getElementById('promotionTitle').style.display = 'none';
			}
			
			function endVideo() {
				this.removeEventListener('ended', endVideo, false);
				document.getElementById('videoScreen').style.display = 'none';
				document.getElementById('videoFinished').style.display = 'block';
			}
			
			if (!video.addEventListener) {
				video.attachEvent('play', startVideo, false);
				video.attachEvent('ended', endVideo, false);
			}
			else {
				video.addEventListener('play', startVideo, false);
				video.addEventListener('ended', endVideo, false);
			}
		}
		else {
			document.getElementById('promotionTitle').style.display = 'none';
		}
	}
}//-----------------------------------------------------------------
// Licensed Materials - Property of IBM
//
// WebSphere Commerce
//
// (C) Copyright IBM Corp. 2013, 2016 All Rights Reserved.
//
// US Government Users Restricted Rights - Use, duplication or
// disclosure restricted by GSA ADP Schedule Contract with
// IBM Corp.
//-----------------------------------------------------------------

var FindByCSRUtilities = function(){


    this.showHide = function(nodeId, hiddenClassName, activeClassName){
        $('#'+nodeId).toggleClass(hiddenClassName);
        $('#'+nodeId).toggleClass(activeClassName);
    };

    this.changeDropDownArrow = function(nodeId, arrowClass){
        $('#'+nodeId).toggleClass(arrowClass);
    };


    this.toggleSelection = function(nodeCSS,nodeId,parentNode,cssClassName){
        // Get list of all active nodes with cssClass = nodeCSS under parentNode.
        var activeNodes = $('.'+cssClassName, "#"+parentNode);

        // Toggle the css class for the node with id = nodeId
        $('#'+nodeId,  "#"+parentNode).toggleClass(cssClassName);

        // Remove the css class for all the active nodes.
        activeNodes.removeClass(cssClassName);
    };

    this.handleErrorScenario = function(){
        var errorMessageObj = $("#errorMessageFindOrders");
        var errorSectionObj = $("#errorMessage_sectionFindOrders");
        if(errorMessageObj.length){
            var errorMessage = errorMessageObj.val();

            if(errorMessage != null && errorMessage != undefined && errorSectionObj != null){
                 $(errorSectionObj).css('display', 'block');
                 $(errorSectionObj).css('color', '#CA4200');
                 // TODO - set focus to error div..for accessibility...
                 $(errorSectionObj).text(errorMessage);
            }
        } else {

             $(errorSectionObj).css('display', 'none');
        }
    };

    this.cancelEvent =  function(e) {
        if (e.stopPropagation) {
            e.stopPropagation();
        }
        if (e.preventDefault) {
            e.preventDefault();
        }
        e.cancelBubble = true;
        e.cancel = true;
        e.returnValue = false;
    };

    this.closeActionButtons = function(nodeCSS,parentNode,cssClassName,hiddenClassName,activeClassName){
        $('.'+nodeCSS, "#"+parentNode).removeClass(cssClassName);
    };

    this.resetActionButtonStyle = function(nodeCSS,parentNode,hiddenClassName,activeClassName){
        $('.'+nodeCSS, "#"+parentNode).addClass(hiddenClassName);
        $('.'+nodeCSS, "#"+parentNode).removeClass(activeClassName);
    };

    this.toggleCSSClass = function(nodeCSS,nodeId,parentNode,hiddenClassName,activeClassName){
        // Get the list of current nodes
        var activeNodes = $('.'+activeClassName, "#"+parentNode);

        // For the clicked node, toggle the CSS Class. If hidden then display / If displayed then hide.
        $('#'+nodeId, "#"+parentNode).toggleClass(hiddenClassName);
        $('#'+nodeId, "#"+parentNode).toggleClass(activeClassName);

        // For all activeNodes, remove the activeCSS and add the hiddenCSS
        activeNodes.removeClass(activeClassName);
        activeNodes.addClass(hiddenClassName);
    };


    this.setUserInSession = function(userId, selectedUser,landingURL){

        var renderContext = wcRenderContext.getRenderContextProperties('findOrdersSearchResultsContextCSR');
        if(selectedUser != '' && selectedUser != null) {
            renderContext["selectedUser"] = escapeXml(selectedUser, true);
        }
        if(landingURL != '' && landingURL != null){
            renderContext["landingURL"] = landingURL;
        }

    // If we are setting a forUser in session here, it has to be CSR role. Save this info in context.
        // Once user is successfully set, we will set this info in cookie.
        renderContext["WC_OnBehalf_Role_"] = "CSR";

        var params = [];
        params.runAsUserId = userId;
        params.storeId = WCParamJS.storeId;
        wcService.invoke("AjaxRunAsUserSetInSessionCSR", params);
    };

    this.onUserSetInSession = function(){
        var renderContext = wcRenderContext.getRenderContextProperties('findOrdersSearchResultsContextCSR');
        var selectedUser = renderContext["selectedUser"];
        if(selectedUser != '' && selectedUser != null){
            //write the cookie.
            setCookie("WC_BuyOnBehalf_"+WCParamJS.storeId, escapeXml(selectedUser, true), {path:'/', domain:cookieDomain});
        }
        var onBehalfRole = renderContext["WC_OnBehalf_Role_"];
        if(onBehalfRole != '' && onBehalfRole != null){
            //write the cookie.
            setCookie("WC_OnBehalf_Role_"+WCParamJS.storeId, onBehalfRole, {path:'/', domain:cookieDomain});
        }
    };



    this.enableDisableUserAccount = function(userId, status,logonId){

        //Save it in context
        var context = wcRenderContext.getRenderContextProperties("UserRegistrationAdminUpdateStatusContextCSR");
        context["userId"] = userId;

        // If userStatus is already available in context, then use it.
        // This means, the status is updated by making an Ajax call after the page is loaded and status is updated.
        var updatedStatus = context[userId+"_updatedStatus"];
        if(updatedStatus != null){
            if(updatedStatus == '0'){
                status = '1';
            } else {
                status = '0';
            }
        }
        context[userId+"_userStatus"] = status;
        // Invoke service
        wcService.invoke("AjaxRESTUserRegistrationAdminUpdateStatusCSR", {'userId' : userId, 'userStatus':status, 'logonId' : logonId});
    };

    this.onEnableDisableUserStatusAccount = function(serviceResponse){
        var message = Utils.getLocalizationMessage("CUSTOMER_ACCOUNT_ENABLE_SUCCESS");
        if(serviceResponse.userStatus == '0'){
            message = Utils.getLocalizationMessage("CUSTOMER_ACCOUNT_DISABLE_SUCCESS");
        }
        MessageHelper.displayStatusMessage(message);
        onBehalfUtilitiesJS.updateUIAndRenderContext(serviceResponse,"UserRegistrationAdminUpdateStatusContextCSR");
    };



};


$(document).ready(function() {
    findbyCSRJS = new FindByCSRUtilities();

});


/**
 * Declares a new render context for find orders  result list - To display orders based on search criteria.
 */
wcRenderContext.declare("findOrdersSearchResultsContextCSR",[],{'isPaginatedResults':'false'});


//Declare context and service for updating the status of user.
wcRenderContext.declare("UserRegistrationAdminUpdateStatusContextCSR",[],{});
wcService.declare({
    id: "AjaxRESTUserRegistrationAdminUpdateStatusCSR",
    actionId: "AjaxRESTUserRegistrationAdminUpdateStatusCSR",
    url: getAbsoluteURL() +  "AjaxRESTUserRegistrationAdminUpdate",
    formId: ""

     /**
      *  This method refreshes the panel
      *  @param (object) serviceResponse The service response object, which is the
      *  JSON object returned by the service invocation.
      */
    ,successHandler: function(serviceResponse) {
        findbyCSRJS.onEnableDisableUserStatusAccount(serviceResponse);
        cursor_clear();
    }

    /**
    * display an error message.
    * @param (object) serviceResponse The service response object, which is the
    * JSON object returned by the service invocation.
    */
    ,failureHandler: function(serviceResponse) {
        if (serviceResponse.errorMessage) {
            MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
        } else {
            if (serviceResponse.errorMessageKey) {
                MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
            }
        }
    }

});


// Service to start on-behalf user session.
wcService.declare({
    id: "AjaxRunAsUserSetInSessionCSR",
    actionId: "AjaxRunAsUserSetInSessionCSR",
    url: getAbsoluteURL() + "AjaxRunAsUserSetInSession",
    formId: ""

    /**
     * Clear messages on the page.
     * @param (object) serviceResponse The service response object, which is the JSON object returned by the service invocation
     */
    ,successHandler: function(serviceResponse) {
        MessageHelper.hideAndClearMessage();
        //Use this CSR_SUCCESS_ACCOUNT_ACCESS
        MessageHelper.displayStatusMessage(Utils.getLocalizationMessage("CSR_SUCCESS_CUSTOMER_ACCOUNT_ACCESS"));

        findbyCSRJS.onUserSetInSession();
        setDeleteCartCookie(); // Mini Cart cookie should be refreshed to display shoppers cart details...
        var landingURL = wcRenderContext.getRenderContextProperties('findOrdersSearchResultsContextCSR')["landingURL"];
        window.location.href = landingURL; // if landingURL is null, it reloads same page. so don't check for != ''
    }

    /**
     * Displays an error message on the page if the request failed.
     * @param (object) serviceResponse The service response object, which is the JSON object returned by the service invocation.
     */
    ,failureHandler: function(serviceResponse) {
        if (serviceResponse.errorMessage) {
            MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
        } else {
            if (serviceResponse.errorMessageKey) {
                MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
            }
        }
        cursor_clear();
    }
});


//-----------------------------------------------------------------
// Licensed Materials - Property of IBM
//
// WebSphere Commerce
//
// (C) Copyright IBM Corp. 2013, 2016 All Rights Reserved.
//
// US Government Users Restricted Rights - Use, duplication or
// disclosure restricted by GSA ADP Schedule Contract with
// IBM Corp.
//-----------------------------------------------------------------

var FindOrders = function(){

    this.searchListData = {
                            "progressBarId":"FindOrdersList_form_botton_1", "formId":"FindOrders_searchForm",
                            "searchButtonId":"FindOrdersList_form_botton_1", "clearButtonId":"FindOrdersList_form_botton_2",
                             "searchOptionLabel" : "searchOptionLabel"
                          },


     /**
        Setup events for Search and Clear Results button in Find Orders Page
    */
    this.setUpEvents = function(){

        var scope = this;
        var target = document.getElementById(this.searchListData.searchButtonId);
        if(target != null) {
            $(target).on("click",function(event){
                scope.doSearch();
            });
        }

        target = $("#" +this.searchListData.clearButtonId);
        if(target != null) {
            $(target).on("click",function(event){
                scope.clearFilter();
            });
        }

    };


    this.clearFilter = function(){

        this.clearSearchResults();

        // Remove search criteria..
        $('#FindOrders_searchForm input[id ^= "findOrders_"]').each(function(i, inputElement){
            inputElement.value = null;
        });

        //Remove search criteria from select menu
        $('#FindOrders_searchForm select[id ^= "findOrders_"]').each(function(j, inputElement){
            var jqueryObject = $('#' + inputElement.id);
            if(jqueryObject.length){
                jqueryObject.val('');
                jqueryObject.Select("refresh_noResizeButton");
            }

            if(inputElement.id === "findOrders_Form_Input_state") {
                $("#" + inputElement.id).replaceWith('<input type="text" id="findOrders_Form_Input_state" name="state" />');
            }
        });

        //Remove input in date pickers
        $('#datepickerFrom').val("");
        $('#datepickerTo').val("");
    };

    this.doSearch = function(){
        this.clearSearchResults();

        //Do we have any search criteria to search ?
        var doSearch = false;
        $('#'+this.searchListData.formId+' input[id ^= "findOrders_"]').each(function(i, inputElement){
                 var value = inputElement.value;
                 if(value != null && value != ''){
                     doSearch = true;
                 }
             });


        if(!doSearch){
            $('#'+this.searchListData.formId+' select[id ^= "findOrders_"]').each(function(j, inputElement){
                    var jqueryObject = $('#' + inputElement.id);
                    var value = jqueryObject.val();
                    if(value != '' ){
                        doSearch = true;
                    }
                 });
        }


        if(!doSearch) {
        	MessageHelper.formErrorHandleClient(this.searchListData.searchButtonId, Utils.getLocalizationMessage("CSR_NO_SEARCH_CRITERIA"));
            return false;
        }


        var renderContextProperties = wcRenderContext.getRenderContextProperties('findOrdersSearchResultsContext');
        renderContextProperties["searchInitialized"] = "true";

        setCurrentId(this.searchListData.progressBarId);
        if(!submitRequest()){
            return;
        }

        cursor_wait();
        var params = {};
        // code level formatting can be taken care or in js. Based on server REST need, include formatting here.
        //this.formatDate();
        $("#findOrdersRefreshArea").refreshWidget("updateFormId", this.searchListData.formId);
        wcRenderContext.updateRenderContext("findOrdersSearchResultsContext", params);

    };



    this.toggleOrderSummarySection = function(orderId){
        findbyCSRJS.showHide('orderDetailsExpandedContent_'+orderId, 'collapsed', 'expanded');
        findbyCSRJS.changeDropDownArrow('dropDownArrow_'+orderId,'expanded');
        return true;
    };

    this.handleActionDropDown = function(event,memberId){
        findbyCSRJS.cancelEvent(event);
        findbyCSRJS.toggleSelection('actionDropdown','actionDropdown_'+memberId, 'findOrdersSearchResults', 'active');
        findbyCSRJS.toggleCSSClass('actionButton','actionButton7_'+memberId,'findOrdersSearchResults','actionDropdownAnchorHide','actionDropdownAnchorDisplay');
        return false;
    }

    this.clearSearchResults = function(){
        // Remove search results
        if($("#findOrdesResultList_table").length){
            $("#findOrdesResultList_table").css("display","none");
        }
    };






    this.accessOrderDetails = function(userId, selectedUser, landingURL)
    {


        var renderContextProperties = wcRenderContext.getRenderContextProperties('findOrdersSearchResultsContext');
        // First need to set user in sesison before accessing orderDetails page...

        // in case of order details display, landing URL will be different. So set that here before calling setUserInSession command.
        // in case of guest orders, landingURL will be coming null and it will pass null as well..
        if(landingURL != '' && landingURL != null){
            renderContextProperties["landingURL"] = landingURL;
        }
        // currently landingUrl is registered customers account link...if it is guest user, landing url will be differnt..
        findbyCSRJS.setUserInSession(userId,selectedUser,landingURL);

    };


    this.lockUnlockOrder = function(orderId, isLocked, takeOverLock){

        //Save it in context
        var context = wcRenderContext.getRenderContextProperties("OrderLockUnlockContext");
        context["orderId"] = orderId;
        var takeOverLockStatus = context[orderId+"_takeOverLock"];
        if(takeOverLockStatus != null){
            //if context has already  saved data then pick up from conetxt
            takeOverLock = takeOverLockStatus;
        }

        if(takeOverLock == 'true')
        {
            //take over lock first and then call unlock order
            wcService.invoke("AjaxRESTTakeOverlock", {'orderId' : orderId, 'filterOption' : "All", 'takeOverLock' : 'Y',  'storeId': WCParamJS.storeId, 'langId':  WCParamJS.langId});

        }
        else
        {
            // this is required to set value in context back when CSR decides to unlock again..
            var lockStatus = context[orderId+"_isLocked"];
            if(lockStatus != null){
                //if context has already  saved data then pick up from conetxt
                    isLocked = lockStatus;
            }
            // Invoke service : if order is already locked, call unlock cart to unlock the same else lock it
            if(isLocked=='true')
            {
                //unlock order
                wcService.invoke("AjaxRESTOrderUnlock", {'orderId' : orderId, 'filterOption' : "All", 'isLocked':isLocked, 'storeId': WCParamJS.storeId, 'langId':  WCParamJS.langId});

            }else
            {
                //lock order...
                wcService.invoke("AjaxRESTOrderLock", {'orderId' : orderId, 'filterOption' : "All", 'isLocked':isLocked, 'storeId': WCParamJS.storeId, 'langId':  WCParamJS.langId});

            }
        }


    };



    this.onlockUnlockOrder = function(serviceResponse){

        var message = Utils.getLocalizationMessage("SUCCESS_ORDER_LOCK");
        var lockStatusText = Utils.getLocalizationMessage('UNLOCK_CUSTOMER_ORDER_CSR');
        if(serviceResponse.isLocked[0] == 'true'){
            message = Utils.getLocalizationMessage("SUCCESS_ORDER_UNLOCK");
            lockStatusText = Utils.getLocalizationMessage('LOCK_CUSTOMER_ORDER_CSR');
        }
        MessageHelper.displayStatusMessage(message);

        var renderContext = wcRenderContext.getRenderContextProperties("OrderLockUnlockContext"); //this should be orderlock related context
        var orderId = renderContext["orderId"];  // orderid
        var lockStatus = renderContext[orderId+"_isLocked"];

        // Update widget text...
        $("#orderLocked_"+orderId).html(lockStatusText);

        if($("#minishopcart_lock_"+orderId) != null){
            var node = $("#minishopcart_lock_"+orderId);
            if(renderContext[orderId+"_isLocked"] == "true")
            {
                 $(node).attr("class", "");
            }
            else
            {
                $(node).attr("class", "nodisplay");
            }
        }
    };

    this.displayCSROrderSummaryPage = function(orderId){
        document.location.href = "CSROrderSummaryView"+"?"+getCommonParametersQueryString()+"&orderId="+orderId;
    };
};


$(document).ready(function() {
    findOrdersJS = new FindOrders();
    findOrdersJS.setUpEvents();

});

function declareFindOrdersRefreshArea() {
    // ============================================
    // div: findOrdersRefreshArea refresh area
    // eclares a new refresh controller for the Find Orders List
    var myWidgetObj = $("#findOrdersRefreshArea");

    /**
     * Declares a new render context for find orders  result list - To display orders based on search criteria.
     */
    wcRenderContext.declare("findOrdersSearchResultsContext", ["findOrdersRefreshArea"], {'searchInitialized':'false', 'isPaginatedResults':'false'},"");

    var myRCProperties = wcRenderContext.getRenderContextProperties("findOrdersSearchResultsContext");
    var baseURL = getAbsoluteURL()+'FindOrdersResultListViewV2';

    var renderContextChangedHandler = function() {
        myWidgetObj.refreshWidget("updateUrl", baseURL +"?"+getCommonParametersQueryString());
        myWidgetObj.html("");
        myWidgetObj.refreshWidget("refresh", myRCProperties);
    };

    var postRefreshHandler = function() {
        findbyCSRJS.handleErrorScenario();
        console.debug("Post refresh handler of findOrdersController");
        cursor_clear();
    }

    // initialize widget
    myWidgetObj.refreshWidget({renderContextChangedHandler: renderContextChangedHandler, postRefreshHandler: postRefreshHandler});

};

//Declare context and service for updating the status of user.
wcRenderContext.declare("OrderLockUnlockContext",[],{});

wcService.declare({
        id: "AjaxRESTOrderLock",
        actionId: "AjaxRESTOrderLock",
        url:  getAbsoluteURL()+'AjaxRESTOrderLock',
        formId: ""


     /**
      *  This method refreshes the panel
      *  @param (object) serviceResponse The service response object, which is the
      *  JSON object returned by the service invocation.
      */
    ,successHandler: function(serviceResponse) {
        // set context of lock for this orderid as true... as it has been locked..

        var renderContext = wcRenderContext.getRenderContextProperties("OrderLockUnlockContext"); //this should be orderlock related context
        var orderId = renderContext["orderId"];  // orderid
        renderContext[orderId+"_isLocked"] = "true";
        findOrdersJS.onlockUnlockOrder(serviceResponse);
        cursor_clear();
    }

    /**
    * display an error message.
    * @param (object) serviceResponse The service response object, which is the
    * JSON object returned by the service invocation.
    */
    ,failureHandler: function(serviceResponse) {
        if (serviceResponse.errorMessage) {
            MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
        } else {
            if (serviceResponse.errorMessageKey) {
                MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
            }
        }
    }

});
wcService.declare({

    id: "AjaxRESTOrderUnlock",
    actionId: "AjaxRESTOrderUnlock",
    url:  getAbsoluteURL()+'AjaxRESTOrderUnlock',
    formId: ""


 /**
  *  This method refreshes the panel
  *  @param (object) serviceResponse The service response object, which is the
  *  JSON object returned by the service invocation.
  */
,successHandler: function(serviceResponse) {
    //var lockStatus = context.properties[orderId+"_isLocked"];
    // set context of lock for this orderid as false... as it has been unlocked..
    var renderContext = wcRenderContext.getRenderContextProperties("OrderLockUnlockContext"); //this should be orderlock related context
    var orderId = renderContext["orderId"];  // orderid
    renderContext[orderId+"_isLocked"] = "false";

    findOrdersJS.onlockUnlockOrder(serviceResponse);
    cursor_clear();
}

/**
* display an error message.
* @param (object) serviceResponse The service response object, which is the
* JSON object returned by the service invocation.
*/
,failureHandler: function(serviceResponse) {
    if (serviceResponse.errorMessage) {
        MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
    } else {
        if (serviceResponse.errorMessageKey) {
            MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
        }
    }
}

});

wcService.declare({

    id: "AjaxRESTTakeOverlock",
    actionId: "AjaxRESTTakeOverlock",
    url:  getAbsoluteURL()+'/AjaxRESTTakeOverlock',
    formId: ""


 /**
  *  This method refreshes the panel
  *  @param (object) serviceResponse The service response object, which is the
  *  JSON object returned by the service invocation.
  */
,successHandler: function(serviceResponse) {
    //findOrdersJS.onlockUnlockOrder(serviceResponse);
    //after successfully taking over lock, it should call unlock
    var context = wcRenderContext.getRenderContextProperties("OrderLockUnlockContext");
    var orderId = context["orderId"];
    context[orderId+"_takeOverLock"] = "false";
    findOrdersJS.lockUnlockOrder(orderId, 'true', 'false');
    cursor_clear();
}

/**
* display an error message.
* @param (object) serviceResponse The service response object, which is the
* JSON object returned by the service invocation.
*/
,failureHandler: function(serviceResponse) {
    if (serviceResponse.errorMessage) {
        MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
    } else {
        if (serviceResponse.errorMessageKey) {
            MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
        }
    }
}

});
//-----------------------------------------------------------------
// Licensed Materials - Property of IBM
//
// WebSphere Commerce
//
// (C) Copyright IBM Corp. 2013, 2016 All Rights Reserved.
//
// US Government Users Restricted Rights - Use, duplication or
// disclosure restricted by GSA ADP Schedule Contract with
// IBM Corp.
//-----------------------------------------------------------------


var OrderComments = function(){

    this.editIconId = "editIcon";
    this.widgetId = ''; //Id of the InlineEditBox widget
    this.mainDivId = 'orderComment'; // enclosing div which contains the InlineEditBox widget.
    this.maxCommentLength = 3000;
    this.commentsLoadStatus = new Object();

    /**
        Called after successfully loading the order comments with ajax call and
        displaying the InLineEdit widget (before displaying edit box/save/cancel buttons)
    */
    this.startUp = function(){

        //Comments are successfully loaded. Make a note of it.
        this.commentsLoadStatus[this.widgetId] = 1;
        //Update order comments section heading.
        var commentsPaginationInfo =$("#orderCommentHeading").val();
        if($("#orderCommentHeadingPaginationInfo").val() !== null){
            commentsPaginationInfo = commentsPaginationInfo +"&nbsp;"+$("#orderCommentHeadingPaginationInfo").val();
        }
        $("#orderCommentToggleLabel").html(commentsPaginationInfo);
    };

    /**
        Called after successfully saving new order comment with ajax call.
    */

    this.resetWidget = function(resetEditText){

        if($("#comment").val() != ''){
            $("#comment").val('');
        }

          // Update orderComments heading with new pagination info.
        var commentsPaginationInfo = $("#orderCommentHeading").val();
        if($("#orderCommentHeadingPaginationInfo").val() !== null){
            commentsPaginationInfo = commentsPaginationInfo +"&nbsp;"+$("#orderCommentHeadingPaginationInfo").val();
        }
        $("#orderCommentToggleLabel").html(commentsPaginationInfo);

        // Display addCommentWidget
         $("#commentWidget").remove();
         $('#addCommentWidget').show();
    }

    this.cancelEdit = function(){
        this.resetWidget();
    };

    this.showHide = function(nodeId, hiddenClassName, activeClassName){
        var node = $('#'+nodeId);
        node.toggleClass(hiddenClassName);
        node.toggleClass(activeClassName);
    };

    this.expandCollapseArea = function(){
        this.showHide('orderCommentContainer_plusImage_link', 'collapsed', 'displayInline');
        this.showHide('orderCommentContainer_minusImage_link', 'collapsed', 'displayInline');
        this.showHide('orderCommentContent', 'collapsed', 'expanded');

        if($("#orderCommentContainer_plusImage_link").hasClass('displayInline')){
            document.getElementById("orderCommentContainer_plusImage_link").focus();
        } else if($("#orderCommentContainer_minusImage_link").hasClass('displayInline')){
            document.getElementById("orderCommentContainer_minusImage_link").focus();
        }
    };

    this.loadComments = function(orderId,widgetId){
        if(this.commentsLoadStatus[widgetId] == 1){
            //Comments already loaded.
            return false;
        }

        // Fetch comments from server by making an Ajax call.
        this.widgetId = widgetId;
        wcRenderContext.updateRenderContext('orderCommentsContext', {"orderId": orderId});
    };

    this.saveComments = function(orderId, widgetId, mode){
        var orderComment = $.trim($("#comment").val());
        if(orderComment === null || orderComment.length === 0){
            MessageHelper.displayErrorMessage(Utils.getLocalizationMessage('EMPTY_COMMENT'));
            this.resetWidget(false);
            return false;
        }

        if(!MessageHelper.isValidUTF8length(orderComment, this.maxCommentLength)){
            MessageHelper.displayErrorMessage(Utils.getLocalizationMessage('COMMENT_LENGTH_OUT_OF_RANGE'));
            // Let the comment text be available to CSR. So that they can reduce the char count, instead of keying in again
            this.resetWidget(false);
            return false;
        }

        var params = [];
        params["mode"] = mode;
        params["orderComment"] = orderComment;
        params["orderId"] = orderId;
        cursor_wait();
        wcService.invoke("AjaxRESTAddOrderComment", params);
    };


    this.showHideorderCommentsSliderContent = function(){
        $( document ).ready(function() {
                $('#orderCommentsSlider_content').toggleClass('orderCommentsSlider_content_closed');
                $('#orderCommentsSlider_trigger').toggleClass('orderCommentsSlider_trigger_closed');
        });
    };
}
$(document).ready(function() {
    orderCommentsJS = new OrderComments();
});
    var declareOrderCommentListRefreshArea = function() {
        // ============================================
        // div: orderCommentListRefreshArea refresh area
        // Declares a new refresh controller for the fetching order level comments.
        
        /**
         * Declares a new render context for managing orderComments customers list - To display registered customers based on search criteria.
         */
        wcRenderContext.declare("orderCommentsContext", ["orderCommentListRefreshArea"], {});

        var myWidgetObj = $("#orderCommentListRefreshArea");
        var myRCProperties = wcRenderContext.getRenderContextProperties("orderCommentsContext");
        var baseURL = getAbsoluteURL()+'OrderCommentsListViewV2';

        var renderContextChangedHandler = function() {
            console.debug("renderContextChangedHandler of orderCommentListRefreshArea");
            myWidgetObj.refreshWidget("updateUrl", baseURL+"?"+getCommonParametersQueryString());
            myWidgetObj.attr("role", "region");
            myWidgetObj.attr("tabIndex", 0);
            myWidgetObj.refreshWidget("refresh", myRCProperties);
        };

        wcTopic.subscribe("AjaxRESTAddOrderComment", function() {
            console.debug("modelChangedHandler of orderCommentListRefreshArea");
            myWidgetObj.refreshWidget("updateUrl", baseURL+"?"+getCommonParametersQueryString());
            myWidgetObj.refreshWidget("refresh", myRCProperties);
        });
        
        var postRefreshHandler = function() {
             console.debug("Post refresh handler of orderCommentListRefreshArea");
             cursor_clear();
             orderCommentsJS.startUp();
        };
       
        // initialize widget
        myWidgetObj.refreshWidget({renderContextChangedHandler: renderContextChangedHandler, postRefreshHandler: postRefreshHandler});
    };



// when user clicks on edit link and the InlineEditor is displayed.

$.fn.inlineEdit = function (replaceWith) {

    $(this).keypress(function (event) {

        if (event.keyCode == 13) { // Checks for the enter key
            $(this).click();
            event.preventDefault();
        }
    });

    $(this).click(function () {

        var self = $(this);
        self.hide();
        self.after(replaceWith);
        $("#comment").focus();
        $("#saveButton").addClass("button_primary saveButton");
        $("#cancelButton").addClass("button_secondary cancelButton");
        $("#comment").addClass("expandingTextArea");

    });
} 





// Service to add Order Level Comments
wcService.declare({
    id: "AjaxRESTAddOrderComment",
    actionId: "AjaxRESTAddOrderComment",
    url: getAbsoluteURL() + "AjaxRESTAddOrderComment"+"?"+getCommonParametersQueryString(),
    formId: ""

    /**
     * Clear messages on the page.
     * @param (object) serviceResponse The service response object, which is the JSON object returned by the service invocation
     */
    ,successHandler: function(serviceResponse) {
        //After saving the comments, reset the widget to initial state.
        //Remove the saved comment from textArea.
        orderCommentsJS.resetWidget(true);
        cursor_clear();
    }

    /**
     * Displays an error message on the page if the request failed.
     * @param (object) serviceResponse The service response object, which is the JSON object returned by the service invocation.
     */
    ,failureHandler: function(serviceResponse) {
        if (serviceResponse.errorMessage) {
            MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
        } else {
            if (serviceResponse.errorMessageKey) {
                MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
            }
        }
        cursor_clear();
    }
});


//-----------------------------------------------------------------
// Licensed Materials - Property of IBM
//
// WebSphere Commerce
//
// (C) Copyright IBM Corp. 2013, 2016 All Rights Reserved.
//
// US Government Users Restricted Rights - Use, duplication or
// disclosure restricted by GSA ADP Schedule Contract with
// IBM Corp.
//-----------------------------------------------------------------


var RegisteredCustomers = function(){


    this.searchListData = {
                            "progressBarId":"RegisteredCustomersList_form_botton_1", "formId":"RegisteredCustomersSearch_searchForm",
                            "searchButtonId":"RegisteredCustomersList_form_botton_1", "clearButtonId":"RegisteredCustomersList_form_botton_2"
                          },

    this.csrResetPasswordIds = {
                                "administratorPasswordId":"administratorPassword", "errorDivId":"csr_resetPassword_error", "errorMessageId":"csr_resetPassword_error_msg",
                                "parentNodeId":"csr_reset_password", "resetPasswordButtonId":"csr_resetPassword_button",
                                 "resetPasswordDropDownPanelId":"csr_resetPassword_dropdown_panel"
                               },

    this.csrPasswordEnabled = false,

    /**
        Setup events for Search and Clear Results button in Find Registered Customer Page
    */
    this.setUpEvents = function(){
        var scope = this;
        var target = $("#" +this.searchListData.searchButtonId);
        if(target != null) {
            $(target).on("click",function(event){
                scope.doSearch();
            });
        }

        target = $("#" +this.searchListData.clearButtonId);
        if(target != null) {
            $(target).on("click",function(event){
                scope.clearFilter();
            });
        }

    };

    /**
        Clear search results and search criteria.
    */
    this.clearFilter = function(){

        this.clearSearchResults();
        // Remove search criteria..

        $('#RegisteredCustomersSearch_searchForm input[id ^= "RegisteredCustomersSearch_"]').each(function(j, inputElement){
            inputElement.value = null;
        });

        // Remove search criteria in select menu
        $('#RegisteredCustomersSearch_searchForm select[id ^= "RegisteredCustomersSearch_"]').each(function(j, inputElement){
            var jqueryObject = $("#" + inputElement.id);
            if(jqueryObject != null){
                jqueryObject.val('');
                jqueryObject.Select("refresh_noResizeButton");
            }

            if(inputElement.id === "RegisteredCustomersSearch_Form_Input_state") {
                $("#" + inputElement.id).replaceWith('<input type="text" id="RegisteredCustomersSearch_Form_Input_state" name="state" />');
            }
        });
    };

    /**
        Search for registered customers.
    */
    this.doSearch = function(){
        this.clearSearchResults();

        //Do we have any search criteria to search ?
        var doSearch = false;
        $('#'+ this.searchListData.formId+' input[id ^= "RegisteredCustomersSearch_"]').each(function(i, inputElement){
                 var value = inputElement.value;
                 if(value != null && value != ''){
                     doSearch = true;
                 }
             });


        // Do we have some criteria in drop down boxes - State / Country ?
        if(!doSearch){
            $('#'+this.searchListData.formId+' select[id ^= "RegisteredCustomersSearch_"]').each(function(j, inputElement){
                    var jqueryObject = $('#' + inputElement.id);
                    var value = jqueryObject.val();
                    if(value != '' ){
                        doSearch = true;
                    }
                 });
        }


        if(!doSearch) {
        	MessageHelper.formErrorHandleClient(this.searchListData.searchButtonId, Utils.getLocalizationMessage("CSR_NO_SEARCH_CRITERIA"));
        	return false;
        }

        wcRenderContext.getRenderContextProperties('registeredCustomersSearchResultsContext')["searchInitializedForCustomers"] = "true";

        setCurrentId(this.searchListData.progressBarId);
        if(!submitRequest()){
            return;
        }

        cursor_wait();
        var params = {};
        $("#registeredCustomersRefreshArea").refreshWidget("updateFormId", this.searchListData.formId);
        wcRenderContext.updateRenderContext("registeredCustomersSearchResultsContext", params);
    };


    this.toggleMemberSummarySection = function(memberId){
        this.showHide('memberDetailsExpandedContent_'+memberId, 'collapsed', 'expanded');
        this.changeDropDownArrow('dropDownArrow_'+memberId,'expanded');
        return true;
    };


    this.handleActionDropDown = function(event,memberId, parentNode){
        this.cancelEvent(event);
        this.toggleSelection('actionDropdown','actionDropdown_'+memberId, parentNode, 'active');
        this.toggleCSSClass('actionButton','actionButton7_'+memberId,parentNode,'actionDropdownAnchorHide','actionDropdownAnchorDisplay');
        return false;
    }

    this.showHide = function(nodeId, hiddenClassName, activeClassName){
        $('#'+nodeId).toggleClass(hiddenClassName);
        $('#'+nodeId).toggleClass(activeClassName);
    };

    this.changeDropDownArrow = function(nodeId, arrowClass){
        $('#'+nodeId).toggleClass(arrowClass);
    };

    this.clearSearchResults = function(){
        // Remove search results
        if($("#registeredCustomersList_table") != null){
            $("#registeredCustomersList_table").css("display","none");
        }
    };

    this.toggleSelection = function(nodeCSS,nodeId,parentNode,cssClassName){
        // Get list of all active nodes with cssClass = nodeCSS under parentNode.
        var activeNodes = $('.'+cssClassName, "#"+parentNode);

        // Toggle the css class for the node with id = nodeId
        $('#'+nodeId, "#"+parentNode).toggleClass(cssClassName);

        // Remove the css class for all the active nodes.

        activeNodes.removeClass(cssClassName);
    };

    this.resetPasswordByAdminOnBehalfForBuyers = function(userId){
        wcService.invoke("AjaxRESTMemberPasswordResetByAdminOnBehalfForBuyer", {'logonId':userId, 'URL':"test"});
    };

    this.resetPasswordByAdminOnBehalf = function(userId){
        if(this.csrPasswordEnabled) {
            //  Use this when CSR password is mandatory to reset customer password.
            var administratorPassword = $("#" +this.csrResetPasswordIds.administratorPasswordId).val();
            if(administratorPassword == null || administratorPassword == ''){
                var error = Utils.getLocalizationMessage('CSR_PASSWORD_EMPTY_MESSAGE');
                this.onResetPasswordByAdminError(error);
                return false;
            }
            wcService.invoke("AjaxRESTMemberPasswordResetByAdminOnBehalf", {'administratorPassword': administratorPassword,'logonId':userId, 'URL':"test"});
        } else {
            wcService.invoke("AjaxRESTMemberPasswordResetByAdminOnBehalf", {'logonId':userId,'URL':"test"});
        }
    };

    this.resetPasswordByAdmin = function(userId,administratorPassword){
        wcService.invoke("AjaxRESTMemberPasswordResetByAdmin", {'administratorPassword' : administratorPassword, 'logonId':userId, 'URL':"test"});
    };

    this.handleCSRPasswordReset = function(event){
        this.cancelEvent(event);

        if(this.csrPasswordEnabled) {
            $("#" +this.csrResetPasswordIds.administratorPasswordId).val('');
        }
        // Change the styling of the ResetPassword button
        $('#'+this.csrResetPasswordIds.resetPasswordButtonId ,'#'+this.csrResetPasswordIds.parentNodeId).toggleClass('clicked');

        // Toggle the css class for the dropDown panel with id = nodeId
        $('#'+this.csrResetPasswordIds.resetPasswordDropDownPanelId, '#'+this.csrResetPasswordIds.parentNodeId).toggleClass('active');

        // Hide error div.
        $('#'+this.csrResetPasswordIds.errorDivId, '#'+this.csrResetPasswordIds.parentNodeId).addClass('hidden');

        return false;
    }

    this.hideErrorDiv = function(){
        // Hide error div.
        $('#'+this.csrResetPasswordIds.errorDivId, '#'+ this.csrResetPasswordIds.parentNodeId).addClass('hidden');
    }

    this.onResetPasswordByAdminError = function(errorMessage, errorResponse){
        $("#" +this.csrResetPasswordIds.errorMessageId).html(errorMessage);
        // Display error div.
        $('#'+ this.csrResetPasswordIds.errorDivId, '#'+this.csrResetPasswordIds.parentNodeId).removeClass('hidden');
        // focus to error div.
        $("#" +this.csrResetPasswordIds.errorMessageId).focus();
    }

    this.onResetPasswordByAdminSuccess = function(){
        // Change the styling of the ResetPassword button
        $('#'+this.csrResetPasswordIds.resetPasswordButtonId, '#'+ this.csrResetPasswordIds.parentNodeId).toggleClass('clicked');

        // Toggle the css class for the dropDown panel with id = nodeId
        $('#'+this.csrResetPasswordIds.resetPasswordDropDownPanelId, '#'+ this.csrResetPasswordIds.parentNodeId).toggleClass('active');
        return false;
    }

    this.handleErrorScenario = function(){
            var errorMessageObj = $("#errorMessage");
        var errorSectionObj = $("#errorMessage_section");
        if(errorMessageObj.length){
            var errorMessage = errorMessageObj[0].value;
            if(errorMessage != null && errorMessage.length != "" && errorSectionObj != null){
                 $('#errorMessage_section').css( 'display', 'block');
                 // TODO - set focus to error div..for accessibility...
                 $('#errorMessage_section').text(errorMessage);

            }
        } else {
            $('#errorMessage_section').css( 'display', 'none');
        }
    };

    this.cancelEvent =  function(e) {
        if (e.stopPropagation) {
            e.stopPropagation();
        }
        if (e.preventDefault) {
            e.preventDefault();
        }
        e.cancelBubble = true;
        e.cancel = true;
        e.returnValue = false;
    };

    this.closeActionButtons = function(nodeCSS,parentNode,cssClassName,hiddenClassName,activeClassName){
        $('.'+nodeCSS, "#"+ parentNode).removeClass(cssClassName);
    };

    this.resetActionButtonStyle = function(nodeCSS,parentNode,hiddenClassName,activeClassName){
        $('.'+nodeCSS, "#"+parentNode).addClass(hiddenClassName);
        $('.'+nodeCSS, "#"+parentNode).removeClass(activeClassName);
    };

    this.toggleCSSClass = function(nodeCSS,nodeId,parentNode,hiddenClassName,activeClassName){
        // Get the list of current nodes
        var activeNodes = $('.'+activeClassName, "#"+parentNode);

        // For the clicked node, toggle the CSS Class. If hidden then display / If displayed then hide.
        $('#'+nodeId,"#"+ parentNode).toggleClass(hiddenClassName);
        $('#'+nodeId,"#"+ parentNode).toggleClass(activeClassName);

        // For all activeNodes, remove the activeCSS and add the hiddenCSS
        activeNodes.removeClass(activeClassName);
        activeNodes.addClass(hiddenClassName);
    };

    this.createGuestUser = function(landingURL){
        var renderContext = wcRenderContext.getRenderContextProperties('registeredCustomersSearchResultsContext');
        if((landingURL == null || landingURL == '') && !stringStartsWith(document.location.href, "https")){
            renderContext["landingURL"] = '';
        } else {
            // Reload home page
            landingURL = WCParamJS.homePageURL;
            renderContext["landingURL"] = landingURL;
        }

        var params = [];
        wcService.invoke("AjaxRESTCreateGuestUser", params);
    };

    this.createRegisteredUser = function(landingURL){
        if(landingURL != null) {
           wcRenderContext.getRenderContextProperties('registeredCustomersSearchResultsContext')["landingURL"] = landingURL;
        }

        var params = [];
        var form = $("#Register");
        if(form.guestUserId != null && form.guestUserId.value != null){
            // Guest user id exists. Use it while registering new user.
            params.userId = form.guestUserId.value;
        }
        // Do not set errorViewName, since we are making Ajax call. Handle the response back in same page.
        $(form.errorViewName).remove();
        wcService.invoke("AjaxRESTUserRegistrationAdminAdd", params);
    };

    this.setUserInSession = function(userId, selectedUser,landingURL){
        var renderContext = wcRenderContext.getRenderContextProperties('registeredCustomersSearchResultsContext');
        if(selectedUser != '' && selectedUser != null) {
            renderContext["selectedUser"] = escapeXml(selectedUser, true);
        }
        if(landingURL != '' && landingURL != null){
            renderContext["landingURL"] = landingURL;
        }
        // If we are setting a forUser in session here, it has to be CSR role. Save this info in context.
        // Once user is successfully set, we will set this info in cookie.
        renderContext["WC_OnBehalf_Role_"] = "CSR";

        var params = [];
        params.runAsUserId = userId;
        params.storeId = WCParamJS.storeId;
        wcService.invoke("AjaxRunAsUserSetInSession", params);
    };

    this.onUserSetInSession = function(){
        var renderContext = wcRenderContext.getRenderContextProperties('registeredCustomersSearchResultsContext');
        var selectedUser = renderContext["selectedUser"];
        if(selectedUser != '' && selectedUser != null){
            //write the cookie.
            setCookie("WC_BuyOnBehalf_"+WCParamJS.storeId, escapeXml(selectedUser, true), {path:'/', domain:cookieDomain});
        }
        var onBehalfRole = renderContext["WC_OnBehalf_Role_"];
        if(onBehalfRole != '' && onBehalfRole != null){
            //write the cookie.
            setCookie("WC_OnBehalf_Role_"+WCParamJS.storeId, onBehalfRole, {path:'/', domain:cookieDomain});
        }
    };


    this.enableDisableUserAccount = function(userId, status){
        //Save it in context
	var context = wcRenderContext.getRenderContextProperties("UserRegistrationAdminUpdateStatusContext");
        context["userId"] = userId;

        // If userStatus is already available in context, then use it.
        // This means, the status is updated by making an Ajax call after the page is loaded and status is updated.
	var updatedStatus = context[userId+"_updatedStatus"];
        if(updatedStatus != null){
            if(updatedStatus == '0'){
                status = '1';
            } else {
                status = '0';
            }
        }
	context[userId+"_userStatus"] = status;

        // Invoke service
        wcService.invoke("AjaxRESTUserRegistrationAdminUpdateStatus", {'userId' : userId, 'userStatus':status});
    };

    this.onEnableDisableUserStatusAccount = function(serviceResponse){
        var message = Utils.getLocalizationMessage("CUSTOMER_ACCOUNT_ENABLE_SUCCESS");
        if(serviceResponse.userStatus == '0'){
            message = Utils.getLocalizationMessage("CUSTOMER_ACCOUNT_DISABLE_SUCCESS");
        }
        MessageHelper.displayStatusMessage(message);
        onBehalfUtilitiesJS.updateUIAndRenderContext(serviceResponse,"UserRegistrationAdminUpdateStatusContext");

    };

};

$(document).ready(function() {
    registeredCustomersJS = new RegisteredCustomers();
    registeredCustomersJS.setUpEvents();
});

    /**
     * Declares a new render context for registered customers list - To display registered customers based on search criteria.
     */
     if (!wcRenderContext.checkIdDefined("UserRegistrationAdminUpdateStatusContext")) {
    wcRenderContext.declare("registeredCustomersSearchResultsContext", ["registeredCustomersRefreshArea"], {'searchInitializedForCustomers':'false', 'isPaginatedResults':'false'},"");
}
function declareRegisteredCustomersRefreshArea() {
    // ============================================
    // div: registeredCustomersRefreshArea refresh area
    // Declares a new refresh controller for the Registered Customers List
    var myWidgetObj = $("#registeredCustomersRefreshArea");

    var myRCProperties = wcRenderContext.getRenderContextProperties("registeredCustomersSearchResultsContext"),
    baseURL = getAbsoluteURL()+'RegisteredCustomersListViewV2',
    renderContextChangedHandler = function() {
	myWidgetObj.refreshWidget("updateUrl", baseURL +"?"+getCommonParametersQueryString());
        $("#registeredCustomersRefreshArea").html("");
        console.debug(myRCProperties);
        $("#registeredCustomersRefreshArea").refreshWidget("refresh", myRCProperties)
    },

    postRefreshHandler = function() {
        registeredCustomersJS.handleErrorScenario();
        console.debug("Post refresh handler of registeredCustomersController");
        cursor_clear();
    };

    // initialize widget
    myWidgetObj.refreshWidget({renderContextChangedHandler: renderContextChangedHandler, postRefreshHandler: postRefreshHandler});
}

// Declare context and service for updating the status of user.
 if (!wcRenderContext.checkIdDefined("UserRegistrationAdminUpdateStatusContext")) {
wcRenderContext.declare("UserRegistrationAdminUpdateStatusContext", [], {});
}
wcService.declare({
    id: "AjaxRESTUserRegistrationAdminUpdateStatus",
    actionId: "AjaxRESTUserRegistrationAdminUpdateStatus",
    url: getAbsoluteURL() +  "AjaxRESTUserRegistrationAdminUpdate",
    formId: ""

     /**
      *  This method refreshes the panel
      *  @param (object) serviceResponse The service response object, which is the
      *  JSON object returned by the service invocation.
      */
    ,successHandler: function(serviceResponse) {
        registeredCustomersJS.onEnableDisableUserStatusAccount(serviceResponse);
        cursor_clear();
    }

    /**
    * display an error message.
    * @param (object) serviceResponse The service response object, which is the
    * JSON object returned by the service invocation.
    */
    ,failureHandler: function(serviceResponse) {
        if (serviceResponse.errorMessage) {
            MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
        } else {
            if (serviceResponse.errorMessageKey) {
                MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
            }
        }
    }

});


// Service to start on-behalf user session.
wcService.declare({
    id: "AjaxRunAsUserSetInSession",
    actionId: "AjaxRunAsUserSetInSession",
    url: getAbsoluteURL() + "AjaxRunAsUserSetInSession",
    formId: ""

    /**
     * Clear messages on the page.
     * @param (object) serviceResponse The service response object, which is the JSON object returned by the service invocation
     */
    ,successHandler: function(serviceResponse) {
		if(typeof callCenterIntegrationJS != 'undefined' && callCenterIntegrationJS != undefined && callCenterIntegrationJS != null){
			var params = {};
			params.status = "success";
			params.serviceResponse = serviceResponse;
			callCenterIntegrationJS.postActionMessage(params, "START_ON_BEHALF_SESSION_RESPONSE");	
		}
        MessageHelper.hideAndClearMessage();
        MessageHelper.displayStatusMessage(Utils.getLocalizationMessage("CSR_SUCCESS_CUSTOMER_ACCOUNT_ACCESS"));
        registeredCustomersJS.onUserSetInSession();
        setDeleteCartCookie(); // Mini Cart cookie should be refreshed to display shoppers cart details...
        var landingURL = wcRenderContext.getRenderContextProperties('registeredCustomersSearchResultsContext')["landingURL"];
        if(landingURL != "-1"){
			window.location.href = landingURL; // if landingURL is null, it reloads same page. so don't check for != ''
		}

    }

    /**
     * Displays an error message on the page if the request failed.
     * @param (object) serviceResponse The service response object, which is the JSON object returned by the service invocation.
     */
    ,failureHandler: function(serviceResponse) {
		if(typeof callCenterIntegrationJS != 'undefined' && callCenterIntegrationJS != undefined && callCenterIntegrationJS != null){
			var params = {};
			params.status = "error";
			params.serviceResponse = serviceResponse;
			callCenterIntegrationJS.postActionMessage(params, "START_ON_BEHALF_SESSION_RESPONSE");	
		}
        if (serviceResponse.errorMessage) {
            MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
        } else {
            if (serviceResponse.errorMessageKey) {
                MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
            }
        }
        cursor_clear();
    }
});

// Service to Create Guest User and create on-behalf session
wcService.declare({
    id: "AjaxRESTCreateGuestUser",
    actionId: "AjaxRESTCreateGuestUser",
    url: getAbsoluteURL() + "AjaxRESTCreateGuestUser",
    formId: ""

    /**
     * Clear messages on the page.
     * @param (object) serviceResponse The service response object, which is the JSON object returned by the service invocation
     */
    ,successHandler: function(serviceResponse) {
        MessageHelper.hideAndClearMessage();
        MessageHelper.displayStatusMessage(Utils.getLocalizationMessage("CSR_SUCCESS_NEW_GUEST_USER_CREATION"));
        var guestUserName = Utils.getLocalizationMessage("GUEST");
        // Set this new guest user in session. Start on-behalf session for guest user.
        registeredCustomersJS.setUserInSession(serviceResponse.userId, guestUserName);
    }

    /**
     * Displays an error message on the page if the request failed.
     * @param (object) serviceResponse The service response object, which is the JSON object returned by the service invocation.
     */
    ,failureHandler: function(serviceResponse) {
        if (serviceResponse.errorMessage) {
            MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
        } else {
            if (serviceResponse.errorMessageKey) {
                MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
            }
        }
        cursor_clear();
    }
});


//Declare context for user registration admin add
//wcRenderContext.declare("UserRegistrationAdminAddContext", [], {'administratorPassword':'', 'userId':''});

// Service to register new user and start on-behalf user session.
wcService.declare({
    id: "AjaxRESTUserRegistrationAdminAdd",
    actionId: "AjaxRESTUserRegistrationAdminAdd",
    url: getAbsoluteURL() + "AjaxRESTUserRegistrationAdminAdd",
    formId: "Register"

    /**
     * Clear messages on the page.
     * @param (object) serviceResponse The service response object, which is the JSON object returned by the service invocation
     */
    ,successHandler: function(serviceResponse) {

        MessageHelper.hideAndClearMessage();
        MessageHelper.displayStatusMessage(Utils.getLocalizationMessage("CSR_SUCCESS_NEW_REGISTERED_USER_CREATION"));
        registeredCustomersJS.setUserInSession(serviceResponse.userId, serviceResponse.firstName+ ' ' + serviceResponse.lastName);
        cursor_clear();
    }

    /**
     * Displays an error message on the page if the request failed.
     * @param (object) serviceResponse The service response object, which is the JSON object returned by the service invocation.
     */
    ,failureHandler: function(serviceResponse) {
        if (serviceResponse.errorMessage) {
            MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
        } else {
            if (serviceResponse.errorMessageKey) {
                MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
            }
        }
        cursor_clear();
    }
});//-----------------------------------------------------------------
// Licensed Materials - Property of IBM
//
// WebSphere Commerce
//
// (C) Copyright IBM Corp. 2014, 2015 All Rights Reserved.
//
// US Government Users Restricted Rights - Use, duplication or
// disclosure restricted by GSA ADP Schedule Contract with
// IBM Corp.
//-----------------------------------------------------------------

/**
 * @fileOverview This file provides all the functions and variables to manage Global Login panel.
 */

/* global document, window, $, setCookie, getCookie, cookieDomain, WCParamJS, GlobalLoginJS, Utils, cursor_clear, cursor_wait, submitRequest, wc, processAndSubmitForm, invokeItemAdd, invokeOtherService, isOnPasswordUpdateForm, service */

/**
* Constant key in activePanel
*/
var KEY_ACTIVE = 'active',

    /**
    * Constant key in activePanel
    */
    KEY_SELECTED = 'selected';

GlobalLoginJS = {

    /**
     * This variable stores the ID of the language that the store currently uses. Its default value is set to -1, which corresponds to United States English.
     * @private
     */
    langId: "-1",

    /**
     * This variable stores the ID of the current store. Its default value is empty.
     * @private
     */
    storeId: "",

    /**
     * This variable stores the ID of the catalog. Its default value is empty.
     * @private
     */
    catalogId: "",

    /**
     * This variable stores the ID of active panels. Its default value is empty.
     * @private
     */
    activePanel: {},

    widgetsLoadedOnPage: [],

    /**
     * This variable stores the ID of active panels. Its default value is empty.
     * @private
     */
    isPanelVisible: true,

    /**
     * True if mouse down event registered, false otherwise (prevents registering
     * event more than once).
     */
    mouseDownConnectHandle: null,
    /**
     * Sets the common parameters for the current page.
     * For example, the language ID, store ID, and catalog ID.
     *
     * @param {Integer} langId The ID of the language that the store currently uses.
     * @param {Integer} storeId The ID of the current store.
     * @param {Integer} catalogId The ID of the catalog.
     */
    setCommonParameters: function (langId, storeId, catalogId) {
        this.langId = langId;
        this.storeId = storeId;
        this.catalogId = catalogId;
        cursor_clear();
    },

    hideGLPanel: function (isPanelVisible) {
        this.isPanelVisible = isPanelVisible;
    },

    registerWidget: function (widgetId) {
        this.widgetsLoadedOnPage.push(widgetId);
    },

    InitHTTPSecure: function (widgetId) {
        var href = document.location.href;
        var index = href.lastIndexOf("s", 4);

        if (index != -1) {
            // Open sign in panel if loaded with HTTPS.
            GlobalLoginJS.displayPanel(widgetId);

        } else {
			// Loaded with HTTP. Change it to HTTPS along with appropriate port.
			if (WCParamJS.urlPrefixForHTTP) {
				var newHref = href.substring(WCParamJS.urlPrefixForHTTP.length);
				index = newHref.indexOf("/");
				newHref = WCParamJS.urlPrefixForHTTPS + newHref.substring(index);
			} else {
				var newHref = href.substring(0,4) + "s" + (href.substring(4));
			}
            setCookie("WC_DisplaySignInPanel_" + WCParamJS.storeId, "true", {
                path: '/',
                domain: cookieDomain
            });
            window.location = newHref;
            return;
        }
    },

    
 displayPanel: function (widgetId) {
		var redirectToPageName = getCookie("WC_RedirectToPage_"+WCParamJS.storeId);
			
		if (redirectToPageName != undefined && redirectToPageName != null)
  	setCookie("WC_RedirectToPage_"+WCParamJS.storeId, null, {expires:-1,path:"/", domain:cookieDomain});

 //check if the sign in panel is loaded. if loaded, toggle the dropdown. Else, trigger a refresh.
 var widgetNode = $("#" + widgetId);
 if (widgetNode.length > 0) {
 var panelLoaded = widgetNode.attr("panel-loaded");
 if (panelLoaded) {
 this.togglePanel(widgetNode);
 // Change the URL to display after successfull logOn.
 if(redirectToPageName != null && typeof (redirectToPageName) != 'undefined'){
 var globalLogInForm = document.getElementById(this.globalLogInWidgetID+"_GlobalLogon");
 if(globalLogInForm != null && typeof(globalLogInForm) != 'undefined'){
 globalLogInForm.URL.value = redirectToPageName;
 }
 }
 } else if (typeof isOnPasswordUpdateForm === 'undefined' || isOnPasswordUpdateForm == false) {
 if (!submitRequest()) {
 return;
 }
 cursor_wait();
 wcRenderContext.updateRenderContext("GlobalLogin_context",{"displayContract":"false", "widgetId" : widgetId, "redirectToPageName": redirectToPageName} );
 }
 }
	},



    togglePanel: function (widgetNode) {
        // toggle the current active global login panel.
        if (this.activePanel[KEY_ACTIVE] != null && this.activePanel[KEY_SELECTED] != null) {
            $("#" + this.activePanel[KEY_ACTIVE]).toggleClass("active");
            $("#" + this.activePanel[KEY_SELECTED]).toggleClass("selected");

            //if the current active panel is not the caller
            if (this.activePanel[KEY_ACTIVE] != widgetNode.attr("id")) {
                var toggleControl = widgetNode.attr("data-toggle-control");
                //toggle current widget
                widgetNode.toggleClass("active");
                toggleControl.toggleClass("selected");

                //set the current caller as active
                this.activePanel[KEY_ACTIVE] = widgetNode.attr("id");
                this.activePanel[KEY_SELECTED] = toggleControl;
            } else {
                delete this.activePanel.active;
                delete this.activePanel.selected;
                widgetNode.attr("panel-loaded", false);
                this.unregisterMouseDown();
            }
        } else {
            var toggleControl = widgetNode.attr("data-toggle-control");
            //no panel is active. toggle the current
            widgetNode.toggleClass("active");
            $("#" + toggleControl).toggleClass("selected");

            //set the current caller as active
            this.activePanel[KEY_ACTIVE] = widgetNode.attr("id");
            this.activePanel[KEY_SELECTED] = toggleControl;
            this.registerMouseDown();
        }
    },

    updateGlobalLoginSignInContent: function (widgetId) {
        if (!submitRequest()) {
            return;
        }
        cursor_wait();
        var redirectToPageName = getCookie("WC_RedirectToPage_" + WCParamJS.storeId);
        if (redirectToPageName != undefined && redirectToPageName != null) {
            setCookie("WC_RedirectToPage_" + WCParamJS.storeId, null, {
                expires: -1,
                path: '/',
                domain: cookieDomain
            });
        }
        wcRenderContext.updateRenderContext("GlobalLogin_context",{"displayContract":"false", "widgetId": widgetId, "redirectToPageName": redirectToPageName});
    },

    updateGlobalLoginUserDisplay: function (displayName) {
        $("#Header_GlobalLogin_signOutQuickLinkUser").html(displayName);
    },

    updateGlobalLoginContent: function (widgetId) {
        if (!submitRequest()) {
            return;
        }
        cursor_wait();
        wcRenderContext.updateRenderContext("GlobalLogin_context",{"displayContract":"true", "widgetId": widgetId});
    },

    updateOrganization: function (formName, widgetId) {
        var orgSetInSessionURL = widgetId + '_' + 'orgSetInSessionURL';
        var orgSetInSessionURLEle = document.getElementById(orgSetInSessionURL);
        if (orgSetInSessionURLEle != null) {
            var href = document.location.href;
            orgSetInSessionURLEle.value = href;
        }
        var form = document.forms[widgetId + '_' + formName];
        if (!submitRequest()) {
            return;
        }
        processAndSubmitForm(form);
    },

    prepareSubmit: function (widgetId) {
        var idPrefix = widgetId + "_";
        if (document.getElementById(idPrefix + "signInDropdown") != null && document.getElementById(idPrefix + "signInDropdown").className.indexOf("active") > -1) {
            document.getElementById(idPrefix + "inlinelogonErrorMessage_GL_logonPassword").setAttribute("class", "errorLabel");
            document.getElementById(idPrefix + "inlineLogonErrorMessage_GL_logonId").setAttribute("class", "errorLabel");
            var form_input_field = document.getElementById(idPrefix + "WC_AccountDisplay_FormInput_logonId_In_Logon_1");
            if (form_input_field != null) {
                if (this.isEmpty(form_input_field.value)) {
                    document.getElementById(idPrefix + "inlineLogonErrorMessage_GL_logonId").className = document.getElementById(idPrefix + "inlineLogonErrorMessage_GL_logonId").className + " active";
                    return false;
                }
            }
            var form_input_field = document.getElementById(idPrefix + "WC_AccountDisplay_FormInput_logonPassword_In_Logon_1");
            if (form_input_field != null) {
                if (this.isEmpty(form_input_field.value)) {
                    document.getElementById(idPrefix + "inlinelogonErrorMessage_GL_logonPassword").className = document.getElementById(idPrefix + "inlinelogonErrorMessage_GL_logonPassword").className + " active";
                    return false;
                }
            }
        }
        return true;
    },

    /**
     * Checks if a string is null or empty.
     * @param (string) str The string to check.
     * @return (boolean) Indicates whether the string is empty.
     */
    isEmpty: function (str) {
        var reWhiteSpace = new RegExp(/^\s+$/);
        if (str == null || str == '' || reWhiteSpace.test(str)) {
            return true;
        }
        return false;
    },

    /**
     * Updates the contract that is available to the current user.
     * @param {string} formName  The name of the form that contains the selected contracts.
     */
    updateContract: function (formName) {
        var form = document.forms[formName];

        /* For Handling multiple clicks. */
        if (!submitRequest()) {
            return;
        }

        form.submit();
    },

    deleteUserLogonIdCookie: function (contractURL) {
        var userLogonIdCookie = getCookie("WC_LogonUserId_" + WCParamJS.storeId);
        if (userLogonIdCookie != null) {
            setCookie("WC_LogonUserId_" + WCParamJS.storeId, null, {
                expires: -1,
                path: '/',
                domain: cookieDomain
            });
        }
    },

    changeRememberMeState: function (jspStoreImgDir, target) {
        var targetEle = document.getElementById(target);
        if (targetEle.className.indexOf("active") > -1) {
            targetEle.className = targetEle.className.replace('active', '');
            targetEle.setAttribute("aria-checked", "false");
            targetEle.setAttribute("src", jspStoreImgDir + "images/checkbox.png");
            document.getElementById(target.replace("_img", "")).setAttribute("value", "false");
        } else {
            targetEle.className = targetEle.className + " active";
            targetEle.setAttribute("src", jspStoreImgDir + "images/checkbox_checked.png");
            targetEle.setAttribute("aria-checked", "true");
            document.getElementById(target.replace("_img", "")).setAttribute("value", "true");
        }
    },

    deleteLoginCookies: function () {
        this.deleteUserLogonIdCookie();
        setCookie("WC_BuyOnBehalf_" + WCParamJS.storeId, null, {
            path: '/',
            expires: -1,
            domain: cookieDomain
        });
    },

    /**
     * Submit a global login sign in form
     * @param (object) widgetId The form widgetId id.
     */
    submitGLSignInForm: function (formId, widgetId) {
        service = wcService.getServiceById('globalLoginAjaxLogon');
        service.setFormId(formId);
        var params = {
            widgetId: widgetId
        };

        /*For Handling multiple clicks. */
        if (!submitRequest()) {
            return;
        }
        cursor_wait();
        wcService.invoke('globalLoginAjaxLogon', params);
    },

    /**
     * After successful login and setting a contract in session, we need to process the action that the shopper
     * was performing before signing in. It will do nothing if shopper was not trying to perform any actions.
     */
    processNextURL: function () {
        var myNextURL = getCookie("WC_nextURL_" + WCParamJS.storeId);
        if (myNextURL != undefined && myNextURL.length > 0) {
            myNextURL = myNextURL.replace(/&amp;/g, "&");
            if (myNextURL.indexOf('AjaxRESTOrderItemAdd') != -1) {
                invokeItemAdd(myNextURL);
            } else {
                invokeOtherService(myNextURL);
            }
        }
    },

    registerMouseDown: function () {
        if (!this.mouseDownConnectHandle) {
            $(document.documentElement).on("mousedown", $.proxy(this.handleMouseDown, this));
            this.mouseDownConnectHandle = true;
        }
    },

    unregisterMouseDown: function () {
        if (this.mouseDownConnectHandle) {
            $(document.documentElement).off("mousedown");
            this.mouseDownConnectHandle = false;
        }
    },

    handleMouseDown: function (evt) {
        if (this.activePanel[KEY_ACTIVE] != null && this.activePanel[KEY_SELECTED] != null) {
            Utils.ifSelectorExists("#" + this.activePanel[KEY_ACTIVE], function(widgetNode) {
                var toggleControl = $("#" + this.activePanel[KEY_SELECTED]);
                var node = evt.target;
                if (node != document.documentElement) {
                    var close = true;
                    while (node && node != document.documentElement) {
                        if (Utils.elementExists("#" + node.id + "_dropdown") && Utils.elementExists("#" + widgetNode.id + "_numEntitledContracts") != null && $("#" + widgetNode.id + "_numEntitledContracts").val() > 0) {
                            var nodePosition = Utils.position(node),
                                windowHeight = window.innerHeight,
                                newHeight;
                            if (windowHeight - nodePosition.y > nodePosition.y) {
                                newHeight = windowHeight - nodePosition.y;
                            } else {
                                newHeight = nodePosition.y;
                            }
                            var dropdownHeight = $("#" + node.id + "_dropdown").get(0).clientHeight;
                            if (dropdownHeight > newHeight) {
                                $("#" + node.id + "_dropdown").css("height", newHeight + "px");
                            }
                        }
                        if (widgetNode.is(node) || toggleControl.is(node) || $(node).hasClass("dijitPopup")) {
                            close = false;
                            break;
                        }
                        node = node.parentNode;
                    }
                    node = null;
                    if (node == null) {
                        widgetNode.children("div").each(function(i, e) {
                            var position = Utils.position(e);
                            if (evt.clientX >= position.x && evt.clientX < position.x + position.w &&
                                evt.clientY >= position.y && evt.clientY < position.y + position.h) {
                                close = false;
                                return false; // breaks
                            }
                        });
                        if (Utils.elementExists("#" + widgetNode.id + "_WC_B2BMyAccountParticipantRole_select_2_dropdown") &&
                            $("#" + widgetNode.id + "_WC_B2BMyAccountParticipantRole_select_2_dropdown").css("display") != "none" &&
                            Utils.elementExists("#" + widgetNode.id + "_numEntitledContracts") && $("#" + widgetNode.id + "_numEntitledContracts").val() > 0) {
                            var nodePosition = Utils.position("#" + widgetNode.id + "_WC_B2BMyAccountParticipantRole_select_2"),
                                windowHeight = window.innerHeight,
                                newHeight;
                            if (windowHeight - nodePosition.y > nodePosition.y) {
                                newHeight = windowHeight - nodePosition.y;
                            } else {
                                newHeight = nodePosition.y;
                            }
                            var dropDown = $("#" + widgetNode.id + "_WC_B2BMyAccountParticipantRole_select_2_dropdown"),
                                dropdownHeight = dropDown.get(0).clientHeight;
                            if (dropdownHeight > newHeight) {
                                dropDown.css("height", newHeight + "px");
                            }
                        }
                    }
                    if (close) {
                        this.togglePanel(widgetNode);
                    }
                }
            }, this);
        }
    }
};//-----------------------------------------------------------------
// Licensed Materials - Property of IBM
//
// WebSphere Commerce
//
// (C) Copyright IBM Corp. 2014, 2015 All Rights Reserved.
//
// US Government Users Restricted Rights - Use, duplication or
// disclosure restricted by GSA ADP Schedule Contract with
// IBM Corp.
//-----------------------------------------------------------------

$(document).ready(function () {
    window.setTimeout(function () {
        var href = document.location.href,
            index = href.lastIndexOf("s", 4),
            widgetId = 'Header_GlobalLogin';
        if (window.matchMedia && window.matchMedia("(max-width: 390px)").matches) {
            var widgetId = 'QuickLinks_GlobalLogin';
        }
        var idPrefix = widgetId + "_";

        //update the visible sign in link 		
        // TODO: test
        if ($("#" + idPrefix + "signInQuickLink").length) {
            if (index != -1) {
                var displaySignInPanel = getCookie("WC_DisplaySignInPanel_" + WCParamJS.storeId);
                if (displaySignInPanel != undefined && displaySignInPanel != null && displaySignInPanel.toString() == "true") {
                    GlobalLoginJS.updateGlobalLoginSignInContent(widgetId);
                    setCookie("WC_DisplaySignInPanel_" + WCParamJS.storeId, null, {
                        expires: -1,
                        path: '/',
                        domain: cookieDomain
                    });
                }
            }
        } else {
            var logonUserCookie = getCookie("WC_LogonUserId_" + WCParamJS.storeId);
            if (logonUserCookie != undefined && logonUserCookie != null && logonUserCookie != "") {
                var logonUserName = logonUserCookie.toString(),
                //update both the sign out links
                    widgetIds = GlobalLoginJS.widgetsLoadedOnPage;
                if (Utils.existsAndNotEmpty(widgetIds)) {
                    // TODO: test
                    widgetIds.forEach(function(registeredWidgetId) {
                        var idPrefix = registeredWidgetId + "_";

                        if ($("#" + idPrefix + "signOutQuickLink").length) {
                            var logonUserName = logonUserCookie.toString();
                            $("#" + idPrefix + "signOutQuickLinkUser").html(escapeXml(logonUserName, true));
	                        
                            if (Utils.varExists(GlobalLoginShopOnBehalfJS)) {
                                GlobalLoginShopOnBehalfJS.updateSignOutLink(registeredWidgetId);
                            }
                        }
                    });
                }
            }
            var displayContractPanel = getCookie("WC_DisplayContractPanel_" + WCParamJS.storeId);
            if ((displayContractPanel != undefined && displayContractPanel != null && displayContractPanel.toString() == "true") || (logonUserCookie == undefined && logonUserCookie == null)) {
                if (typeof isOnPasswordUpdateForm === 'undefined' || isOnPasswordUpdateForm == false) {
                    //Right after user logged in, perform Global Login Ajax call and display Global Login Contract panel.				
                    GlobalLoginJS.updateGlobalLoginContent(widgetId);
                } else if (isOnPasswordUpdateForm == true) {
                    GlobalLoginJS.updateGlobalLoginUserDisplay("...");
                }

            }
        }
    }, 100);
});//-----------------------------------------------------------------
// Licensed Materials - Property of IBM
//
// WebSphere Commerce
//
// (C) Copyright IBM Corp. 2014, 2015 All Rights Reserved.
//
// US Government Users Restricted Rights - Use, duplication or
// disclosure restricted by GSA ADP Schedule Contract with
// IBM Corp.
//-----------------------------------------------------------------

function declareSignInRefreshArea (thisRefreshAreaId) {
    // ============================================
    // common render context
    if (!wcRenderContext.checkIdDefined("GlobalLogin_context")) {
        wcRenderContext.declare("GlobalLogin_context", [thisRefreshAreaId], {"displayContract":"false"});
    } else {
        wcRenderContext.addRefreshAreaId("GlobalLogin_context", thisRefreshAreaId);
    }

    // render content changed handler
    var renderContextChangedHandler = function() {
        var renderContext = wcRenderContext.getRenderContextProperties("GlobalLogin_context");
        if(renderContext['widgetId'] == thisRefreshAreaId){
            $("#"+thisRefreshAreaId).refreshWidget("refresh",renderContext);
        }
    };

    // post refresh handler
    var postRefreshHandler = function() {
        cursor_clear();
        $("#" + thisRefreshAreaId).attr("panel-loaded", true);
        //Quick links
        if (window.matchMedia && window.matchMedia("(max-width: 390px)").matches) {
            $("#quickLinksButton").addClass("selected");
            $("#quickLinksMenu").addClass("active");
        }
        //toggle the panel
        GlobalLoginJS.displayPanel(thisRefreshAreaId);
        $("#" + thisRefreshAreaId + "_signInDropdown").focus();
    };

    // initialize widget
    $("#"+thisRefreshAreaId).refreshWidget({renderContextChangedHandler: renderContextChangedHandler, postRefreshHandler: postRefreshHandler});

}

function declareSignOutRefreshArea(thisRefreshAreaId) {
    if (!wcRenderContext.checkIdDefined("GlobalLogin_context")) {
        wcRenderContext.declare("GlobalLogin_context", [thisRefreshAreaId], {"displayContract":"false"});
    } else {
        wcRenderContext.addRefreshAreaId("GlobalLogin_context", thisRefreshAreaId);
    }

    var renderContextChangedHandler = function() {
        var renderContext = wcRenderContext.getRenderContextProperties("GlobalLogin_context");
        if(renderContext['widgetId'] == thisRefreshAreaId){
            $("#"+thisRefreshAreaId).refreshWidget("refresh",renderContext);
        }
    };

    wcTopic.subscribe("RunAsUserSetInSession", function(message) {
        if(message.actionId == 'RunAsUserSetInSession' ){
            if (Utils.varExists(GlobalLoginShopOnBehalfJS)) {
                GlobalLoginShopOnBehalfJS.updateSignOutLink(thisRefreshAreaId);
                GlobalLoginShopOnBehalfJS.initializePanels();
            }
        }
    });

    var postRefreshHandler = function() {
        cursor_clear();
        $("#" + thisRefreshAreaId).attr("panel-loaded", true);

        var idPrefix = thisRefreshAreaId + "_";

        //initialize the caller Id for filtering it from the search results
        if (Utils.varExists(GlobalLoginShopOnBehalfJS)) {
            Utils.ifSelectorExists("#" + idPrefix + "callerId", function(hiddenField) {
                GlobalLoginShopOnBehalfJS.setCallerId(hiddenField.val());
            });
        }

        var userDisplayNameField = $("#" + idPrefix + "userDisplayNameField");
        //get the user name from the display name field.
        if (userDisplayNameField !== null) {
            //clear the old cookie and write it afresh.
            var logonUserCookie = getCookie("WC_LogonUserId_" + WCParamJS.storeId);
            if (logonUserCookie != null) {
                setCookie("WC_LogonUserId_" + WCParamJS.storeId, null, {
                    expires: -1,
                    path: '/',
                    domain: cookieDomain
                });
            }
            setCookie("WC_LogonUserId_" + WCParamJS.storeId, userDisplayNameField.val(), {
                path: '/',
                domain: cookieDomain
            });

            var updateLogonUserCookie = getCookie("WC_LogonUserId_" + WCParamJS.storeId);
            if (updateLogonUserCookie !== 'undefined' && updateLogonUserCookie.length) {
                logonUserName = updateLogonUserCookie.toString();
            } else {
                logonUserName = userDisplayNameField.val();
            }
            var widgetIds = GlobalLoginJS.widgetsLoadedOnPage;
            if (Utils.existsAndNotEmpty(widgetIds)) {
                widgetIds.forEach(function(registeredWidgetId) {
                    idPrefix = registeredWidgetId + "_";
                    Utils.ifSelectorExists("#" + idPrefix + "signOutQuickLink", function(signOutLink) {
                        $("#" + idPrefix + "signOutQuickLinkUser").html(escapeXml(logonUserName, true));

                        if (Utils.varExists(GlobalLoginShopOnBehalfJS)) {
                            GlobalLoginShopOnBehalfJS.updateSignOutLink(registeredWidgetId);
                            GlobalLoginShopOnBehalfJS.initializePanels();
                        }
                    });
                });
            }
        }
		
		var displayContractPanel = getCookie("WC_DisplayContractPanel_" + WCParamJS.storeId);
		var widgetIds = GlobalLoginJS.widgetsLoadedOnPage;
		var tempIdPrefix = "";
        if (Utils.existsAndNotEmpty(widgetIds)) {
            widgetIds.forEach(function(registeredWidgetId) {
				tempIdPrefix = registeredWidgetId + "_";
				Utils.ifSelectorExists("#" + tempIdPrefix + "activeContractIdsArrayLength", function(activeContractsInput) {
					idPrefix = registeredWidgetId + "_";
                });
			});
			var activeContractIdsArrayLength = $("#" + idPrefix + "activeContractIdsArrayLength");
			if (activeContractIdsArrayLength != null && activeContractIdsArrayLength.value > 1 && (displayContractPanel == undefined || displayContractPanel == null)) {
				setCookie("WC_DisplayContractPanel_" + WCParamJS.storeId, "true", {
					path: '/',
					domain: cookieDomain
				});
				window.location = $("#" + idPrefix + "setFirstContractInSessionURLField").val();
				return;
			}
        }
		
        if (displayContractPanel != undefined && displayContractPanel != null && displayContractPanel.toString() == "true") {
            setCookie("WC_DisplayContractPanel_" + WCParamJS.storeId, null, {
                expires: -1,
                path: '/',
                domain: cookieDomain
            });
        }
        GlobalLoginJS.processNextURL();

        //Display the sign out drop down panel on quick link when view is below 390px.
        if (window.matchMedia("(max-width: 390px)").matches) {
            $("#quickLinksButton").addClass("selected");
            $("#quickLinksMenu").addClass("active");
        }
        GlobalLoginJS.displayPanel(thisRefreshAreaId);
        $("#" + thisRefreshAreaId + "_loggedInDropdown").focus();
    };

    // initialize widget
    $("#"+thisRefreshAreaId).refreshWidget({renderContextChangedHandler: renderContextChangedHandler, postRefreshHandler: postRefreshHandler});

}
//-----------------------------------------------------------------
// Licensed Materials - Property of IBM
//
// WebSphere Commerce
//
// (C) Copyright IBM Corp. 2014, 2016 All Rights Reserved.
//
// US Government Users Restricted Rights - Use, duplication or
// disclosure restricted by GSA ADP Schedule Contract with
// IBM Corp.
//-----------------------------------------------------------------

/**
 * @fileOverview This javascript is used by the Global Login widget to handle the services
 * @version 1.10
 */

/* global document, window, $, wc, Utils, WCParamJS, MessageHelper, cursor_clear, getAbsoluteURL */


/**
 * This service allows customer to sign in
 * @constructor
 */
wcService.declare({
    id: "globalLoginAjaxLogon",
    actionId: "globalLoginAjaxLogon",
    url: getAbsoluteURL() + "AjaxLogon",
    formId: "",

    /**
     * Hides all the messages and the progress bar.
     * @param (object) serviceResponse The service response object, which is the
     * JSON object returned by the service invocation.
     */
    successHandler: function (serviceResponse) {
        cursor_clear();
        var errorMessage = "";
        if (serviceResponse.ErrorCode != null) {
            var errorCode = Number(serviceResponse.ErrorCode);
            switch (errorCode) {
            case 2000:
                errorMessage = MessageHelper.messages["GLOBALLOGIN_SIGN_IN_ERROR_2000"];
                break;
            case 2010:
                errorMessage = MessageHelper.messages["GLOBALLOGIN_SIGN_IN_ERROR_2010"];
                break;
            case 2020:
                errorMessage = MessageHelper.messages["GLOBALLOGIN_SIGN_IN_ERROR_2020"];
                break;
            case 2030:
                errorMessage = MessageHelper.messages["GLOBALLOGIN_SIGN_IN_ERROR_2030"];
                break;
            case 2110:
                errorMessage = MessageHelper.messages["GLOBALLOGIN_SIGN_IN_ERROR_2110"];
                break;
            case 2300:
                errorMessage = MessageHelper.messages["GLOBALLOGIN_SIGN_IN_ERROR_2300"];
                break;
            case 2340:
                errorMessage = MessageHelper.messages["GLOBALLOGIN_SIGN_IN_ERROR_2340"];
                break;
            case 2400:
                errorMessage = MessageHelper.messages["GLOBALLOGIN_SIGN_IN_ERROR_2400"];
                break;
            case 2410:
                errorMessage = MessageHelper.messages["GLOBALLOGIN_SIGN_IN_ERROR_2410"];
                break;
            case 2420:
                errorMessage = MessageHelper.messages["GLOBALLOGIN_SIGN_IN_ERROR_2420"];
                break;
            case 2430:
                document.location.href = "ResetPasswordForm?storeId=" + WCParamJS.storeId + "&catalogId=" + WCParamJS.catalogId + "&langId=" + WCParamJS.langId + "&errorCode=" + errorCode;
                break;
            case 2170:
                document.location.href = "ChangePassword?storeId=" + WCParamJS.storeId + "&catalogId=" + WCParamJS.catalogId + "&langId=" + WCParamJS.langId + "&errorCode=" + errorCode + "&logonId=" + serviceResponse.logonId;
                break;
            case 2570:
                errorMessage = MessageHelper.messages["GLOBALLOGIN_SIGN_IN_ERROR_2570"];
                    break;
                case 2440:
                    errorMessage = MessageHelper.messages["GLOBALLOGIN_SIGN_IN_ERROR_2440"];
                    break;
                case 2450:
                    errorMessage = MessageHelper.messages["GLOBALLOGIN_SIGN_IN_ERROR_2450"];
                    break;
            }
            if (document.getElementById(serviceResponse.widgetId + "_logonErrorMessage_GL") != null) {
                document.getElementById(serviceResponse.widgetId + "_logonErrorMessage_GL").innerHTML = errorMessage;
                document.getElementById(serviceResponse.widgetId + "_WC_AccountDisplay_FormInput_logonId_In_Logon_1").setAttribute("aria-invalid", "true");
                document.getElementById(serviceResponse.widgetId + "_WC_AccountDisplay_FormInput_logonId_In_Logon_1").setAttribute("aria-describedby", "logonErrorMessage_GL_alt");
                document.getElementById(serviceResponse.widgetId + "_WC_AccountDisplay_FormInput_logonPassword_In_Logon_1").setAttribute("aria-invalid", "true");
                document.getElementById(serviceResponse.widgetId + "_WC_AccountDisplay_FormInput_logonPassword_In_Logon_1").setAttribute("aria-describedby", "logonErrorMessage_GL_alt");
            }
        } else {

            var url = serviceResponse.URL[0].replace(/&amp;/g, '&'),
                languageId = serviceResponse.langId;
            if (languageId != null && document.getElementById('langSEO' + languageId) != null) { // Need to switch language.

                var browserURL = document.location.href,
                    currentLangSEO = '/' + $('#currentLanguageSEO').val() + '/';

                if (browserURL.indexOf(currentLangSEO) !== -1) {
                    // If it's SEO URL.
                    var preferLangSEO = '/' + $('#langSEO' + languageId).val() + '/';

                    var query = url.substring(url.indexOf('?') + 1, url.length),
                        parameters = Utils.queryToObject(query);
                    if (parameters["URL"] != null) {
                        var redirectURL = parameters["URL"],
                            query2 = redirectURL.substring(redirectURL.indexOf('?') + 1, redirectURL.length),
                            parameters2 = Utils.queryToObject(query2);
                        // No redirect URL
                        if (parameters2["URL"] != null) {
                            var finalRedirectURL = parameters2["URL"];
                            if (finalRedirectURL.indexOf(currentLangSEO) != -1) {
                                // Get the prefer language, and replace with prefer language.
                                finalRedirectURL = finalRedirectURL.replace(currentLangSEO, preferLangSEO);
                                parameters2["URL"] = finalRedirectURL;
                            }
                            query2 = $.param(parameters2);
                            redirectURL = redirectURL.substring(0, redirectURL.indexOf('?')) + '?' + query2;
                        } else {
                            //Current URL is the final redirect URL.
                            redirectURL = redirectURL.toString().replace(currentLangSEO, preferLangSEO);
                        }
                        parameters["URL"] = redirectURL;
                    }
                    query = $.param(parameters);
                    url = url.substring(0, url.indexOf('?')) + '?' + query;

                } else {
                    // Not SEO URL.
                    // Parse the parameter and check whether if have langId parameter.
                    if (url.contains('?')) {
                        var query = url.substring(url.indexOf('?') + 1, url.length),
                            parameters = Utils.queryToObject(query);
                        if (parameters["langId"] != null) {
                            parameters["langId"] = languageId;
                            var query2 = $.param(parameters);
                            url = url.substring(0, url.indexOf('?')) + '?' + query2;
                        } else {
                            url = url + "&langId=" + languageId;
                        }
                    } else {
                        url = url + "?langId=" + languageId;
                    }
                }
            }

            if (serviceResponse["MERGE_CART_FAILED_SHOPCART_THRESHOLD"] == "1") {
                setCookie("MERGE_CART_FAILED_SHOPCART_THRESHOLD", "1", {path: "/", domain: cookieDomain});
            }
            window.location = url;
        }
    },

    /**
     * display an error message.
     * @param (object) serviceResponse The service response object, which is the
     * JSON object returned by the service invocation.
     */
    failureHandler: function (serviceResponse) {
        if (serviceResponse.errorMessage) {
            MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
        } else {
            if (serviceResponse.errorMessageKey) {
                MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
            }
        }
        cursor_clear();
    }
});//-----------------------------------------------------------------
// Licensed Materials - Property of IBM
//
// WebSphere Commerce
//
// (C) Copyright IBM Corp. 2014, 2016 All Rights Reserved.
//
// US Government Users Restricted Rights - Use, duplication or
// disclosure restricted by GSA ADP Schedule Contract with
// IBM Corp.
//-----------------------------------------------------------------

/* global KeyCodes */
var SEARCH_CRITERIA_LAST_NAME = "lastName";

GlobalLoginShopOnBehalfJS = {

    //The topic to subscribe to
    USER_SEARCH_CRITERIA_TOPIC: "userSearchCriteriaChanged",

    firstNameSearchType: 3,

    lastNameSearchType: 3,

    updateTimer: null,

    //The timeout value
    timeOut: 1000,

    buyerSearchURL: "",

    loadedPanels: {},

    callerId: "",

    logoutURL: null,

    redirectURL: null,

    buyerData: [],

    /**
     *Sets the id of the Admin who is calling on behalf of buyer
     *@param callerId The id of the buyer admin   
     */
    setCallerId: function (callerId) {
        this.callerId = callerId;
    },

    /**
     *Sets the REST URL to be used for finding buyers
     *@param buyerSearchURL The REST URL   
     */
    setBuyerSearchURL: function (buyerSearchURL) {
        this.buyerSearchURL = buyerSearchURL;
    },

    /**
     *This method registers the panels loaded on the page.
     *@param shopOnBehalfPanelId The panel which shows the shopping on behalf options
     *@param shopForSelfPanelId the corresponding panel which shows the shop for self options.      
     */
    registerShopOnBehalfPanel: function (shopOnBehalfPanelId, shopForSelfPanelId) {
        this.loadedPanels[shopOnBehalfPanelId] = shopForSelfPanelId;
    },

    /**
     *This method checks if the current page is loaded in HTTPs.
     *@return true if the page was in HTTP; false, otherwise.   
     */
    isPageUsingHTTP: function () {
        var protocol = document.location.protocol;
        return (protocol == 'http:');
    },

    /**
     *This function reloads the page using HTTPS. Once the page is loaded, the shop on behalf
     *check box will be toggled.   
     */
    initHTTPSecure: function () {
        //reload the page with HTTPS and show the sign in panel
        var newHref = "https://" + document.location.host + document.location.pathname;
        if (Utils.existsAndNotEmpty(document.location.search)) {
            newHref = newHref + document.location.search;
        }
        //set these cookies to process the page once its reloaded.
        setCookie("WC_DisplayContractPanel_" + WCParamJS.storeId, true, {
            path: "/",
            domain: cookieDomain
        });
        setCookie("WC_ToogleOnBehalfPanel_" + WCParamJS.storeId, true, {
            path: "/",
            domain: cookieDomain
        });
        window.location.href = newHref;
        return;
    },

    /**
     *This method initializes the panels that have been registered.
     *It sets up the event listeners on these panels. This method is called
     *when the panels are loaded.              
     */
    initializePanels: function () {
        if (this.loadedPanels) {
            for (var shopOnBehalfPanelId in this.loadedPanels) {
                Utils.ifSelectorExists("#" + shopOnBehalfPanelId, function(shopOnBehalfPanel) {
                    this.initializePanel(shopOnBehalfPanelId, this.loadedPanels[shopOnBehalfPanelId]);
                }, this);
            }
        }

    },

    /**
     *This method initializes a panel. It setups the event listeners on the panel
     *@param shopOnBehalfPanelId The panel which shows the shopping on behalf options
     *@param shopForSelfPanelId the corresponding panel which shows the shop for self options.
     */
    initializePanel: function (shopOnBehalfPanelId, shopForSelfPanelId) {
        var isInitialized = $("#" + shopOnBehalfPanelId).attr("isEventsSetup");
        if (!isInitialized) {
            this.setUpEvents(shopOnBehalfPanelId);
            $("#" + shopOnBehalfPanelId).attr("isEventsSetup", true);

            //check the toggle button if the cookie has been set.
            var toogleOnBehalfPanel = getCookie("WC_ToogleOnBehalfPanel_" + WCParamJS.storeId);
            if (toogleOnBehalfPanel != null && toogleOnBehalfPanel) {
                this.toggleShopOnBehalfPanel(shopOnBehalfPanelId + "_shopOnBehalfCheckBox", shopForSelfPanelId, shopOnBehalfPanelId);

                //delete the cookie.
                setCookie("WC_ToogleOnBehalfPanel_" + WCParamJS.storeId, null, {
                    path: "/",
                    expires: -1
                });
            }
        }
        // TODO: test
        var callerId = "";
        Utils.ifSelectorExists("#" + shopOnBehalfPanelId + "_callerId", function(callerIdNode) {
            callerId = callerIdNode.html();
        });
        this.setCallerId(callerId);
    },

    /**
     * This method toggles the shop on behalf panel. If the page is loaded in HTTP,
     * this method reloads the page with HTTPs.
     *       
     * @param target The check box node
     * @param shopForSelfSectionId The ID of the panel which shows the shop for self options
     * @param shopOnBehalfOfSectionId The ID of the panel which shows the shop on behalf options          
     */
    toggleShopOnBehalfPanel: function (target, shopForSelfSectionId, shopOnBehalfOfSectionId) {
        if (this.isPageUsingHTTP()) {
            this.initHTTPSecure();
        } else {
            var $target = $("#" + target);
            if($target.length === 0) return;

            var targetSrc = $target.attr("src");
            if ($target.hasClass("uncheckedCheckBox")) {
                //shop on behalf is unchecked. Check it.
                $target.attr("src", targetSrc.replace("checkbox", "checkbox_checked"))
                    .removeClass("uncheckedCheckBox")
                    .addClass("checkedCheckBox");
                
                //show shop on behalf options.
                $("#" + shopForSelfSectionId).css('display', 'none');
                $("#" + shopOnBehalfOfSectionId).css('display', 'block');
            } else {
                //shop on behalf is checked. Uncheck it.
                $target.attr("src", targetSrc.replace("checkbox_checked", "checkbox"))
                    .removeClass("checkedCheckBox")
                    .addClass("uncheckedCheckBox");
                
                //show show for self options.
                $("#" + shopOnBehalfOfSectionId).css('display', 'none');
                $("#" + shopForSelfSectionId).css('display', 'block');
            }
        }
    },

    /**
     * Sets up events for the user search text box.
     * @param shopOnBehalfOfSectionId The shop on behalf panel Id
     */
    setUpEvents: function (shopOnBehalfOfSectionId) {
        var eventName = 'keyup',
            scope = this;
        $(document).ready(function () {
            var textBox = shopOnBehalfOfSectionId + "_buyerUserName",
                searchErrorLabel = shopOnBehalfOfSectionId + "_errorLabel";
            console.debug("Setting up  on " + eventName + " event for DOM element = " + textBox + ". ", "Topic = " + scope.USER_SEARCH_CRITERIA_TOPIC);
            Utils.ifSelectorExists("#" + textBox, function(textBoxObj) {
                wcTopic.subscribe(scope.USER_SEARCH_CRITERIA_TOPIC, function (data) {
                    //read the search input text and clear the timer.
                    data["buyerSearchInput"] = textBoxObj.val();
                    console.debug("Clearing previous timers and starting a new one. Search results will updated after " + scope.timeOut + " milliSeconds.", data);
                    clearTimeout(scope.updateTimer);
                    scope.updateTimer = setTimeout(function() {
                        scope.updateSearchResults(data);
                    }, scope.timeOut);
                });
                
                textBoxObj.on(eventName, function (event) {
                    //get the text box value and publish the data
                    var data = {
                        "buyerSearchInput": textBoxObj.val(),
                        "data-parent": textBoxObj.attr("data-parent"),
                        "originator": textBoxObj.attr("id"),
                        'searchErrorLabel': searchErrorLabel
                    };
                    console.debug("publishing ", data);
                    if (event.keyCode === KeyCodes.TAB) {
                        return;
                    } 
                    wcTopic.publish(scope.USER_SEARCH_CRITERIA_TOPIC, data);
                });
            });
        });
    },

    /**
     *This method processes the search criteria input by the user and triggers a search.
     *@param searchCriteria The raw search criteria input
     */
    updateSearchResults: function (searchCriteria) {
        console.debug("User input : ", searchCriteria.buyerSearchInput);
        //break down the search input into first name and last name.
        if (searchCriteria.buyerSearchInput !== 'undefined') {
            var searchInput = new String(searchCriteria.buyerSearchInput),
                lastName = searchInput;
            searchCriteria[SEARCH_CRITERIA_LAST_NAME] = lastName;

            this.performSearch(searchCriteria);
        }
    },

    /**
     *This method performs the buyer user search based on the search criteria specified.
     *@searchCriteria The search criteria   
     */
    performSearch: function (searchCriteria) {
        var renderContextProperties = wcRenderContext.getRenderContextProperties('GlobalLoginShopOnBehalf_context');
        var lastName = searchCriteria[SEARCH_CRITERIA_LAST_NAME];
        var previousLastName = renderContextProperties["previousLastName"];
        //search only when the previous first name or last name dont match the current
        if (lastName != previousLastName && lastName !== '') {
            //save the current search criteria as previous in the render context.
            renderContextProperties['previousLastName'] = lastName;

            $("#" + searchCriteria['originator'] + "Error").css("display", "none");
            
            setCurrentId(searchCriteria['originator']);

            //perform the search
            if (!submitRequest()) {
                return;
            }
            cursor_wait();

            //The REST service uses a GET.
            $.ajax({
                url: GlobalLoginShopOnBehalfJS.buyerSearchURL,
                dataType: "json",
                data: {
                    'lastName': lastName,
                    'lastNameSearchType': GlobalLoginShopOnBehalfJS.lastNameSearchType
                },
                headers: {
                    'Content-Type': 'text/plain; charset=utf-8'
                },
                context: this,
                success: function (response, textStatus, jqXHR) {
                    cursor_clear();
                    this.displaySearchResults(response, searchCriteria);
                },
                error: function(jqXHR, textStatus, err) {
                    cursor_clear();
                    err['errorCode'] = 'GENERICERR_MAINTEXT';
                    this.handleError(err, searchCriteria);
                }
            });
        } else {
            console.debug('input has not changed');
        }
    },

    /**
     *This method displays the user search results.
     *@param searchResults The result set 
     *@param searchCriteria The search criteria used for search.
     */
    displaySearchResults: function (searchResults, searchCriteria) {
        console.debug('Search results :', searchResults);
        var scope = this,
            $errorLabel = $("#" + searchCriteria.searchErrorLabel);
        //set up the buyer data for the search results drop down.
        var dropdownData = [],
            lastNameFirst = Utils.arrContains(['ja-jp', 'ko-kr', 'zh-cn', 'zh-tw'], Utils.getLocale());
        if (searchResults != null && Utils.existsAndNotEmpty(searchResults.userDataBeans)) {
            $errorLabel.removeClass("active");
            for (var i = 0; i < searchResults.userDataBeans.length; i++) {
                var userEntry = searchResults.userDataBeans[i];
                userEntry.displayName = "";

                var userFirstName = '',
                    userLastName = '';
                
                if (Utils.notNullOrWhiteSpace(userEntry.firstName)) {
                    userFirstName = lastNameFirst ? " " + userEntry.firstName : userEntry.firstName + " ";
                }
                
                if (Utils.notNullOrWhiteSpace(userEntry.lastName)) {
                    userLastName = userEntry.lastName;
                }
                userEntry.displayName = lastNameFirst ? userLastName + userFirstName : userFirstName + userLastName;
                
                userEntry.fullName = $.trim(userEntry.displayName);

                userEntry.displayName += " (" + userEntry.logonId + ")";
                
                userEntry.displayName = $.trim(userEntry.displayName);

                if(userEntry.userId !== scope.callerId) {
                    dropdownData.push(userEntry.displayName);
                }
            }
            this.buyerData = searchResults.userDataBeans;
        } else {
            $errorLabel.addClass('active');
        }

        //set the buyerData to the buyer user dropdown
        var $autocomplete = $("#" + searchCriteria['originator']);
        $autocomplete.autocomplete({
            "source": dropdownData,
            "select": function (event, ui) {
                        GlobalLoginShopOnBehalfJS.selectUser(event.target, ui.item.value);
                    }
        });
        $autocomplete.autocomplete("search", $autocomplete.val());
    },

    /**
     *This method displays the error when the search fails.
     *@param error Error data
     *@param searchCriteria The original search criteria      
     */
    handleError: function (error, nodeToDisplayError) {
        console.debug('An error occurred while searching for users ', error);
        var errorMessage = null;
        if (error.errorMessage != null) {
            errorMessage = error.errorMessage;
        } else if (error.errorMessageKey != null) {
            errorMessage = Utils.getLocalizationMessage(error.errorMessageKey);
        } else if (error.errorCode != null) {
            errorMessage = Utils.getLocalizationMessage(error.errorCode);
        }
        if (errorMessage == null || errorMessage === "") {
            errorMessage = Utils.getLocalizationMessage('GENERICERR_MAINTEXT');
        }
        // TODO: test
        $("#" + nodeToDisplayError).html(errorMessage)
            .css("display", "block");
    },

    /**
     *This method is invoked when the admin selects the user.
     *This method invokes the RunAsUserSetInSessionService and refreshes the panel to indicate the buyer
     *@param userDropDown The drop down node.
     *@param selectedUserName The selected user display name.
     */
    selectUser: function (userDropDown, selectedUserName) {
        var $searchUsersBox = $("#" + userDropDown.id);
        var selectedUser = $.grep(this.buyerData, function(e){ return e.displayName === selectedUserName; })[0];
        if (selectedUser != null && selectedUser.userId !== '-1') {
            var renderContextProperties = wcRenderContext.getRenderContextProperties('GlobalLoginShopOnBehalf_context');
            renderContextProperties["selectedUser"] = selectedUser;
            renderContextProperties["shopOnBehalfPanelId"] = $searchUsersBox.attr('data-parent');
            renderContextProperties["shopForSelfPanelId"] = this.loadedPanels[$searchUsersBox.attr('data-parent')];

            setCurrentId(userDropDown.id);
            if (!submitRequest()) {
                return;
            }
            cursor_wait();
            var shopOnBehalfATForm = document.forms["shopOnBehalf_AuthTokenInfo"];
            var authToken = shopOnBehalfATForm.shopOnBehalf_AuthToken.value;
            wcService.invoke("RunAsUserSetInSessionService", {
                'runAsUserId': selectedUser.userId,
                'authToken': authToken
            });
        }
    },

    /**
     *This method is invoked when the RunAsUserSetInSessionService is successful.
     *It refreshes the panel
     */
    onUserSetInSession: function () {
        var renderContextProperties = wcRenderContext.getRenderContextProperties('GlobalLoginShopOnBehalf_context');
        var selectedUser = renderContextProperties["selectedUser"];

        //write the cookie.
        setCookie("WC_BuyOnBehalf_" + WCParamJS.storeId, escapeXml(selectedUser.fullName, true), {
            path: '/',
            domain: cookieDomain
        });
        var widgetIds = GlobalLoginJS.widgetsLoadedOnPage;
        if (widgetIds != null && widgetIds.length > 0) {
            for (var i = 0; i < widgetIds.length; i++) {
                this.updateSignOutLink(widgetIds[i]);
            }
        }
        setDeleteCartCookie();
        //instead of refreshing the panel, we refresh the page to my account page to update the my account links.
        setCookie("WC_DisplayContractPanel_" + WCParamJS.storeId, true, {
            path: "/",
            domain: cookieDomain
        });
        document.location.href = "AjaxLogonForm?storeId=" + WCParamJS.storeId + "&catalogId=" + WCParamJS.catalogId + "&langId=" + WCParamJS.langId + "&myAcctMain=1";
    },

    /**
     *This method is invoked when the user chooses an organization.
     *It invokes the OrganizationSetInSessionService service.
     *      
     *@param The organization drop down node
     */
    updateOrganization: function (organizationNode) {
        var organizationDropDown = $("#" + organizationNode.id)[0];
        var organizationSelected = organizationDropDown.value;
        var renderContextProperties = wcRenderContext.getRenderContextProperties('GlobalLoginShopOnBehalf_context');
        renderContextProperties["shopOnBehalfPanelId"] = organizationDropDown['data-parent'];
        renderContextProperties["shopForSelfPanelId"] = this.loadedPanels[organizationDropDown['data-parent']];

        setCurrentId(organizationNode.id);
        if (!submitRequest()) {
            return;
        }
        cursor_wait();
        wcService.invoke("OrganizationSetInSessionService", {
            'activeOrgId': organizationSelected
        });
    },

    /**
     *This method is invoked when the user chooses a contract.
     *It invokes the ContractSetInSessionService service.  
     *   
     *@param contractNode The contract drop down node.
     */
    updateContract: function (contractNode) {
        var contractDropDown = $("#" + contractNode.id)[0];
        var contractSelected = contractDropDown.value;
        var renderContextProperties = wcRenderContext.getRenderContextProperties('GlobalLoginShopOnBehalf_context');
        renderContextProperties["shopOnBehalfPanelId"] = contractDropDown['data-parent'];
        renderContextProperties["shopForSelfPanelId"] = this.loadedPanels[contractDropDown['data-parent']];

        setCurrentId(contractDropDown.id);
        if (!submitRequest()) {
            return;
        }
        cursor_wait();
        wcService.invoke("ContractSetInSessionService", {
            'contractId': contractSelected
        });
    },

    /**
     *This method clears the user set in session. It restores the session to that of the buyer admin and redirects the user to redirectURL
     */
    clearUserSetInSession: function (link, redirectURL) {
        if (link != null && link !== '') {
            setCurrentId(link.id);
        }
        if (!submitRequest()) {
            return;
        }
        cursor_wait();
        this.logoutURL = null;
        this.redirectURL = redirectURL;
        wcService.invoke("RestoreOriginalUserSetInSessionService");
    },

    /**
     * This method clears the user set in the session before logging off the buyer admin.
     */
    clearUserSetInSessionAndLogoff: function (logoutURL) {
        if (!submitRequest()) {
            return;
        }
        cursor_wait();
        this.logoutURL = logoutURL;
        this.redirectURL = null;
        wcService.invoke("RestoreOriginalUserSetInSessionService");
    },

    restoreCSRSessionAndRedirect: function (redirectURL) {
        GlobalLoginJS.deleteUserLogonIdCookie();
        GlobalLoginShopOnBehalfJS.deleteBuyerUserNameCookie();
        GlobalLoginShopOnBehalfJS.clearUserSetInSession('', redirectURL);
    },

    /**
     *This method is invoked when the for user session is successfully terminated.
     *This method reloads the current page.         
     */
    onRestoreUserSetInSession: function () {
        //clear the cookie
        setCookie("WC_BuyOnBehalf_" + WCParamJS.storeId, null, {
            path: '/',
            expires: -1,
            domain: cookieDomain
        });
        /* Page is getting reloaded.. Why to update the links now ?
				var widgetIds = GlobalLoginJS.widgetsLoadedOnPage;
                if (widgetIds != null && widgetIds.length > 0){
                	for (var i = 0; i < widgetIds.length; i++) {
                		this.updateSignOutLink(widgetIds[i]);
                	}
                }*/
		setDeleteCartCookie();
		deleteOnBehalfRoleCookie();
		if (this.redirectURL == "-1"){
			// Stay on the same page.
			return;
		} else if (this.logoutURL == null && this.redirectURL == null) {
			//refresh the page, if it's not HTTPS
			if(!stringStartsWith(document.location.href, "https")){
				document.location.reload();
			} else {
				// Reload home page
				document.location.href =  WCParamJS.homePageURL;
			}

		} else if(this.redirectURL != null && this.redirectURL != "-1"){
			document.location.href = this.redirectURL;
		}
		else {
			logout(this.logoutURL);
        }
    },

    /**
     * This method updates the sign out link to display the buyer name.
     * This method is invoked once the buyer's session is established.
     */
    updateSignOutLink: function (widgetId) {
        var idPrefix = widgetId + "_";
        // TODO: test
        Utils.ifSelectorExists("#" + idPrefix + "signOutQuickLinkUser", function(signOutLink) {
            var logonUser = "",
                logonUserCookie = getCookie("WC_LogonUserId_" + WCParamJS.storeId);
            if (typeof logonUserCookie != 'undefined') {
                logonUser = logonUserCookie;
            }
            // TODO: test
            signOutLink.html(escapeXml(logonUser, true));
            var buyerUserName = "",
                buyOnBehalfCookie = getCookie("WC_BuyOnBehalf_" + WCParamJS.storeId);
            if (typeof buyOnBehalfCookie != 'undefined') {
                buyerUserName = escapeXml(buyOnBehalfCookie, true);
            }
            if (buyerUserName !== "") {
                // TODO: test
                signOutLink.append(" (" + buyerUserName + ")");
            }
        });
    },

    deleteBuyerUserNameCookie: function () {
        setCookie("WC_BuyOnBehalf_" + WCParamJS.storeId, null, {
            expires: -1,
            path: '/',
            domain: cookieDomain
        });
        var widgetIds = GlobalLoginJS.widgetsLoadedOnPage;
        if (widgetIds != null && widgetIds.length > 0) {
            for (var i = 0; i < widgetIds.length; i++) {
                this.updateSignOutLink(widgetIds[i]);
            }
        }
    },

    resetBuyerUserNameCookie: function (buyerUserName) {
        setCookie("WC_BuyOnBehalf_" + WCParamJS.storeId, escapeXml(buyerUserName, true), {
            path: '/',
            domain: cookieDomain
        });
        var widgetIds = GlobalLoginJS.widgetsLoadedOnPage;
        if (widgetIds != null && widgetIds.length > 0) {
            for (var i = 0; i < widgetIds.length; i++) {
                this.updateSignOutLink(widgetIds[i]);
            }
        }
    },

    resetDropdown: function (dropDownNode) {
        var $dropDown = $("#" + dropDownNode.id);
        if($dropDown.length) {
            $dropDown.val("");
        }
    },
    
    declareShopOnBehalfPanelRefreshArea: function(divId) {
        // ============================================
        // div: divId refresh area
        // 
        if(typeof divId === "object") {
            divId = divId[0];
        }
        
        var myWidgetObj = $("#"+divId);
        wcRenderContext.addRefreshAreaId("GlobalLoginShopOnBehalf_context", divId);
        var myRCProperties = wcRenderContext.getRenderContextProperties("GlobalLoginShopOnBehalf_context");
        
        /** 
         * Refreshes the Global Login panel.
         * This function is called when a render context event is detected. 
         */
        var renderContextChangedHandler = function () {
            myWidgetObj.refreshWidget("refresh", myRCProperties);
        };
        
        /** 
         * Clears the progress bar
         */
        var postRefreshHandler = function () {
            delete myRCProperties.selectedUser;
            delete myRCProperties.firstName;
            delete myRCProperties.lastName;
            delete myRCProperties.previousFirstName;
            delete myRCProperties.previousLastName;
            delete myRCProperties.showOnBehalfPanel;
            GlobalLoginShopOnBehalfJS.initializePanels();
            cursor_clear();
        }
         
        // initialize widget
        myWidgetObj.refreshWidget({renderContextChangedHandler: renderContextChangedHandler, postRefreshHandler: postRefreshHandler});
    }

};

/**
 * Declares a new render context for initiating on behalf session
 */
wcRenderContext.declare("GlobalLoginShopOnBehalf_context", [], {'previousLastName': null, 'firstName': null, 'lastName': null});

/**
 *  Service declaration to invoke RunAsUserSetInSession command.
 *  @constructor
 */
wcService.declare({
    id: "RunAsUserSetInSessionService",
    actionId: "RunAsUserSetInSession",
    url: "AjaxRunAsUserSetInSession",
    formId: "",

    /**
     *  This method refreshes the panel 
     *  @param (object) serviceResponse The service response object, which is the
     *  JSON object returned by the service invocation.
     */
    successHandler: function (serviceResponse) {
        GlobalLoginShopOnBehalfJS.onUserSetInSession();
        cursor_clear();
    },

    /**
     * display an error message.
     * @param (object) serviceResponse The service response object, which is the
     * JSON object returned by the service invocation.
     */
    failureHandler: function (serviceResponse) {
        var renderContextProperties = wcRenderContext.getRenderContextProperties('GlobalLoginShopOnBehalf_context');
        GlobalLoginShopOnBehalfJS.handleError(serviceResponse, renderContextProperties["shopOnBehalfPanelId"] + "_ErrorField");
        cursor_clear();
    }

});

/**
 *  Service declaration to invoke OrganizationSetInSession command.
 *  @constructor
 */
wcService.declare({
    id: "OrganizationSetInSessionService",
    actionId: "OrganizationSetInSession",
    url: "AjaxOrganizationSetInSession",
    formId: "",

    /**
     *  @param (object) serviceResponse The service response object, which is the
     *  JSON object returned by the service invocation.
     */
    successHandler: function (serviceResponse) {
        console.debug("Organization set in session successfully");
        cursor_clear();
    }

    /**
     * display an error message.
     * @param (object) serviceResponse The service response object, which is the
     * JSON object returned by the service invocation.
     */
    ,
    failureHandler: function (serviceResponse) {
        var renderContextProperties = wcRenderContext.getRenderContextProperties('GlobalLoginShopOnBehalf_context');
        GlobalLoginShopOnBehalfJS.handleError(serviceResponse, renderContextProperties["shopOnBehalfPanelId"] + "_ErrorField");
        cursor_clear();
    }

});

/**
 *  Service declaration to invoke the ContractSetInSessionCmd
 *  @constructor
 */
wcService.declare({
    id: "ContractSetInSessionService",
    actionId: "ContractSetInSession",
    url: "AjaxContractSetInSession",
    formId: ""

    /**
     *  This method updates the order table with the 
     *  @param (object) serviceResponse The service response object, which is the
     *  JSON object returned by the service invocation.
     */
    ,
    successHandler: function (serviceResponse) {
        cursor_clear();
    }

    /**
     * display an error message.
     * @param (object) serviceResponse The service response object, which is the
     * JSON object returned by the service invocation.
     */
    ,
    failureHandler: function (serviceResponse) {
        var renderContextProperties = wcRenderContext.getRenderContextProperties('GlobalLoginShopOnBehalf_context');
        GlobalLoginShopOnBehalfJS.handleError(serviceResponse, renderContextProperties["shopOnBehalfPanelId"] + "_ErrorField");
        cursor_clear();
    }

});

/**
 *  Service declaration to invoke the ContractSetInSessionCmd
 *  @constructor
 */
wcService.declare({
    id: "RestoreOriginalUserSetInSessionService",
    actionId: "RestoreOriginalUserSetInSessionService",
    url: "AjaxRestoreOriginalUserSetInSession?" + getCommonParametersQueryString(),
    formId: "",

    /**
     *  This method updates the order table with the 
     *  @param (object) serviceResponse The service response object, which is the
     *  JSON object returned by the service invocation.
     */
    successHandler: function (serviceResponse) {
		if(typeof callCenterIntegrationJS != 'undefined' && callCenterIntegrationJS != undefined && callCenterIntegrationJS != null){
			var params = {};
			params.status = "success";
			params.serviceResponse = serviceResponse;
			callCenterIntegrationJS.postActionMessage(params,"TERMINATE_ON_BEHALF_SESSION_RESPONSE");
		}
        GlobalLoginShopOnBehalfJS.onRestoreUserSetInSession();
        cursor_clear();
    }

    /**
     * display an error message.
     * @param (object) serviceResponse The service response object, which is the
     * JSON object returned by the service invocation.
     */
    ,
    failureHandler: function (serviceResponse) {
		if(typeof callCenterIntegrationJS != 'undefined' && callCenterIntegrationJS != undefined && callCenterIntegrationJS != null){
			var params = {};
			params.status = "error";
			params.serviceResponse = serviceResponse;
			callCenterIntegrationJS.postActionMessage(params, "TERMINATE_ON_BEHALF_SESSION_RESPONSE");	
		}
        var renderContextProperties = wcRenderContext.getRenderContextProperties('GlobalLoginShopOnBehalf_context');
        GlobalLoginShopOnBehalfJS.handleError(serviceResponse, renderContextProperties["shopOnBehalfPanelId"] + "_ErrorField");
        cursor_clear();
    }

});

//-----------------------------------------------------------------
// Licensed Materials - Property of IBM
//
// WebSphere Commerce
//
// (C) Copyright IBM Corp. 2012, 2016 All Rights Reserved.
//
// US Government Users Restricted Rights - Use, duplication or
// disclosure restricted by GSA ADP Schedule Contract with
// IBM Corp.
//-----------------------------------------------------------------

/** 
 * @fileOverview This file provides the render context used to display
 * the recommendations from Coremetrics Intelligent Offer. It also
 * contains the zone population function called with the results to
 * display.
 */

/** 
 * @class The IntelligentOfferJS class defines the render context used to display
 * the recommendations from Coremetrics Intelligent Offer.
 */
IntelligentOfferJS = {
	/* The common parameters used in service calls. */
	langId: "-1",
	storeId: "",
	catalogId: "",
	widgetsCurCount: 0,
	widgetsTotalCount: 0,
	
	/**
	 * This function initializes common parameters used in all service calls.
	 * @param {int} langId The language id to use.
	 * @param {int} storeId The store id to use.
	 * @param {int} catalogId The catalog id to use.
	 */
	setCommonParameters:function(langId,storeId,catalogId){
		this.langId = langId;
		this.storeId = storeId;
		this.catalogId = catalogId;
	},

	/** 
	 * Declare the controller function for the Intelligent Offer Recommendations e-Marketing Spot refressh area.
	 * @param {array} contains wc site zone id and updateSwatch
	 */
	declareWC_IntelligentOfferESpot_controller: function(args) {
		var WC_zone = args[0];
		var updateSwatch = args[1];
		var contextId = "WC_IntelligentOfferESpot_context_ID_" + WC_zone;
		var containerId = "WC_IntelligentOfferESpot_container_ID_" + WC_zone;
		var myWidgetObj = $("#" + containerId);

		if (!wcRenderContext.checkIdDefined(contextId)) {
			wcRenderContext.declare(contextId, [], {partNumbers: "", zoneId: "", espotTitle: "", updateSwatch: updateSwatch});
		}
		wcRenderContext.addRefreshAreaId(contextId, containerId);
		var myRCProperties = wcRenderContext.getRenderContextProperties(contextId);
		
		// initialize widget
		myWidgetObj.refreshWidget({

			/** 
			 * Refreshes the Intelligent Offer Recommendations e-Marketing Spot area.
			 * This function is called when a render context changed event is detected. 
			 */
			renderContextChangedHandler: function() {
				myWidgetObj.refreshWidget("refresh", myRCProperties);
			},
			
			/** 
			 * Post handling for the Intelligent Offer Recommendations e-Marketing Spot area.
			 * This function is called after a successful refresh.
			 */
			postRefreshHandler: function() {
				cursor_clear();
				// updateSwatch should be set to true if swatches should be selected by default
				if(myRCProperties.updateSwatch === "true"){
					shoppingActionsJS.updateSwatchListView();
				}
				// need to process cm_cr tags
				cX("onload");
			}
		});
		this.widgetsTotalCount++;
	}
};

/**
 *  This function is the zone population function called by Coremetrics Intelligent Offer.
 *  It creates a comma separated list of the partnumbers to display, and then updates
 *  the refresh area that will display the recommendations.
 */
function io_rec_zp(a_product_ids,zone,symbolic,target_id,category,rec_attributes,target_attributes,target_header_txt) {
	if (symbolic !== '_NR_') {
		var n_recs = a_product_ids.length;
		var rec_part_numbers;
		for (var ii=0; ii < n_recs; ii++) {
			if (ii === 0) {
 				rec_part_numbers = a_product_ids[ii];
			} else {
				rec_part_numbers = rec_part_numbers + ',' + a_product_ids[ii];
			}
			
		}
		
		var zoneId = zone.replace(/\s+/g,'');
		wcRenderContext.updateRenderContext('WC_IntelligentOfferESpot_context_ID_' + zoneId, {'partNumbers':rec_part_numbers, 'zoneId': zoneId, 'espotTitle': target_header_txt});
	}
	else{
		var  rec_part_numbers;
		var zoneId = zone.replace(/\s+/g,'');
		target_header_txt = '';
		wcRenderContext.updateRenderContext('WC_IntelligentOfferESpot_context_ID_' + zoneId, {'partNumbers':rec_part_numbers, 'zoneId': zoneId, 'espotTitle': target_header_txt});
	}
};
//-----------------------------------------------------------------
// Licensed Materials - Property of IBM
//
// WebSphere Commerce
//
// (C) Copyright IBM Corp. 2014, 2016 All Rights Reserved.
//
// US Government Users Restricted Rights - Use, duplication or
// disclosure restricted by GSA ADP Schedule Contract with
// IBM Corp.
//-----------------------------------------------------------------

/** 
 * @fileOverview This javascript is used by the My Account Navigation widget to control the refresh areas.
 * @version 1.2
 */

/**
 * Declares a new refresh controller for number of order approvals.
 */
var declareNumberOfOrderApprovalsController = function() {
    var myWidgetObj = $("#NumberOfOrderApprovals_Widget");
    
    /** 
	* Refreshes the number of order approvals display if a request is approved/rejected.
	* This function is called when a modelChanged event is detected. 
	*/    	   
	wcTopic.subscribe(["AjaxApproveOrderRequest", "AjaxRejectOrderRequest", "AjaxApproveRequest", "AjaxRejectRequest"], function () {
	    myWidgetObj.refreshWidget("refresh");
	});
    
    myWidgetObj.refreshWidget({
        /** 
        * Refresh number of order approval display to keep it consistent with table
        * This function is called when a render context changed event is detected. 
        */
        renderContextChangedHandler: function() {
            // Do not refresh the count in Left Navigation bar, when the search criteria changes in the main table view.
            // Left Nav displays the count of orders to approve without any filter applied.
            //widget.refresh();
        },

        postRefreshHandler: function() {
            //cursor_clear();

        }
    });
};

/**
 * Declares a new refresh controller for number of buyer approvals.
 */
var declareNumberOfBuyerApprovalsController = function() {
    var myWidgetObj = $("#NumberOfBuyerApprovals_Widget");

    /** 
	* Refreshes the number of buyer approvals display if a request is approved/rejected.
	* This function is called when a modelChanged event is detected. 
	*/    	   
	wcTopic.subscribe(["AjaxApproveBuyerRequest", "AjaxRejectBuyerRequest", "AjaxApproveRequest", "AjaxRejectRequest"], function () {
		myWidgetObj.refreshWidget("refresh");
	});
    
    myWidgetObj.refreshWidget({
        /** 
        * Refresh number of buyer approval display to keep it consistent with table
        * This function is called when a render context changed event is detected. 
        */
        renderContextChangedHandler: function() {
            // Do not refresh the count in Left Navigation bar, when the search criteria changes in the main table view.
            // Left Nav displays the count of orders to approve without any filter applied.
        	//widget.refresh();
        },

        postRefreshHandler: function() {
            //cursor_clear();

        }
    });
};//-----------------------------------------------------------------
// Licensed Materials - Property of IBM
//
// WebSphere Commerce
//
// (C) Copyright IBM Corp. 2014 All Rights Reserved.
//
// US Government Users Restricted Rights - Use, duplication or
// disclosure restricted by GSA ADP Schedule Contract with
// IBM Corp.
//-----------------------------------------------------------------

/**
 *@fileOverview This javascript file defines all the javascript functions used by order approval widget
 */

	OrderApprovalListJS = {
			
		/** 
		 * This variable stores the ID of the language that the store currently uses. Its default value is set to -1, which corresponds to United States English.
		 * @private
		 */
		langId: "-1",
		
		/** 
		 * This variable stores the ID of the current store. Its default value is empty.
		 * @private
		 */
		storeId: "",
		
		/** 
		 * This variable stores the ID of the catalog. Its default value is empty.
		 * @private
		 */
		catalogId: "",
		
		/**
		* These variables define approve or reject status in the APRVSTATUS table. 1 for approved or 2 for rejected.
		*/
		cApproveStatus: 1,
		cRejectStatus: 2,
		
		/**
		* These variables refers to Ids of startSubmitDate and endSubmitDate element in OrderApprovalList_ToolBar_UI.jspf.
		*/
		formStartDateId: "",
		formEndDateId: "",
		
		/**
		 * Search tool bar Id
		 */
		toolbarId: "",
		
		/**
		 * Sets the common parameters for the current page. 
		 * For example, the language ID, store ID, and catalog ID.
		 *
		 * @param {Integer} langId The ID of the language that the store currently uses.
		 * @param {Integer} storeId The ID of the current store.
		 * @param {Integer} catalogId The ID of the catalog.
		 */
		setCommonParameters: function(langId,storeId,catalogId,requisitionListId){
			this.langId = langId;
			this.storeId = storeId;
			this.catalogId = catalogId;
		},
		
		/**
		 * Sets the common parameters for the current page. 
		 *
		 * @param {String} formStartDateId The ID of the startDate element.
		 * @param {String} formEndDateId The ID of the endDate element.
		 * @param {String} toolbarId The ID of the tool bar element.
		 */
		setToolbarCommonParameters: function(formStartDateId,formEndDateId, toolbarId){
			this.formStartDateId = formStartDateId;
			this.formEndDateId = formEndDateId;
			this.toolbarId = toolbarId;
		},
		
		/**
		* Approves a order record
		* @param {Long} aprvstatus_id The id of the request to be approved
		*/
		approveOrder: function(aprvstatus_id) {
			service = wcService.getServiceById('AjaxApproveOrderRequest');

			var params = {
                storeId : this.storeId,
                catalogId : this.catalogId,
                langId : this.langId,
                aprv_act : this.cApproveStatus,
                approvalStatusId : aprvstatus_id,
                viewtask : "OrderApprovalView"
            };

			/*For Handling multiple clicks. */
			if(!submitRequest()){
				return;
			}			
			cursor_wait();
			wcService.invoke('AjaxApproveOrderRequest',params);		
		},

		/**
		* Rejects a order record
		* @param {Long} aprvstatus_id The id of the request to be approved
		*/
		rejectOrder: function(aprvstatus_id) {
			service = wcService.getServiceById('AjaxRejectOrderRequest');

			var params = {
			    storeId: this.storeId,
			    catalogId: this.catalogId,
			    langId: this.langId,
			    aprv_act: this.cRejectStatus,
			    approvalStatusId: aprvstatus_id,
			    viewtask: "OrderApprovalView"
			};

			/*For Handling multiple clicks. */
			if(!submitRequest()){
				return;
			}			
			cursor_wait();
			wcService.invoke('AjaxRejectOrderRequest',params);
		},
		
		/**
		* This function is called when user selects a different page from the current page
		* @param (Object) data The object that contains data used by pagination control 
		*/
		showResultsPage:function(data){
			var pageNumber = data[0]['pageNumber'],
                pageSize = data[0]['pageSize'];
			pageNumber = parseInt(pageNumber);
			pageSize = parseInt(pageSize);

			setCurrentId(data[0]["linkId"]);

			if(!submitRequest()){
				return;
			}

			var beginIndex = pageSize * ( pageNumber - 1 );
			cursor_wait();

			wcRenderContext.updateRenderContext('OrderApprovalTable_Context', {"beginIndex": beginIndex});
			MessageHelper.hideAndClearMessage();
		},
		
		
		/**
		 * Clear the context search term value set by search form
		 */
		reset:function(){
			this.updateContext({"beginIndex":"0", "orderId": "", "firstName": "", "lastName":"","startDate":"","endDate":""});
		},
		
		/**
		 * Search for buyer approval requests use the search terms specified in the toolbar search form.
		 * 
		 * @param (String) formId	The id of toolbar search form element.
		 */
		doSearch:function(formId){
			var form = $("#" + formId)[0],
                startDateValue = "",
                endDateValue = "",
                startDateWidgetValue = $("#" + this.formStartDateId + "_datepicker").datepicker("getDate");
			if (Utils.varExists(startDateWidgetValue)){
				startDateValue = startDateWidgetValue.toISOString().replace(/\.\d\d\dZ/, '+0000');
			}
			var endDateWidgetValue = $("#" + this.formEndDateId + "_datepicker").datepicker("getDate");
			if (Utils.varExists(endDateWidgetValue)){
				//add one day to the picked endDate.We pick a date the value for the date object
				//is yyyy-MM-dd 00:00:00(beginning of a day, we need it to be end of the a day)
				endDateWidgetValue = Utils.addDays(endDateWidgetValue, 1);
				//deduct one millisecond from the added date
				endDateWidgetValue = Utils.addMilliseconds(endDateWidgetValue, -1);
				endDateValue = endDateWidgetValue.toISOString().replace(/\.\d\d\dZ/, '+0000');
			}
			this.updateContext({
			    "beginIndex": "0",
			    "orderId": form.orderId.value.replace(/^\s+|\s+$/g, ''),
			    "firstName": form.submitterFirstName.value.replace(/^\s+|\s+$/g, ''),
			    "lastName": form.submitterLastName.value.replace(/^\s+|\s+$/g, ''),
			    "startDate": startDateValue,
			    "endDate": endDateValue
			});
		},
		
		/**
		 * Filter the buyer Approval list by status
		 * 
		 * @param (String) status The id of toolbar search form element.
		 */
		doFilter:function(status){
			this.updateContext({"beginIndex":"0", "approvalStatus": status});
		},
		
		/**
		 * Update the OrderApprovalTable_Context context with given context object.
		 * 
		 * @param (Object)context The context object to update
		 */
		updateContext:function(context){
			this.saveToolbarStatus();
			if(!submitRequest()){
				return;
			}			
			cursor_wait();
			wcRenderContext.updateRenderContext("OrderApprovalTable_Context", context);
			MessageHelper.hideAndClearMessage();
		},
		
		/**
		 * Save the toolbar aria-expanded attribute value
		 */
		saveToolbarStatus:function(){
            Utils.ifSelectorExists("#" + this.toolbarId, function($toolbar) {
                this.toolbarExpanded = $toolbar.attr("aria-expanded");
            }, this);
		},
		
		/**
		 * Restore the toolbar aria-expanded attribute, called by post-refresh handler
		 */
		restoreToolbarStatus:function(){
			if (Utils.varExists(this.toolbarExpanded)){
				$("#" + this.toolbarId).attr("aria-expanded", this.toolbarExpanded);
			}
		}
	}//-----------------------------------------------------------------
// Licensed Materials - Property of IBM
//
// WebSphere Commerce
//
// (C) Copyright IBM Corp. 2016 All Rights Reserved.
//
// US Government Users Restricted Rights - Use, duplication or
// disclosure restricted by GSA ADP Schedule Contract with
// IBM Corp.
//-----------------------------------------------------------------

/** 
 * @fileOverview This file provides all the functions and variables to manage order lists and the items within.
 * This file is included in all pages with order list actions.
 */

/**
 * This class defines the functions and variables that customers can use to re-order processed orders.
 * @class The OrderListJS class defines the functions and variables that customers can use to manage their previous orders.
 */
OrderListJS = {
    /** 
     * This variable stores the ID of the language that the store currently uses. Its default value is set to -1, which corresponds to United States English.
     * @private
     */
    langId: "-1",
    
    /** 
     * This variable stores the ID of the current store. Its default value is empty.
     * @private
     */
    storeId: "",
    
    /** 
     * This variable stores the ID of the catalog. Its default value is empty.
     * @private
     */
    catalogId: "",

    /** This variable stores the ID of the newly created saved order. Its default value is empty. **/
    newOrderId : "",

    /** A boolean used to indicate if the current saved order was just deleted. Its default value is false. **/
    currentOrderDeleted : false,

    /** 
     * This array stores the quantities of each product in the order. Its default value is empty.
     * @private
     */
    quantityList: {},

    /** 
     * A boolean used to indicate if the current order list is saved order list. Its default value is false.
     * @private
     */
    savedOrder: false,

    /**
     * This variable stores the current dropdown dialog element.
     * @private
     */
    dropDownDlg: null,

    /**
     * This variable stores the expiry date of a subscription. For renewal, the start date is expiry date plus one day.
     */
    subscriptionDate: "",

    /**
     * This variable stores the orderId for subscription renewal
     */
    subscriptionOrderId: "",

    /**
     * This variable stores the orderItemId for subscription renewal
     */
    subscriptionOrderItemId: "",

    /**
     * Sets the common parameters for the current page. 
     * For example, the language ID, store ID, catalog ID, and whether it's saved order list.
     *
     * @param {Integer} langId The ID of the language that the store currently uses.
     * @param {Integer} storeId The ID of the current store.
     * @param {Integer} catalogId The ID of the catalog.
     * @param {Boolean} savedOrder The indicator of saved order list.
     */
    setCommonParameters:function(langId,storeId,catalogId,savedOrder){
        this.langId = langId;
        this.storeId = storeId;
        this.catalogId = catalogId;
        this.savedOrder = savedOrder;
        cursor_clear();
    },

    /**
     * return a boolean value which indicates whether this is a saved order list
     */
    isSavedOrder: function () {
        return this.savedOrder;
    },

    /**
     * Initialize the URL of Saved Order List widget controller.
     *
     * @param {object} widgetUrl The controller's URL.
     */
    initOrderListUrl:function(widgetPrefix, widgetUrl){
        $("#" + widgetPrefix + "OrderListTable_Widget").refreshWidget("updateUrl", widgetUrl);
    },

    /**
     * set the subscriptionDate variable
     * @param {string} The expiry date of the subscription to be renewed.
     */
    setSubscriptionDate: function (value) {
        this.subscriptionDate = value;
    },

    /**
     * return a string which indicates the start date of the renewed subscription. The start date is one day plus the end date of that subscription.
     */
    getSubscriptionDate: function () {
        var year = parseInt(this.subscriptionDate.substring(0,4),10);
        var month = parseInt(this.subscriptionDate.substring(5,7),10);
        var date = parseInt(this.subscriptionDate.substring(8,10),10);

        if(month == 2){
            if((year % 4 == 0) && (year % 100 != 0) && (year % 400 == 0))
            {
                if(date != 29)
                {
                    date = date + 1;
                    if(date < 10)
                        date = "0" + date;
                    month = "02";
                }
                else
                {
                    date = "01";
                    month = "03";
                }
            }
            else
            {
                if(date != 28)
                {
                    date = date + 1;
                    if(date < 10)
                        date = "0" + date;
                    month = "02";
                }
                else
                {
                    date = "01";
                    month = "03";
                }
            }
        }
        else if(month == 12){
            if(date != 31)
            {
                date = date + 1;
                if(date < 10)
                    date = "0" + date;
                month = "12";
            }
            else
            {
                date = "01";
                month = "01";
                year = year + 1;
            }
        }
        else if(month == 4 || month == 6 || month == 9 || month == 11){
            if(date != 30)
            {
                date = date + 1;
                if(date < 10)
                    date = "0" + date;
            }
            else
            {
                date = "01";
                month = month + 1;
            }
            if(month < 10)
                month = "0" + month;
        }
        else{
            if(date != 31)
            {
                date = date + 1;
                if(date < 10)
                    date = "0" + date;
            }
            else
            {
                date = "01";
                month = month + 1;
            }
            if(month < 10)
                month = "0" + month;
        }

        var start = this.subscriptionDate.indexOf("T",0);
        var end = this.subscriptionDate.indexOf("Z",start);
        var appendString= this.subscriptionDate.substring(start+1,end);
        var newDateString = year+'-'+month+'-'+date+'T'+appendString+'Z';
        return(newDateString);
    },

    /**
     * This function sets the url for subscriptionrenew service and then it invokes the service to renew the subscription.
     * @param {string} SubscriptionCopyURL The url for the subscription copy service.
     */
    prepareSubscriptionRenew:function(SubscriptionCopyURL){

        /*For Handling multiple clicks. */
        if(!submitRequest()){
            return;
        }
        cursor_wait();
        wcService.getServiceById("SubscriptionRenew").setUrl(SubscriptionCopyURL);
        wcService.invoke("SubscriptionRenew");
    },

    /**
     * This function sets the url for ordercopy service and then it invokes the service to copy the old order.
     * @param {string} OrderCopyURL The url for the order copy service.
     */
    prepareOrderCopy:function(OrderCopyURL){

        /*For Handling multiple clicks. */
        if(!submitRequest()){
            return;
        }
        cursor_wait();
        wcService.getServiceById("OrderCopy").setUrl(OrderCopyURL);
        wcService.invoke("OrderCopy");
    },

    /**
     * This function sets the url for ssfs order copy service and then it invokes the service to copy the old order.
     * @param {string} SSFSOrderCopyUrl The url for the ssfs order copy service.
     */
    prepareSSFSOrderCopy:function(SSFSOrderCopyUrl){

        /*For Handling multiple clicks. */
        if(!submitRequest()){
            return;
        }
        cursor_wait();
        wcService.getServiceById("SSFSOrderCopy").setUrl(SSFSOrderCopyUrl);
        wcService.invoke("SSFSOrderCopy");
    },

    /**
     * get the last order record info in render context
     * @param {Integer} The current page number.
     * @param {string} The last order external id in current page.
     * @param {string} The last order record info in render context.
     * @param {boolean} value either true or false. True if it's for next page. False otherwise.
     */
    getLastRecordInfo: function (currentPage, lastExtOrderId, lastRecordInfoInContext, nextOrNot) {
        var lastRecordArray = lastRecordInfoInContext.split(";");
        var refinedRecordInfoIncontext;

        if(!nextOrNot){
            //previous page
            if(lastRecordInfoInContext != '' && lastRecordInfoInContext != undefined){
                if(lastRecordInfoInContext.lastIndexOf(";")>-1){
                    refinedRecordInfoIncontext = lastRecordInfoInContext.substring(0, lastRecordInfoInContext.lastIndexOf(";"));
                }else{
                    refinedRecordInfoIncontext = "";
                }
            }
        }else{
            //next page
            if(currentPage==1 || currentPage==''|| currentPage == undefined){
                //first page
                if(lastExtOrderId !='' && lastExtOrderId!=undefined){
                    refinedRecordInfoIncontext = lastExtOrderId;
                }else{
                    refinedRecordInfoIncontext = " ";
                }
            }else{
                if(lastRecordInfoInContext != '' && lastRecordInfoInContext != undefined){
                    if(lastExtOrderId !='' && lastExtOrderId!=undefined){
                        refinedRecordInfoIncontext = lastRecordInfoInContext.concat(";").concat(lastExtOrderId);
                    }else{
                        refinedRecordInfoIncontext = lastRecordInfoInContext.concat(";").concat(" ");
                    }
                }
            }
        }

        return refinedRecordInfoIncontext;
    },

    /**
     * Displays the actions list drop down panel.
     * @param {object} event The event to retrieve the input keyboard key.
     * @param {string} dialogId The id of the content pane containing the action popup details
     */
    showActionsPopup: function(event, dialogId){
        if(event == null || event.keyCode === KeyCodes.DOWN_ARROW){
            var dialog = $("#" + dialogId).data("wc-WCDialog");
            if(dialog) {
                this.dropDownDlg = dialog;
                this.dropDownDlg.open();
            }
        }
    },

    /**
     *This function displays the Recurring Order / Subscription action popup.
     *@param {String} action This variable can be either recurring_order or subscription.
     *@param {String} subscriptionId This variable gives the subscription id to be canceled.
     *@param {String} popupIndex the index of the action popup (required to close it later)
     *@param {String} message This variable gives the message regarding cancel notice period.
     */
    showPopup:function(action, subscriptionId, popupIndex, message){
        var popup = $("#Cancel_"+action+"_popup").data("wc-WCDialog");
        if (popup !=null) {
            closeAllDialogs(); //close other dialogs(quickinfo dialog, etc) before opening this.
            popup.element.attr("data-popupIndex", popupIndex);
            popup.open();
            document.getElementById("Cancel_yes_"+action).setAttribute("onclick", "OrderListJS.cancelRecurringOrder("+ subscriptionId + "," + popupIndex + ");");

            if(document.getElementById("cancel_notice_"+action) && document.getElementById(message)){
                $("#cancel_notice_"+action).html($("#" + message).val());
            }
        }else {
            console.debug("Cancel_subscription_popup"+" does not exist");
        }
    },

    /**
     * This function cancels a recurring order.
     * @param {String} subscriptionId The unique ID of the subscription to cancel.
     * @param {int} popupIndex the index of the action drop down
     */
    cancelRecurringOrder:function(subscriptionId, popupIndex){
        /*For Handling multiple clicks. */
        if(!submitRequest()){
            return;
        }
        cursor_wait();

        var params = {
            subscriptionId: subscriptionId,
            URL: "",
            storeId: OrderListServicesDeclarationJS.storeId,
            catalogId: OrderListServicesDeclarationJS.catalogId,
            langId: OrderListServicesDeclarationJS.langId
        };
        wcService.invoke("AjaxCancelSubscription", params);
    },

    /**
     * Display order list for pagination
     */
    showResultsPage:function(data){
        var pageNumber = data['pageNumber'],
        pageSize = data['pageSize'];
        pageNumber = parseInt(pageNumber);
        pageSize = parseInt(pageSize);

        setCurrentId(data["linkId"]);

        if(!submitRequest()){
            return;
        }

        var beginIndex = pageSize * ( pageNumber - 1 );
        cursor_wait();
        wcRenderContext.updateRenderContext('OrderListTable_Context', {'beginIndex':beginIndex});
        MessageHelper.hideAndClearMessage();
    },

    /**
     * Creates an empty order.
     */
    createNewList:function() {
        var form_name = document.getElementById("OrderList_NewListForm_Name");
        if (form_name !=null && this.isEmpty(form_name.value)) {
            MessageHelper.formErrorHandleClient(form_name.id,MessageHelper.messages["LIST_TABLE_NAME_EMPTY"]); return false;
        }
        service = wcService.getServiceById('AjaxOrderCreate');
        
        var params = {
            storeId: this.storeId,
            catalogId: this.catalogId,
            langId: this.langId,
            description: $(form_name).val()
        };
            
        /*For Handling multiple clicks. */
        if(!submitRequest()){
            return;
        }
        cursor_wait();
        wcService.invoke('AjaxOrderCreate',params);
    },
    
    /**
     * Deletes a saved order
     * This method is invoked by the <b>Delete</b> action.
     * @param (string) orderId The orderId of the saved order.
     */
    deleteOrder:function (orderId) {
        var params = {
            orderId: orderId,
            filterOption: "All",
            storeId: this.storeId,
            catalogId: this.catalogId,
            langId: this.langId
        };
        /*For Handling multiple clicks. */
        if(!submitRequest()){
            return;
        }
        cursor_wait();
        wcService.invoke("AjaxSingleOrderCancel", params);
    },
    
    /**
     * Duplicates a saved order.
     * This method is invoked by the <b>Duplicate order</b> action.
     * @param (string) orderId The order from which the new saved order is created.
     * @param (string) orderDesc The name of the saved order.
     */
    duplicateOrder:function (orderId, orderDesc) {
        MessageHelper.hideAndClearMessage();
        
        var params = {
            storeId: this.storeId,
            storeId: this.storeId,
            catalogId: this.catalogId,
            langId: this.langId,
            fromOrderId_1: orderId,
            toOrderId: "**",
            copyOrderItemId_1: "*",
            keepOrdItemValidContract: "1",
            URL: "TableDetailsDisplayURL"
        };
        if (orderDesc != null && orderDesc != 'undefined'){
            params["description"] = orderDesc;
        }
        if(!submitRequest()){
            return;
        }
        cursor_wait();
        wcService.invoke('AjaxSingleOrderCopy',params);
    },
    
    /**
    * Sets the selected saved order as the current order in the saved orders table.
    * This method is invoked by the <b>Set as Current Order</b> action. 
    **/
    setCurrentOrder : function (orderId) {
        if (orderId != null && orderId != 'undefined') {
            if(!submitRequest()){
                return;
            }
            var params = {
                storeId: this.storeId,
                catalogId: this.catalogId,
                langId: this.langId,
                orderId: orderId,
                URL: ""
            };
            wcService.invoke("AjaxSetPendingOrder", params);
        }
    },
    
    /**
     * Updates the current order in the database to match the order in the shopping cart.
     * This method is called when the Saved Order list page loads, and when a saved order is added/deleted. 
     * @param (string) currentOrderId The orderId to set as the current order.
     */
    updateCurrentOrder : function(currentOrderId) {
        if (currentOrderId != null) {
            var params = {
                storeId: this.storeId,
                catalogId: this.catalogId,
                langId: this.langId,
                URL: "",
                orderId: currentOrderId
            };
            wcService.invoke("AjaxUpdatePendingOrder", params);
        }
    },
    
    /**
     * Returns the order ID of the first saved order in the table.
     * @returns {String} The order ID of the first saved order if not empty, otherwise, returns null.
     * 
     **/
    getFirstSavedOrderIdFromList : function() {
        var savedOrderLink = document.getElementById("WC_OrderList_Link_2_1");
        
        if (savedOrderLink && savedOrderLink != null && savedOrderLink != 'undefined' && savedOrderLink.innerHTML != null && savedOrderLink.innerHTML != 'undefined') {
            var savedOrderText = savedOrderLink.innerHTML,
            savedOrderId = savedOrderText.split(" ")[0];
            
            return savedOrderId;
        } else {
            return null;
        }
    },
    
    /**
     * Returns the current order ID from the currentOrderJSON div.
     * @returns {String} The order ID of the current order or null if the currentOrderJSON div cannot be found.
     * 
     **/
    getCurrentOrderId : function() {
        var jsonDIV = null;
        Utils.ifSelectorExists("#currentOrderJSON", function($node) {
            jsonDIV = JSON.parse($node.html());
        });
        if (jsonDIV != null && jsonDIV != 'undefined' && jsonDIV.currentOrderId != null && jsonDIV.currentOrderId != 'undefined') {
            return jsonDIV.currentOrderId;
        }
        else {
            return null;
        }
    },
    
    /**
     * Sets the newOrderId variable. This variable is only used to store the first saved order in the list.
     * @param newOrdId The order ID of the newly created saved order.
     */
    setNewOrderId : function(newOrdId) {
        this.newOrderId = newOrdId;
    },

    /**
     * Returns the ID of the new saved order. 
     * The newOrderId variable is set only when it is the first saved order in the list.
     * @returns {String} The ID of the newly created saved order.
     */
    getNewOrderId : function() {
        return this.newOrderId;
    },
    
    /**
     * Returns the currentOrderDeleted flag. 
     * @returns {boolean} true or false indicating whether the current saved order was deleted.
     * 
     */
    isCurrentOrderDeleted : function() {
        return this.currentOrderDeleted;
    },
    
    /**
     * Sets the currentOrderDeleted flag to true or false. 
     * This flag determines if the current saved order was deleted.
     * @param currOrderDeleted A boolean (true/false) indicating if the saved order was deleted.
     */
    setCurrentOrderDeleted : function(currOrderDeleted) {
        this.currentOrderDeleted = currOrderDeleted;
    },
    
    /**
    * Opens the saved order details view for the order.
    * This method is invoked by the <b>View Details</b> action.
    * @param (string) reqListURL The URL to the 
    **/
    viewDetails : function (reqListURL) {
        document.location.href = reqListURL;
    },
    
    /**
     * Checks if a string is null or empty.
     * @param (string) str The string to check.
     * @return (boolean) Indicates whether the string is empty.
     */
    isEmpty:function (str) {
        var reWhiteSpace = new RegExp(/^\s+$/);
        if (str == null || str =='' || reWhiteSpace.test(str) ) {
            return true;
        }
        return false;
    },
    
    /**
     * Remove the quantity of the SKU (e.g. when row is hidden)
     * @param (string) restUrl The rest url for getting order items
     * @param (string) params String with the params to be passed in
     */
    getOrderItems:function(restUrl, params){
        $.get(restUrl, params, function(order, textStatus, jqXHR) {
        	if(typeof(order) == 'string'){
        		order = $.parseJSON(order);
        	}
            OrderListJS.quantityList = {};
            if (order.orderItem == null) {
                MessageHelper.displayErrorMessage(Utils.getLocalizationMessage('MYACCOUNT_SAVEDORDERLIST_EMPTY_ADD_TO_REQ_FAIL'));
                return;
            }
            for (var i = 0; i < order.orderItem.length; i++) {
                var orderId = order.orderId;

                if (!(orderId in OrderListJS.quantityList)) {
                    OrderListJS.quantityList[orderId] = {};
                }
                OrderListJS.quantityList[orderId][order.orderItem[i].productId] = order.orderItem[i].quantity;
            }

            if (typeof addReqListsJS != 'undefined') {
                addReqListsJS.toggleDropDownMenu(true,false);
            }
        });
    },
    
    /**
     *This method locks the order specified when the buyer administrator is browsing in an on behalf mode.
     */
    lockOrderOnBehalf: function(orderId){
        var params = {
            orderId: orderId,
            filterOption: "All",
            storeId: this.storeId,
            catalogId: this.catalogId,
            langId: this.langId
        };
        /*For Handling multiple clicks. */
        if(!submitRequest()){
            return;
        }
        cursor_wait();
        wcService.invoke("AjaxRESTOrderLockOnBehalf", params);
    },
    
    /**
     * This method take over the lock on the order by other buyer administrator 
     * when the buyer administrator is browsing in an on behalf mode.
     */
    takeOverLockOrderOnBehalf: function(orderId, isCurrentOrder){
        var params = {
            orderId: orderId,
            filterOption: "All",
            storeId: this.storeId,
            catalogId: this.catalogId,
            langId: this.langId,
            takeOverLock: "Y"
        };
        if (undefined !== isCurrentOrder && isCurrentOrder =='true'){
            setDeleteCartCookie();
            params["isCurrentOrder"] = 'true';
        } else {
            params["isCurrentOrder"] = 'false';
        }
        
        /*For Handling multiple clicks. */
        if(!submitRequest()){
            return;
        }
        cursor_wait();
        wcService.invoke("AjaxRESTOrderLockTakeOverOnBehalf", params);
    },
        
    /**
     *This method unlocks the order specified when the buyer administrator is browsing in 
     *an on behalf mode.
     */
    unlockOrderOnBehalf: function(orderId){
        var params = {
            orderId: orderId,
            filterOption: "All",
            storeId: this.storeId,
            catalogId: this.catalogId,
            langId: this.langId
        };
        /*For Handling multiple clicks. */
        if(!submitRequest()){
            return;
        }
        cursor_wait();
        wcService.invoke("AjaxRESTOrderUnlockOnBehalf", params);
    }
}
//-----------------------------------------------------------------
// Licensed Materials - Property of IBM
//
// WebSphere Commerce
//
// (C) Copyright IBM Corp. 2016 All Rights Reserved.
//
// US Government Users Restricted Rights - Use, duplication or
// disclosure restricted by GSA ADP Schedule Contract with
// IBM Corp.
//-----------------------------------------------------------------

/**
 * Declares a new render context for order list.
 */
wcRenderContext.declare("OrderListTable_Context", [], {beginIndex: "0"});

/**
 * Declares a new refresh controller for order list.
 */
var declareOrderDisplayRefreshArea = function(widgetPrefix) {
    var myWidgetObj = $("#" + widgetPrefix + "OrderListTable_Widget");
    wcRenderContext.addRefreshAreaId("OrderListTable_Context", widgetPrefix + "OrderListTable_Widget");
    var myRCProperties = wcRenderContext.getRenderContextProperties("OrderListTable_Context");
    
    /**
     * Displays the previous/next page of orders.
     * This function is called when a render context changed event is detected.
     */
    wcTopic.subscribe(["AjaxCancelSubscription", "AjaxOrderCreate", "AjaxSingleOrderCancel", "AjaxSingleOrderCopy", "AjaxSetPendingOrder", "AjaxRESTOrderUnlockOnBehalf", "AjaxRESTOrderLockOnBehalf", "AjaxRESTOrderLockTakeOverOnBehalf"], function () {
        myWidgetObj.refreshWidget("refresh", myRCProperties);
    });
    
    var renderContextChangedHandler = function() {
        myWidgetObj.refreshWidget("refresh", myRCProperties);
    }
    
    var postRefreshHandler = function() {
        cursor_clear();

        if(OrderListJS.isSavedOrder()) {
            // If the current saved order gets deleted, we trigger the "AjaxUpdatePendingOrder" 
             // to set the first saved order in the list as the current saved order.
             if (OrderListJS.getFirstSavedOrderIdFromList() != null && OrderListJS.isCurrentOrderDeleted() == true) {
                 OrderListJS.updateCurrentOrder(OrderListJS.getFirstSavedOrderIdFromList());
             }

             // If it's the only saved order in the list and the current saved order div is not currently set,
             // ensure that it's set as the current saved order.
             if (Utils.existsAndNotEmpty(OrderListJS.getNewOrderId())) {
                 var newOrderId = OrderListJS.getNewOrderId();
                 OrderListJS.updateCurrentOrder(newOrderId);
                 OrderListJS.setNewOrderId(null);
             }

             if (OrderListJS.isCurrentOrderDeleted() == true) {
                 OrderListJS.setCurrentOrderDeleted(false);
             }

             toggleMobileView();
        }
    }
    
    // initialize widget
    myWidgetObj.refreshWidget({renderContextChangedHandler: renderContextChangedHandler, postRefreshHandler: postRefreshHandler});
}//-----------------------------------------------------------------
// Licensed Materials - Property of IBM
//
// WebSphere Commerce
//
// (C) Copyright IBM Corp. 2016 All Rights Reserved.
//
// US Government Users Restricted Rights - Use, duplication or
// disclosure restricted by GSA ADP Schedule Contract with
// IBM Corp.
//-----------------------------------------------------------------

/**
 * @fileOverview This javascript contains declarations of AJAX services used within
 * WebSphere Commerce.
 */

/**
 * @class This class stores common parameters needed to make the service call.
 */
OrderListServicesDeclarationJS = {
    /* The common parameters used in service calls */
    langId: "-1",
    storeId: "",
    catalogId: "",

    /**
     * This function initializes common parameters used in all service calls.
     * @param {int} langId The language id to use.
     * @param {int} storeId The store id to use.
     * @param {int} catalogId The catalog id to use.
     */
    setCommonParameters:function(langId,storeId,catalogId){
        this.langId = langId;
        this.storeId = storeId;
        this.catalogId = catalogId;
    }
}

/**
 *  This service enables customer to Reorder an already existing order.
 *  @constructor
 */
wcService.declare({
    id: "OrderCopy",
    actionId: "OrderCopy",
    url: "AjaxRESTOrderCopy",
    formId: ""

    /**
     *  Copies all the items from the existing order to the shopping cart and redirects to the shopping cart page.
     *  @param (object) serviceResponse The service response object, which is the
     *  JSON object returned by the service invocation.
     */
    ,successHandler: function(serviceResponse) {
        for (var prop in serviceResponse) {
            console.debug(prop + "=" + serviceResponse[prop]);
        }
        if (serviceResponse.newOrderItemsCount != null && serviceResponse.newOrderItemsCount <= 0){
            MessageHelper.displayErrorMessage(MessageHelper.messages["CANNOT_REORDER_ANY_MSG"]);
        }
        else {
            setDeleteCartCookie();

            var postRefreshHandlerParameters = [];
            var initialURL = "AjaxRESTOrderPrepare";
            var urlRequestParams = [];
            urlRequestParams["orderId"] = serviceResponse.orderId;
            urlRequestParams["storeId"] = OrderListServicesDeclarationJS.storeId;

            postRefreshHandlerParameters.push({"URL":"AjaxCheckoutDisplayView","requestType":"GET", "requestParams":{}}); 
            var service = getCustomServiceForURLChaining(initialURL,postRefreshHandlerParameters,null);
            wcService.invoke(service.getParam("id"), urlRequestParams);
        }
    }

    /**
     * display an error message.
     * @param (object) serviceResponse The service response object, which is the
     * JSON object returned by the service invocation.
     */
    ,failureHandler: function(serviceResponse) {
        if (serviceResponse.errorMessageKey === "_ERR_PROD_NOT_ORDERABLE") {
            MessageHelper.displayErrorMessage(MessageHelper.messages["PRODUCT_NOT_BUYABLE"]);
        } else if (serviceResponse.errorMessageKey === "_ERR_INVALID_ADDR") {
            MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
        }else {
            if (serviceResponse.errorMessage) {
                MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
            }
            else {
                    if (serviceResponse.errorMessageKey) {
                    MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
                    }
            }
        }
        cursor_clear();
    }
}),

/**
 *  This service enables customer to Reorder an already existing order in external system.
 *  @constructor
 */
wcService.declare({
    id: "SSFSOrderCopy",
    actionId: "SSFSOrderCopy",
    url: "AjaxSSFSOrderCopy",
    formId: ""

        /**
         *  Copies all the items from the existing order to the shopping cart and redirects to the shopping cart page.
        *  @param (object) serviceResponse The service response object, which is the
        *  JSON object returned by the service invocation.
        */
    ,successHandler: function(serviceResponse) {
        for (var prop in serviceResponse) {
            console.debug(prop + "=" + serviceResponse[prop]);
        }

        setDeleteCartCookie();
        document.location.href=appendWcCommonRequestParameters("AjaxCheckoutDisplayView?langId="+OrderListServicesDeclarationJS.langId+"&storeId="+OrderListServicesDeclarationJS.storeId+"&catalogId="+OrderListServicesDeclarationJS.catalogId);
    }

    /**
    * display an error message.
    * @param (object) serviceResponse The service response object, which is the
    * JSON object returned by the service invocation.
    */
    ,failureHandler: function(serviceResponse) {
        if (serviceResponse.errorMessageKey === "_ERR_PROD_NOT_ORDERABLE") {
            MessageHelper.displayErrorMessage(MessageHelper.messages["PRODUCT_NOT_BUYABLE"]);
        } else if (serviceResponse.errorMessageKey === "_ERR_INVALID_ADDR") {
            MessageHelper.displayErrorMessage(MessageHelper.messages["INVALID_CONTRACT"]);
        }else {
            if (serviceResponse.errorMessage) {
                MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
            }
            else {
                    if (serviceResponse.errorMessageKey) {
                    MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
                    }
            }
        }
        cursor_clear();
    }
}),

/**
 * This service cancels a subscription.
 * @constructor
 */
wcService.declare({
    id: "AjaxCancelSubscription",
    actionId: "AjaxCancelSubscription",
    url: "AjaxRESTRecurringOrSubscriptionCancel",
    formId: ""

    /**
     * Clear messages on the page.
     * @param (object) serviceResponse The service response object, which is the JSON object returned by the service invocation
     */
    ,successHandler: function(serviceResponse) {
        MessageHelper.hideAndClearMessage();
        cursor_clear();
        closeAllDialogs();
        if(serviceResponse.subscriptionType == "RecurringOrder"){
            if(serviceResponse.state == "PendingCancel"){
                MessageHelper.displayStatusMessage(MessageHelper.messages["SCHEDULE_ORDER_PENDING_CANCEL_MSG"]);
            }
            else{
                MessageHelper.displayStatusMessage(MessageHelper.messages["SCHEDULE_ORDER_CANCEL_MSG"]);
            }
        }
        else{
            if(serviceResponse.state == "PendingCancel"){
                MessageHelper.displayStatusMessage(MessageHelper.messages["SUBSCRIPTION_PENDING_CANCEL_MSG"]);
            }
            else{
                MessageHelper.displayStatusMessage(MessageHelper.messages["SUBSCRIPTION_CANCEL_MSG"]);
            }
        }
    }

    /**
     * Displays an error message on the page if the request failed.
     * @param (object) serviceResponse The service response object, which is the JSON object returned by the service invocation.
     */
    ,failureHandler: function(serviceResponse) {
        if (serviceResponse.errorMessage) {
            MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
        } else {
            if (serviceResponse.errorMessageKey) {
                MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
            }
        }
        cursor_clear();
    }
}),

/**
 *  This service enables customer to Renew a subscription.
 *  @constructor
 */
wcService.declare({
    id: "SubscriptionRenew",
    actionId: "SubscriptionRenew",
    url: "AjaxRESTOrderCopy",
    formId: ""

    /**
     *  Copies all the items from the existing subscription to the shopping cart and calls service to update requested shipping date.
    *  @param (object) serviceResponse The service response object, which is the
    *  JSON object returned by the service invocation.
    */
    ,successHandler: function(serviceResponse) {
        for (var prop in serviceResponse) {
            console.debug(prop + "=" + serviceResponse[prop]);
        }

        var params = [];

        params.storeId      = OrderListServicesDeclarationJS.storeId;
        params.catalogId    = OrderListServicesDeclarationJS.catalogId;
        params.langId       = OrderListServicesDeclarationJS.langId;
        params.orderId      = serviceResponse.orderId;
        params.calculationUsage  = "-1,-2,-3,-4,-5,-6,-7";
        params.requestedShipDate = OrderListJS.getSubscriptionDate();

        OrderListJS.subscriptionOrderId = serviceResponse.orderId;
        OrderListJS.subscriptionOrderItemId = serviceResponse.orderItemId[0];

        wcService.invoke("SetRequestedShippingDate",params);
    }

    /**
     * display an error message.
     * @param (object) serviceResponse The service response object, which is the
     * JSON object returned by the service invocation.
     */
    ,failureHandler: function(serviceResponse) {
        if (serviceResponse.errorMessageKey == "_ERR_PROD_NOT_ORDERABLE") {
            MessageHelper.displayErrorMessage(MessageHelper.messages["PRODUCT_NOT_BUYABLE"]);
        } else if (serviceResponse.errorMessageKey == "_ERR_INVALID_ADDR") {
            MessageHelper.displayErrorMessage(MessageHelper.messages["INVALID_CONTRACT"]);
        }else {
            if (serviceResponse.errorMessage) {
                MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
            }
            else {
                    if (serviceResponse.errorMessageKey) {
                    MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
                    }
            }
        }
        cursor_clear();
    }

}),

/**
 *  This service sets the requested shipping date for a subscription renewal.
 *  @constructor
 */
wcService.declare({
    id: "SetRequestedShippingDate",
    actionId: "SetRequestedShippingDate",
    url: "AjaxRESTOrderShipInfoUpdate",
    formId: ""
/**
 * hides all the messages and the progress bar
 * @param (object) serviceResponse The service response object, which is the
 * JSON object returned by the service invocation
 */
    ,successHandler: function(serviceResponse) {
        cursor_clear();
        document.location.href=appendWcCommonRequestParameters("RESTOrderPrepare?langId="+OrderListServicesDeclarationJS.langId+"&storeId="+OrderListServicesDeclarationJS.storeId+"&catalogId="+OrderListServicesDeclarationJS.catalogId+"&orderId="+serviceResponse.orderId+"&URL=AjaxCheckoutDisplayView?langId="+OrderListServicesDeclarationJS.langId+"&storeId="+OrderListServicesDeclarationJS.storeId+"&catalogId="+OrderListServicesDeclarationJS.catalogId);
    }

    /**
 * display an error message
 * @param (object) serviceResponse The service response object, which is the
 * JSON object returned by the service invocation
 */
    ,failureHandler: function(serviceResponse) {
        if (serviceResponse.errorMessageKey == "_ERR_ORDER_ITEM_FUTURE_SHIP_DATE_OVER_MAXOFFSET") {
            var params = [];

            params.storeId      = OrderListServicesDeclarationJS.storeId;
            params.catalogId    = OrderListServicesDeclarationJS.catalogId;
            params.langId       = OrderListServicesDeclarationJS.langId;
            params.orderId      = OrderListJS.subscriptionOrderId;
            params.orderItemId      = OrderListJS.subscriptionOrderItemId;
            params.calculationUsage  = "-1,-2,-3,-4,-5,-6,-7";
            wcService.invoke("RemoveSubscriptionItem",params);

            MessageHelper.displayStatusMessage(MessageHelper.messages["CANNOT_RENEW_NOW_MSG"]);
        }
        else{
            if (serviceResponse.errorMessage) {
                MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
            }
            else {
                if (serviceResponse.errorMessageKey) {
                    MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
                    }
            }
            cursor_clear();
        }
    }

}),

/**
 * This service removes the subscription item from the shopping cart if renewal fails.
 * @constructor
 */
wcService.declare({
    id: "RemoveSubscriptionItem",
    actionId: "RemoveSubscriptionItem",
    url: "AjaxRESTOrderItemDelete",
    formId: ""

    /**
     * @param (object) serviceResponse The service response object, which is the
     * JSON object returned by the service invocation.
     */
    ,successHandler: function(serviceResponse) {
        cursor_clear();
    }

        /**
     * display an error message
     * @param (object) serviceResponse The service response object, which is the
     * JSON object returned by the service invocation
     */
    ,failureHandler: function(serviceResponse) {
        if (serviceResponse.errorMessage) {
            MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
        }
        else {
                if (serviceResponse.errorMessageKey) {
                MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
                }
        }
        if(serviceResponse.errorCode){
            wcTopic.publish("OrderError",serviceResponse);
        }
        cursor_clear();
    }

})

/**
 * This service allows customer to create a new saved order
 * @constructor
 */
wcService.declare({
    id:"AjaxOrderCreate",
    actionId:"AjaxOrderCreate",
    url:"AjaxRESTOrderCreate",
    formId:""

     /**
     * Hides all the messages and the progress bar.
     * @param (object) serviceResponse The service response object, which is the
     * JSON object returned by the service invocation.
     */
    ,successHandler: function(serviceResponse) {
        MessageHelper.hideAndClearMessage();
        cursor_clear();
        MessageHelper.displayStatusMessage(MessageHelper.messages["MYACCOUNT_SAVEDORDERLIST_CREATE_SUCCESS"]);
        
        var firstSavedOrderId = OrderListJS.getFirstSavedOrderIdFromList();
        if (firstSavedOrderId == null) {
            OrderListJS.setNewOrderId(serviceResponse.outOrderId);
        }
    }
        
    /**
     * Display an error message.
     * @param (object) serviceResponse The service response object, which is the
     * JSON object returned by the service invocation.
     */
    ,failureHandler: function(serviceResponse) {
        if (serviceResponse.errorMessage) {
             if (serviceResponse.errorCode == "CMN0409E")
             {
                 MessageHelper.displayErrorMessage(MessageHelper.messages["MYACCOUNT_SAVEDORDERLIST_CREATE_FAIL"]);
             }
             else
             {
                 MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
             }
        } 
        else {
             if (serviceResponse.errorMessageKey) {
                MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
             }
        }
        cursor_clear();
    }
}),

/**
 * This service deletes an existing saved order.
 * @constructor
 */
wcService.declare({
    id:"AjaxSingleOrderCancel",
    actionId:"AjaxSingleOrderCancel",
    url:"AjaxRESTOrderCancel",
    formId:""

     /**
     * Hides all the messages and the progress bar.
     * @param (object) serviceResponse The service response object, which is the
     * JSON object returned by the service invocation.
     */
    ,successHandler: function(serviceResponse) {
        MessageHelper.hideAndClearMessage();
        cursor_clear();
        MessageHelper.displayStatusMessage(MessageHelper.messages["MYACCOUNT_SAVEDORDERLIST_DELETE_SUCCESS"]);

        //set the OrderListJS.currentOrderDeleted flag to true if the current order was deleted.
        var deletedOrderId = serviceResponse.orderId;
        var currentOrderId = OrderListJS.getCurrentOrderId();
        if (currentOrderId == deletedOrderId) {
            OrderListJS.setCurrentOrderDeleted(true);
        } 
    }
        
    /**
     * Display an error message.
     * @param (object) serviceResponse The service response object, which is the
     * JSON object returned by the service invocation.
     */
    ,failureHandler: function(serviceResponse) {
        if (serviceResponse.errorMessage) {
             if (serviceResponse.errorCode == "CMN0409E")
             {
                 MessageHelper.displayErrorMessage(MessageHelper.messages["MYACCOUNT_SAVEDORDERLIST_DELETE_FAIL"]);
             }
             else
             {
                 MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
             }
        } 
        else {
             if (serviceResponse.errorMessageKey) {
                MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
             }
        }
        cursor_clear();
    }
}),

/**
* This service allows customer to create a saved order from an existing order.
* @constructor
*/
wcService.declare({
    id:"AjaxSingleOrderCopy",
    actionId:"AjaxSingleOrderCopy",
    url:"AjaxRESTOrderCopy",
    formId:""

     /**
    * Hides all the messages and the progress bar.
    * @param (object) serviceResponse The service response object, which is the
    * JSON object returned by the service invocation.
    */
    ,successHandler: function(serviceResponse) {
        var params = {
            storeId: OrderListJS.storeId,
            catalogId: OrderListJS.catalogId,
            langId: OrderListJS.langId,
            updatePrices: "1",
            orderId: serviceResponse.orderId,
            calculationUsageId: "-1"
        };
        wcService.invoke("AjaxSingleOrderCalculate", params);
        MessageHelper.hideAndClearMessage();
        cursor_clear();
        MessageHelper.displayStatusMessage(MessageHelper.messages["MYACCOUNT_SAVEDORDERLIST_COPY_SUCCESS"]);
    }
        
    /**
    * Display an error message.
    * @param (object) serviceResponse The service response object, which is the
    * JSON object returned by the service invocation.
    */
    ,failureHandler: function(serviceResponse) {
        if (serviceResponse.errorMessage) {
             if (serviceResponse.errorCode == "CMN0409E")
             {
                 MessageHelper.displayErrorMessage(MessageHelper.messages["MYACCOUNT_SAVEDORDERLIST_COPY_FAIL"]);
             }
             else
             {
                 MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
             }
        }
        else {
             if (serviceResponse.errorMessageKey) {
                MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
             }
        }
        cursor_clear();
    }
}),

/**
 * Perform the order calculation operations to compute the contract prices for the order items in an order.
 * Perform the service or command call.
 */
wcService.declare({
    id: "AjaxSingleOrderCalculate",
    actionId: "AjaxSingleOrderCalculate",
    url: "AjaxRESTOrderCalculate",
    formId: ""

 /**
 * Display a success message
 * @param (object) serviceResponse The service response object, which is the
 * JSON object returned by the service invocation
 */

    ,successHandler: function(serviceResponse) {
        MessageHelper.hideAndClearMessage();
        MessageHelper.displayStatusMessage(MessageHelper.messages["MYACCOUNT_SAVEDORDERLIST_CALCULATE_SUCCESS"]);
        cursor_clear();
    }

 /**
 * Display an error message
 * @param (object) serviceResponse The service response object, which is the
 * JSON object returned by the service invocation
 */
    ,failureHandler: function(serviceResponse) {
        
        if (serviceResponse.errorMessage) {
            if (serviceResponse.errorCode == "CMN0409E")
             {
                 MessageHelper.displayErrorMessage(MessageHelper.messages["MYACCOUNT_SAVEDORDERLIST_CALCULATE_FAIL"]);
             }
             else
             {
                 MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
             }
        } 
        else {
             if (serviceResponse.errorMessageKey) {
                MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
             }
        }
        cursor_clear();
    }
})

/**
 * Invokes the order unlock action.
 * Perform the service or command call.
 */
wcService.declare({
    id: "AjaxRESTOrderUnlockOnBehalf",
    actionId: "AjaxRESTOrderUnlockOnBehalf",
    url: "AjaxRESTOrderUnlockOnBehalf",
    formId: ""

 /**
 * Display a success message
 * @param (object) serviceResponse The service response object, which is the
 * JSON object returned by the service invocation
 */

    ,successHandler: function(serviceResponse) {
        MessageHelper.hideAndClearMessage();
        MessageHelper.displayStatusMessage(MessageHelper.messages["MYACCOUNT_SAVEDORDERLIST_ORDER_UNLOCK_SUCCESS"]);
        cursor_clear();
    }

 /**
 * Display an error message
 * @param (object) serviceResponse The service response object, which is the
 * JSON object returned by the service invocation
 */
    ,failureHandler: function(serviceResponse) {
        
        if (serviceResponse.errorMessage) {
                 MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
        } 
        else {
             if (serviceResponse.errorMessageKey) {
                MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
             }
        }
        cursor_clear();
    }
})

/**
 * Invokes the order unlock action.
 * Perform the service or command call.
 */
wcService.declare({
    id: "AjaxRESTOrderLockOnBehalf",
    actionId: "AjaxRESTOrderLockOnBehalf",
    url: "AjaxRESTOrderLockOnBehalf",
    formId: ""

 /**
 * Display a success message
 * @param (object) serviceResponse The service response object, which is the
 * JSON object returned by the service invocation
 */

    ,successHandler: function(serviceResponse) {
        MessageHelper.hideAndClearMessage();
        MessageHelper.displayStatusMessage(MessageHelper.messages["MYACCOUNT_SAVEDORDERLIST_ORDER_LOCK_SUCCESS"]);
        cursor_clear();
    }

 /**
 * Display an error message
 * @param (object) serviceResponse The service response object, which is the
 * JSON object returned by the service invocation
 */
    ,failureHandler: function(serviceResponse) {
        
        if (serviceResponse.errorMessage) {
                 MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
        } 
        else {
             if (serviceResponse.errorMessageKey) {
                MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
             }
        }
        cursor_clear();
    }
})

/**
 * Invokes the order lock take over action.
 * Perform the service or command call.
 */
wcService.declare({
    id: "AjaxRESTOrderLockTakeOverOnBehalf",
    actionId: "AjaxRESTOrderLockTakeOverOnBehalf",
    url: "AjaxRESTOrderLockTakeOverOnBehalf",
    formId: ""

 /**
 * Display a success message
 * @param (object) serviceResponse The service response object, which is the
 * JSON object returned by the service invocation
 */

    ,successHandler: function(serviceResponse) {
        MessageHelper.hideAndClearMessage();
        MessageHelper.displayStatusMessage(MessageHelper.messages["MYACCOUNT_SAVEDORDERLIST_ORDER_LOCK_SUCCESS"]);
        cursor_clear();
        if (serviceResponse['isCurrentOrder'] !== undefined && serviceResponse['isCurrentOrder'][0] == 'true'){
            document.location.reload();
            //refresh the page to update cart
        }
    }

 /**
 * Display an error message
 * @param (object) serviceResponse The service response object, which is the
 * JSON object returned by the service invocation
 */
    ,failureHandler: function(serviceResponse) {
        
        if (serviceResponse.errorMessage) {
                 MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
        } 
        else {
             if (serviceResponse.errorMessageKey) {
                MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
             }
        }
        cursor_clear();
    }
})//-----------------------------------------------------------------
// Licensed Materials - Property of IBM
//
// WebSphere Commerce
//
// (C) Copyright IBM Corp. 2013, 2016 All Rights Reserved.
//
// US Government Users Restricted Rights - Use, duplication or
// disclosure restricted by GSA ADP Schedule Contract with
// IBM Corp.
//-----------------------------------------------------------------

/** 
 * Declares a new refresh controller for the Organization Summary widget
 */
var declareOrgSearchResultsController = function() {
	var myWidgetObj = $("#orgSearchResultsRefreshArea");
	
	wcRenderContext.declare("orgSearchResultsContext",["orgSearchResultsRefreshArea"],{"orgListDisplayType":"search","searchTerm":"", "startIndex":"0"});

	var myRCProperties = wcRenderContext.getRenderContextProperties("orgSearchResultsContext");
    
	var baseURL = getAbsoluteURL() + 'OrgListDisplayViewV2';
    
	myWidgetObj.refreshWidget({
    	renderContextChangedHandler: function() {
    		myWidgetObj.refreshWidget("updateUrl", baseURL + "?" + getCommonParametersQueryString());
    		myWidgetObj.html("");
    		console.debug(myRCProperties);
    		myWidgetObj.refreshWidget("refresh", myRCProperties);
       },

    	postRefreshHandler: function() {
    		cursor_clear();
    	}
	});
};

// onChange function for organization list select button
function OrganizationOnChange(id, displayName) {
	var data = {"newOrgId":id, "newOrgName":displayName};
	organizationListJS.updateSelectedOrgDetails(data);

	// Publish the event
	wcTopic.publish(organizationListJS.ORG_CHANGED_TOPIC,data);
}
$(document).ready(function() {

organizationListJS = {

	/** HashMap structure to manage parent - child organization relationship
	 *  Key - Parent Org Id
	 *  Value - List of child organizations under Parent Org Id.
	 *  Each object in the list contains complete details about the child organization like orgId, orgName, parentOrgId
	*/
	parentChildOrgDetails : new Object(),

	/**
	* HashMap structure.
	* Key - orgId
	* Value - orgName
	*/
	orgIdToNameMap: new Object(),

	/**
	* Array of top level parent orgIds
	*/
	parentOrgIdsArray : new Array(),

	// UniCode value for &nbps; 
	//HTML Select Option element will treat &nbps; as normal string when options element is created dynamically using script. So as a workaround use unicode format
	//indentation : "\xA0\xA0\xA0", 
	indentation : 27, // padding by 27 px for every child node

	/*
	* Topic name which gets published when the selection in organization drop down box changes.
	*/
	ORG_CHANGED_TOPIC : "organizationChanged",

	/*
	* Topic name to which this widget subscribes. Any widget can publish this topic to receive the current orgId selected in the drop down box.
	*/
	CURRENT_ORG_ID_REQUEST : "currentOrgIdRequest",

	/**
	* Topic name used to publish the current orgId.
	*/
	CURRENT_ORG_ID : "currentOrgId",

	/**
	* Current Organization selected
	*/
	CURRENT_DATA : {"newOrgId":"","newOrgName":""},
	
	/**
	* Set the indentation which can be used while displaying the tree structure
	*/
	setIndentation:function(indent){
		this.iindentation = indent;
	},

	orgSearchListData : {"searchInputFieldId":"orgNameInputField", "clearFilterButtonId":"clearFilter", "progressBarId":"searchOrgListButton", "searchParameterName":"orgName", "searchResultsDivId":"orgSearchResultsRefreshArea"},

	/**
	* This method converts the flat structure of organizaiton list into tree structure and displays the tree structure in the drop down box
	* flatStructure - List of organizations
	* selectBox - Id of the drop down box where the tree structure will be displayed
	*/
	createAndDisplayOrgTree:function(flatStructure,selectBox,selectedOrgEntityId){

		var parentOrgIdsSet = new Object();
		var seenParentOrgIds = new Object();

		//Keep track of id to Name mapping. Needed to get parentOrg Name. For Accessibility label.
		for(var i = 0; i < flatStructure.organizationDataBeans.length; i++){
			var orgDetails = flatStructure.organizationDataBeans[i];
			var orgId = orgDetails.organizationId;
			var orgName = orgDetails.displayName;
			this.orgIdToNameMap[orgId] = orgName; 
		}

		for(var i = 0; i < flatStructure.organizationDataBeans.length; i++){

			var orgDetails = flatStructure.organizationDataBeans[i];
			var orgId = orgDetails.organizationId;
			var parentOrgId = orgDetails.parentMemberId;
			var orgName = orgDetails.displayName;

			var childOrgList = this.parentChildOrgDetails[parentOrgId];
			if(childOrgList === undefined){
				childOrgList = new Array();
				this.parentChildOrgDetails[parentOrgId] = childOrgList;
			} 
			var child = new Object();
			child["orgId"] = orgId;
			child["parentOrgId"] = parentOrgId;
			child["orgName"] = orgName;
			child["parentOrgName"] = this.orgIdToNameMap[parentOrgId]; // This is for aria-label. To call out parent org Name.
			childOrgList[childOrgList.length] = child;

			// Identify the parentOrgIds
			if(!Object.prototype.hasOwnProperty.call(seenParentOrgIds, parentOrgId)){
				parentOrgIdsSet[parentOrgId] = "true";
			} 
			seenParentOrgIds[orgId] = "true";
			seenParentOrgIds[parentOrgId] = "true";
			if(Object.prototype.hasOwnProperty.call(parentOrgIdsSet, orgId)){
				delete parentOrgIdsSet[orgId];
			}
		}
		for(var i in parentOrgIdsSet){
			this.parentOrgIdsArray[this.parentOrgIdsArray.length] = i;
		}

		console.debug("Parent to Child Org Details = ", this.parentChildOrgDetails);
		console.debug("Top Level Parent Org Ids = ",this.parentOrgIdsArray);
		console.debug("Org Id to Name Map ", this.orgIdToNameMap);
		this.displayOrgTree(this.parentChildOrgDetails, this.parentOrgIdsArray, selectBox,selectedOrgEntityId);
	},

	/**
	* Displays organization structure in Tree form.
	* parentChildDetailsMap - Object containing parent to child org relationship.
	* parentIdsList - List of top level ( root ) OrgIds.
	* selectBox - id of the drop down box used to display the tree structure.
	*/
	displayOrgTree:function(parentChildDetailsMap, parentIdsList, selectBox,selectedOrgEntityId){
		var selectBoxObj = $("#" + selectBox);

		for(var i = 0; i < parentIdsList.length; i++){
			var childId = parentIdsList[i];
			this.buildOrgTreeRecursively(parentChildDetailsMap,childId, selectBoxObj, 8);
		}
		console.debug(selectBoxObj);
		// Set the selected orgEntityId in the selectBox object.
		$("#" + selectBox).Select("refresh");
	},

	/**
	* Recursively builds the tree structure mark-up.
	* parentChildDetailsMap - Object containing parent to child org relationship.
	* childId - Child Organization id
	* selectBoxObj - Drop down object where tree structure is built
	* indentation - Used to indent child orgs from parent orgs
	*/
	buildOrgTreeRecursively:function(parentChildDetailsMap,childId,parentNode,indentation){

		var childDetails = parentChildDetailsMap[childId];
		var scope = this;
		if(childDetails != null){
			for(var j = 0; j < childDetails.length; j++){
				var child = childDetails[j];
				var id1 = child['orgId'];
				var name = child['orgName'];
				var parentOrgName = child["parentOrgName"];
				var style = "padding-left:"+indentation+"px;";

				// Generate ARIA LABEL
				var ariaLevel = (indentation / this.indentation) + 1;
				//var tempString = storeNLS['ORG_TO_PARENT_ORG']; - 	// ORG_TO_PARENT_ORG : "${0} created under parent organization - ${1}",
				var stringPattern = "{0} - {1}";
				var tempString;
				if(parentOrgName != null){
					tempString = Utils.substituteStringWithMap(stringPattern, {
						0: name,
						1: parentOrgName
					});
				} else {
					// tempString = storeNLS['TOP_LEVEL_ORG']; - // TOP_LEVEL_ORG : "${0}. This is the top level organization"
					stringPattern = "{0}";
					tempString = Utils.substituteStringWithMap(stringPattern, {0: name});
				}
			
				var text = "<option aria-label = '"+ tempString +"' aria-level = '"+ariaLevel+"' style = '"+style+"'" +
						"value = '" + id1 + "'>"+name+"</option>";
				var option = {id:id1, label:text, displayName:name};
				parentNode.append(option.label);
				if(parentChildDetailsMap[id1] != null){
					this.buildOrgTreeRecursively(parentChildDetailsMap,id1, parentNode,indentation + this.indentation);
				} 
			}
		}
	},

	/**
	* For the given eventName and domNodeId, this function sets up the event with topicName = ORG_CHANGED_TOPIC
	* The data contains the orgId currently selected, with key set to "newOrgId"
	* 
	* This method also subscribes to CURRENT_ORG_ID_REQUEST topic and in response publishes CURRENT_ORG_ID with data object containing the current orgId.
	*/
	setUpEvents:function(eventName, selectBoxDivId){
		var scope = this;
		$(document).ready(function() {
			wcTopic.subscribe(scope.CURRENT_ORG_ID_REQUEST, function(data){
				console.debug("pulbish "+scope.CURRENT_ORG_ID, scope.CURRENT_DATA);
				// Add CURRENT_DATA to the data supplied by the publisher of this event.. and then publish a new event
				$.extend(data, scope.CURRENT_DATA);
				wcTopic.publish(scope.CURRENT_ORG_ID, data);
			});
		});
	},

	cancelEvent: function(e) {
		if (e.stopPropagation) {
			e.stopPropagation();
		}
		if (e.preventDefault) {
			e.preventDefault();
		}
		e.cancelBubble = true;
		e.cancel = true;
		e.returnValue = false;
	},

	updateSelectedOrgDetails:function(data,publishEvent){
		this.CURRENT_DATA["newOrgId"] = data["newOrgId"];
		this.CURRENT_DATA["newOrgName"] = data["newOrgName"];
		console.debug("Current Organization selected", this.CURRENT_DATA);
		if(publishEvent != 'undefined' && publishEvent == 'true'){
			wcTopic.publish(this.ORG_CHANGED_TOPIC,data);
		}
	},

	updateSelectedOrgName:function(elementId,name){
		$("#" + elementId).html(name);
		var scope = this;
		$(document).ready(function() {
			wcTopic.subscribe(scope.ORG_CHANGED_TOPIC, function(data){
				$("#" + elementId).html(data.newOrgName);
			});
		});
	},
	
	getCurrentData:function(){
		return this.CURRENT_DATA;
	},

	showResultsPage:function(data){

		var pageNumber = data['pageNumber'];
		var pageSize = data['pageSize'];
		pageNumber = parseInt(pageNumber);
		pageSize = parseInt(pageSize);
		var startIndex = (pageNumber - 1) * pageSize;

		setCurrentId(data["linkId"]);

		if(!submitRequest()){
			return;
		}

		console.debug(wcRenderContext.getRenderContextProperties('orgSearchResultsContext').properties);
		var beginIndex = pageSize * ( pageNumber - 1 );
		cursor_wait();

		wcRenderContext.updateRenderContext('orgSearchResultsContext', {"startIndex": startIndex});
		MessageHelper.hideAndClearMessage();
	},

	toggleSelection:function(nodeCSS,nodeId,parentNode,cssClassName){
		// Get list of all active nodes with cssClass = nodeCSS under parentNode.
		var activeNodes = $("#" + parentNode).find('.'+cssClassName);

		// Toggle the css class for the node with id = nodeId
		$("#" + parentNode).find('#'+nodeId).toggleClass(cssClassName);

		// Remove the css class for all the active nodes.
		activeNodes.removeClass(cssClassName);
	},

	closeActionButtons:function(nodeCSS,parentNode,cssClassName,hiddenClassName,activeClassName){
		$("#" + parentNode).find('.'+nodeCSS).removeClass(cssClassName);
	},

	resetActionButtonStyle:function(nodeCSS,parentNode,hiddenClassName,activeClassName){
		$("#" + parentNode).find('.'+nodeCSS).addClass(hiddenClassName);
		$("#" + parentNode).find('.'+nodeCSS).removeClass(activeClassName);
	},

	toggleCSSClass:function(nodeCSS,nodeId,parentNode,hiddenClassName,activeClassName){
		// Get the list of current nodes
		var activeNodes = $("#" + parentNode).find('.'+activeClassName); 

		// For the clicked node, toggle the CSS Class. If hidden then display / If displayed then hide.
		$("#"+parentNode).find('#'+nodeId).toggleClass(hiddenClassName);
		$("#"+parentNode).find('#'+nodeId).toggleClass(activeClassName);

		// For all activeNodes, remove the activeCSS and add the hiddenCSS
		activeNodes.removeClass(activeClassName);
		activeNodes.addClass(hiddenClassName);
	},

	doSearch:function(){
		searchTerm = $("#" + this.orgSearchListData.searchInputFieldId).val();
		if(searchTerm == 'undefined' || searchTerm.length == 0){
			searchTerm = "*";
		}
		setCurrentId(this.orgSearchListData.progressBarId);
		if(!submitRequest()){
			return;
		}
		cursor_wait();
		var params = {};
		params[this.orgSearchListData.searchParameterName] = searchTerm;
		params["startIndex"] = "0"; // Reset start index..This is a new search..
		wcRenderContext.updateRenderContext("orgSearchResultsContext", params);	
		$("#" + this.orgSearchListData.clearFilterButtonId).css("display","block"); // Display clearFilter button
	},

	handleSearchInput:function(event,doSearch){
		var searchTerm = $("#" + this.orgSearchListData.searchInputFieldId).val();
		if(searchTerm != 'undefined' && searchTerm.length > 0){
			$("#" + this.orgSearchListData.clearFilterButtonId).css("display","block");
		} else {
			$("#" + this.orgSearchListData.clearFilterButtonId).css("display","none");
		}
		$("#" + this.orgSearchListData.searchResultsDivId).html(""); // Clear previous search results..
		if(doSearch == 'true' && event != null && event.keyCode == KeyCodes.ENTER){
			this.doSearch();
		}
		return false;
	}

};

});//-----------------------------------------------------------------
// Licensed Materials - Property of IBM
//
// WebSphere Commerce
//
// (C) Copyright IBM Corp. 2013, 2016 All Rights Reserved.
//
// US Government Users Restricted Rights - Use, duplication or
// disclosure restricted by GSA ADP Schedule Contract with
// IBM Corp.
//-----------------------------------------------------------------

/**
 * Declares a new render context for the Organization Member Group widget
 */
wcRenderContext.declare("orgMemberGroupContext",["orgMemberGroupRefreshArea"],{'orgEntityId':null, 'progressBarId':null});

/** 
 * Declares a new refresh controller for the Organization Member Group widget
 */
function declareOrgMemberGroupController() {
	var myWidgetObj = $("#orgMemberGroupRefreshArea");

	var myRCProperties = wcRenderContext.getRenderContextProperties("orgMemberGroupContext");

	var baseURL = getAbsoluteURL() + 'OrgMemberGroupDisplayViewV2';
	
	wcTopic.subscribe(["AjaxApprovalGroupUpdate"], function() {
		myWidgetObj.refreshWidget("updateUrl", baseURL + "?" + getCommonParametersQueryString());
		setCurrentId(myRCProperties["progressBarId"]);
		submitRequest();
		cursor_wait();
		myWidgetObj.refreshWidget("refresh", myRCProperties);
	});

	myWidgetObj.refreshWidget({
		renderContextChangedHandler: function() {},
		
		postRefreshHandler: function() {
			cursor_clear();
			widgetCommonJS.removeSectionOverlay();
       }
	});
};

organizationMemberApprovalGroupJS = {

	widgetShortName: "OrgMemberApprovalGroupWidget", // My Name
	
	/**
	*/
	updateMemberApprovalGroup:function(orgEntityId, approvalGroupCheckBoxName, checkBoxCSSClassName){

		var service = wcService.getServiceById('AjaxApprovalGroupUpdate');

		if(service == null || service == undefined){
			/**
			 */
			wcService.declare({
				id: "AjaxApprovalGroupUpdate",
				actionId: "AjaxApprovalGroupUpdate",
				url: getAbsoluteURL() + "AjaxRESTApprovalGroupUpdate",
				formId: ""
				
				/**
				 * Clear messages on the page.
				 * @param (object) serviceResponse The service response object, which is the JSON object returned by the service invocation
				 */
				,successHandler: function(serviceResponse) {
					MessageHelper.hideAndClearMessage();
					MessageHelper.displayStatusMessage(Utils.getLocalizationMessage("APPROVAL_MEMBER_GROUP_UPDATED"));
				}
				
				/**
				 * Displays an error message on the page if the request failed.
				 * @param (object) serviceResponse The service response object, which is the JSON object returned by the service invocation.
				 */
				,failureHandler: function(serviceResponse) {
					if (serviceResponse.errorMessage) {
						MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
					} else {
						if (serviceResponse.errorMessageKey) {
							MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
						}
					}
					cursor_clear();
				}
			});
		}

		var checkBox = $('#' + approvalGroupCheckBoxName).find('.'+checkBoxCSSClassName);
		var segmentId = "";
		for(var i = 0; i < checkBox.length; i++){
			if(segmentId == ""){
				segmentId = checkBox[i].getAttribute("data-memberGroupId");
			} else {
				segmentId = segmentId +","+checkBox[i].getAttribute("data-memberGroupId");
			}
		}

		var params = [];
		params.orgEntityId = orgEntityId;
		params.segmentId = segmentId;
		params.storeId = WCParamJS.storeId;
		params.authToken =  $("#authToken").val();
		params.URL = "URL";
		
		setCurrentId(approvalGroupCheckBoxName+"Icon");
		if(!submitRequest()){
			return;
		}
		cursor_wait();
		var context = wcRenderContext.getRenderContextProperties("orgMemberGroupContext");
		context["orgEntityId"] = orgEntityId;
		context["progressBarId"] = approvalGroupCheckBoxName+"Icon"
		wcService.invoke("AjaxApprovalGroupUpdate", params);
	},
	
	preSelectAssignedMemberGroup:function(selectedGroupIds){
		var assignedGroups = $("#" + selectedGroupIds).val();
		var assignedGroupIds = assignedGroups.split(",");
		if(assignedGroupIds.length > 0){
			var checkBox = $('#memberGroupEdit').find('.arrowForDojoQuery');
			for(var i = 0; i < checkBox.length; i++){
				var roleId = checkBox[i].getAttribute("data-memberGroupId");
				
				for(var j = 0; j < assignedGroupIds.length; j++){
					if(assignedGroupIds[j] == roleId){
						$(checkBox[i]).addClass("arrow");
						$(checkBox[i]).attr("aria-checked","true");
						break;
					} else {
						$(checkBox[i]).removeClass("arrow");
						$(checkBox[i]).attr("aria-checked","false");
					}
				}
			}
		}
	}
};//-----------------------------------------------------------------
// Licensed Materials - Property of IBM
//
// WebSphere Commerce
//
// (C) Copyright IBM Corp. 2013, 2016 All Rights Reserved.
//
// US Government Users Restricted Rights - Use, duplication or
// disclosure restricted by GSA ADP Schedule Contract with
// IBM Corp.
//-----------------------------------------------------------------

/**
 * Declares a new render context for the Organization Roles widget
 */
wcRenderContext.declare("orgRolesContext",["orgRolesRefreshArea"],{'orgEntityId':null, "progressBarId":null});

/** 
 * Declares a new refresh controller for the Organization Roles widget
 */
function declareOrgRolesController() {
	var myWidgetObj = $("#orgRolesRefreshArea");
	
	var baseURL = getAbsoluteURL() + 'OrgRolesDisplayViewV2';
	
	var myRCProperties = wcRenderContext.getRenderContextProperties("orgRolesContext");
	
	wcTopic.subscribe(["AjaxOrgRolesUpdate"], function() {
		myWidgetObj.refreshWidget("updateUrl", baseURL + "?" + getCommonParametersQueryString());
		setCurrentId(myRCProperties["progressBarId"]);
		submitRequest();
		cursor_wait();
		myWidgetObj.refreshWidget("refresh", myRCProperties);
	});

	myWidgetObj.refreshWidget({
		renderContextChangedHandler: function() {
			myWidgetObj.refreshWidget("updateUrl", baseURL + "?" + getCommonParametersQueryString());
			if(myRCProperties["refreshWidget"] != "false"){
				myWidgetObj.html("");
				myWidgetObj.refreshWidget("refresh", myRCProperties);
			}
		},

		postRefreshHandler: function() {
			cursor_clear();
			widgetCommonJS.removeSectionOverlay();
		}
	});
};

organizationRolesJS = {

	widgetShortName: "OrgRolesWidget", // My Name
	initialSelectedRolesList: [],

	getOrgRolesUpdateService:function(actionId,postSuccessHandler,postRefreshHandlerParameters){
		
		var service = wcService.getServiceById('AjaxOrgRolesUpdate');

		if(service == null || service == undefined){
			/**
			 */
			wcService.declare({
				id: "AjaxOrgRolesUpdate",
				actionId: "AjaxOrgRolesUpdate",
				url: getAbsoluteURL() + "AjaxRESTOrganizationRoleAssign",
				formId: ""
				
				/**
				 * Clear messages on the page.
				 * @param (object) serviceResponse The service response object, which is the JSON object returned by the service invocation
				 */
				,successHandler: function(serviceResponse) {
					MessageHelper.hideAndClearMessage();
					if(this.postRefreshHandlerParameters == null || (this.postRefreshHandlerParameters != null && this.postRefreshHandlerParameters.showSuccessMessage != 'false')){
						MessageHelper.displayStatusMessage(Utils.getLocalizationMessage("ORG_ROLES_UPDATED"));
					}
					if(this.postSuccessHandler != null){
						cursor_clear();
						this.postSuccessHandler(serviceResponse,this.postRefreshHandlerParameters);
					}
				}
				
				/**
				 * Displays an error message on the page if the request failed.
				 * @param (object) serviceResponse The service response object, which is the JSON object returned by the service invocation.
				 */
				,failureHandler: function(serviceResponse) {
					if (serviceResponse.errorMessage) {
						MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
					} else {
						if (serviceResponse.errorMessageKey) {
							MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
						}
					}
					cursor_clear();
				}
			});
			service = wcService.getServiceById('AjaxOrgRolesUpdate');
		}
		if(actionId != null && actionId != 'undefined'){
			service.setActionId(actionId);
		}
		if(postSuccessHandler != null && postSuccessHandler != 'undefined'){
			service.setParam("postSuccessHandler", postSuccessHandler);
		} else {
			service.setParam("postSuccessHandler", null);
		}
		if(postRefreshHandlerParameters != null && postRefreshHandlerParameters != 'undefined'){
			service.setParam("postRefreshHandlerParameters", postRefreshHandlerParameters);
		} else {
			service.setParam("postRefreshHandlerParameters", null);
		}
		return service;
	},

	unassignRolesForOrg:function(serviceResponse,jsonObject){
		organizationRolesJS.updateOrganizationRoles(jsonObject.orgEntityId, jsonObject.approvalGroupCheckBoxName,jsonObject.checkBoxCSSClassName,jsonObject.action);
	},

	/**
	*/
	updateOrganizationRoles:function(orgEntityId, approvalGroupCheckBoxName, checkBoxCSSClassName,action){
		var scope = this;
		// Array of checked checkBoxes.
		var checkBoxes = $("#" + approvalGroupCheckBoxName).find('.'+checkBoxCSSClassName);
		var unAssignRoles = false;
		var assignRoles = false;
		var unAssignRoleIds = [];
		var assignRoleIds = [];
		var context = wcRenderContext.getRenderContextProperties("orgRolesContext");
		var params = [];
		params.memberId = orgEntityId;
		params.authToken = $("#authToken").val();
		params.storeId = WCParamJS.storeId;
		params.URL = "PassThisToAvoidException";
		
		checkBoxes.each($.proxy(function(i, entry){
			var roleId = entry.getAttribute("data-orgRolesId");
			if(this.initialSelectedRolesList.indexOf(roleId) == -1){
				// Initial list doesn't contain this roleId. It is selected now. Update at server side.
				assignRoleIds[assignRoleIds.length] = roleId;
			}	
		},scope));

		// Loop through initial selected roles list and see if it's still checked..
		$(scope.initialSelectedRolesList).each($.proxy(function(i, entry){
			var stillChecked = false;
			for(var i = 0; i < checkBoxes.length; i++){
				var selectedRoleId = checkBoxes[i].getAttribute("data-orgRolesId");
				if(selectedRoleId == entry){
					stillChecked = true;
					break;
				}
			}
			if(!stillChecked){
				unAssignRoleIds[unAssignRoleIds.length] = entry;
			}
		},scope));


		if(assignRoleIds.length > 0){
			assignRoles = true; // Need to assign some additional roles.
		}

		if(unAssignRoleIds.length > 0){
			unAssignRoles = true; // Need to un-assign some roles.
		}

		// After the service invoke, in the SuccessHandler call this postOrgRolesAssignHandler function with postRefreshHandlerParameters
		var postOrgRolesAssignHandler = null;
		var postRefreshHandlerParameters = null;


		if((action == 'undefined' || action == null || action == "assignRole") && assignRoles){
			// Start with assignRoles. Chain this service call with unAssignRoles call, if needed
			params.action = "assignRole";
			console.debug("assignRoleIds", assignRoleIds);
			for(var i = 0; i < assignRoleIds.length; i++){
				params["roleId"+i] = assignRoleIds[i];
			}

			if(unAssignRoles){
				postOrgRolesAssignHandler = scope.unassignRolesForOrg;
				context["refreshWidget"]  = "false"; // Do not refresh Roles widget immeditely. Wait for unAssign action to complete
				postRefreshHandlerParameters = {"orgEntityId":orgEntityId,"approvalGroupCheckBoxName":approvalGroupCheckBoxName,"checkBoxCSSClassName":checkBoxCSSClassName,"action":"unassignRole"};
				postRefreshHandlerParameters.showSuccessMessage = "false"; // Do not show success message till unAssign action is also done.
			}
		} else {
			action = "unassignRole"; //Nothing to assign.. Move the chain to unassignRole;
		}
		
		if(action == "unassignRole" && unAssignRoles){
			params.action ="unassignRole";
			console.debug("unAssignRoleIds", unAssignRoleIds);
			for(var i = 0; i < unAssignRoleIds.length; i++){
				params["roleId"+i] = unAssignRoleIds[i];
			}

			context["refreshWidget"]  = "true"; // Refresh widget
		}

		if(assignRoles || unAssignRoles){
			setCurrentId(approvalGroupCheckBoxName+"Icon");
			if(!submitRequest()){
				return;
			}
			cursor_wait();
			context["orgEntityId"] = orgEntityId;
			context["progressBarId"] = approvalGroupCheckBoxName+"Icon";
			var service = this.getOrgRolesUpdateService('AjaxOrgRolesUpdate', postOrgRolesAssignHandler, postRefreshHandlerParameters);
			wcService.invoke(service.getParam("id"), params);
		} else {
			MessageHelper.displayStatusMessage(Utils.getLocalizationMessage("ORG_ROLES_UPDATE_NO_CHNAGE"));
		}
	},

	preSelectAssignedRoles:function(selectedRoleIds){
		this.initialSelectedRolesList = [];
		var assignedRoles = $("#" + selectedRoleIds).val();
		var assignedRoleIds = assignedRoles.split(",");
		if(assignedRoleIds.length > 0){
			var checkBox = $('#orgRolesEdit').find('.arrowForDojoQuery');
			for(var i = 0; i < checkBox.length; i++){
				var roleId = checkBox[i].getAttribute("data-orgRolesId");
				
				for(var j = 0; j < assignedRoleIds.length; j++){
					if(assignedRoleIds[j] == roleId){
						$(checkBox[i]).addClass("arrow");
						$(checkBox[i]).attr("aria-checked","true");
						this.initialSelectedRolesList[this.initialSelectedRolesList.length] = roleId;
						break;
					} else {
						$(checkBox[i]).removeClass("arrow");
						$(checkBox[i]).attr("aria-checked","false");
					}
				}
			}
		}
		console.debug("List of roleIds == "+this.initialSelectedRolesList);
	},

	/**
	* Subscribe to 'organizationChanged' topic and respond to it by updating the roles available for the selected newOrgId
	*/
	subscribeToOrgChangeEvent:function(currentOrgEntityId){
		var topicName = "organizationChanged";
		var renderContext = wcRenderContext.getRenderContextProperties("orgRolesContext");
		renderContext["orgEntityId"] = currentOrgEntityId;
		$(document).ready(function() {
			wcTopic.subscribe("organizationChanged", function(data){
				var renderContext = wcRenderContext.getRenderContextProperties("orgRolesContext");
				if(renderContext["orgEntityId"] != data.newOrgId){
					// Only update if currentOrgId has changed in the drop down box...
					setCurrentId("orgRolesUpdateProgressBar");
					if(!submitRequest()){
						return;
					}
					cursor_wait();
					wcRenderContext.updateRenderContext("orgRolesContext", {'orgEntityId' : data.newOrgId, 'roleDisplayType':'create', "progressBarId":'orgRolesUpdateProgressBar'});	
				}
			});
		});
	}
};//-----------------------------------------------------------------
// Licensed Materials - Property of IBM
//
// WebSphere Commerce
//
// (C) Copyright IBM Corp. 2013, 2016 All Rights Reserved.
//
// US Government Users Restricted Rights - Use, duplication or
// disclosure restricted by GSA ADP Schedule Contract with
// IBM Corp.
//-----------------------------------------------------------------

/** 
 * Declares a new render context for the Organization Summary widget - To display basic summary of organziation
 */
wcRenderContext.declare("orgSummaryDisplayContext",["orgSummary","orgSummaryAddressRefreshArea","orgSummaryContactInfoRefreshArea"],{
	'orgEntityId':null, 
	'orgSummaryType':null,
	'progressBarId':null, 
	'widgetrefreshtype':null
});

/** 
 * Declares a new refresh controller for the Organization Summary widget
 */
var declareOrgSummaryController = function (divId) {
	var myWidgetObj = $("#" + divId);
	
	var myRCProperties = wcRenderContext.getRenderContextProperties("orgSummaryDisplayContext");

	var baseURL = getAbsoluteURL() + 'OrgSummaryDisplayViewV2';
	
	wcTopic.subscribe(["AjaxOrgSummaryUpdate"], function() {
		myWidgetObj.refreshWidget("updateUrl", baseURL + "?" + getCommonParametersQueryString());
		//properties of widget should be always in lower case. widgetRefreshType doesn't work.
		if(myRCProperties['widgetrefreshtype'] == myWidgetObj.attr("widgetrefreshtype")){
			setCurrentId(myRCProperties["progressBarId"]);
			submitRequest();
			cursor_wait();
			myWidgetObj.refreshWidget("refresh", myRCProperties);
		}
	});

	myWidgetObj.refreshWidget({
		renderContextChangedHandler: function() {
			myWidgetObj.refreshWidget("updateUrl", baseURL + "?" + getCommonParametersQueryString());
			myWidgetObj.html("");
			myWidgetObj.refreshWidget("refresh", myRCProperties);
		},

		postRefreshHandler: function() {
			cursor_clear();
			widgetCommonJS.removeSectionOverlay();
		}
	});
};


organizationSummaryJS = {

	widgetShortName: "OrgSummaryWidget", // My Name
	mandatoryFields : "",
	OrganizationCreateEditViewName:"OrganizationCreateEditView",

	//infoJsonData :{'parameterNameUsedByCommand':'fieldNameInUI'}

	orgInfoJsonData : {"orgEntityName":"orgName"},
	orgValidationData : [ {"fieldName":"orgName", "type":"any", "maxLength":"128", "required":"true", "errorMessageKey":"ERROR_OrgName"}],

	contactInfoJsonData : {"email1":"email1", "phone1":"phone1", "fax1":"fax1"},
	contactValidationData : [
								{"fieldName":"email1", "type":"email", "maxLength":"256", "required":"true", "errorMessageKey":"ERROR_Email"},
								{"fieldName":"phone1", "type":"phone", "maxLength":"32", "required":"false", "errorMessageKey":"ERROR_Phone"},
								{"fieldName":"fax1", "type":"any", "maxLength":"32", "required":"false", "errorMessageKey":"ERROR_Fax"}
							],

	addressInfoJsonData : {"address1":"address1", "city":"city", "state":"state", "country":"country", "zipCode":"zipCode"},
	addressValidationData : [
									{"fieldName":"address1", "type":"any", "maxLength":"50", "required":"nls", "errorMessageKey":"ERROR_Address"},
									{"fieldName":"city", "type":"any", "maxLength":"128", "required":"nls", "errorMessageKey":"ERROR_City"},
									{"fieldName":"state", "type":"any", "maxLength":"128", "required":"nls", "errorMessageKey":"ERROR_State"},
									{"fieldName":"country", "type":"any", "maxLength":"128", "required":"nls", "errorMessageKey":"ERROR_Country"},
									{"fieldName":"zipCode", "type":"any", "maxLength":"40", "required":"nls", "errorMessageKey":"ERROR_ZipCode"}
								],

	summaryInfoJsonData:  {'description':'orgDescription','businessCategory':'orgBusinessCategory'},
	summaryValidationData: [
								{"fieldName":"orgDescription", "type":"any", "maxLength":"512", "required":"false", "errorMessageKey":"ERROR_OrganizationDescription"},
								{"fieldName":"orgBusinessCategory", "type":"any", "maxLength":"128", "required":"false", "errorMessageKey":"ERROR_BusinessCategory"}
							],

	/**
	* Subscribe to 'organizationChanged' topic and respond to it by updating the organization summary for the newOrgId
	*/
	subscribeToOrgChangeEvent:function(currentOrgEntityId){
		var topicName = "organizationChanged";

		var renderContext = wcRenderContext.getRenderContextProperties("orgSummaryDisplayContext");
		renderContext["orgEntityId"] = currentOrgEntityId;

		$(document).ready(function() {
			wcTopic.subscribe("organizationChanged", function(data){
				var renderContext = wcRenderContext.getRenderContextProperties("orgSummaryDisplayContext");
				if(renderContext["orgEntityId"] != data.newOrgId){
					setCurrentId("orgSummaryInfoProgressBar");
					if(!submitRequest()){
						return;
					}
					cursor_wait();
					wcRenderContext.updateRenderContext("orgSummaryDisplayContext", {'orgEntityId' : data.newOrgId, 'orgSummaryType':null, "progressBarId":null});	
				}
			});

		});
	},


	/**
	* Publishes 'currentOrgIdRequest' topic.
	* Organization List widget will respond to this event and publishes the "currentOrgId" topic along with the orgId.
	* Responds to "currentOrgId" topic event by refreshing the organization summary data for the newOrgId
	*/
	publishOrgIdRequest:function(){
		var topicName = "currentOrgIdRequest";
		var scope = this;
		$(document).ready(function() {
			wcTopic.subscribe("currentOrgId", function(data){
				if(data.requestor === scope.widgetShortName){
					// The original request was from me. So respond to this event.
					wcRenderContext.updateRenderContext("orgSummaryDisplayContext", {'orgEntityId' : data.newOrgId, 'orgSummaryType':null, "progressBarId":null});	
				}
			});
			// Set the requestor to my widgetShortName. 
			// Respond to follow-up events, only if the event published was in response to my request. 
			// The requestor attribute in the data helps to check this.
			var data = {"requestor":scope.widgetShortName};
			wcTopic.publish(topicName, data);
		});
	},

	redirectToCreateEditPage:function(orgEntityCreateEditViewName, actionType){
		if(actionType == 'E'){
			// Publish an event and get back the current organizaiton ID
			var topicName = "currentOrgIdRequest";
			var scope = this;
			$(document).ready(function() {	
				wcTopic.subscribe("currentOrgId", function(data){
					if(data.requestor == "CreateEditAction"){
						// The original request was from me. So respond to this event.
						document.location.href = orgEntityCreateEditViewName+"&orgEntityId="+data.newOrgId;
					}
				});
				// Set the requestor == CreateEditAction. 
				// Respond to follow-up events, only if the event published was in response to my request. 
				// The requestor attribute in the data helps to check this.
				var data = {"requestor":"CreateEditAction"};
				wcTopic.publish(topicName, data);
			});

		} else if(actionType == 'C'){
			// Publish an event and get back the current organizaiton ID
			var topicName = "currentOrgIdRequest";
			var scope = this;
			$(document).ready(function() {
				wcTopic.subscribe("currentOrgId", function(data){
					if(data.requestor == "CreateEditAction"){
						// The original request was from me. So respond to this event.
						var url = orgEntityCreateEditViewName;
						if(data != null && data.newOrgId != null){
							url = url + "&parentOrgEntityId="+data.newOrgId;
						}
						if(data != null && data.newOrgName != null){
							url = url + "&parentOrgEntityName="+data.newOrgName;
						}
						document.location.href = url;
					}
				});
				// Set the requestor == CreateEditAction. 
				// Respond to follow-up events, only if the event published was in response to my request. 
				// The requestor attribute in the data helps to check this.
				var data = {"requestor":"CreateEditAction"};
				wcTopic.publish(topicName, data);
			});
		}

	},

	postOrgCreation:function(serviceResponse,progressBarId){
		console.debug("serviceResponse after org creation ", serviceResponse);
		console.debug(progressBarId);
		console.debug("Start updating roles for "+serviceResponse.orgEntityId);

		var checkBox = $('#orgRolesEdit').find('.arrow');
		if(checkBox.length == 0){
			MessageHelper.displayStatusMessage(Utils.getLocalizationMessage("ORG_ROLES_UPDATE_NO_CHNAGE"));
			this.postRolesCreation(serviceResponse);
			return false;
		}

		var params = [];
		params.memberId = serviceResponse.orgEntityId;
		params.authToken = $("#authToken").val();
		params.storeId = WCParamJS.storeId;
		params.URL = "PassThisToAvoidException";
		params.action = "assignRole";

		for(var i = 0; i < checkBox.length; i++){
			var roleId = checkBox[i].getAttribute("data-orgRolesId");
			params["roleId"+i] = roleId;
		}
		
		setCurrentId(progressBarId);
		if(!submitRequest()){
			return;
		}
		cursor_wait();
		var rolesService = organizationRolesJS.getOrgRolesUpdateService('AjaxOrgRolesUpdateDuringOrgCreate', this.postRolesCreation, serviceResponse);
		wcService.invoke(rolesService.getParam("id"), params);

	},

	postRolesCreation:function(serviceResponse, jsonObject){
		var orgEntityId = null;
		if(jsonObject != null && jsonObject != 'undefined' && jsonObject.orgEntityId != null){
			orgEntityId = jsonObject.orgEntityId;
		} else if(serviceResponse != null && serviceResponse != 'undefined' && serviceResponse.orgEntityId != null){
			orgEntityId = serviceResponse.orgEntityId;
		}
		document.location.href = organizationSummaryJS.OrganizationCreateEditViewName+"?"+getCommonParametersQueryString()+"&orgEntityId="+orgEntityId;
	},

	invokeOrgEntityCreateService:function(params,progressBarId){
		
		var service = wcService.getServiceById('AjaxOrgEntityAdd');
		var scope = this;

		if(service == null || service == undefined){
			/**
			 */
			wcService.declare({
				id: "AjaxOrgEntityAdd",
				actionId: "AjaxOrgEntityAdd",
				url: getAbsoluteURL() + "AjaxRESTOrganizationRegistration",
				formId: ""
				
				/**
				 * Clear messages on the page.
				 * @param (object) serviceResponse The service response object, which is the JSON object returned by the service invocation
				 */
				,successHandler: function(serviceResponse) {
					MessageHelper.hideAndClearMessage();
					MessageHelper.displayStatusMessage(Utils.getLocalizationMessage("ORG_ENTITY_CREATED_UPDATING_ROLES"));
					scope.postOrgCreation(serviceResponse,progressBarId);
				}
				
				/**
				 * Displays an error message on the page if the request failed.
				 * @param (object) serviceResponse The service response object, which is the JSON object returned by the service invocation.
				 */
				,failureHandler: function(serviceResponse) {
					if (serviceResponse.errorMessage) {
						MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
					} else {
						if (serviceResponse.errorMessageKey) {
							MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
						}
					}
					cursor_clear();
				}
			});
		}
		
		setCurrentId(progressBarId);
		if(!submitRequest()){
			return;
		}
		cursor_wait();
		params.storeId = WCParamJS.storeId;
		params.URL = "PassThisToAvoidException";
		wcService.invoke("AjaxOrgEntityAdd", params);
	},

	invokeOrgEntityUpdateService:function(orgEntityId, params,jsonData,editSectionId){
		
		var service = wcService.getServiceById('AjaxOrgSummaryUpdate');

		if(service == null || service == undefined){
			/**
			 */
			wcService.declare({
				id: "AjaxOrgSummaryUpdate",
				actionId: "AjaxOrgSummaryUpdate",
				url: getAbsoluteURL() + "AjaxRESTOrganizationUpdate",
				formId: ""
				
				/**
				 * Clear messages on the page.
				 * @param (object) serviceResponse The service response object, which is the JSON object returned by the service invocation
				 */
				,successHandler: function(serviceResponse) {
					MessageHelper.hideAndClearMessage();
					MessageHelper.displayStatusMessage(Utils.getLocalizationMessage("ORG_SUMMARY_UPDATED"));
				}
				
				/**
				 * Displays an error message on the page if the request failed.
				 * @param (object) serviceResponse The service response object, which is the JSON object returned by the service invocation.
				 */
				,failureHandler: function(serviceResponse) {
					if (serviceResponse.errorMessage) {
						MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
					} else {
						if (serviceResponse.errorMessageKey) {
							MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
						}
					}
					cursor_clear();
				}
			});
		}
		
		setCurrentId(editSectionId+'Icon');
		if(!submitRequest()){
			return;
		}
		cursor_wait();

		for(i in jsonData){
			var node = $("#" + jsonData[i])[0];
			if(node == null || node == 'undefined'){
				node = $("[name="+jsonData[i]+"]")[0];
			}
			console.debug(" node for", jsonData[i], node);
			params[i] = node.value;
		}

		params.orgEntityId = orgEntityId;
		params.storeId = WCParamJS.storeId;
		params.URL = "PassThisToAvoidException";

		wcService.invoke("AjaxOrgSummaryUpdate", params);
	},

	updateOrgSummaryDisplayContext:function(orgEntityId, refreshType, progressBarId){
		var context = wcRenderContext.getRenderContextProperties("orgSummaryDisplayContext");
		context["orgEntityId"] = orgEntityId;
		context["orgSummaryType"] = 'edit';
		context["progressBarId"] = progressBarId;

		// Reset all
		context["orgSummaryBasicEdit"] = 'false';
		context["orgSummaryAddressEdit"] = 'false';
		context["orgSummaryContactInfoEdit"] = 'false';
		context["widgetrefreshtype"] = refreshType;

		if(refreshType == 'basic'){
			context["orgSummaryBasicEdit"] = 'true';
		} else 	if(refreshType == 'address'){
			context["orgSummaryAddressEdit"] = 'true';
		} else 	if(refreshType == 'contactInfo'){
			context["orgSummaryContactInfoEdit"] = 'true';
		}
	},

	updateOrganizationSummary:function(orgEntityId, editSectionId){
		if(!this.validateData(this.summaryValidationData)) {
			return;
		} else {
			// Close Edit Section and display readOnly section.
			widgetCommonJS.toggleReadEditSection(editSectionId, 'read')
		}
		var params = [];
		this.updateOrgSummaryDisplayContext(orgEntityId,"basic",editSectionId+"Icon");
		this.invokeOrgEntityUpdateService(orgEntityId,params,this.summaryInfoJsonData,editSectionId);
	},

	updateOrganizationAddress:function(orgEntityId, editSectionId){
		
		if(!this.validateData(this.addressValidationData)){
			return;
		} else {
			// Close Edit Section and display readOnly section.
			widgetCommonJS.toggleReadEditSection(editSectionId, 'read')
		}

		var params = [];
		this.updateOrgSummaryDisplayContext(orgEntityId,"address",editSectionId+"Icon");
		this.invokeOrgEntityUpdateService(orgEntityId,params,this.addressInfoJsonData,editSectionId);
	},

	updateOrganizationContactInfo:function(orgEntityId, editSectionId){
		if(!this.validateData(this.contactValidationData)) {
			return;
		} else {
			// Close Edit Section and display readOnly section.
			widgetCommonJS.toggleReadEditSection(editSectionId, 'read')
		}
		var params = [];
		this.updateOrgSummaryDisplayContext(orgEntityId,"contactInfo", editSectionId+"Icon");
		this.invokeOrgEntityUpdateService(orgEntityId,params,this.contactInfoJsonData,editSectionId);

	},

	updateParameterValues:function(params,jsonData){
		for(i in jsonData){
			var node = $("#" + jsonData[i])[0];
			if(node == null || node == 'undefined'){
				node = $("[name="+jsonData[i]+"]")[0];
			} 
			if(node != null){
				console.debug("for ", i, "value is ",node.value);
				params[i] = node.value;
			} else {
				console.debug("For ",  i, "value is null");
			}
		}
	},
	createOrgEntity:function(progressBarId){

		if(!this.validateData(this.orgValidationData)) return false;
		var parentMemberId = organizationListJS.getCurrentData()['newOrgId'];
		if(parentMemberId == null || parentMemberId == 'undefined' || parentMemberId.length == 0 ){
			if($("#orgNameInputField")[0] != 'undefined' && $("#orgNameInputField")[0] != null){
				MessageHelper.formErrorHandleClient("orgNameInputField", Utils.getLocalizationMessage("ERROR_ParentOrgNameEmpty"));
				return false;
			}
		}
		//if(!this.validateData(this.summaryValidationData)) return false;
		if(!this.validateData(this.addressValidationData)) return false;
		if(!this.validateData(this.contactValidationData)) return false;

		var params = [];
		this.updateParameterValues(params,this.orgInfoJsonData);
		this.updateParameterValues(params,this.summaryInfoJsonData);
		this.updateParameterValues(params,this.addressInfoJsonData);
		this.updateParameterValues(params,this.contactInfoJsonData);

		params['parentMemberId'] = parentMemberId
		params['orgEntityType'] = 'O'; // Always create organization type. OrganizationalUnit type is not supported.
		params['addToRegisteredCustomersGroup'] = 'true'; // Make this new organization as part of RegisteredCustomers member group owned by the stores owning organization.
		this.invokeOrgEntityCreateService(params,progressBarId);
	},

	setMandatoryFields:function(fields){
		this.mandatoryFields = fields;
	},

	validateData:function(validationData){
		reWhiteSpace = new RegExp(/^\s+$/);
		for(var i = 0; i < validationData.length; i++){
			//console.debug("The validation data at ",i, "is ", validationData[i]);
			var data = validationData[i];
			var fieldName = data["fieldName"];
			var fieldType = data["fieldType"];
			var node = $("[name="+fieldName+"]")[0];
			var required = data["required"];
			var dataType = data["type"];
			var maxLength = data["maxLength"];
			var errorMessageKey = data["errorMessageKey"];


			if(node != null && node != 'undefined'){
				var value = node.value;
				console.debug("value == ",value, "for fieldName ",fieldName);
				console.debug("Requried == ",required);
				console.debug("set of mandatory fields == ",this.mandtoryFields);
				console.debug("Requried by NLS rule == ",this.mandatoryFields.indexOf(fieldName));
				// IsMandatory validation
				if(required == 'true' || (required == "nls" && this.mandatoryFields.indexOf(fieldName) != "-1")){
					if(value == "" || reWhiteSpace.test(value)){
						console.debug("empty .. show error message for ",node.id);
						if(node.tagName == "SELECT" || node.tagName == "select") {
							// for jquery select menu
							MessageHelper.formErrorHandleClient(node.id + "-button", Utils.getLocalizationMessage(errorMessageKey+"Empty"));
						} else {
							MessageHelper.formErrorHandleClient(node.id, Utils.getLocalizationMessage(errorMessageKey+"Empty"));
						}
						return false;
					}
				} 

				// MaxLength validation
				if(maxLength != "-1"){
					console.debug("max length == ",maxLength);
					if(!MessageHelper.isValidUTF8length(value, data["maxLength"])){ 
						MessageHelper.formErrorHandleClient(node.id, Utils.getLocalizationMessage(errorMessageKey+"TooLong"));
						return false;
					}
				}

				// Data Type validation
				if(dataType == "email"){
					if(!MessageHelper.isValidEmail(value)){
						MessageHelper.formErrorHandleClient(node.id, Utils.getLocalizationMessage("ERROR_INVALIDEMAILFORMAT"));
						return false;
					}
				} else if(dataType == "phone"){
					if(!MessageHelper.IsValidPhone(value)){
						MessageHelper.formErrorHandleClient(node.id, Utils.getLocalizationMessage("ERROR_INVALIDPHONE"));
						return false;
					}
				} else if(dataType == "numeric"){
					if(!MessageHelper.IsNumeric(value)){
						MessageHelper.formErrorHandleClient(node.id, Utils.getLocalizationMessage("ERROR_INVALID_NUMERIC"));
						return false;
					}
				}
			}
		}
		return true;
	},
	
	resetFormValue: function(target_name){
		var target = $("#" + target_name);
 		target.find("form").each(function(index, form){
			$(form)[0].reset();
			$(form).find("select.wcSelect").each(function(index, select){
				$(select).Select("refresh_noResizeButton");
			})
		});
 	}
};//-----------------------------------------------------------------
// Licensed Materials - Property of IBM
//
// WebSphere Commerce
//
// (C) Copyright IBM Corp. 2014, 2016 All Rights Reserved.
//
// US Government Users Restricted Rights - Use, duplication or
// disclosure restricted by GSA ADP Schedule Contract with
// IBM Corp.
//-----------------------------------------------------------------

/** 
 * @fileOverview This file provides all the functions and variables to manage member info.
 * This file is included in all pages with organization users list actions.
 */

/**
 * This service allows admin to update member info
 * @constructor
 */
wcService.declare({
	id:"OrganizationUserInfoAdminUpdateMember",
	url:"AjaxRESTUserRegistrationAdminUpdate"

	 /**
     * Hides all the messages and the progress bar.
     * @param (object) serviceResponse The service response object, which is the
     * JSON object returned by the service invocation.
     */
	,successHandler: function(serviceResponse) {
		MessageHelper.hideAndClearMessage();
		cursor_clear();		
		MessageHelper.displayStatusMessage(MessageHelper.messages["ORGANIZATIONUSERINFO_UPDATE_SUCCESS"]);
	}
		
	/**
     * display an error message.
     * @param (object) serviceResponse The service response object, which is the
     * JSON object returned by the service invocation.
     */
	,failureHandler: function(serviceResponse) {

		if (serviceResponse.errorMessage) {
			MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
		} 
		else {
			 if (serviceResponse.errorMessageKey) {
				MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
			 }
		}
		cursor_clear();
	}			
});


/**
 * This service allows admin to add/create new member
 * Upon successfully creating user, the successHandler will call 
 * UserRoleManagementJS.assignRole function
 * @constructor
 */
wcService.declare({
	id:"chainedAjaxUserRegistrationAdminAdd",
	url:"AjaxRESTUserRegistrationAdminAdd",
	formId:"Register"

	 /**
     * Hides all the messages and the progress bar.
     * @param (object) serviceResponse The service response object, which is the
     * JSON object returned by the service invocation.
     */
	,successHandler: function(serviceResponse) {
		MessageHelper.hideAndClearMessage();
		if (typeof(UserRoleManagementJS) != 'undefined' && !UserRoleManagementJS.isEmptySelectedRoles()){
			UserRoleManagementJS.chainedAssignRole(serviceResponse.userId);
		}
		else {
			document.location.href = OrganizationUserInfoJS.getChainedServiceRediretUrl();
			cursor_clear();		
			MessageHelper.displayStatusMessage(MessageHelper.messages["ORGANIZATIONUSER_CREATE_SUCCESS"]);
		}
	}
		
	/**
     * display an error message.
     * @param (object) serviceResponse The service response object, which is the
     * JSON object returned by the service invocation.
     */
	,failureHandler: function(serviceResponse) {

		if (serviceResponse.errorMessage) {
			MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
		} 
		else {
			 if (serviceResponse.errorMessageKey) {
				MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
			 }
		}
		cursor_clear();
	}			
});


 	
	/**
	 * This class defines the functions and variables that customers can use to create, update, and view user.
	 * @class The OrganizationUserInfoJS class defines the functions and variables that can be used to manage Organization users 
	 */
	OrganizationUserInfoJS ={		
		
		widgetShortName: "OrgUserUserInfoWidget",
		/** 
		 * This variable stores the ID of the language that the store currently uses. Its default value is set to -1, which corresponds to United States English.
		 * @private
		 */
		langId: "-1",
		
		/** 
		 * This variable stores the ID of the current store. Its default value is empty.
		 * @private
		 */
		storeId: "",
		
		/** 
		 * This variable stores the ID of the catalog. Its default value is empty.
		 * @private
		 */
		catalogId: "",	
		
		/** 
		 * This variable stores the redirect url for chained create user service upon success.
		 * 
		 */
		chainedServiceRedirectUrl: "",	
		
		
		/**
		 * Sets the common parameters for the current page. 
		 * For example, the language ID, store ID, and catalog ID.
		 *
		 * @param {Integer} langId The ID of the language that the store currently uses.
		 * @param {Integer} storeId The ID of the current store.
		 * @param {Integer} catalogId The ID of the catalog.
		 */
		setCommonParameters:function(langId,storeId,catalogId){
			this.langId = langId;
			this.storeId = storeId;
			this.catalogId = catalogId;
			cursor_clear();
		},	
		
		/**
		 * Initialize the URL of Buyer List widget controller. 	 
		 *
		 * @param {object} userDetailsUrl The userDetails controller's URL.
		 * @param {object} userAddressUrl The userAddress controller's URL.
		 */
		initOrganizationUserInfoControllerUrls:function(userDetailsUrl,userAddressUrl){
			$("#OrganizationUserInfo_userDetail_Widget").attr("refreshurl", userDetailsUrl);
			$("#OrganizationUserInfo_userAddress_Widget").attr("refreshurl", userAddressUrl);
		},
		
		/**
		 * Initialize the Parent org info that the buyer to be created under. Will be used for constructing url return
		 * to "Organizations and buyers" page with pre-selected org. 
		 *
		 * @param {object} parentOrgName The parent Organization name.
		 * @param {object} parentOrgId The parentOrganization ID.
		 */
		initializeParentOrgInfo:function(parentOrgName, parentOrgId){
			this._parentOrgEntityName = parentOrgName;
			this._parentOrgEntityId = parentOrgId;
		},
		
		/**
		 * Update member user account status to 'Enabled' or 'Disalbed', status 0 means disabled, status 1 means enabled.
		 * 
		 * @param formId The id of the form to update
		 */
		saveUserInfoChange:function(form){
			if (! this.validateAndPrepareUserInfo(form)) return;
			wcService.getServiceById('OrganizationUserInfoAdminUpdateMember').setFormId(form.id);
			wcService.getServiceById('OrganizationUserInfoAdminUpdateMember').setActionId("OrganizationUserInfoAdminUpdateMember_" + form.id);
			if(!submitRequest()){
				return;
			}			
			cursor_wait();
			wcService.invoke('OrganizationUserInfoAdminUpdateMember');
		},
		
		/**
		 * This function validate and prepare the update form for submit, the form is used to update user info.
		 * @param {string} form The name of the form containing personal information of the customer.
		 */
		validateAndPrepareUserInfo:function(form){
			if (form.name != 'UserAddress') {
				if(typeof(form.logonPassword_old) != 'undefined' && typeof(form.logonPasswordVerify_old) != 'undefined'){
					if(form.logonPassword_old.name == "logonPassword") {
						form.logonPassword_old.name = "logonPassword_old";
						form.logonPasswordVerify_old.name = "logonPasswordVerify_old";
					}
					/*check whether the values in password and verify password fields match, if so, update the password. */ 
					if (form.logonPassword_old.value.length != 0)
					{
						if(form.logonPassword_old.value!= form.logonPasswordVerify_old.value)
						{
							MessageHelper.formErrorHandleClient(form.logonPasswordVerify_old.id,MessageHelper.messages["PWDREENTER_DO_NOT_MATCH"]);
							return false; 
						}
						form.logonPassword_old.name = "logonPassword";
						form.logonPasswordVerify_old.name = "logonPasswordVerify";
					}
				}
			}
			
			/** Uses the common validation function defined in AddressHelper class for validating first name, 
			 *  last name, street address, city, country/region, state/province, ZIP/postal code, e-mail address and phone number. 
			 */

			if(!AddressHelper.validateAddressForm(form)){
				return false;
			}
			
			/* Checks whether the customer has registered for promotional e-mails. */
			if(form.sendMeEmail && form.sendMeEmail.checked ){
			    if (form.receiveEmail) form.receiveEmail.value = true;
			}
			else {
				if (form.receiveEmail) form.receiveEmail.value = false;
			}
			
			if(form.sendMeSMSNotification && form.sendMeSMSNotification.checked){
				if (form.receiveSMSNotification) form.receiveSMSNotification.value = true;
			}
			else {
				if (form.receiveSMSNotification) form.receiveSMSNotification.value = false;
			}

			if(form.sendMeSMSPreference && form.sendMeSMSPreference.checked){
				if (form.receiveSMS)form.receiveSMS.value = true;
			}
			else {
				if (form.receiveSMS) form.receiveSMS.value = false;
			}

			if(form.mobileDeviceEnabled != null && form.mobileDeviceEnabled.value == "true"){
				if(!MyAccountDisplay.validateMobileDevice(form)){
					return false;
				}
			}
			if(form.birthdayEnabled != null && form.birthdayEnabled.value == "true"){
				if(!MyAccountDisplay.validateBirthday(form)){
					return false;
				}
			}
			return true;
		},

		/**
		* Publishes 'currentOrgIdRequest' topic.
		* Organization List widget will respond to this event and publishes the "currentOrgId" topic along with the orgId.
		* Responds to "currentOrgId" topic event by refreshing the organization summary data for the newOrgId
		*/
		publishOrgIdRequest:function(){
			var topicName = "currentOrgIdRequest";
			var scope = this;
			
			wcTopic.subscribe("currentOrgId", function(data){
				if(data.requestor === scope.widgetShortName){
					// The original request was from me. So respond to this event.
					var parentMemberIdInput = $("#WC_OrganizationUserInfo_userDetails_Form_Input_parentMemberId");
					parentMemberIdInput.attr("value",data.newOrgId);
					scope._parentOrgEntityName = data.newOrgName;
					scope._parentOrgEntityId = data.newOrgId;
				}
				// Set the requestor to my widgetShortName. 
				// Respond to follow-up events, only if the event published was in response to my request. 
				// The requestor attribute in the data helps to check this.
				var data = {"requestor":scope.widgetShortName};
				wcTopic.publish(topicName, data);
			});
		},
		
		/**
		* Subscribe to 'organizationChanged' topic.
		* Organization User Info widget will respond to this topic event by updating the parentMemberId to newOrgId
		*/
		subscribeToOrgChange:function() {
			var topicName = "organizationChanged";
			var scope = this;
			wcTopic.subscribe(topicName, function(data){
				//console.debug("organizationChanged received");
				var parentMemberIdInput = $("#WC_OrganizationUserInfo_userDetails_Form_Input_parentMemberId");
				parentMemberIdInput.attr("value",data.newOrgId);
				scope._parentOrgEntityName = data.newOrgName;
				scope._parentOrgEntityId = data.newOrgId;
			});
		},
		 	
	 	resetFormValue: function(target){
	 		$(target).find("form").each(function(index, form){
				$(form)[0].reset();
				$(form).find("select.wcSelect").each(function(index, select){
					$(select).Select("refresh_noResizeButton");
				})
			});
	 	},
	 	
	 	subscribeToToggleCancel: function(){
	 		var topicName = "sectionToggleCancelPressed";
	 		var scope = this;
	 		wcTopic.subscribe(topicName, function(data){
	 			if (data.target === 'WC_OrganizationUserInfo_userDetails_pageSection' || data.target === 'WC_OrganizationUserInfo_userAddress_pageSection'){
	 				scope.resetFormValue(document.getElementById(data.target));
	 			}
	 		});
	 	},
	 	
	 	/**
	 	 * The function is called from add/create buyer page submit button, in 'chainedAjaxUserRegistrationAdminAdd' successHandler
	 	 * will call role assignment and member group widget's service.
	 	 * @param form the user details and address form to submit
	 	 * @url the url for the store page that will be displayed upon submit success.
	 	 */
	 	chainedServicePrepareSubmit: function(form, url) {
			var random = Math.random();
			var randomPassword = random.toString(36).slice(-7); // Get last 7 chars. Will add one numeric char to make it 8 char long...
			var randomInt = Math.floor((random * 9) + 1);
			randomPassword += randomInt; //Password should contain at least one numeric character...
			if($("#logonPassword")[0] == null || $("#logonPassword")[0] == undefined){
				$(form).append( $('<input>', {
					type: "hidden",
					value: randomPassword,
					name: "logonPassword",
					id: "logonPassword",
				}));
			}
			if($("#logonPasswordVerify")[0] == null || $("#logonPasswordVerify")[0] == undefined){
				$(form).append( $('<input>', {
					type: "hidden",
					value: randomPassword,
					name: "logonPasswordVerify",
					id: "logonPasswordVerify"
				}));
			}
			if($("#passwordExpired")[0] == null || $("#passwordExpired")[0] == undefined){
				$(form).append( $('<input>', {
					type: "hidden",
					value: "1",
					name: "passwordExpired",
					id: "passwordExpired"
				}));
			}

	 		if (!LogonForm.validatePrepareForm(form)){
	 			return;
	 		}
	 		this.chainedServiceRedirectUrl = url;
	 		wcService.getServiceById('chainedAjaxUserRegistrationAdminAdd').setFormId(form.id);
			if(!submitRequest()){
				return;
			}			
			cursor_wait();
			wcService.invoke('chainedAjaxUserRegistrationAdminAdd');
	 	},
	 	
	 	/**
	 	 * Return URL with pre-selected Organization info.
	 	 */
	 	getChainedServiceRediretUrl: function(){
	 		var url = this.chainedServiceRedirectUrl;
	 		if (url != '' && this._parentOrgEntityId !== undefined && this._parentOrgEntityId !== null){
	 			url = url + '&orgEntityId='+ this._parentOrgEntityId + '&orgEntityName='+ this._parentOrgEntityName;
	 		}
	 		return url;
	 	}
	 	
	};
 	
//-----------------------------------------------------------------
// Licensed Materials - Property of IBM
//
// WebSphere Commerce
//
// (C) Copyright IBM Corp. 2014, 2016 All Rights Reserved.
//
// US Government Users Restricted Rights - Use, duplication or
// disclosure restricted by GSA ADP Schedule Contract with
// IBM Corp.
//-----------------------------------------------------------------


/**
 * Declares a new refresh controller for read only user details section.
 */
function declareOrganizationUserInfo_userDetail_controller() {
	var myWidgetObj = $("#OrganizationUserInfo_userDetail_Widget");
	 
	/** 
	 * Refreshes the organization users list display if a list item is updated
	 * This function is called when a modelChanged event is detected. 
	 */
	wcTopic.subscribe(["OrganizationUserInfoAdminUpdateMember_UserDetails","AjaxRESTMemberPasswordResetByAdminOnBehalfForBuyer"], function() {
		myWidgetObj.refreshWidget("refresh");
	});
	
	myWidgetObj.refreshWidget({
		/** 
		 * Clears the progress bar
		 */
		postRefreshHandler: function() {
			widgetCommonJS.removeSectionOverlay();
			cursor_clear();
			//Initialize toggle events after page refresh
			widgetCommonJS.initializeEditSectionToggleEvent();
		}
	});
};

/**
 * Declares a new refresh controller for read only user address section.
 */
function declareOrganizationUserInfo_userAddress_controller() {
	var myWidgetObj = $("#OrganizationUserInfo_userAddress_Widget");
	
	/** 
	 * Refreshes the organization users list display if a list item is updated
	 * This function is called when a modelChanged event is detected. 
	 */
	wcTopic.subscribe(["OrganizationUserInfoAdminUpdateMember_UserAddress"], function() {
		myWidgetObj.refreshWidget("refresh");
	});
	
	myWidgetObj.refreshWidget({
		/** 
		 * Clears the progress bar
		 */
		postRefreshHandler: function() {
			widgetCommonJS.removeSectionOverlay();
			cursor_clear();
			//Initialize toggle events after page refresh
			widgetCommonJS.initializeEditSectionToggleEvent();
		}
	});
};//-----------------------------------------------------------------
// Licensed Materials - Property of IBM
//
// WebSphere Commerce
//
// (C) Copyright IBM Corp. 2014, 2016 All Rights Reserved.
//
// US Government Users Restricted Rights - Use, duplication or
// disclosure restricted by GSA ADP Schedule Contract with
// IBM Corp.
//-----------------------------------------------------------------

/** 
 * @fileOverview This file provides all the functions and variables to manage buyers list and the items within.
 * This file is included in all pages with organization users list actions.
 */

/**
 * This service allows customer to create a new requisition list
 * @constructor
 */
wcService.declare({
	id:"OrganizationUsersListAdminUpdateMember",
	actionId:"OrganizationUsersListAdminUpdateMember",
	url:"AjaxRESTUserRegistrationAdminUpdate",
	formId:""

	 /**
     * Hides all the messages and the progress bar.
     * @param (object) serviceResponse The service response object, which is the
     * JSON object returned by the service invocation.
     */
	,successHandler: function(serviceResponse) {
		MessageHelper.hideAndClearMessage();
		cursor_clear();		
		MessageHelper.displayStatusMessage(MessageHelper.messages["ORGANIZATIONUSERSLIST_UPDATE_USERSTATUS_SUCCESS"]);
	}
		
	/**
     * display an error message.
     * @param (object) serviceResponse The service response object, which is the
     * JSON object returned by the service invocation.
     */
	,failureHandler: function(serviceResponse) {

		if (serviceResponse.errorMessage) {
			MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
		} 
		else {
			 if (serviceResponse.errorMessageKey) {
				MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
			 }
		}
		cursor_clear();
	}			
});

/**
 * This class defines the functions and variables that customers can use to create, update, and view their buyers list.
 * @class The OrganizationUsersListJS class defines the functions and variables that customers can use to manage their buyers list, 
 */
OrganizationUsersListJS ={		
	
	widgetShortName: "OrgUsersListWidget",
	/** 
	 * This variable stores the ID of the language that the store currently uses. Its default value is set to -1, which corresponds to United States English.
	 * @private
	 */
	langId: "-1",
	
	/** 
	 * This variable stores the ID of the current store. Its default value is empty.
	 * @private
	 */
	storeId: "",
	
	/** 
	 * This variable stores the ID of the catalog. Its default value is empty.
	 * @private
	 */
	catalogId: "",	
	
	viewUserURL: "",
	
	addUserURL: "",
	
	/**
	 * Sets the common parameters for the current page. 
	 * For example, the language ID, store ID, and catalog ID.
	 *
	 * @param {Integer} langId The ID of the language that the store currently uses.
	 * @param {Integer} storeId The ID of the current store.
	 * @param {Integer} catalogId The ID of the catalog.
	 * @param {Integer} authToken The authToken for current user to perform operation on server.
	 * @param {String} viewUserURL The URL for viewing and editing user.
	 * @param {String} addUserURL The URL for adding a user.
	 */
	setCommonParameters:function(langId,storeId,catalogId,authToken,viewUserURL,addUserURL){
		this.langId = langId;
		this.storeId = storeId;
		this.catalogId = catalogId;
		this.authToken = authToken;
		this.viewUserURL = viewUserURL;
		this.addUserURL = addUserURL;
		cursor_clear();
	},	
	
	/**
	 * Initialize the URL of Buyer List widget controller. 	 
	 *
	 * @param {object} widgetUrl The controller's URL.
	 */
	initOrganizationUsersListUrl:function(widgetUrl){
		$("#OrganizationUsersListTable_Widget").attr("refreshurl", widgetUrl);
	},
	
	/**
	 * Initial context with Organization info.
	 */
	initContextOrgEntity:function(orgEntityId, orgEntityName){
		wcRenderContext.getRenderContextProperties("OrganizationUsersListTable_Context").orgEntityId = orgEntityId;
		wcRenderContext.getRenderContextProperties("OrganizationUsersListTable_Context").orgEntityName = orgEntityName;
	},
	
	/**
	 * Search for Organization users use the search terms specified in the toolbar search form.
	 * 
	 * @param formId	The id of toolbar search form element.
	 */
	doSearch:function(formId){
		var form = $("#" + formId);
		this.updateContext({"beginIndex":"0", "userFirstName":form[0].userFirstName.value, "userLastName":form[0].userLastName.value, "userLogonId":form[0].userLogonId.value, "userRoleId":form[0].userRoleId.value, "userAccountStatus":form[0].userAccountStatus.value});
	},
	
	/**
	 * Clear the context search term value set by search form
	 */
	reset:function(){
		this.updateContext({"beginIndex":"0", "userFirstName":"", "userLastName":"", "userLogonId":"", "userRoleId":"", "userAccountStatus":""});
	},
	
	/**
	 * Save the toolbar aria-expanded attribute value
	 */
	saveToolbarStatus:function(){
		var toolbar = $("#OrganizationUsersList_toolbar");
		if (toolbar !== undefined && toolbar !== null){
			this.toolbarExpanded = toolbar.attr("aria-expanded");
		}
	},
	
	/**
	 * Restore the toolbar aria-expanded attribute, called by post refresh handler
	 */
	restoreToolbarStatus:function(){
		if (this.toolbarExpanded !== undefined && this.toolbarExpanded !== null){
			$("#OrganizationUsersList_toolbar").attr("aria-expanded", this.toolbarExpanded);
		}
	},
	
	/**
	 * Update the OrganizationUsersListTable context with given context object.
	 * 
	 * @param context The context object to update
	 */
	updateContext:function(context){
		this.saveToolbarStatus();
		if(!submitRequest()){
			return;
		}			
		cursor_wait();
		wcRenderContext.updateRenderContext("OrganizationUsersListTable_Context", context);
	},
	
	/**
	 * Update member user account status to 'Enabled' or 'Disalbed', status 0 means disabled, status 1 means enabled.
	 * 
	 * @param memberId The is of the member to be enable or disable
	 * @param status The '0' or '1' status
	 */
	updateMemberStatus:function(memberId, status){
		var params = {};
		params.URL = "StoreView"; //old command still check the presence of the 'URL' parameter
		params.storeId = this.storeId;
		params.langId = this.langId;
		params.userId = memberId;
		params.userStatus = status;
		params.authToken = this.authToken;
		this.saveToolbarStatus();
		if(!submitRequest()){
			return;
		}			
		cursor_wait();
		wcService.invoke('OrganizationUsersListAdminUpdateMember',params);
	},
	
	/**
	 * Redirect to add user detail page.
	 */
	addUser:function(){
		var orgEntityId = wcRenderContext.getRenderContextProperties("OrganizationUsersListTable_Context")['orgEntityId'];
		var orgName = wcRenderContext.getRenderContextProperties("OrganizationUsersListTable_Context")['orgEntityName'];
		//if (parentMemberId == "") parentMemberId = "7000000000000000801"; 
		var URL = this.addUserURL + "&orgEntityId=" + orgEntityId + "&orgEntityName=" + orgName;
		setPageLocation(URL);
	},
	
	/**
	 * Redirect to view user details page.
	 * 
	 * @param memberId The ID of the user
	 */
	viewDetails:function(memberId){
		var URL = this.viewUserURL + "&memberId=" + memberId;
		setPageLocation(URL);
		return false;
	},
	
	/**
	 * Update context to show page according specific number.
	 * 
	 * @param data The data for updating context.
	 */
	showPage:function(data){
		var pageNumber = data['pageNumber'];
		var pageSize = data['pageSize'];
		pageNumber = parseInt(pageNumber);
		pageSize = parseInt(pageSize);
		var beginIndex = pageSize * ( pageNumber - 1 );
		setCurrentId(data["linkId"]);
		//client has no way to change pageSize, so default pageSize defined in EnvironmentSetup.jspf will be used
		this.updateContext({"beginIndex":beginIndex});
	},
	
	/**
	* Publishes 'currentOrgIdRequest' topic.
	* Organization List widget will respond to this event and publishes the "currentOrgId" topic along with the orgId.
	* Responds to "currentOrgId" topic event by refreshing the organization summary data for the newOrgId
	*/
	publishOrgIdRequest:function(){
		var topicName = "currentOrgIdRequest";
		var scope = this;
		$(document).ready(function() {
			wcTopic.subscribe("currentOrgId", function(data){
				if(data.requestor === scope.widgetShortName){
					// The original request was from me. So respond to this event.
					scope.toolbarExpanded = "false";
					if (data.newOrgId.replace(/^\s+|\s+$/g, '') == ''){
						return;
					}
					if(!submitRequest()){
						return;
					}			
					cursor_wait();
					wcRenderContext.updateRenderContext("OrganizationUsersListTable_Context", {"beginIndex":"0", "userFirstName":"", "userLastName":"", "userLogonId":"", "userRoleId":"", "userAccountStatus":"","orgEntityId" : data.newOrgId, "orgEntityName": data.newOrgName});
				}
			});
			// Set the requestor to my widgetShortName. 
			// Respond to follow-up events, only if the event published was in response to my request. 
			// The requestor attribute in the data helps to check this.
			var data = {"requestor":scope.widgetShortName};
			wcTopic.publish(topicName, data);
		});
	},
	
	/**
	* Subscribe to 'organizationChanged' topic.
	* Organization Users List widget will respond to this topic event by refreshing the organization user list data for the newOrgId
	*/
	subscribeToOrgChange:function(data) {
		var topicName = "organizationChanged";
		var scope = this;
		$(document).ready(function() {
			wcTopic.subscribe(topicName, function(data){
				//console.debug("organizationChanged received");
				var renderContext = wcRenderContext.getRenderContextProperties("OrganizationUsersListTable_Context");
				if(renderContext["orgEntityId"] != data.newOrgId){
					scope.toolbarExpanded = "false";
					submitRequest();
					cursor_wait();
					wcRenderContext.updateRenderContext("OrganizationUsersListTable_Context", {"beginIndex":"0", "userFirstName":"", "userLastName":"", "userLogonId":"", "userRoleId":"", "userAccountStatus":"","orgEntityId" : data.newOrgId, "orgEntityName": data.newOrgName});
				}
			});
		});
	}
};//-----------------------------------------------------------------
// Licensed Materials - Property of IBM
//
// WebSphere Commerce
//
// (C) Copyright IBM Corp. 2014, 2016 All Rights Reserved.
//
// US Government Users Restricted Rights - Use, duplication or
// disclosure restricted by GSA ADP Schedule Contract with
// IBM Corp.
//-----------------------------------------------------------------


/**
 * Declares a new render context for creating a new list.
 */
wcRenderContext.declare("OrganizationUsersListTable_Context",["OrganizationUsersListTable_Widget"],{"beginIndex":"0", "userFirstName":"", "userLastName":"", "userLogonId":"", "userRoleId":"", "userAccountStatus":"", "orgEntityId":"", "OrgEntityName":""},"");

/**
 * Declares a new refresh controller for creating a new List.
 */
function declareOrganizationUsersListTable_controller() {
	var myWidgetObj = $("#OrganizationUsersListTable_Widget");
	
	var myRCProperties = wcRenderContext.getRenderContextProperties("OrganizationUsersListTable_Context");
	
	/** 
	 * Refreshes the organization users list display if a list item is updated
	 * This function is called when a modelChanged event is detected. 
	 */
	wcTopic.subscribe(["OrganizationUsersListAdminUpdateMember"], function() {
		myWidgetObj.refreshWidget("refresh", myRCProperties);
	});

	myWidgetObj.refreshWidget({
		/** 
		 * Refreshes the list table display if an item is updated.
		 * This function is called when a render context event is detected. 
		 */	
		renderContextChangedHandler: function() {
			myWidgetObj.html("");
			myWidgetObj.refreshWidget("refresh", myRCProperties);
		},
	
		/** 
		 * Clears the progress bar
		 */
		postRefreshHandler: function() {
			OrganizationUsersListJS.restoreToolbarStatus();
			cursor_clear();			 
		}
	});
};//-----------------------------------------------------------------
// Licensed Materials - Property of IBM
//
// WebSphere Commerce
//
// (C) Copyright IBM Corp. 2014 All Rights Reserved.
//
// US Government Users Restricted Rights - Use, duplication or
// disclosure restricted by GSA ADP Schedule Contract with
// IBM Corp.
//-----------------------------------------------------------------

function AddToRequisitionListsJS(storeId, catalogId, langId, dropDownMenuId, selectListMenuId, createListMenuId, listTypeMenuId, listNameFieldId, listTypeFieldId, addResultMenuId, buttonStyle, jsObjectName) {

    this.storeId = storeId;
    this.catalogId = catalogId;
    this.langId = langId;
    this.dropDownMenuId = dropDownMenuId;
    this.selectListMenuId = selectListMenuId;
    this.createListMenuId = createListMenuId;
    this.listTypeMenuId = listTypeMenuId;
    this.listNameFieldId = listNameFieldId;
    this.listTypeFieldId = listTypeFieldId;
    this.addResultMenuId = addResultMenuId;
    this.buttonStyle = buttonStyle;

    this.jsObjectName = jsObjectName;

    this.dropDownVisible = false;

    this.dropDownInFocus = false;

    this.pageName = "";
    this.params = {};

    var eventName = "";

    this.dropDownMenuId = "";
    this.createListMenuId = "";
    this.addResultMenuId = "";
    this.addSingleSKU = false;
    this.addBundle = false;
    this.addPDK = false;
    var product_id = 0;

    var quantity = 1; // One item to add to list by default
    var catEntryId = 0;

    var catEntryResolved = false;
	
	this.addDK = false;
	var configurationXML = "";
	

    /**
     * Re-initializes variables when product is successfully added to a list
     */
    this._initialize = function () {
        this.someRadioButtonChecked = false;
        this.createListDetailsMenuOpen = false;
        this.listTypeMenuOpen = false;
        this.dropDownOpen = false;
        this.addSingleSKU = false;
        this.addBundle = false;
        this.params.status = 'Y'; // Default to private list
    };

    /**
     * Setter for topic.subscribe callback
     */
    this.setQuantity = function (newQuantity) {
        if (newQuantity != '') {
            quantity = newQuantity;
        }
    };
    /**
     * Getter for topic.subscribe callback
     */
    this.getQuantity = function () {
        return quantity;
    };
    /**
     * Setter for topic.subscribe callback
     */
    this.setCatEntryId = function (newCatEntryId, newProductId) {
        if (newCatEntryId != null) {
            catEntryResolved = true;
            catEntryId = newCatEntryId;
            product_id = newProductId;
        } else {
            catEntryResolved = false;
        }

    };
    /**
     * Getter for topic.subscribe callback
     */
    this.getCatEntryId = function () {
        return catEntryId;
    };

    /**
     * Sets product ID to be added to cart
     */
    this.setProductId = function (newProductId) {
        product_id = newProductId;
    };

    /**
     * sets whether a PDK is being added to the list
     */
    this.setAddPDK = function (addpdk) {
        this.addPDK = addpdk;
    };

	/**
	 * sets whether a DK is being added to the requisition list
	 */
	this.setAddDK = function(adddk) {
		this.addDK = adddk;
	};

	/**
	 * sets the configuration xml of the DK
	 */
	this.setConfigurationXML = function(configXML) {
		this.configurationXML = configXML;
	};
	
	/**
	 * Converts xml accepted form to < >
	 * @param {String} str, String to be converted
	 * @return {String} converted string
	 */
	this.unEscapeXml =  function(str){
		return str.replace(/&lt;/gm, "<").replace(/&gt;/gm, ">").replace(/&#034;/gm,"\"");
	};
	
	
    /**
     * Hides the dropdown
     * @param dropDownId - dropdown node
     */
    this._hideDropDownMenu = function (dropDownId) {
        Utils.ifSelectorExists("#" + dropDownId, function (dropDown) {
            dropDown.css("display", "none");
            $('#grayOut').css("display", "none");
            $('#grayOutPopup').css("display", "none");

            this.dropDownVisible = false;
            this.dropDownInFocus = false;
            this.dropDownOpen = false;
        }, this);

        if (document.removeEventListener) {
            document.removeEventListener("keydown", this.trapTabKey, true);
        }
    };

    /**
     * Shows the dropdown
     * @param dropDownId - dropdown node id
     * @param resolveCatentry - if true, then catentry must be resolved before showing drop down menu
     */
    this._showDropDownMenu = function (dropDownId, resolveCatentry) {
        if (resolveCatentry && !catEntryResolved) {
            MessageHelper.displayErrorMessage(Utils.getLocalizationMessage('ERROR_SL_RESOLVED_SKU'));
            return;
        }

        Utils.ifSelectorExists("#" + dropDownId, function (dropDown) {
            dropDown.css("display", "block");
            var radioButtons = $('.radioButton', dropDown);
            if (radioButtons.length) {
                radioButtons[0].focus();
            }
            $('#grayOut').css("display", "block");
            $('#grayOutPopup').css("display", "block");

            this.dropDownVisible = true;
            this.dropDownInFocus = true;
            this.dropDownOpen = true;
            MessageHelper.hideAndClearMessage();
        }, this);

        if (document.addEventListener) {
            document.addEventListener("keydown", this.trapTabKey, true);
        }
    };

    /**
     * Hides the list of requisition lists
     */
    this._hideSelectList = function () {
        $("#" + this.selectListMenuId).css("display", "none");
    };

    /**
     * Shows the list of requisition lists
     */
    this._showSelectList = function () {
        $("#" + this.selectListMenuId).css("display", "block");
    };

    /**
     * Traps the tab key when in the popup
     * @event the key event
     */
    this.trapTabKey = function (event) {
        if (event.keyCode === KeyCodes.TAB) {
            var popup = $('.requisitionListContent.popup').toArray().find(function (a_popup) {
                return a_popup.offsetHeight !== 0;
            });

            if (popup) {
                var visibleFocusableItems = $('[tabindex$=\"0\"]', popup).toArray().filter(function (a_item) {
                    return a_item.offsetHeight !== 0; // visible
                });
                var focusedItem = document.activeElement;
                var numberOfFocusableItems = visibleFocusableItems.length;
                var focusedItemIndex = visibleFocusableItems.indexOf(focusedItem);

                if (event.shiftKey) {
                    //back tab - if focused on first item and user presses back-tab, go to the last focusable item
                    if (focusedItemIndex == 0) {
                        event.preventDefault();
                        visibleFocusableItems[numberOfFocusableItems - 1].focus();
                    }
                } else {
                    //forward tab - if focused on the last item and user presses tab, go to the first focusable item
                    if (focusedItemIndex == numberOfFocusableItems - 1) {
                        event.preventDefault();
                        visibleFocusableItems[0].focus();
                    }
                }
            }
        }
    };

    /**
     * Toggle showing the requisition list drop down
     * @param showSelectList - optionally choose whether the list of requisition lists should be affected by the toggle
     * @param resolveCatentry - optionally choose whether or not catentry needs to be resolved (defaults to true)
     * @param multipleSKUs - optionally choose whether or not we are adding multiple SKUs (e.g. from SKU list widget)
     * @param singleSkuId - optional single skuId being passed in from SKU list widget
     * @param addBundle - optionally choose whether or not we are adding a bundle
     */
    this.toggleDropDownMenu = function (showSelectList, resolveCatentry, multipleSKUs, singleSkuId, addBundle) {
        if (resolveCatentry == null) {
            resolveCatentry = true;
        }

        // Check to make sure quantity fields are populated when adding bundle
        if (addBundle) {
            for (var productId in shoppingActionsJS.productList) {
                var productDetails = shoppingActionsJS.productList[productId];
                var quantity = parseInt(productDetails.quantity);
                if (quantity == 0) {
                    continue;
                }
                if (productDetails.id == 0) {
                    MessageHelper.displayErrorMessage(Utils.getLocalizationMessage('ERR_RESOLVING_SKU'));
                    return;
                }
                if (isNaN(quantity) || quantity < 0) {
                    MessageHelper.displayErrorMessage(Utils.getLocalizationMessage('QUANTITY_INPUT_ERROR'));
                    return;
                }
            }
            this.addBundle = true;
        }

        // Check to make sure quantity fields are populated if adding multiple SKUs
        if (multipleSKUs) {
            if (product_id in SKUListJS.quantityList) {
                var length = 0;
                for (var skuId in SKUListJS.quantityList[product_id]) {
                    var quantity = SKUListJS.quantityList[product_id][skuId];
                    if (!isPositiveInteger(quantity)) {
                        MessageHelper.displayErrorMessage(Utils.getLocalizationMessage('QUANTITY_INPUTS_ERROR'));
                        return;
                    }
                    length++;
                }
                if (length == 0) {
                    MessageHelper.displayErrorMessage(Utils.getLocalizationMessage('QUANTITY_INPUTS_ERROR'));
                    return;
                }
            } else {
                MessageHelper.displayErrorMessage(Utils.getLocalizationMessage('QUANTITY_INPUTS_ERROR'));
                return;
            }
        }

        // Check to make sure quantity field is populated when adding single SKU from SKU List widget
        if (singleSkuId) {
            var quantity = $("#" + singleSkuId + "_Mobile_Quantity_Input").val();
            if (!isPositiveInteger(quantity)) {
                MessageHelper.displayErrorMessage(Utils.getLocalizationMessage('QUANTITY_INPUT_ERROR'));
                return;
            }

            this.setQuantity(quantity);
            this.addSingleSKU = true;
        }

        if (this.dropDownOpen == false) {
            this._showDropDownMenu(dropDownMenuId, resolveCatentry);
        } else {
            this._hideDropDownMenu(dropDownMenuId);
        }
        if (showSelectList == false) {
            this._hideSelectList();
        } else {
            this._showSelectList();
        }
    };

    /**
     * Check a radio button
     * @param nodeToCheck - the radio button to check
     * @param listId - list's ID
     * @param radiovalue - list's name
     */
    this.checkRadioButton = function (nodeToCheck, listId, radioValue) {
        if (nodeToCheck) {
            $(".checked", "#" + dropDownMenuId).css("display", "none");
            $(".checked", nodeToCheck).css("display", "block");
            $(".radioButton", "#" + dropDownMenuId).attr("aria-checked", "false");
            $(nodeToCheck).attr("aria-checked", "true");
            if (radioValue !== undefined) {
                this.params.name = radioValue.replace(/&#039;/gm, "'");
            }
            this.params.requisitionListId = listId;
            this.someRadioButtonChecked = true;
        }
    };

    /**
     * Toggle showing the create list menu
     * @param state - state of the menu.  True = shown, false = hidden
     */
    this.toggleCreateListDetailsMenu = function (state) {
        // Only toggle the menu when the requested state is different from the current state
        if (this.createListDetailsMenuOpen == true && state == false) {
            $("#" + createListMenuId).css("display", "none");
            this.createListDetailsMenuOpen = false;
            $("#" + this.pageName + "scrollContainer").scrollTop($("#" + this.pageName + "scrollContainer")[0].scrollHeight);
        } else if (this.createListDetailsMenuOpen == false && state == true) {
            $("#" + createListMenuId).css("display", "block");
            this.createListDetailsMenuOpen = true;
            $("#" + this.pageName + "scrollContainer").scrollTop($("#" + this.pageName + "scrollContainer")[0].scrollHeight);
        }
    };

    /**
     * Handles a keyboard event on the list type menu
     */
    this.handleKeyEventListTypeMenu = function (event) {
        switch (event.keyCode) {
            case KeyCodes.UP_ARROW:
                event.preventDefault();
                if (this.params.status == 'Z') {
                    this.setListType('Y');
                }
                break;
            case KeyCodes.DOWN_ARROW:
                event.preventDefault();
                if (this.params.status == 'Y') {
                    this.setListType('Z');
                }
                break;
        }
    };

    /**
     * Toggle showing the list type menu when creating a new list
     */
    this.toggleListTypeMenu = function () {
        if (this.listTypeMenuOpen == true) {
            $("#" + listTypeMenuId).css("display", "none");
            this.listTypeMenuOpen = false;
            $("#" + this.pageName + "scrollContainer").scrollTop($("#" + this.pageName + "scrollContainer")[0].scrollHeight);
        } else {
            $("#" + listTypeMenuId).css("display", "block");
            this.listTypeMenuOpen = true;
            $("#" + this.pageName + "scrollContainer").scrollTop($("#" + this.pageName + "scrollContainer")[0].scrollHeight);
        }
    };

    /**
     * Set the type of list for the newly created list
     * @param listTypeToSet - 'Y' for private, 'Z' for shared/public
     */
    this.setListType = function (listTypeToSet) {
        if (this.params.status != listTypeToSet) {
            $("#" + listTypeFieldId + this.params.status).css("display", "none");
            this.params.status = listTypeToSet;
            $("#" + listTypeFieldId + this.params.status).css("display", "block");
            $("#" + this.pageName + "scrollContainer").scrollTop($("#" + this.pageName + "scrollContainer")[0].scrollHeight);
        }
    };


    /**
     * addSkus2RequisitionListAjax This function is used to add one or more SKUs to a requisition list using an AJAX call.
     **/
    this.addSkus2RequisitionListAjax = function () {
        if (this.someRadioButtonChecked == true) {
            params = {
                storeId: this.storeId,
                catalogId: this.catalogId,
                langId: this.langId,
                pageName: this.pageName,
                buttonStyle: this.buttonStyle,
                productId: product_id,
                name: this.params.name,
                status: this.params.status,
                requisitionListId: this.params.requisitionListId,
                addBundle: this.addBundle,
                addMultipleSKUs: 'true'
            };

            if (this.addSingleSKU) {
                var quantity = $("#" + catEntryId + "_Mobile_Quantity_Input").val();
                if (!isPositiveInteger(quantity)) {
                    MessageHelper.displayErrorMessage(Utils.getLocalizationMessage('QUANTITY_INPUT_ERROR'));
                    return;
                }

                params["catEntryId_1"] = catEntryId;
                params["quantity_1"] = quantity;
            } else if (this.addBundle) {
                var i = 1;
                for (var prodId in shoppingActionsJS.productList) {
                    var productDetails = shoppingActionsJS.productList[prodId];
                    var quantity = parseInt(productDetails.quantity);
                    if (quantity == 0) {
                        continue;
                    }
                    if (productDetails.id == 0) {
                        MessageHelper.displayErrorMessage(Utils.getLocalizationMessage('ERR_RESOLVING_SKU'));
                        return;
                    }
                    if (isNaN(quantity) || quantity < 0) {
                        MessageHelper.displayErrorMessage(Utils.getLocalizationMessage('QUANTITY_INPUT_ERROR'));
                        return;
                    }

                    params["catEntryId_" + i] = productDetails.id;
                    params["quantity_" + i] = quantity;
                    params["productId_" + i++] = prodId;
                }
            } else {
                //Get all of the SKUs and their quantities and pass in as parameters (e.g. catEntryId_1, quantity_1, catEntryId_2, quantity_2)
                if (product_id in SKUListJS.quantityList) {
                    var i = 1;
                    for (var skuId in SKUListJS.quantityList[product_id]) {
                        var quantity = SKUListJS.quantityList[product_id][skuId];
                        if (!isPositiveInteger(quantity)) {
                            MessageHelper.displayErrorMessage(Utils.getLocalizationMessage('QUANTITY_INPUTS_ERROR'));
                            return;
                        }
                        params["catEntryId_" + i] = skuId;
                        params["quantity_" + i++] = quantity;
                    }
                }
            }


            if (params.catEntryId_1 == null || params.quantity_1 == null) {
                MessageHelper.displayErrorMessage(Utils.getLocalizationMessage('QUANTITY_INPUTS_ERROR'));
                return;
            }

            //For Handling multiple clicks
            if (!submitRequest()) {
                return;
            }
            cursor_wait();

            if (this.createListDetailsMenuOpen) {
                params.name = $("#" + this.listNameFieldId).val().replace(/^\s+|\s+$/g, '');
                if (params.name == "") {
                    MessageHelper.displayErrorMessage(Utils.getLocalizationMessage('ERROR_SL_EMPTY_SL_NAME'));
                    return;
                }
            }
            wcService.invoke('addCatalogEntriesToCreateRequisitionList', params);
        } else {
            MessageHelper.displayErrorMessage(Utils.getLocalizationMessage('ERROR_SL_LIST_NOT_CHOSEN'));
            return;
        }
    };

    /**
     * addOrderToRequisitionList This function is used to add an order to a requisition list.
     * @param {String} orderId the order Id being added to cart 	
     **/
    this.addOrderToRequisitionList = function () {
        if (this.someRadioButtonChecked == true) {
            params = {
                storeId: this.storeId,
                catalogId: this.catalogId,
                langId: this.langId,
                pageName: this.pageName,
                buttonStyle: this.buttonStyle,
                productId: product_id,
                name: this.params.name,
                status: this.params.status,
                requisitionListId: this.params.requisitionListId,
                addSavedOrder: 'true'
            };

            //Get all of the catEntryIds and their quantities and pass in as parameters (e.g. catEntryId_1, quantity_1, catEntryId_2, quantity_2)
            if (OrderListJS.quantityList != {}) {
                var i = 1;
                for (var orderId in OrderListJS.quantityList) {
                    for (var catEntryId in OrderListJS.quantityList[orderId]) {
                        var quantity = OrderListJS.quantityList[orderId][catEntryId];

                        params["catEntryId_" + i] = catEntryId;
                        params["quantity_" + i] = quantity;
                        i++;
                    }
                }
            }

            if (params.catEntryId_1 == null || params.quantity_1 == null) {
                MessageHelper.displayErrorMessage(Utils.getLocalizationMessage('MYACCOUNT_SAVEDORDERLIST_EMPTY_ADD_TO_REQ_FAIL'));
                return;
            }

            //For Handling multiple clicks
            if (!submitRequest()) {
                return;
            }
            cursor_wait();

            if (this.createListDetailsMenuOpen) {
                params.name = $("#" + this.listNameFieldId).val().replace(/^\s+|\s+$/g, '');
                if (params.name == "") {
                    MessageHelper.displayErrorMessage(Utils.getLocalizationMessage('ERROR_SL_EMPTY_SL_NAME'));
                    return;
                }
            }
            wcService.invoke('addOrderToCreateRequisitionList', params);
        } else {
            MessageHelper.displayErrorMessage(Utils.getLocalizationMessage('ERROR_SL_LIST_NOT_CHOSEN'));
            return;
        }
    };

    /**
     * Add the product to a specific or new list
     */
    this.addToList = function () {
        if (this.someRadioButtonChecked == true) {
            params = {
                storeId: this.storeId,
                catalogId: this.catalogId,
                langId: this.langId,
                catEntryId: catEntryId,
                productId: product_id,
                pageName: this.pageName,
                buttonStyle: this.buttonStyle,
                name: this.params.name,
                status: this.params.status,
                requisitionListId: this.params.requisitionListId,
                quantity: quantity
            };
            if (quantity < 1) {
                MessageHelper.displayErrorMessage(Utils.getLocalizationMessage('QUANTITY_INPUT_ERROR'));
                return;
            }
            if (!submitRequest()) {
                return;
            }
            cursor_wait();
            if (this.createListDetailsMenuOpen) {
                params.name = $("#" + this.listNameFieldId).val().replace(/^\s+|\s+$/g, '');
                if (params.name == "") {
                    MessageHelper.displayErrorMessage(Utils.getLocalizationMessage('ERROR_SL_EMPTY_SL_NAME'));
                    return;
                }
            }
            if (this.addPDK) {
                wcService.getServiceById("addToCreateRequisitionList").setUrl(getAbsoluteURL() + "AjaxRESTRequisitionListConfigurationAdd");
            }
            wcService.invoke('addToCreateRequisitionList', params);
        } else {
            MessageHelper.displayErrorMessage(Utils.getLocalizationMessage('ERROR_SL_LIST_NOT_CHOSEN'));
            return;
        }
    };

    /**
     * Add the product to a specific or new list
     */
    this.moveToList = function (requisitionOrderItemId) {
        if (this.someRadioButtonChecked == true) {
            params = {
                storeId: this.storeId,
                catalogId: this.catalogId,
                langId: this.langId,
                catEntryId: catEntryId,
                productId: product_id,
                pageName: this.pageName,
                buttonStyle: this.buttonStyle,
                name: this.params.name,
                status: this.params.status,
                requisitionListId: this.params.requisitionListId,
                requisitionOrderItemId: requisitionOrderItemId,
                quantity: quantity
            };
            if (quantity < 1) {
                MessageHelper.displayErrorMessage(Utils.getLocalizationMessage('QUANTITY_INPUT_ERROR'));
                return;
            }
            if (!submitRequest()) {
                return;
            }
            cursor_wait();
            if (this.createListDetailsMenuOpen) {
                params.name = $("#" + this.listNameFieldId).val().replace(/^\s+|\s+$/g, '');
                if (params.name == "") {
                    MessageHelper.displayErrorMessage(Utils.getLocalizationMessage('ERROR_SL_EMPTY_SL_NAME'));
                    return;
                }
            }
			if (this.addPDK || this.addDK) {
				if (this.addDK){
					params.configurationXML = this.unEscapeXml( this.configurationXML);
				}
				wcService.getServiceById("addToCreateRequisitionListAndDeleteFromCart").setUrl(getAbsoluteURL() + "AjaxRESTRequisitionListConfigurationAdd");
			}
            wcService.invoke('addToCreateRequisitionListAndDeleteFromCart', params);
        } else {
            MessageHelper.displayErrorMessage(Utils.getLocalizationMessage('ERROR_SL_LIST_NOT_CHOSEN'));
            return;
        }
    };

    /**
     * Hide and reset widget after successfully adding an item to a list
     */
    this.continueShopping = function () {
        Utils.ifSelectorExists("#" + addResultMenuId, function ($addResultMenu) {
            $addResultMenu.css("display", "none");
            this.toggleDropDownMenu(true);
            this._initialize();

            if (document.removeEventListener) {
                document.removeEventListener("keydown", this.trapTabKey, true);
            }

            $("#" + this.pageName + "addToShoppingListBtn").focus();
        }, this);
    };

    /**
     * Service declaration to add a catalog entry to a requisition list.  List is created if it does not exist.
     */
    wcService.declare({
        id: "addToCreateRequisitionList",
        actionId: "addToCreateRequisitionList",
        url: getAbsoluteURL() + "AjaxRequisitionListUpdateItem",
        formId: "",

        successHandler: function (serviceResponse) {
            MessageHelper.hideAndClearMessage();
            cursor_clear();

            var productName = "";
            // Get the product or SKU name
            if ($("#ProductInfoName_" + serviceResponse.productId).length) {
                productName = $("#" + "ProductInfoName_" + serviceResponse.productId).val();
            } else if ($("#ProductInfoName_" + catEntryId).length) {
                productName = $("#" + "ProductInfoName_" + catEntryId).val();
            }

            var productThumbnail = "";
            // Get the product's image or SKU image
            if ($("#ProductInfoImage_" + serviceResponse.productId).length) {
                productThumbnail = $("#" + "ProductInfoImage_" + serviceResponse.productId).val();
            } else if ($("#ProductInfoImage_" + catEntryId).length) {
                productThumbnail = $("#" + "ProductInfoImage_" + catEntryId).val();
            }

            // Refresh the widget's refresh area and show item was added to a list
            wcRenderContext.updateRenderContext("requisitionLists_content_context", {
                "showSuccess": "true",
                "listName": serviceResponse.name,
                "productName": productName,
                "productThumbnail": productThumbnail,
                "storeId": serviceResponse.storeId,
                "buttonStyle": serviceResponse.buttonStyle,
                "parentPage": serviceResponse.pageName,
                "productId": serviceResponse.productId
            });

            // Keep polling until the continue shopping button is visible after AJAX update, then focus on it
            var poll = window.setInterval(function () {
                Utils.ifSelectorExists("#" + serviceResponse.pageName + "requisitionListsContShopButton", function ($contShopButton) {
                    if ($contShopButton.get(0).offsetHeight !== 0) {
                        window.clearInterval(poll);
                        $contShopButton.focus();
                        if (document.addEventListener) {
                            document.addEventListener("keydown", this.trapTabKey, true);
                        }
                    }
                }, this);
            }, 100);
        },

        failureHandler: function (serviceResponse) {
            if (serviceResponse.errorMessage) {
                MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
            } else {
                if (serviceResponse.errorMessageKey) {
                    MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
                }
            }
            cursor_clear();
        }
    });

    /**
     * Service declaration to add a catalog entry to a requisition list.  List is created if it does not exist.
     */
    wcService.declare({
        id: "addToCreateRequisitionListAndDeleteFromCart",
        actionId: "addToCreateRequisitionListAndDeleteFromCart",
        url: getAbsoluteURL() + "AjaxRESTRequisitionListUpdateItem",
        formId: "",

        successHandler: function (serviceResponse) {
            MessageHelper.hideAndClearMessage();
            cursor_clear();

            var productName = "";
            // Get the product or SKU name
            if ($("#catalogEntry_name_" + serviceResponse.requisitionOrderItemId).length) {
                productName = $("#" + "catalogEntry_name_" + serviceResponse.requisitionOrderItemId).html();
            }

            var productThumbnail = "";
            // Get the product's image or SKU image
            if ($("#catalogEntry_img_" + serviceResponse.requisitionOrderItemId).length) {
                productThumbnail = document.getElementById("catalogEntry_img_" + serviceResponse.requisitionOrderItemId).childNodes[1].src;
            }

            // Refresh the widget's refresh area and show item was added to a list
            wcRenderContext.updateRenderContext("requisitionLists_content_context", {
                "showSuccess": "true",
                "listName": serviceResponse.name,
                "productName": productName,
                "productThumbnail": productThumbnail,
                "storeId": serviceResponse.storeId,
                "buttonStyle": serviceResponse.buttonStyle,
                "parentPage": serviceResponse.pageName
            });

            CheckoutHelperJS.deleteFromCart(serviceResponse.requisitionOrderItemId);

            // Keep polling until the continue shopping button is visible after AJAX update, then focus on it
            var poll = window.setInterval(function () {
                Utils.ifSelectorExists("#" + serviceResponse.pageName + "requisitionListsContShopButton", function ($contShopButton) {
                    if ($contShopButton.get(0).offsetHeight != 0) {
                        window.clearInterval(poll);
                        $contShopButton.focus();
                        if (document.addEventListener) {
                            document.addEventListener("keydown", this.trapTabKey, true);
                        }
                    }
                });
            }, 100);

            // Remove the grayOut.  User does not have chance to cancel gray out themselves when catentry is deleted from the cart 
            $("#grayOut").css("display", "none");
            $("#grayOutPopup").css("display", "none");
        },

        failureHandler: function (serviceResponse) {
            if (serviceResponse.errorMessage) {
                MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
            } else if (serviceResponse.errorMessageKey) {
                MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
            }
            cursor_clear();
        }
    });

    /**
     * Service declaration to add multiple catalog entries to a requisition list.  List is created if it does not exist.
     */
    wcService.declare({
        id: "addCatalogEntriesToCreateRequisitionList",
        actionId: "addCatalogEntriesToCreateRequisitionList",
        url: getAbsoluteURL() + "AjaxRESTRequisitionListUpdateItem",
        formId: "",

        successHandler: function (serviceResponse) {
            MessageHelper.hideAndClearMessage();
            cursor_clear();

            var productName = [];
            var productThumbnail = [];
            var productSKU = [];

            // Get the SKU name and thumbnail urls
            for (var i = 1;
                ("catEntryId_" + i) in serviceResponse; i++) {
                var catEntryId = serviceResponse["catEntryId_" + i];
                var productId = serviceResponse["productId_" + i]; //Used when adding bundle

                var catEntryName = Utils.selectExistingElement(["#item_name_" + catEntryId, "#ProductInfoName_" + productId]);
                if (catEntryName) {
                    productName.push(catEntryName.val());
                    Utils.ifSelectorExists("#item_sku_" + catEntryId, function (catEntrySKU) {
                        productSKU.push("(" + catEntrySKU.val() + ")");
                    });
                }

                var catEntryThumbnail = Utils.selectExistingElement(["#item_thumbnail_" + catEntryId, "#ProductInfoImage_" + catEntryId]);
                if (catEntryThumbnail) {
                    productThumbnail.push(catEntryThumbnail.val());
                } else { //Get the thumbnail image from the JSON in the HTML in the bundle case
                    Utils.ifSelectorExists("#entitledItem_" + productId, function (element) {
                        var entitledItemJSON = JSON.parse(element.html());
                        for (var j in entitledItemJSON) {
                            var entitledItem = entitledItemJSON[j];
                            if (entitledItem.catentry_id == catEntryId) {
                                if (entitledItem.ItemThumbnailImage != null) {
                                    productThumbnail.push(entitledItem.ItemThumbnailImage);
                                    break;
                                }
                            }
                        }
                    });
                }
            }

            var type = "";
            if (serviceResponse.addBundle) {
                type = 'bundle';
            }

            // Refresh the widget's refresh area and show item was added to a list
            wcRenderContext.updateRenderContext("requisitionLists_content_context", {
                "showSuccess": "true",
                "listName": serviceResponse.name,
                "productName": productName,
                "productThumbnail": productThumbnail,
                "productSKU": productSKU,
                "storeId": serviceResponse.storeId,
                "buttonStyle": serviceResponse.buttonStyle,
                "parentPage": serviceResponse.pageName,
                "productId": serviceResponse.productId,
                "addMultipleSKUs": serviceResponse.addMultipleSKUs,
                "numberOfSKUs": i - 1,
                "type": type
            });

            // Keep polling until the continue shopping button is visible after AJAX update, then focus on it
            var poll = window.setInterval(function () {
                Utils.ifSelectorExists("#" + serviceResponse.pageName + "requisitionListsContShopButton", function ($contShopButton) {
                    if ($contShopButton.get(0).offsetHeight !== 0) {
                        window.clearInterval(poll);
                        $contShopButton.focus();
                        if (document.addEventListener) {
                            document.addEventListener("keydown", this.trapTabKey, true);
                        }
                    }
                }, this);
            }, 100);

            wcTopic.publish('SKUsAddedToReqList');
        },

        failureHandler: function (serviceResponse) {
            if (serviceResponse.errorMessage) {
                MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
            } else {
                if (serviceResponse.errorMessageKey) {
                    MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
                }
            }
            cursor_clear();
        }
    });

    /**
     * Service declaration to add saved order to a requisition list.  List is created if it does not exist.
     */
    wcService.declare({
        id: "addOrderToCreateRequisitionList",
        actionId: "addOrderToCreateRequisitionList",
        url: getAbsoluteURL() + "AjaxRESTRequisitionListUpdateItem",
        formId: "",

        successHandler: function (serviceResponse) {
            MessageHelper.hideAndClearMessage();
            cursor_clear();

            // Refresh the widget's refresh area and show item was added to a list
            wcRenderContext.updateRenderContext("requisitionLists_content_context", {
                "showSuccess": "true",
                "listName": serviceResponse.name,
                "storeId": serviceResponse.storeId,
                "buttonStyle": serviceResponse.buttonStyle,
                "parentPage": serviceResponse.pageName,
                "productID": serviceResponse.productId,
                "addSavedOrder": serviceResponse.addSavedOrder,
                "orderId": serviceResponse.orderId
            });

            // Keep polling until the continue shopping button is visible after AJAX update, then focus on it
            var poll = window.setInterval($.proxy(function () {
                Utils.ifSelectorExists("#" + serviceResponse.pageName + "requisitionListsContShopButton", function ($contShopButton) {
                    if ($contShopButton.get(0).offsetHeight != 0) {
                        window.clearInterval(poll);
                        $contShopButton.focus();
                        if (document.addEventListener) {
                            document.addEventListener("keydown", this.trapTabKey, true);
                        }
                    }
                }, this);
            }, this), 100);
        },

        failureHandler: function (serviceResponse) {
            if (serviceResponse.errorMessage) {
                MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
            } else {
                if (serviceResponse.errorMessageKey) {
                    MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
                }
            }
            cursor_clear();
        }
    });

    if (jsObjectName != 'AddToRequisitionListJS') {
        this.pageName = jsObjectName.replace('AddToRequisitionListsJS', '');
    };
    this._initialize();
}

/**
* Declares a new refresh controller
for Add To Requisition List display.*/
var declareRequsitionListsContentController = function (widgetPrefix) {
    if (!wcRenderContext.checkIdDefined("requisitionLists_content_context")) {
        wcRenderContext.declare("requisitionLists_content_context", [], {
            "showSuccess": "false"
        });
    }
    var myWidgetObj = $("#" + widgetPrefix + "requisitionlists_content_widget");
    wcRenderContext.addRefreshAreaId("requisitionLists_content_context", widgetPrefix + "requisitionlists_content_widget");
    var myRCProperties = wcRenderContext.getRenderContextProperties("requisitionLists_content_context");


    /**
     * Declares a new render context for the Requisition List display.
     */
    var renderContextChangedHandler = function () {
            var widgetId = myRCProperties["parentPage"] + "requisitionlists_content_widget";
            if (widgetId === myWidgetObj.attr("id")) {
                // Only refresh the widget associated with parentPage
                myWidgetObj.refreshWidget("refresh", myRCProperties);
            };

        },



        postRefreshHandler = function () {
            MessageHelper.hideAndClearMessage();
            cursor_clear();
        }
    myWidgetObj.refreshWidget({
        renderContextChangedHandler: renderContextChangedHandler,
        postRefreshHandler: postRefreshHandler
    });
};
//-----------------------------------------------------------------
// Licensed Materials - Property of IBM
//
// WebSphere Commerce
//
// (C) Copyright IBM Corp. 2011, 2015 All Rights Reserved.
//
// US Government Users Restricted Rights - Use, duplication or
// disclosure restricted by GSA ADP Schedule Contract with
// IBM Corp.
//-----------------------------------------------------------------



/** 
 * @fileOverview This javascript provides the variables and methods to manipulate the product images, and for switching 
 * the tabs used on the product pages.
 * @version 1.5
 */
			
			/** This variable stores the identifier of the image currently used for a product */
			var currentAngleImgId="productAngleProdLi0";

			function changeThumbNail(angleImgId,imgsrc){
					if (currentAngleImgId != "") {
						if(document.getElementById(currentAngleImgId) != null){
							document.getElementById(currentAngleImgId).className ='';
						}
					}
					currentAngleImgId = angleImgId;
					document.getElementById(angleImgId).className ='selected';
					document.getElementById("productMainImage").src = imgsrc;
			}//-----------------------------------------------------------------
// Licensed Materials - Property of IBM
//
// WebSphere Commerce
//
// (C) Copyright IBM Corp. 2011, 2014 All Rights Reserved.
//
// US Government Users Restricted Rights - Use, duplication or
// disclosure restricted by GSA ADP Schedule Contract with
// IBM Corp.
//-----------------------------------------------------------------

/**
 * Function to create javascript object InventoryStatusJS
 *
 * @param {Object} storeParams params specific to a store
 * @param {Object} catEntryParams params specific to base Item
 * @param {Array} physicalStores inventory details specific to physical store
 * 
 **/
function InventoryStatusJS(storeParams, catEntryParams, physicalStores, productId) {
    this.storeParams = storeParams;
    this.catEntryParams = catEntryParams;
    this.physicalStores = physicalStores;
    this.productId = productId;
    this.isFetchInventoryStatus = false;
    this.itemId = -1;

    /**
     * Setter for itemId
     * 
     * @param Integer catEntryId
     * @param Integer productId
     */
    this.setCatEntry = function (catEntryId, productId) {
        // if it is ItemBean, no need to set the attributes, since it is not required to resolve SKU
        if (this.catEntryParams.type != "ItemBean") {

            // hiding the availability section
            $("#InventoryStatus_Availability_Section_" + this.productId).css("display", "none");

            // showing the show availability link
            $("#InventoryStatus_ShowLink_Section_" + this.productId).css("display", "block");

            // If we are able to resolve the sku, then show the inventory status 
            if (catEntryId != -1) {
                this.itemId = catEntryId;
                this.checkAvailability(this.isFetchInventoryStatus);
                this.isFetchInventoryStatus = false;
            }
        }
    };

    /**
     * Restores the Inventory Availability section to the initial state if no SKU is resolved
     * 
     * @param Integer catEntryId
     * @param Integer productId
     */
    this.restoreDefaultState = function (catEntryId, productId) {
        if (catEntryId == null) {
            // hiding the availability section
            $("#InventoryStatus_Availability_Section_" + this.productId).css("display", "none");

            // showing the show availability link
            $("#InventoryStatus_ShowLink_Section_" + this.productId).css("display", "block");
        }
    };

    /**
     * After resolving the SKU for a product, checks the inventory status online 
     * and in the stores selected by the user 
     */
    this.checkAvailability = function (allowParallelCall) {
        MessageHelper.hideAndClearMessage();

        var params = this.setCommonParams();
        if (-1 == this.itemId) {
            MessageHelper.displayErrorMessage(storeNLS['ERR_RESOLVING_SKU']);
            return;
        }
        params.itemId = this.itemId;

        // hiding the show availability link
        $("#InventoryStatus_ShowLink_Section_" + this.productId).css("display", "none");

        setCurrentId('progressbar_' + this.productId);
        // if the call is during the page load, allow parallel calls, since there may be other ajax calls in progress
        if (!allowParallelCall) {
            // For Handling multiple clicks.
            if (!submitRequest()) {
                return;
            }
        }

        cursor_wait();
        wcService.invoke("getInventoryStatus_" + this.productId, params);
    };

    /**
     * Populate the contents of the inventory details section in the product display page with the JSON returned 
     * from the server. This is the callback function that is called after the AJAX call to get the inventory 
     * details successfully returns to the client.
     * 
     * @param {object} serviceRepsonse The JSON response from the service.
     * @param {object} ioArgs The arguments from the service call.
     */
    this.populateInvDetails = function (serviceResponse, ioArgs) {
        if (serviceResponse.onlineInventory) {
            // setting the online inventory status
            $("#InventoryStatus_OnlineStatus_Img_" + this.productId).replaceWith("<img id='InventoryStatus_OnlineStatus_Img_" + this.productId + "' src='" + imageDirectoryPath + styleDirectoryPath + serviceResponse.onlineInventory.image + "' alt='' border='0' />");
            $("#InventoryStatus_OnlineStatus_" + this.productId).text(serviceResponse.onlineInventory.status);

            // removing the in store section if present
            $("#InventoryStatus_InStore_Section_" + this.productId).detach();

            // check if the physical store section is present
            if ($("#InventoryStatus_InStore_Heading_" + this.productId).length) {
                // adding the empty store section
                $("#InventoryStatus_InStore_Heading_" + this.productId).after("<div id='InventoryStatus_InStore_Section_" + this.productId + "' class='sublist'>");

                this.physicalStores = serviceResponse.inStoreInventory.stores;
                // adding the store inventory details as child elements in the store section
                for (idx = 0; idx < serviceResponse.inStoreInventory.stores.length; idx++) {
                    var store = serviceResponse.inStoreInventory.stores[idx];

                    // adding the store name
                    $("#InventoryStatus_InStore_Section_" + this.productId).append("<a id='WC_InventoryStatus_Link_" + this.productId + "_store_" + (idx + 1) + "' href='javascript:InventoryStatusJS_" + this.productId + ".fetchStoreDetails(" + store.id + ");' class='store_name'>" + store.name + "</a>");
                    // adding clear div
                    $("#InventoryStatus_InStore_Section_" + this.productId).append("<div class='clear_float'></div>");
                    // adding the image status of store name
                    $("#InventoryStatus_InStore_Section_" + this.productId).append("<span> <img src='" + imageDirectoryPath + styleDirectoryPath + store.image + "' alt='" + store.altText + "' /> </span>");
                    // adding the text status of store name
                    $("#InventoryStatus_InStore_Section_" + this.productId).append("<span class='text'>" + store.statusText + "</span>");
                    // adding clear div
                    $("#InventoryStatus_InStore_Section_" + this.productId).append("<div class='clear_float'></div>");
                    // adding spacer
                    $("#InventoryStatus_InStore_Section_" + this.productId).append("<div class='item_spacer_10px'></div>");
                }
                // add select store link
                $("#InventoryStatus_SelectStoreLink_" + this.productId).text(serviceResponse.inStoreInventory.checkStoreText);
            }

            // showing the availability section
            $("#InventoryStatus_Availability_Section_" + this.productId).css("display", "block");
        } else {
            MessageHelper.displayErrorMessage(storeNLS["INV_STATUS_RETRIEVAL_ERROR"]);
        }
        cursor_clear();
    };

    /**
     * This resolves the product SKUs to a single item by comparing the attributes selected by the user
     * 
     * @return {Integer} uniqueId, of the selected SKU.
     * 					 -1, if no match found
     */
    this.resolveSKU = function () {
        for (idx = 0; idx < this.catEntryParams.skus.length; idx++) {
            var matches = 0;
            var attributeCount = 0;
            for (attribute in this.catEntryParams.skus[idx].attributes) {
                attributeCount++;
                if (this.catEntryParams.attributes && this.catEntryParams.skus[idx].attributes[attribute] == this.catEntryParams.attributes[attribute]) {
                    matches++;
                } else {
                    break;
                }
            }
            if (matches == attributeCount) {
                return this.catEntryParams.skus[idx].id;
            }
        }
        return -1;
    };

    /**
     * Sets the store specific values such as storeId, catalogId and langId
     * to the params object and returns it
     * 
     * @return {Object} params with store specific values
     */
    this.setCommonParams = function () {
        var params = new Object();
        params.storeId = this.storeParams.storeId;
        params.catalogId = this.storeParams.catalogId;
        params.langId = this.storeParams.langId;
        return params;
    };

    /**
     * Show Store details popup after fetching the required details
     */
    this.fetchStoreDetails = function (storeId) {
        MessageHelper.hideAndClearMessage();

        var params = new Object();
        params.physicalStoreId = storeId;

        // For Handling multiple clicks.
        if (!submitRequest()) {
            return;
        }
        cursor_wait();
        wcService.invoke("getPhysicalStoreDetails_" + this.productId, params);
    };

    /**
     * Populate the contents of the store details section in the product display page with the JSON returned 
     * from the server. This is the callback function that is called after the AJAX call to get the inventory 
     * details successfully returns to the client.
     * 
     * @param {object} serviceRepsonse The JSON response from the service.
     * @param {object} ioArgs The arguments from the service call.
     */
    this.populateStoreDetails = function (serviceResponse, ioArgs) {
        var store = serviceResponse;

        // set unescaped working hours
        store.hours = this.unEscapeXml(serviceResponse.hours);

        // set inventory status
        var storeInventory = this.fetchInventoryStatus(ioArgs.physicalStoreId);

        // set store availability details
        store.imageTag = "<img src='" + imageDirectoryPath + styleDirectoryPath + storeInventory.image + "' alt='" + storeInventory.altText + "'/>";
        store.statusText = storeInventory.statusText;

        if (storeInventory.status == 'Available') {
            store.availabilityDetails = "(" + storeInventory.availableQuantity + ")"; // adding the available quantity
        } else if (storeInventory.status == 'Backorderable') {
            store.availabilityDetails = "(" + storeInventory.availableDate + ")"; // adding the available date
        } else {
            store.availabilityDetails = "";
        }
        var storeDetails = $("#Store_Details_Template_" + this.productId).html();
        $("#Store_Details_" + this.productId).html(Utils.substituteStringWithObj(storeDetails, store));

        // Display store details
        var popup = $("#InventoryStatus_Store_Details_" + this.productId).data("wc-WCDialog");
        if (popup) {
            closeAllDialogs(); //close other dialogs(quickinfo dialog, etc) before opening this. 				
            popup.open();
        } else {
            console.debug("InventoryStatus_Store_Details_" + this.productId + " does not exist");
        }
        cursor_clear();
    };

    /**
     * 
     */
    this.fetchInventoryStatus = function (storeId) {
        for (idx = 0; idx < this.physicalStores.length; idx++) {
            if (this.physicalStores[idx].id == storeId) {
                return this.physicalStores[idx];
            }
        }
        return {};
    };

    /**
     * Converts xml accepted form to < >
     * 
     * @param {String} str, String to be converted
     * 
     * @return {String} converted string
     */
    this.unEscapeXml = function (str) {
        var str = str.replace(/&lt;/gm, "<").replace(/&gt;/gm, ">");
        return str;
    };

    this.loadStoreLocator = function (storeLocatorUrl, bundleId) {
        var catalogEntryId = bundleId;
        if (null == catalogEntryId || '' == catalogEntryId) {
            catalogEntryId = this.itemId;
            if (-1 == catalogEntryId) {
                catalogEntryId = productId;
            }
        }
        loadLink(storeLocatorUrl + "&productId=" + catalogEntryId);
    }
}
//-----------------------------------------------------------------
// Licensed Materials - Property of IBM
//
// WebSphere Commerce
//
// (C) Copyright IBM Corp. 2011, 2014 All Rights Reserved.
//
// US Government Users Restricted Rights - Use, duplication or
// disclosure restricted by GSA ADP Schedule Contract with
// IBM Corp.
//-----------------------------------------------------------------

if (typeof (MerchandisingAssociationJS) == "undefined" || MerchandisingAssociationJS == null || !MerchandisingAssociationJS) {

    MerchandisingAssociationJS = {
        storeParams: {},
        baseItemParams: {},
        merchandisingAssociations: [],
        associationIndex: 0,

        /**
         * Method to set values
         *
         * @param {Object} storeParams params specific to a store
         * @param {Object} baseItemParams params specific to base Item
         * @param {Array} merchandisingAssociations items associated with the base item
         * 
         **/
        setValues: function (storeParams, baseItemParams, merchandisingAssociations) {
            this.storeParams = storeParams;
            this.baseItemParams = baseItemParams;
            this.baseItemParams.quantity = 1;
            this.merchandisingAssociations = merchandisingAssociations;
        },

        /**
         * Setter for baseItemQuantity
         * 
         * @param Integer baseItemQuantity
         */
        setBaseItemQuantity: function (baseItemQuantity) {
            var baseItemQuantity = $.parseJSON(baseItemQuantity);
            // If the quantity is an object with multiple quantities
            if (baseItemQuantity.length) {
                for (idx = 0; idx < baseItemQuantity.length; idx++) {
                    for (idx2 = 0; idx2 < MerchandisingAssociationJS.baseItemParams.components.length; idx2++) {
                        if (MerchandisingAssociationJS.baseItemParams.components[idx2].skus) {
                            for (idx3 = 0; idx3 < MerchandisingAssociationJS.baseItemParams.components[idx2].skus.length; idx3++) {
                                if (MerchandisingAssociationJS.baseItemParams.components[idx2].skus[idx3].id == baseItemQuantity[idx].id) {
                                    MerchandisingAssociationJS.baseItemParams.components[idx2].id = baseItemQuantity[idx].id;
                                    break;
                                }
                            }
                        }
                        if (MerchandisingAssociationJS.baseItemParams.components[idx2].id == baseItemQuantity[idx].id) {
                            MerchandisingAssociationJS.baseItemParams.components[idx2].quantity = baseItemQuantity[idx].quantity;
                            break;
                        }
                    }
                }
                // If the quantity is a single value
            } else {
                MerchandisingAssociationJS.baseItemParams.quantity = baseItemQuantity;
            }
        },

        /**
         * Setter for baseItemAttributes
         * 
         * @param Integer baseItemQuantity
         */
        setBaseItemAttributes: function (baseItemAttributes) {
            this.baseItemParams.attributes = $.parseJSON(baseItemAttributes);
        },

        /**
         * Setter for baseItemAttributes. Retrieve product attributes from catentry object. 
         * 
         * @param Integer baseItemQuantity
         */
        setBaseItemAttributesFromProduct: function (catEntryId, productId) {
            var selectedAttributes = productDisplayJS.selectedAttributesList["entitledItem_" + productId];
            MerchandisingAssociationJS.setBaseItemAttributes(JSON.stringify(selectedAttributes));
        },

        /**
         * changeItem scrolls the associated catEntries up and down
         *
         * @param {int} direction +1, scrolls up and -1, scrolls down
         *
         **/
        changeItem: function (direction) {
            if ((this.associationIndex + direction) >= 0 && (this.associationIndex + direction) < this.merchandisingAssociations.length) {
                this.associationIndex = this.associationIndex + direction;
                // sets the associated item name
                $("#association_item_name").html(this.merchandisingAssociations[this.associationIndex].name);
                if (document.getElementById("ProductInfoName_" + this.merchandisingAssociations[this.associationIndex - direction].productId) != null) {
                    document.getElementById("ProductInfoName_" + this.merchandisingAssociations[this.associationIndex - direction].productId).value = this.merchandisingAssociations[this.associationIndex].name;
                    document.getElementById("ProductInfoName_" + this.merchandisingAssociations[this.associationIndex - direction].productId).id = "ProductInfoName_" + this.merchandisingAssociations[this.associationIndex].productId;
                }
                // sets the associated thumbnail image of the item
                $("#association_thumbnail").attr('src', this.merchandisingAssociations[this.associationIndex].thumbnail);
                if ($("#ProductInfoImage_" + this.merchandisingAssociations[this.associationIndex - direction].productId).length) {
                    document.getElementById("ProductInfoImage_" + this.merchandisingAssociations[this.associationIndex - direction].productId).value = this.merchandisingAssociations[this.associationIndex].thumbnail;
                    document.getElementById("ProductInfoImage_" + this.merchandisingAssociations[this.associationIndex - direction].productId).id = "ProductInfoImage_" + this.merchandisingAssociations[this.associationIndex].productId;
                }
                // sets the associated item name to alt text
                $("#association_thumbnail").attr("alt", this.merchandisingAssociations[this.associationIndex].name);
                // sets the total offered price
                $("#combined_total").html(this.merchandisingAssociations[this.associationIndex].offeredCombinedPrice);
                if ($("#ProductInfoPrice_" + this.merchandisingAssociations[this.associationIndex - direction].productId).length) {
                    document.getElementById("ProductInfoPrice_" + this.merchandisingAssociations[this.associationIndex - direction].productId).value = this.merchandisingAssociations[this.associationIndex].skuOfferPrice;
                    document.getElementById("ProductInfoPrice_" + this.merchandisingAssociations[this.associationIndex - direction].productId).id = "ProductInfoPrice_" + this.merchandisingAssociations[this.associationIndex].productId;
                }
                // sets the total list price
                $("#list_total").html(this.merchandisingAssociations[this.associationIndex].listedCombinedPrice);
                if ($("#association_url ").attr('ontouchend') == (undefined)) {
                    // sets the product url href
                    $("#association_url").attr("href", this.merchandisingAssociations[this.associationIndex].url);
                }
                // sets the product url title
                $("#association_url").attr("title", this.merchandisingAssociations[this.associationIndex].shortDesc);
                if ($("#association_url").attr('ontouchend') !== (undefined)) {
                    currentPopup = "";
                    $("association_url").attr("ontouchend", "handlePopup('" + this.merchandisingAssociations[this.associationIndex].url + "','merchandisingAssociation_QuickInfoDiv" + this.merchandisingAssociations[this.associationIndex].id + "')");
                }
                // sets the href for quick info
                $("#merchandisingAssociation_QuickInfo").attr("href", "javascript:QuickInfoJS.showDetails(" + this.merchandisingAssociations[this.associationIndex].id + ");");
                if (0 == this.associationIndex) {
                    // changing the up arrow to disabled style
                    $("#up_arrow").removeClass("up_active");
                    $("#down_arrow").addClass("down_active");
                    $("#down_arrow").focus();
                } else if ((this.merchandisingAssociations.length - 1) == this.associationIndex) {
                    // changing the down arrow to disabled style
                    $("#down_arrow").removeClass("down_active");
                    $("#up_arrow").addClass("up_active");
                    $("#up_arrow").focus();
                } else {
                    // changing the arrows to enabled style
                    $("#up_arrow").addClass("up_active");
                    $("#down_arrow").addClass("down_active");
                }
            }
        },

        setCommonParams: function () {
            var params = new Object();
            params.storeId = this.storeParams.storeId;
            params.catalogId = this.storeParams.catalogId;
            params.langId = this.storeParams.langId;
            params.orderId = ".";
            // Remove calculations for performance
            // params.calculationUsage = "-1,-2,-5,-6,-7";
            params.calculateOrder = "0";
            params.inventoryValidation = "true";
            return params;
        },

        validate: function () {
            if (this.baseItemParams.type == 'BundleBean') {
                for (idx = 0; idx < this.baseItemParams.components.length; idx++) {
                    if (!isPositiveInteger(this.baseItemParams.components[idx].quantity)) {
                        MessageHelper.displayErrorMessage(Utils.getLocalizationMessage('QUANTITY_INPUT_ERROR'));
                        return;
                    }
                }
            } else if (this.baseItemParams.type == 'ProductBean' &&
                (null == this.baseItemParams.attributes || "undefined" == this.baseItemParams.attributes)) {
                MessageHelper.displayErrorMessage(Utils.getLocalizationMessage('ERR_RESOLVING_SKU'));
                return;
            } else if (!isPositiveInteger(this.baseItemParams.quantity)) {
                MessageHelper.displayErrorMessage(Utils.getLocalizationMessage('QUANTITY_INPUT_ERROR'));
                return;
            }
        },

        /**
         * addBoth2ShopCart Adds both base product and the associated product to the shopping cart
         *
         *
         **/
        addBoth2ShopCart: function (catEntryID_baseItem, catEntryID_MA, catEntryID_MA_quantity, associationIndex) {
            this.associationIndex = associationIndex;
            this.validate();
            if (!isPositiveInteger(catEntryID_MA_quantity)) {
                MessageHelper.displayErrorMessage(Utils.getLocalizationMessage('QUANTITY_INPUT_ERROR'));
                return;
            }
            var params = this.setCommonParams();

            shoppingActionsJS.productAddedList = new Object();
            //Add the parent product to the cart.
            if (["ItemBean", "ProducteBean", "DynamicKitBean"].indexOf(this.baseItemParams.type) > -1) {
                updateParamObject(params, "catEntryId", this.baseItemParams.id, false, -1);
                updateParamObject(params, "quantity", this.baseItemParams.quantity, false, -1);
                if (this.baseItemParams.type == 'DynamicKitBean') {
                    updateParamObject(params, "catalogEntryType", "dynamicKit", -1);
                }
                if (this.baseItemParams.type == 'ItemBean') {
                    shoppingActionsJS.saveAddedProductInfo(Math.abs(this.baseItemParams.quantity), this.baseItemParams.productId, this.baseItemParams.id, this.baseItemParams.attributes);
                } else {
                    shoppingActionsJS.saveAddedProductInfo(Math.abs(this.baseItemParams.quantity), this.baseItemParams.productId, this.baseItemParams.id, shoppingActionsJS.selectedAttributesList['entitledItem_' + this.baseItemParams.id]);
                }
            } else if (this.baseItemParams.type == 'BundleBean') {
                // Add items in the bundle
                for (idx = 0; idx < this.baseItemParams.components.length; idx++) {
                    updateParamObject(params, "catEntryId", this.baseItemParams.components[idx].id, false, -1);
                    updateParamObject(params, "quantity", this.baseItemParams.components[idx].quantity, false, -1);

                    if (this.baseItemParams.components[idx].productId != undefined) {
                        var selectedAttrList = new Object();
                        for (attr in shoppingActionsJS.selectedProducts[this.baseItemParams.components[idx].productId]) {
                            selectedAttrList[attr] = shoppingActionsJS.selectedProducts[this.baseItemParams.components[idx].productId][attr];
                        }
                        shoppingActionsJS.saveAddedProductInfo(Math.abs(this.baseItemParams.components[idx].quantity), this.baseItemParams.components[idx].productId, this.baseItemParams.components[idx].id, selectedAttrList);
                    } else {
                        shoppingActionsJS.saveAddedProductInfo(Math.abs(this.baseItemParams.components[idx].quantity), this.baseItemParams.components[idx].id, this.baseItemParams.components[idx].id, shoppingActionsJS.selectedProducts[this.baseItemParams.components[idx].id]);
                    }
                }
            } else {
                // Resolve ProductBean to an ItemBean based on the attributes in the main page
                var sku = this.resolveSKU();
                if (-1 == sku) {
                    MessageHelper.displayErrorMessage(Utils.getLocalizationMessage('ERR_RESOLVING_SKU'));
                    return;
                } else {
                    updateParamObject(params, "catEntryId", sku, false, -1);
                    updateParamObject(params, "quantity", this.baseItemParams.quantity, false, -1);
                    shoppingActionsJS.saveAddedProductInfo(Math.abs(this.baseItemParams.quantity), this.baseItemParams.id, sku, this.baseItemParams.attributes);
                }
            }
            if (["ItemBean", "PackageBean", "DynamicKitBean"].indexOf(this.merchandisingAssociations[this.associationIndex].type) > -1) {
                updateParamObject(params, "catEntryId", this.merchandisingAssociations[this.associationIndex].id, false, -1);
                updateParamObject(params, "quantity", catEntryID_MA_quantity, false, -1);
                if (this.merchandisingAssociations[this.associationIndex].productId != undefined) {
                    shoppingActionsJS.saveAddedProductInfo(Math.abs(catEntryID_MA_quantity), this.merchandisingAssociations[this.associationIndex].productId, this.merchandisingAssociations[this.associationIndex].id, shoppingActionsJS.selectedAttributesList['entitledItem_' + this.merchandisingAssociations[this.associationIndex].id]);
                } else {
                    shoppingActionsJS.saveAddedProductInfo(Math.abs(catEntryID_MA_quantity), this.merchandisingAssociations[this.associationIndex].id, this.merchandisingAssociations[this.associationIndex].id, shoppingActionsJS.selectedAttributesList['entitledItem_' + this.merchandisingAssociations[this.associationIndex].id]);
                }
                this.addItems2ShopCart(params);
            } else if (this.merchandisingAssociations[this.associationIndex].type == 'BundleBean') {
                // Add items in the bundle
                for (idx = 0; idx < this.merchandisingAssociations[this.associationIndex].components.length; idx++) {
                    updateParamObject(params, "catEntryId", this.merchandisingAssociations[this.associationIndex].components[idx].id, false, -1);
                    updateParamObject(params, "quantity", catEntryID_MA_quantity, false, -1);
                    shoppingActionsJS.saveAddedProductInfo(Math.abs(catEntryID_MA_quantity), this.merchandisingAssociations[this.associationIndex].components[idx].id, this.merchandisingAssociations[this.associationIndex].components[idx].id, shoppingActionsJS.selectedProducts[this.merchandisingAssociations[this.associationIndex].components[idx].id]);
                }
                this.addItems2ShopCart(params);
            } else {
                // Resolve ProductBean to an ItemBean based on the attributes selected
                var entitledItemJSON = null;
                if ($("#" + catEntryID_MA).length) {
                    //the json object for entitled items are already in the HTML. 
                    entitledItemJSON = eval('(' + $("#" + catEntryID_MA).html() + ')');
                } else {
                    //if $("#" + entitledItemId) is null, that means there's no <div> in the HTML that contains the JSON object. 
                    //in this case, it must have been set in catalogentryThumbnailDisplay.js when the quick info
                    entitledItemJSON = shoppingActionsJS.getEntitledItemJsonObject();
                }
                shoppingActionsJS.setEntitledItems(entitledItemJSON);
                var catEntryID_MA_SKU = shoppingActionsJS.getCatalogEntryId(catEntryID_MA);
                if (null == catEntryID_MA_SKU) {
                    MessageHelper.displayErrorMessage(Utils.getLocalizationMessage('ERR_RESOLVING_SKU'));
                    return;
                } else {
                    updateParamObject(params, "catEntryId", catEntryID_MA_SKU, false, -1);
                    updateParamObject(params, "quantity", catEntryID_MA_quantity, false, -1);
                    shoppingActionsJS.saveAddedProductInfo(catEntryID_MA_quantity, catEntryID_MA.split("_")[1], catEntryID_MA_SKU, shoppingActionsJS.selectedAttributesList['entitledItem_' + this.merchandisingAssociations[this.associationIndex].id]);
                    this.addItems2ShopCart(params);
                }
            }
        },

        resolveSKU: function () {
            for (idx = 0; idx < this.baseItemParams.skus.length; idx++) {
                var matches = 0;
                var attributeCount = 0;
                for (attribute in this.baseItemParams.skus[idx].attributes) {
                    attributeCount++;
                    if (this.baseItemParams.attributes && this.baseItemParams.skus[idx].attributes[attribute] == this.baseItemParams.attributes[attribute]) {
                        matches++;
                    } else {
                        break;
                    }
                }
                if (matches == attributeCount) {
                    return this.baseItemParams.skus[idx].id;
                }
            }
            return -1;
        },

        /**
         * AddItem2ShopCartAjax This function is used to add a single or multiple items to the shopping cart using an ajax call.
         *
         * @param {Object} params, parameters that needs to be passed during service invocation.
         *
         **/
        addItems2ShopCart: function (params) {
            var shopCartService = "AddOrderItem";
            if (params['catalogEntryType'] == 'dynamicKit') {
                shopCartService = "AddPreConfigurationToCart";
            }
            //For Handling multiple clicks
            if (!submitRequest()) {
                return;
            }
            cursor_wait();
            wcService.invoke(shopCartService, params);
        },

        /**
         * This function is used to subscribe events that indicate quantity change and attribute changes.
         *
         * @param {Object} params, parameters that needs to be passed during service invocation.
         *
         **/
        subscribeToEvents: function (baseCatalogEntryId) {
            wcTopic.subscribe("Quantity_Changed", MerchandisingAssociationJS, MerchandisingAssociationJS.setBaseItemQuantity);
            wcTopic.subscribe("DefiningAttributes_Resolved_" + baseCatalogEntryId, MerchandisingAssociationJS.setBaseItemAttributesFromProduct);
        }
    }

}
//
// US Government Users Restricted Rights - Use, duplication or
// disclosure restricted by GSA ADP Schedule Contract with
// IBM Corp.
//-----------------------------------------------------------------

// Declare refresh controller which are used in pagination controls of SearchBasedNavigationDisplay -- both products and articles+videos

// Search for this "prodRecommendationRefresh_controller" it is never defined in any refresh areas, maybe no longer in use?
/*
wc.render.declareRefreshController({
    id: "prodRecommendationRefresh_controller",
    renderContext: wcRenderContext.getRenderContextProperties("searchBasedNavigation_context"),
    url: "",
    formId: ""

    ,renderContextChangedHandler: function(message, widget) {
        var controller = this;
        var renderContext = this.renderContext;
        var resultType = renderContext.properties["resultType"];
        if (["products", "both"].indexOf(resultType) > -1){
            widget.refresh(renderContext.properties);
            console.log("espot refreshing");
        }
    }

    ,postRefreshHandler: function(widget) {
        var controller = this;
        var renderContext = this.renderContext;
        cursor_clear();

        var refreshUrl = controller.url;
        var emsName = "";
        var indexOfEMSName = refreshUrl.indexOf("emsName=", 0);
        if(indexOfEMSName >= 0){
            emsName = refreshUrl.substring(indexOfEMSName+8);
            if (emsName.indexOf("&") >= 0) {
                emsName = emsName.substring(0, emsName.indexOf("&"));
                emsName = "script_" + emsName;
            }
        }

        if (emsName !== "") {
            var espot = $('.genericESpot', $("#" + emsName).parent()).first();
            if (espot.length) {
                espot.addClass('emptyESpot');
            }
        }
        wcTopic.publish("CMPageRefreshEvent");
    }
}); */
//-----------------------------------------------------------------
// Licensed Materials - Property of IBM
//
// WebSphere Commerce
//
// (C) Copyright IBM Corp. 2014, 2016 All Rights Reserved.
//
// US Government Users Restricted Rights - Use, duplication or
// disclosure restricted by GSA ADP Schedule Contract with
// IBM Corp.
//-----------------------------------------------------------------

/**
 *@fileOverview This javascript file defines all the javascript functions used by SKU List widget
 */

SKUListJS = {

    /** 
     * This variable stores the ID of the language that the store currently uses. Its default value is set to -1, which corresponds to United States English.
     * @private
     */
    langId: "-1",

    /** 
     * This variable stores the ID of the current store. Its default value is empty.
     * @private
     */
    storeId: "",

    /** 
     * This variable stores the ID of the catalog. Its default value is empty.
     * @private
     */
    catalogId: "",

    /** 
     * If set to true, then the SKU compare box will be shown. Its default value is true.
     * @private
     */
    disableProductCompare: "",

    /** 
     * This array stores the products which quantities have been updated (and can be added to the cart). Its default value is empty.
     * @private
     */
    quantityList: {},

    /**
     * This variable stores the mousedown event $.proxy handle.
     */
    mouseOverConnectHandle: false,

    /**
     * Sets the common parameters for the current page. 
     * For example, the language ID, store ID, and catalog ID.
     *
     * @param {Integer} langId The ID of the language that the store currently uses.
     * @param {Integer} storeId The ID of the current store.
     * @param {Integer} catalogId The ID of the catalog.
     * @param {Integer} disableProductCompare If set to true, will disable product compare.
     */
    setCommonParameters: function (langId, storeId, catalogId, disableProductCompare) {
        this.langId = langId;
        this.storeId = storeId;
        this.catalogId = catalogId;
        this.disableProductCompare = disableProductCompare;
    },

    /**
     * Updates the quantities of the SKU if the quantities are changed.
     * @param (string) qty The quantity value to update to.
     * @param (string) productId The ID of the product.
     * @param (string) itemId The ID of the item.
     */
    updateItemQuantity: function (qty, productId, itemId) {
        if (!(productId in this.quantityList)) {
            this.quantityList[productId] = {};
        }

        if (qty.replace(/^\s+|\s+$/g, '') == '') {
            this.removeItemQuantity(productId, itemId);
            $('#invalidQuantity_' + productId + '_' + itemId).css('display', 'none');
            return;
        }

        if (!isPositiveInteger(qty)) {
            $('#invalidQuantity_' + productId + '_' + itemId).css('display', 'block');
        } else {
            $('#invalidQuantity_' + productId + '_' + itemId).css('display', 'none');
        }

        this.quantityList[productId][itemId] = qty;
    },

    /**
     * Validate item quantity.
     * @param (string) qty The quantity value to update to.
     * @param (string) skuId The ID of the sku.
     */
    validateQuantity: function (qty, skuId) {
        if (qty.replace(/^\s+|\s+$/g, '') != '' && !isPositiveInteger(qty)) {
            $('#invalidQuantity_' + skuId).css('display', 'block');
        } else {
            $('#invalidQuantity_' + skuId).css('display', 'none');
        }
    },

    /**
     * Remove the quantity of the SKU (e.g. when row is hidden)
     * @param (string) productId The ID of the product.
     * @param (string) itemId The ID of the item.
     */
    removeItemQuantity: function (productId, itemId) {
        if (productId in this.quantityList) {
            delete this.quantityList[productId][itemId];
        }
    },

    /**
     * Remove all quantities currently inputed, e.g. after successfully added to shopping cart or req list 
     */
    removeAllQuantities: function () {
        var quantityFields = $(".productDetailTable .Quantity .input_field");

        for (var i = 0; i < quantityFields.length; i++) {
            quantityFields[i].val("");
            quantityFields[i].change();
        }
    },

    /**
     * Checks if the string is an integer.
     * @param (string) str The string to check.
     * @return (boolean) Indicates whether the string is a number.
     */
    isNumber: function (str) {
        if ((str * 0) == 0) return true;
        else return false;
    },

    /**
     * Checks if a string is null or empty.
     * @param (string) str The string to check.
     * @return (boolean) Indicates whether the string is empty.
     */
    isEmpty: function (str) {
        var reWhiteSpace = new RegExp(/^\s+$/);
        if (str == null || str === '' || reWhiteSpace.test(str)) {
            return true;
        }
        return false;
    },

    /**
     * Redirects to the store locator after appending the current URL
     * @param storeLocatorUrl The store locator URL
     */
    selectStore: function (storeLocatorUrl) {
        setPageLocation(storeLocatorUrl + "&fromUrl=" + encodeURIComponent(document.URL));
    },

    /**
     * Checks the online inventory status in the stores selected by the user
     * @param productId The product ID
     * @param type The product type 
     */
    checkOnlineAvailability: function (productId) {
        var params = {
            productId: productId,
            storeId: this.storeId,
            catalogId: this.catalogId,
            langId: this.langId
        };

        var url = appendWcCommonRequestParameters("GetOnlineInventoryStatusByIDViewV2");
        cursor_wait();

        $.ajax({
            url: url,
            dataType: "json",
            data: params,
            success:
            /**
             * Populate the contents of the online store inventory details section with the JSON returned 
             * from the server. This is the callback function that is called after the AJAX call to get the online
             * inventory details successfully returns to the client.
             * 
             * @param {object} serviceResponse The JSON response from $.ajax.
             * @param {string} status The status of $.ajax call.
             */

                function (serviceResponse, status) {
                if (serviceResponse.onlineInventory) {
					for (var item in serviceResponse.onlineInventory) {
						var onlineInventoryElement = document.getElementById("WC_Sku_List_TableContent_"+item+"_OnlineAvailability");
						var mobileInventoryElement = document.getElementById("WC_Sku_List_MbileContent_"+item+"_OnlineAvailability");
						
						if (onlineInventoryElement != null) {
							onlineInventoryElement.innerHTML = "<span> <img src='" + imageDirectoryPath + styleDirectoryPath + serviceResponse.onlineInventory[item].image 
									+ "' alt='" + serviceResponse.onlineInventory[item].altText + "' /> </span>"
									+ "<span>" + serviceResponse.onlineInventory[item].status + "</span>";
						}
						if (mobileInventoryElement != null) {
							mobileInventoryElement.innerHTML = "<span> <img src='" + imageDirectoryPath + styleDirectoryPath + serviceResponse.onlineInventory[item].image 
									+ "' alt='" + serviceResponse.onlineInventory[item].altText + "' /> </span>"
									+ "<span>" + serviceResponse.onlineInventory[item].status + "</span>";
						}
					}
                } else {
                    MessageHelper.displayErrorMessage(Utils.getLocalizationMessage("INV_STATUS_RETRIEVAL_ERROR"));
                }
                cursor_clear();
            },
            error: function (jqXHR, textStatus, err) {
                MessageHelper.displayErrorMessage(Utils.getLocalizationMessage("INV_STATUS_RETRIEVAL_ERROR"));
                cursor_clear();
            }
        });
    },
    /**
     * Populate the select stores/check stores link depending on whether or not
     * a physical store has been selected
     */
    populateStoreLinks: function () {
        var cookieValue = getCookie("WC_physicalStores");

        if (cookieValue != null) {
            $(".check_stores.link").removeClass("nodisplay");
        } else {
            $(".select_stores.link").removeClass("nodisplay");
        }
    },

    /**
     * Checks the inventory status in the stores selected by the user
     * @param productId The product ID
     * @param itemId The item ID 
     */
    checkAvailability: function (productId, itemId) {
        var params = {
            productId: productId,
            itemId: itemId
        };

        // For Handling multiple clicks.
        if (!submitRequest()) {
            return;
        }

        var url = appendWcCommonRequestParameters("GetInventoryStatusByIDViewV2");
        cursor_wait();

        $.ajax({
            url: url,
            dataType: "json",
            data: params,
            method: "post",
            success:

            /**
             * Populate the contents of the in store inventory details section with the JSON returned 
             * from the server. This is the callback function that is called after the AJAX call to get the inventory 
             * details successfully returns to the client.
             * 
             * @param {object} serviceResponse The JSON response from $.ajax.
             * @param {string} status The status of $.ajax call.
             */

                function (serviceResponse, status) {
                if (serviceResponse.inStoreInventory) {
                    // Removing the in store section if present
                    $("#WC_InStore_Inventory_Section_" + params.itemId).detach();
                    $("#WC_InStore_Mobile_Inventory_Section_" + params.itemId).detach();


                    // Adding the empty store section
                    $("#WC_Check_Stores_Link_" + params.itemId).before("<div id='WC_InStore_Inventory_Section_" + params.itemId + "' class='sublist'>");
                    $("#WC_Check_Stores_Link_Mobile_" + params.itemId).before("<div id='WC_InStore_Mobile_Inventory_Section_" + params.itemId + "' class='sublist'>");

                    SKUListJS.physicalStores = serviceResponse.inStoreInventory.stores;

                    // Adding the store inventory details as child elements in the store section
                    for (i = 0; i < serviceResponse.inStoreInventory.stores.length; i++) {
                        var store = serviceResponse.inStoreInventory.stores[i];

                        // Adding the store name
                        $("#WC_InStore_Inventory_Section_" + params.itemId).append("<a id='WC_InStore_Inventory_Link_" + params.itemId + "_store_" + (i + 1) + "' href='#' onclick=\"SKUListJS.fetchStoreDetails('" + store.id + "', '" + params.productId + "');\" class='store_name'>" + store.name + "&nbsp;</a>");
                        $("#WC_InStore_Mobile_Inventory_Section_" + params.itemId).append("<a id='WC_InStore_Mobile_Inventory_Link_" + params.itemId + "_store_" + (i + 1) + "' href='#' onclick=\"SKUListJS.fetchStoreDetails('" + store.id + "', '" + params.productId + "');\" class='store_name'>" + store.name + "&nbsp;</a>");
                        // Adding clear div
                        $("#WC_InStore_Inventory_Section_" + params.itemId).append("<div class='clear_float'></div>");
                        $("#WC_InStore_Mobile_Inventory_Section_" + params.itemId).append("<div class='clear_float'></div>");
                        // Adding the image status of store name
                        $("#WC_InStore_Inventory_Section_" + params.itemId).append("<span> <img src='" + imageDirectoryPath + styleDirectoryPath + store.image + "' alt='" + store.altText + "' /> </span>");
                        $("#WC_InStore_Mobile_Inventory_Section_" + params.itemId).append("<span> <img src='" + imageDirectoryPath + styleDirectoryPath + store.image + "' alt='" + store.altText + "' /> </span>");
                        // Adding the text status of store name
                        $("#WC_InStore_Inventory_Section_" + params.itemId).append("<span class='text'>" + store.statusText + "</span>");
                        $("#WC_InStore_Mobile_Inventory_Section_" + params.itemId).append("<span class='text'>" + store.statusText + "</span>");
                        // Adding spacer
                        $("#WC_InStore_Inventory_Section_" + params.itemId).append("<div class='item_spacer_10px'></div>");
                        $("#WC_InStore_Mobile_Inventory_Section_" + params.itemId).append("<div class='item_spacer_10px'></div>");
                    }

                    // Change the link from Check Stores to Change Stores
                    $("#WC_Check_Stores_Link_" + params.itemId).addClass("nodisplay");
                    $("#WC_Change_Stores_Link_" + params.itemId).removeClass("nodisplay");
                    $("#WC_Check_Stores_Link_Mobile_" + params.itemId).addClass("nodisplay");
                    $("#WC_Change_Stores_Link_Mobile_" + params.itemId).removeClass("nodisplay");
                } else {
                    MessageHelper.displayErrorMessage(Utils.getLocalizationMessage("INV_STATUS_RETRIEVAL_ERROR"));
                }
                cursor_clear();
            },
            error: function (jqXHR, textStatus, error) {
                MessageHelper.displayErrorMessage(Utils.getLocalizationMessage("INV_STATUS_RETRIEVAL_ERROR"));
                cursor_clear();
            }
        });
    },
    /**
     * Show physical store details popup after fetching the required details
     * @param storeId The ID of the physical store
     * @param productId The ID of the product
     */
    fetchStoreDetails: function (storeId, productId) {
        MessageHelper.hideAndClearMessage();

        var params = {
            physicalStoreId: storeId,
            productId: productId
        };

        var url = appendWcCommonRequestParameters("GetStoreDetailsByIDViewV2");

        // For Handling multiple clicks.
        if (!submitRequest()) {
            return;
        }
        cursor_wait();
        $.ajax({
            url: url,
            dataType: "json",
            data: params,
            method: "post",
            success:
            /**
             * Populate the contents of the store details section in the product display page with the JSON returned 
             * from the server. This is the callback function that is called after the AJAX call to get the inventory 
             * details successfully returns to the client.
             * 
             * @param {object} serviceResponse The JSON response from $.ajax.
             * @param {string} status The status of $.ajax call.
             */
                function (serviceResponse, status) {
                var store = serviceResponse;

                // Get unescaped working hours
                store.hours = SKUListJS.unEscapeXml(serviceResponse.hours);

                // Get inventory status
                var storeInventory = SKUListJS.fetchInventoryStatus(params.physicalStoreId);

                // Get store availability details
                store.imageTag = "<img src='" + imageDirectoryPath + styleDirectoryPath + storeInventory.image + "' alt='" + storeInventory.altText + "'/>";
                store.statusText = storeInventory.statusText;

                if (storeInventory.status == 'Available') {
                    store.availabilityDetails = "(" + storeInventory.availableQuantity + ")"; // Adding the available quantity
                } else if (storeInventory.status == 'Backorderable') {
                    store.availabilityDetails = "(" + storeInventory.availableDate + ")"; // Adding the available date
                } else {
                    store.availabilityDetails = "";
                }

                var storeDetails = $("#Store_Details_Template_" + params.productId).html();
                $("#Store_Details_" + params.productId).html(Utils.substituteStringWithObj(storeDetails, store));

                // Display store details
                var popup = $("#InventoryStatus_Store_Details_" + params.productId).data("wc-WCDialog");
                if (popup) {
                    closeAllDialogs(); // Close other dialogs(quickinfo dialog, etc) before opening this. 				
                    popup.open();
                } else {
                    console.debug("InventoryStatus_Store_Details_" + params.productId + " does not exist");
                }
                cursor_clear();
            },
            error: function (jqXHR, textStatus, error) {
                MessageHelper.displayErrorMessage(Utils.getLocalizationMessage("INV_STATUS_RETRIEVAL_ERROR"));
                cursor_clear();
            }
        });
    },


    /**
     * Returns the inventory status object for the physical store specified
     * @param storeId The storeId of the physical store
     * @return the inventory status object for the store
     */
    fetchInventoryStatus: function (storeId) {
        for (i = 0; i < this.physicalStores.length; i++) {
            if (this.physicalStores[i].id == storeId) {
                return this.physicalStores[i];
            }
        }
        return {};
    },

    /**
     * Converts xml accepted form to < >
     * @param {String} str, String to be converted
     * @return {String} converted string
     */
    unEscapeXml: function (str) {
        return str.replace(/&lt;/gm, "<").replace(/&gt;/gm, ">");
    },

    /**
     * Show SKU list table (e.g. when button is clicked)
     * @param productId the ID of the product
     **/
    showTable: function (productId, top_category, parent_category_rn, categoryId, widgetPrefix) {
        //For Handling multiple clicks
        if (!submitRequest()) {
            return;
        }
        var skuListWidget = $("#WC_Sku_List_Table_" + productId);
        if (skuListWidget) {
            cursor_wait();
            skuListWidget.refreshWidget("refresh", {
                "catalogId": this.catalogId,
                "storeId": this.storeId,
                "productId": productId,
                "disableProductCompare": this.disableProductCompare,
                "jspStoreImgDir": imageDirectoryPath,
                "top_category": top_category,
                "parent_category_rn": parent_category_rn,
                "categoryId": categoryId,
                "widgetPrefix": widgetPrefix
            });
        }

        var ie_version = Utils.get_IE_version();
        if (ie_version < 9) {
            $("#lastShowSKUList").val(productId);
            this.mouseOverConnectHandle = $("#WC_Sku_List_Table_Hide_Button_" + productId).on("mouseover", $.proxy(this.handleMouseOver, this));
        }
    },

    handleMouseOver: function () {
        var productId = $("#lastShowSKUList").val();
        var node = $("#product_name_" + productId);
        var productInfoHeight = 0;
        while (node != null && node.tagName != "LI") {
            node = node.parentNode;
            if (node.className == "product_info") {
                productInfoHeight = node.offsetHeight;
            }
        }
        if (productInfoHeight > 280) {
            $(node).css("height", productInfoHeight + 40 + "px");
        }
        SKUListJS.arrangeProductDetailTables();
    },

    /**
     * Show the display of SKU list table and change the button to hide
     * @param widget the refresh area widget
     **/
    showTableView: function (productId) {
        var Widget = $("#WC_Sku_List_Table_" + productId);
        $(Widget).removeClass("nodisplay");
        $('#WC_Sku_List_Table_Full_' + productId).addClass('expanded');
        $('#WC_Sku_List_Table_Expand_Area_' + productId).addClass('hide');
        $('#WC_Sku_List_Table_Show_Button_' + productId).addClass('nodisplay');
        $('#WC_Sku_List_Table_Hide_Button_' + productId).removeClass('nodisplay');
        $("#WC_Sku_List_Table_Hide_Button_" + productId).focus();
    },

    /**
     * Hide the display of SKU list table and change the button to show
     * @param widget the refresh area widget
     **/
    hideTableView: function (productId) {
        $('#WC_Sku_List_Table_' + productId).addClass('nodisplay');
        $('#WC_Sku_List_Table_Expand_Area_' + productId).removeClass('hide');
        $('#WC_Sku_List_Table_Hide_Button_' + productId).addClass('nodisplay');
        $('#WC_Sku_List_Table_Show_Button_' + productId).removeClass('nodisplay');
        $("#WC_Sku_List_Table_Show_Button_" + productId).focus();
        if (!this.mouseOverConnectHandle) {
            $(document.documentElement).off("mouseover");
            this.mouseOverConnectHandle = false;
        }
    },

    /**
     * Toggle expanded content to show or hide (e.g. when button is clicked)
     * @param productId the ID of the product
     * @param row The row on which the expanded content is contained
     * @param skuId The SKU id of the sku which the row contains
     **/
    toggleExpandedContent: function (productId, row, skuId) {
        $('#WC_Sku_List_ExpandedContent_' + productId + '_' + row).toggleClass('nodisplay');
        $('#WC_Sku_List_Mobile_ExpandedContent_' + productId + '_' + row).toggleClass('nodisplay');
        $('#WC_Sku_List_Row_Header_Mobile_' + skuId).toggleClass('expanded');
        $('#WC_Sku_List_Title_Mobile_' + productId + '_' + row).toggleClass('expanded');
        $('#DropDownArrow_' + productId + '_' + row).toggleClass('expanded');
        $('#DropDownArrow_Mobile_' + productId + '_' + row).toggleClass('expanded');
        $('#DropDownButton_' + productId + '_' + row).toggleClass('expanded');
        $('#DropDownButton_Mobile_' + productId + '_' + row).toggleClass('expanded');

        if ($('#DropDownButton_' + productId + '_' + row).attr('aria-expanded') == 'false') {
            $('#DropDownButton_' + productId + '_' + row, 'aria-expanded').attr('true');
        } else {
            $('#DropDownButton_' + productId + '_' + row, 'aria-expanded').attr('false');
        }

        if ($('#DropDownButton_Mobile_' + productId + '_' + row, 'aria-expanded') == 'false') {
            $('#DropDownButton_Mobile_' + productId + '_' + row, 'aria-expanded').attr('true');
        } else {
            $('#DropDownButton_Mobile_' + productId + '_' + row, 'aria-expanded').attr('false');
        }
    },

    /**
     * Arranges the columns in all SKU list tables on the page. 
     */
    arrangeProductDetailTables: function () {
        var listTables = $(".productDetailTable");

        // For each product detail table, get the productId from the element's ID
        for (var i = 0; i < listTables.length; i++) {
            var productId = listTables[i].id.replace("WC_Sku_List_Table_", "");
            this.arrangeProductDetailTable(productId);
        }
    },

    /**
     * Arranges the columns in the SKU list table. If there is not enough space to show all attributes,
     * some columns will be pushed into the hidden expandable content area.
     * @param productId the productId
     */
    arrangeProductDetailTable: function (productId) {
        // This is the font being used in the column headers for the SKU List widget
        var HEADER_FONT = "bold 12px sans-serif"

        /* This is the minumum pixel width a column can be. Once the width of the columns has 
        gone below this amount, then a column will be removed and pushed into expandable hidden row */
        var MIN_COL_WIDTH = 90;

        // This is the maximum pixel width a column can be. 
        var MAX_COL_WIDTH = 250;

        var container = $("#WC_Sku_List_Table_" + productId).parent();
        var listTable = $("#WC_Sku_List_Table_Full_" + productId);
        var mobileTable = $("#WC_Sku_List_Table_Mobile_" + productId);

        // Check if table is already expanded and visible
        if ((listTable == null || listTable.offsetHeight == 0) && (mobileTable == null || mobileTable.offsetHeight == 0)) {
            return;
        }

        // Show the mobile view when the width of the container is 540 px or less
        if ($(container).width() <= 540) {
            $(listTable).css("display", "none");
            $(mobileTable).css("display", "block");
        } else {
            $(listTable).css("display", "block");
            $(mobileTable).css("display", "none");
        }

        var rowWidth = $(".row", listTable).first().width();

        // Get the set of anchored and unanchored columns
        var anchoredHeaders = $(".columnHeader.anchored", listTable);
        var anchoredCells = $(".gridCell.anchored", listTable);
        var unanchoredHeaders = $(".columnHeader.unanchored", listTable);
        var unanchoredCells = $(".gridCell.unanchored", listTable);

        // The remaining width of the table will be used for unanchored headers (10 pixel buffer, so that headers don't wrap) 
        var unanchoredWidth = rowWidth - 10;
        for (var i = 0; i < anchoredHeaders.length; i++) {
            unanchoredWidth -= $(anchoredHeaders[i]).width();
        }

        // Get the total number of columns in the SKU list table
        var unanchoredColumnWidth = MAX_COL_WIDTH;
        var numOfColumnsToMove = 0;

        // Find the number of unanchored columns that can be shown 
        if (unanchoredWidth / unanchoredHeaders.length < MIN_COL_WIDTH) {
            numOfColumnsToMove = Math.ceil(unanchoredHeaders.length - (unanchoredWidth / MIN_COL_WIDTH));
            if (numOfColumnsToMove > unanchoredHeaders.length) {
                numOfColumnsToMove = unanchoredHeaders.length;
            }
        }

        // After finding out the number of columns needed to be moved, calculate the width of each unanchored column
        var numOfRemainingColumns = unanchoredHeaders.length - numOfColumnsToMove;
        if (numOfRemainingColumns > 0) {
            unanchoredColumnWidth = unanchoredWidth / numOfRemainingColumns;
            if (unanchoredColumnWidth > MAX_COL_WIDTH) {
                unanchoredColumnWidth = MAX_COL_WIDTH;
            }
        } else {
            unanchoredColumnWidth = 0;
        }

        var headersToMove = [];
        var recalculateWidths = false;
        var padding = 20;

        // Bring the compare header to the front of the list, so it will get moved last
        if ($(".columnHeader.unanchored [data-filter=\"Compare\"]", listTable).length != 0) {
            unanchoredHeaders.unshift(unanchoredHeaders.pop());
        }

        // Check if any columns have a string that is too long to display in the currently calculated widths, and move those first
        for (var i = 0; i < unanchoredHeaders.length; i++) {
            if (i >= unanchoredHeaders.length - numOfColumnsToMove) {
                headersToMove.push(unanchoredHeaders[i]);
            } else {
                var attrNode = unanchoredHeaders[i].firstElementChild || unanchoredHeaders[i].firstChild //For IE8
                var attributeName = attrNode.innerHTML.replace(/^\s+|\s+$/g, '');

                if (this.hasLongWord(attributeName, unanchoredColumnWidth - padding, HEADER_FONT)) {
                    headersToMove.push(unanchoredHeaders[i]);
                    numOfColumnsToMove--;
                    recalculateWidths = true;
                }
            }
        }

        // If needed, recalculate the new unanchored column widths after moving a column that had a string that was too long
        if (recalculateWidths) {
            numOfRemainingColumns = unanchoredHeaders.length - headersToMove.length;
            if (numOfRemainingColumns > 0) {
                unanchoredColumnWidth = unanchoredWidth / numOfRemainingColumns;
                if (unanchoredColumnWidth > MAX_COL_WIDTH) {
                    unanchoredColumnWidth = MAX_COL_WIDTH;
                }
            } else {
                unanchoredColumnWidth = 0;
            }
        }

        // Show all columns initially
        $(unanchoredHeaders).css('display', 'block');
        $(unanchoredCells).css('display', 'block');

        // Set the percentage width of each unanchored column
        $(".columnHeader.unanchored, .gridCell.unanchored", listTable).css('width', unanchoredColumnWidth + 'px');

        // Hide all expanded content initially		
        $(".expandedCol", listTable).css('display', 'none');

        // If all columns can be displayed, then hide the expanded content area and the drop down button
        if (headersToMove.length == 0) {
            $(".expandedContent", listTable).addClass('nodisplay');
            $("[data-filter='expandButton']", listTable).css('display', 'none');
            $(".dropDownButton", listTable).css('display', 'none');
            $(".dropDownArrow", listTable).removeClass('expanded');
        }

        // Hide the amount of columns that need to be moved
        for (var i = 0; i < headersToMove.length; i++) {
            $(".expandButton", listTable).css('display', 'block');

            if ($(unanchoredHeaders).index(headersToMove[i]) !== -1) {
                // Get the CSS classname for the column that will be moved to the expanded columns
                var className = $(headersToMove[i]).attr("data-filter");

                // Hide the main column for this CSS class
                var columnToHide = $(".columnHeader.unanchored[data-filter=\"" + className + "\"], .gridCell.unanchored[data-filter=\"" + className + "\"]", listTable);
                $(columnToHide).css('display', 'none');

                // Show the attribute in the expanded content section
                var expandedColumnsToShow = $(".expandedCol[data-filter=\"" + className + "\"]", listTable);
                $(expandedColumnsToShow).css('display', 'block');

                // Set the right border of the cells in the table depending on row width to display the table lines 
                // properly according to the number of columns.
                if (typeof (expandedColumnsToShow[0]) != 'undefined') {
                    var expandedColWidth = $(expandedColumnsToShow[0]).width();
                    var expandedContentPadding = 40;
                    var numOfExpandedColumns = Math.floor((rowWidth - expandedContentPadding) / expandedColWidth);
                    if (numOfExpandedColumns > 1 && headersToMove.length > 1) {
                        if (i % numOfExpandedColumns == numOfExpandedColumns - 1) {
                            $(expandedColumnsToShow).css('borderRight', 'none');
                        } else {
                            $(expandedColumnsToShow).css('borderRight', '1px solid #ccc');
                        }
                    } else {
                        $(expandedColumnsToShow).css('borderRight', 'none');
                    }
                }
            }
        }
    },

    /**
     * Checks if any words in a string is longer than maxWidth
     * @param text The text string
     * @param maxWidth The max width for any word
     * @param font The font of the string
     */
    hasLongWord: function (text, maxWidth, font) {
        // Create a dummy canvas (render invisible with css)
        var c = document.createElement('canvas');

        if (!c.getContext) {
            return false;
        }

        var ctx = c.getContext('2d');
        // Set the context.font to the font that you are using
        ctx.font = font;

        if (ctx.measureText(text).width < maxWidth) {
            return false;
        }

        var words = text.split(' ');

        for (var w in words) {
            var word = words[w];
            var measure = ctx.measureText(word).width;

            if (measure > maxWidth) {
                return true;
            }
        }

        return false;
    },

    /**
     * Filters the SKU list so that only those with selected attributes are shown
     * @param skuId the ID of the item
     * @param productId the ID of the product
     */
    filterSkusByAttribute: function (skuId, productId) {
        var listTable = $("#WC_Sku_List_Table_" + productId);
        var selectedAttributes = productDisplayJS.selectedAttributesList;
        var productKey = "entitledItem_" + productId;

        if (productKey in selectedAttributes) {
            // Display all rows initially
            $(".row.entry, .mobileHeader", listTable).removeClass('nodisplay');

            for (var attribute in selectedAttributes[productKey]) {
                // The value of the selected attribute
                var selectedAttrValue = selectedAttributes[productKey][attribute].replace(/^\s+|\s+$/g, '');

                if (selectedAttrValue !== "") {
                    // The CSS class of the attribute has no spaces or 's or "s
                    var attrClass = attribute.replace(/ /g, "").replace(/'/g, "").replace(/"/g, "");

                    // Get all cells from the column matching the selected attribute 
                    //var attrCells = $(".gridCell." + attrClass, listTable);
                    var attrCells = $("div[data-filter='" + attrClass + "'].gridCell", listTable);

                    for (var i = 0; i < attrCells.length; i++) {
                        // If the selected attribute is not the same as the value inside a matching cell 
                        // found in the SKU list table, then remove the entire row and remove the quantities
                        var attrTextNode = attrCells[i].firstElementChild || attrCells[i].firstChild //For IE8 
                        if (selectedAttrValue != attrTextNode.innerHTML.replace(/^\s+|\s+$/g, '')) {
                            $(attrCells[i].parentNode).addClass('nodisplay');

                            // Get the SKU ID of the row that we want to remove and remove the row in mobile view as well
                            skuId = attrCells[i].parentNode.id.split("WC_Sku_List_Row_Content_")[1];
                            $("#WC_Sku_List_Row_Header_Mobile_" + skuId).addClass('nodisplay');

                            var quantityInput = $(".input_field", attrCells[i].parentNode).first();
                            quantityInput.val("");
                            quantityInput.change();
                        }
                    }
                }
            }
        }
    },

    /**
     * addSku2ShopCartAjax This function is used to add one SKU to the shopping cart using an AJAX call (from mobile view).
     * @param {String} productId the product Id being added to cart
     * @param {String} skuId the SKU Id being added to cart 	
     * @param {Object} customParams - Any additional parameters that needs to be passed during service invocation.
     **/
    addSku2ShopCartAjax: function (productId, skuId, customParams) {
        if (browseOnly) {
            MessageHelper.displayErrorMessage(Utils.getLocalizationMessage('ERROR_ADD2CART_BROWSE_ONLY'));
            return;
        }

        var params = {
            storeId: this.storeId,
            catalogId: this.catalogId,
            langId: this.langId,
            orderId: "."
        };
        // Remove calculations for performance
        // params.calculationUsage = "-1,-2,-5,-6,-7";
        params.inventoryValidation = "true";
        params.calculateOrder = "0";
        var ajaxShopCartService = "AddOrderItem";

        shoppingActionsJS.productAddedList = {};

        var quantity = $("#" + skuId + "_Mobile_Quantity_Input").val();
        if (!isPositiveInteger(quantity)) {
            MessageHelper.displayErrorMessage(Utils.getLocalizationMessage('QUANTITY_INPUT_ERROR'));
            return;
        }

        params["catEntryId"] = skuId;
        params["quantity"] = quantity;

        shoppingActionsJS.saveAddedProductInfo(quantity, productId, skuId, null);

        //Pass any other customParams set by other add on features
        if (customParams != null && customParams != 'undefined') {
            for (i in customParams) {
                params[i] = customParams[i];
            }
            if (customParams['catalogEntryType'] == 'dynamicKit') {
                ajaxShopCartService = "AddPreConfigurationToCart";
            }
        }

        var contractIdElements = document.getElementsByName('contractSelectForm_contractId');
        if (contractIdElements != null && contractIdElements != "undefined") {
            for (i = 0; i < contractIdElements.length; i++) {
                if (contractIdElements[i].checked) {
                    params.contractId = contractIdElements[i].value;
                    break;
                }
            }
        }

        //For Handling multiple clicks
        if (!submitRequest()) {
            return;
        }
        cursor_wait();

        wcService.invoke(ajaxShopCartService, params);
        if (typeof productDisplayJS != 'undefined') {
            productDisplayJS.baseItemAddedToCart = true;
        }

        if ($("#headerShopCartLink") && $("#headerShopCartLink").css('display') !== "none") {
            $("#headerShopCart").focus();
        } else if ($("#headerShopCart1")) {
            $("#headerShopCart1").focus();
        }
    },

    /**
     * addSkus2ShopCartAjax This function is used to add one or more SKUs to the shopping cart using an AJAX call.
     * @param {String} productId the product Id being added to cart 	
     * @param {Object} customParams - Any additional parameters that needs to be passed during service invocation.
     **/
    addSkus2ShopCartAjax: function (productId, customParams) {
        if (browseOnly) {
            MessageHelper.displayErrorMessage(Utils.getLocalizationMessage('ERROR_ADD2CART_BROWSE_ONLY'));
            return;

        }
        var params = {storeId: this.storeId,
catalogId: this.catalogId,
langId: this.langId,
orderId: "."};
        // Remove calculations for performance
        // params.calculationUsage = "-1,-2,-5,-6,-7";
        params.inventoryValidation = "true";
        params.calculateOrder = "0";
        params.addedFromSKUList = "true";
        var ajaxShopCartService = "AddOrderItem";

        shoppingActionsJS.productAddedList = {};

        //Get all of the SKUs and their quantities and pass in as parameters (e.g. catEntryId_1, quantity_1)
        if (productId in this.quantityList) {
            var i = 1;
            for (var skuId in this.quantityList[productId]) {
                var quantity = this.quantityList[productId][skuId];
                if (!isPositiveInteger(quantity)) {
                    MessageHelper.displayErrorMessage(Utils.getLocalizationMessage('QUANTITY_INPUTS_ERROR'));
                    return;
                }
                params["catEntryId_" + i] = skuId;
                params["quantity_" + i] = quantity;
                i++;

                shoppingActionsJS.saveAddedProductInfo(quantity, productId, skuId, null, true);
            }
        }

        if (params.catEntryId_1 == null || params.quantity_1 == null) {
            MessageHelper.displayErrorMessage(Utils.getLocalizationMessage('QUANTITY_INPUTS_ERROR'));
            return;
        }

        //Pass any other customParams set by other add on features
        if (customParams != null && customParams != 'undefined') {
            for (i in customParams) {
                params[i] = customParams[i];
            }
            if (customParams['catalogEntryType'] == 'dynamicKit') {
                ajaxShopCartService = "AddPreConfigurationToCart";
            }
        }

        var contractIdElements = document.getElementsByName('contractSelectForm_contractId');
        if (contractIdElements != null && contractIdElements != "undefined") {
            for (i = 0; i < contractIdElements.length; i++) {
                if (contractIdElements[i].checked) {
                    params.contractId = contractIdElements[i].value;
                    break;
                }
            }
        }

        //For Handling multiple clicks
        if (!submitRequest()) {
            return;
        }
        cursor_wait();

        wcService.invoke(ajaxShopCartService, params);
        if (typeof productDisplayJS != 'undefined') {
            productDisplayJS.baseItemAddedToCart = true;
        }

        if ($("#headerShopCartLink") && $("#headerShopCartLink").css('display') !== "none") {
            $("#headerShopCart").focus();
        } else if ($("#headerShopCart1")) {
            $("#headerShopCart1").focus();
        }
    }
}

//Declare refresh function
var declareSKUListTable_WidgetRefreshArea = function (productId) {
    if(typeof productId == "object" || typeof productId == "array") {
        productId = productId[0];
    }
    var myWidgetObj = $("#WC_Sku_List_Table_" + productId);

    var postRefreshHandler = function () {
        SKUListJS.showTableView(productId);
        SKUListJS.arrangeProductDetailTable(productId);
        SKUListJS.checkOnlineAvailability(productId);
        SKUListJS.populateStoreLinks();
        cursor_clear();
    };
    // initialize widget with properties
    myWidgetObj.refreshWidget({
        postRefreshHandler: postRefreshHandler
    });
}
//-----------------------------------------------------------------
// Licensed Materials - Property of IBM
//
// WebSphere Commerce
//
// (C) Copyright IBM Corp. 2009, 2016 All Rights Reserved.
//
// US Government Users Restricted Rights - Use, duplication or
// disclosure restricted by GSA ADP Schedule Contract with
// IBM Corp.
//-----------------------------------------------------------------

/**
 * @fileOverview This javascript provides all the functions needed for the B2B store logon and registration.
 * @version 1.9
 */

B2BLogonForm ={
    prepareSubmitOrgReg:function (form){
      /////////////////////////////////////////////////////////////////////////////
      // This javascript function is for 'Submit' button in the organization registration page.
      /////////////////////////////////////////////////////////////////////////////
      reWhiteSpace = new RegExp(/^\s+$/);
      if (form.org_orgEntityName !=null && (reWhiteSpace.test(form.org_orgEntityName.value) || form.org_orgEntityName.value=="")) {
         MessageHelper.formErrorHandleClient(form.org_orgEntityName.id,MessageHelper.messages["ERROR_OrgNameEmpty"]); return;
      }
      if(!AddressHelper.validateAddressForm(form,'org_')){
          return;
      }

      if (form.usr_logonId !=null && (reWhiteSpace.test(form.usr_logonId.value) || form.usr_logonId.value=="")){
         MessageHelper.formErrorHandleClient(form.usr_logonId.id,MessageHelper.messages["ERROR_LogonIdEmpty"]); return;
      }
      if (form.usr_logonPassword !=null && (reWhiteSpace.test(form.usr_logonPassword.value) || form.usr_logonPassword.value=="")){
         MessageHelper.formErrorHandleClient(form.usr_logonPassword.id,MessageHelper.messages["ERROR_PasswordEmpty"]); return;
      }else if  (form.usr_logonPasswordVerify !=null && (reWhiteSpace.test(form.usr_logonPasswordVerify.value) || form.usr_logonPasswordVerify.value=="")) {
         MessageHelper.formErrorHandleClient(form.usr_logonPasswordVerify.id,MessageHelper.messages["ERROR_PasswordEmpty"]); return;
      }else if (form.usr_logonPasswordVerify !=null && form.usr_logonPasswordVerify.value!= form.usr_logonPassword.value) {
         MessageHelper.formErrorHandleClient(form.usr_logonPasswordVerify.id,MessageHelper.messages["PWDREENTER_DO_NOT_MATCH"]); return;
      }
      if(!AddressHelper.validateAddressForm(form,'usr_')){
         return;
      }

      if (form.usr_email1 !=null && (reWhiteSpace.test(form.usr_email1.value) || form.usr_email1.value=="")){
         MessageHelper.formErrorHandleClient(form.usr_email1.id,MessageHelper.messages["ERROR_EmailEmpty"]); return;
      }else if(!MessageHelper.isValidEmail(form.usr_email1.value)){
         MessageHelper.formErrorHandleClient(form.usr_email1.id,MessageHelper.messages["WISHLIST_INVALIDEMAILFORMAT"]);return ;
      }
      if (!MessageHelper.IsValidPhone(form.usr_phone1.value)) {
         MessageHelper.formErrorHandleClient(form.usr_phone1.id,MessageHelper.messages["ERROR_INVALIDPHONE"]);
         return ;
      }

      if(form.mobileDeviceEnabled != null && form.mobileDeviceEnabled.value == "true"){
         if(!MyAccountDisplay.validateMobileDevice(form)){
            return;
         }
      }
      if(form.birthdayEnabled != null && form.birthdayEnabled.value == "true"){
         if(!MyAccountDisplay.validateBirthday(form)){
            return;
         }
      }
      this.setSMSCheckBoxes(form);

      form.submit();
   },

    constructParentOrgDN: function (ancestorOrgs) {
      var parentOrgDN = ancestorOrgs;
      while(true) {
         var n = parentOrgDN.indexOf("/");
         if(n == -1) {
            break;
         }
         parentOrgDN = parentOrgDN.substring(0, n) + "," + orgPrefix + parentOrgDN.substring(n + 1, parentOrgDN.length);
      }
      parentOrgDN = orgPrefix + parentOrgDN;
      return parentOrgDN;
   },

   setParentMemberValue: function (){
      document.Register.parentMember.value = this.constructParentOrgDN(document.Register.ancestorOrgs.value);
   },

   fillAdminAddress: function(form, jspStoreImgDir, checkbox){
        if ($('#'+checkbox).hasClass("active")){
            $('#'+checkbox).removeClass("active");
            $('#'+checkbox).attr("aria-checked", "false");
            $('#'+checkbox).attr("src", jspStoreImgDir + "images/checkbox.png");
        } else {
            $('#'+checkbox).addClass("active");
            $('#'+checkbox).attr("src", jspStoreImgDir + "images/checkbox_checked.png");
            $('#'+checkbox).attr("aria-checked", "true");

            form.usr_address1.value = this.getFieldValue(form.org_address1);
            form.usr_address2.value = this.getFieldValue(form.org_address2);
            form.usr_zipCode.value = this.getFieldValue(form.org_zipCode);

            var $orgCountry = $('#WC_OrganizationRegistrationAddForm_AddressEntryForm_FormInput_org_country_1');
            var $usrCountry = $('#WC_OrganizationRegistrationAddForm_AddressEntryForm_FormInput_usr_country_1');

            $usrCountry.val($orgCountry.val());
            $usrCountry.Select("refresh");

            //see AddressHelper.loadAddressFormStatesUI
            AddressHelper.loadAddressFormStatesUI(form.name,'usr_','usr_stateDiv','WC_OrganizationRegistrationAddForm_AddressEntryForm_FormInput_usr_state_1',false,this.getFieldValue(form.org_state));
            form.usr_city.value = this.getFieldValue(form.org_city);
        }
   },

   getFieldValue: function (field){
      //returns the field value iff the the field value is not null or empty.
      return (field==null || field=='')?'':field.value;
   },

   setSMSCheckBoxes: function (form) {
       /*
        * In AddressForm.jsp, setSMSCheckBoxes and sendMeSMSPreference are used as the name of the checkboxes.
        * But for the command BuyerRegistrationAdd to save the data, the name of the checkboxes must be
        * converted to receiveSMSNotification and receiveSMSPreference
        * */
       if (form.sendMeSMSNotification != null) {
           var sendMeSMSNotification = $("#"+ form.sendMeSMSNotification.id);
           if (sendMeSMSNotification != null && sendMeSMSNotification.checked) {
               form.receiveSMSNotification.value = true;
           } else {
               form.receiveSMSNotification.value = false;
           }
       } else {
           form.receiveSMSNotification.value = false;
       }


       if (form.sendMeSMSPreference != null) {
           var sendMeSMSPreference =  $("#"+ form.sendMeSMSPreference.id);
           if (sendMeSMSPreference != null && sendMeSMSPreference.checked) {
               form.receiveSMS.value = true;
           } else {
               form.receiveSMS.value = false;
           }
       } else {
           form.receiveSMS.value = false;
       }
   },

   changeFormAction: function () {
        if (document.getElementById('Register').action.indexOf('UserRegistrationAdd') != -1) {
            document.getElementById('Register').action = 'BuyerRegistrationAdd';
        } else {
            document.getElementById('Register').action = 'UserRegistrationAdd';
        }

        var tempURL = document.Register.URL.value;
        document.Register.URL.value = document.Register.URLOrg.value;
        document.Register.URLOrg.value = tempURL;
    },

    toggleOrgRegistration: function () {
        $('#WC_UserRegistrationAddForm_DivForm_1').toggleClass('nodisplay');
        this.toggleInputs($('#WC_UserRegistrationAddForm_DivForm_1'));
        $('#WC_OrganizationRegistration_DivForm_1').toggleClass('nodisplay');
        $('#WC_OrganizationRegistration_DivForm_2').toggleClass('nodisplay');
        this.disableOrgInputs();
        $('#WC_UserRegistrationAddForm_Buttons_1').toggleClass('nodisplay');
        $('#WC_OrganizationRegistration_Buttons_1').toggleClass('nodisplay');
        this.changeFormAction();
    },

    toggleInputs: function (form) {
                if ($('input, select', form).attr('disabled')) {
                        $('input, select', form).removeAttr('disabled');
                } else {
                        $('input, select', form).attr('disabled', 'disabled');
                }

    },

    disableOrgInputs: function () {
        this.toggleInputs($('#WC_OrganizationRegistration_DivForm_1'));
        this.toggleInputs($('#WC_OrganizationRegistration_DivForm_2'));
    },

    checkRegisterOrg: function (checked) {
        if (checked) {
            this.switchRegistration();
        }
    },

    submitForm: function (form) {
        //check to make sure Buyer Organization is set.
        var reWhiteSpace = new RegExp(/^\s+$/);
        if (form.ancestorOrgs !=null && reWhiteSpace.test(form.ancestorOrgs.value) || form.ancestorOrgs.value=="") {
            MessageHelper.formErrorHandleClient(form.ancestorOrgs.id,MessageHelper.messages["ERROR_OrgNameEmpty"]); return;
        }

        //set the value of buyer organization
        B2BLogonForm.setParentMemberValue(form);

        //set the SMS values
        B2BLogonForm.setSMSCheckBoxes(form);

        //now submit the form
        LogonForm.prepareSubmit(form);
        return false;
    },

    switchRegistration: function (id) {
        $('#registration_arrow').toggleClass('right');
        $('#individual_link').toggleClass('nodisplay');
        $('#individual_image_on').toggleClass('nodisplay');
        $('#organization_link').toggleClass('nodisplay');
        $('#organization_image_on').toggleClass('nodisplay');
        $('#organizationDescription').toggleClass('nodisplay');
        $('#individualDescription').toggleClass('nodisplay');

        if (id == 'individual_link') {
            $('#organization_link').focus();
        } else {
            $('#individual_link').focus();
        }
        this.toggleOrgRegistration();
    },
}
//-----------------------------------------------------------------
// Licensed Materials - Property of IBM
//
// WebSphere Commerce
//
// (C) Copyright IBM Corp. 2007, 2013 All Rights Reserved.
//
// US Government Users Restricted Rights - Use, duplication or
// disclosure restricted by GSA ADP Schedule Contract with
// IBM Corp.
//-----------------------------------------------------------------

/**
 *@fileOverview This javascript file defines all the javascript functions used by requisition list detail widget
 */

	ReqListInfoJS = {
			
		/** 
		 * This variable stores the ID of the language that the store currently uses. Its default value is set to -1, which corresponds to United States English.
		 * @private
		 */
		langId: "-1",
		
		/** 
		 * This variable stores the ID of the current store. Its default value is empty.
		 * @private
		 */
		storeId: "",
		
		/** 
		 * This variable stores the ID of the catalog. Its default value is empty.
		 * @private
		 */
		catalogId: "",

		/**			
		* This variable keeps track of the requisition list type. The choice can be private ('Y') or shared ('Z')
		*/
		status: "",

		/**
		 * Sets the common parameters for the current page. 
		 * For example, the language ID, store ID, and catalog ID.
		 *
		 * @param {Integer} langId The ID of the language that the store currently uses.
		 * @param {Integer} storeId The ID of the current store.
		 * @param {Integer} catalogId The ID of the catalog.
		 */
		setCommonParameters: function(langId,storeId,catalogId,status){
			this.langId = langId;
			this.storeId = storeId;
			this.catalogId = catalogId;
			this.status = status;
		},

		/**
		* Sets the status of the requisition list and update the dropdown to display the current status.
		*
		* @param {String} status The status to set for the requisition list
		* @param {String} statusDisplay The text to show for the requisition list type dropdown (private or shared)
		* @param {String} selectDropdown id of the HTML div that represents the dropdown
		*/		
		setListStatus: function(status, statusDisplay, selectDropdown) {
			this.status = status;
			$("#reqListInfo_curStatus").html(statusDisplay);
			this.toggleSelectDropdown(selectDropdown);
		},
		
		/**
		 * Updates the name or type or both of a requisition list.
		 * @param (object) formName The form that contains the new requisition list data.
		 */
		updateReqList: function(formName) {
			MessageHelper.hideAndClearMessage();
			var form = document.forms[formName];
			if (form.reqListInfo_name!=null && this.isEmpty(form.reqListInfo_name.value)) {
				MessageHelper.formErrorHandleClient(form.reqListInfo_name.id,MessageHelper.messages["ERROR_REQUISITION_LIST_NAME_EMPTY"]); return;
			}

			form.reqListInfo_name.value = trim(form.reqListInfo_name.value);
			form.reqListInfo_type.value = this.status;
			
			//Need to give the service declaration the form with all info about all req list info
			service = wcService.getServiceById("requisitionListUpdate");
			service.setFormId(formName);
			
			if(!submitRequest()){
				return;
			}
			cursor_wait();
			
			//This only updates the name and type for req list since another command updates items separately
			//After successful name/type update, success handler will trigger quantity update service call		
			wcService.invoke('requisitionListUpdate');
		},

		/**
		* Toggles the edit area of requisition list info section
		*/
		toggleEditInfo: function() {
			if ($("#requisitionListCurrentInfo").css('display') === ('none')) {
				$("#toolbarButton1").addClass("button_primary");
				$("#requisitionListCurrentInfo").css('display', 'block');
				$("#editRequisitionListInfo").css('display', 'none');
			} else {
				$("#toolbarButton1").addClass("button_secondary");
				$("#requisitionListCurrentInfo").css('display', 'none');				
				$("#editRequisitionListInfo").css('display', 'block');	
			}
		},

		/**
		* Toggles the requisition list type dropdown
		* @param {String} selectDropdown id of the HTML div that represents the dropdown
		*/		
		toggleSelectDropdown: function(selectDropdown) {
			if ($("#"+selectDropdown).css('display') === 'none') {
				$("#"+selectDropdown).css('display', 'block');
			}	else {
				$("#"+selectDropdown).css('display', 'none');
			}
		},

		/**
		 * Checks if a string is null or empty.
		 * @param (string) str The string to check.
		 * @return (boolean) Indicates whether the string is empty.
		 */
		isEmpty: function(str) {
			var reWhiteSpace = new RegExp(/^\s+$/);
			if (str == null || str =='' || reWhiteSpace.test(str) ) {
				return true;
			}
			return false;
		},

	}//-----------------------------------------------------------------
// Licensed Materials - Property of IBM
//
// WebSphere Commerce
//
// (C) Copyright IBM Corp. 2007, 2013 All Rights Reserved.
//
// US Government Users Restricted Rights - Use, duplication or
// disclosure restricted by GSA ADP Schedule Contract with
// IBM Corp.
//-----------------------------------------------------------------

/**
 *@fileOverview This javascript file defines all the javascript functions used by requisition list items widget
 */

	ReqListItemsJS = {
			
		/** 
		 * This variable stores the ID of the language that the store currently uses. Its default value is set to -1, which corresponds to United States English.
		 * @private
		 */
		langId: "-1",
		
		/** 
		 * This variable stores the ID of the current store. Its default value is empty.
		 * @private
		 */
		storeId: "",
		
		/** 
		 * This variable stores the ID of the catalog. Its default value is empty.
		 * @private
		 */
		catalogId: "",
		
		/**
		* This variable stores the ID of the requisition list. Its default value is empty.
		*/
		requisitionListId: "",

		/**
		 * Sets the common parameters for the current page. 
		 * For example, the language ID, store ID, and catalog ID.
		 *
		 * @param {Integer} langId The ID of the language that the store currently uses.
		 * @param {Integer} storeId The ID of the current store.
		 * @param {Integer} catalogId The ID of the catalog.
		 * @param {Integer} requisitionListId The ID of the requisition list.
		 */
		setCommonParameters: function(langId,storeId,catalogId,requisitionListId){
			this.langId = langId;
			this.storeId = storeId;
			this.catalogId = catalogId;
			this.requisitionListId = requisitionListId;
		},

		/**
		 * Adds an item to the requisition list.
		 * @param (object) formName The form that contains the items to add to the requisition list.
		 */
		addItemToReqList:function(formName){
			MessageHelper.hideAndClearMessage();
			var form = document.forms[formName];
			if (form.skuAdd!=null && this.isEmpty(form.skuAdd.value.replace(/^\s+|\s+$/g, ''))) {
				MessageHelper.formErrorHandleClient(form.skuAdd.id,MessageHelper.messages["ERROR_REQUISITION_LIST_SKU_EMPTY"]); return;
			}else if (form.quantityAdd!=null && this.isEmpty(form.quantityAdd.value.replace(/^\s+|\s+$/g, ''))) {
				form.quantityAdd.value = "1";
			}else if (!this.isNumber(form.quantityAdd.value.replace(/^\s+|\s+$/g, '')) || form.quantityAdd.value.replace(/^\s+|\s+$/g, '') <= 0) {
				MessageHelper.formErrorHandleClient(form.quantityAdd.id,MessageHelper.messages["ERROR_REQUISITION_LIST_QUANTITY_ONE_OR_MORE"]); return;
			}
			
			var params = {
			requisitionListId: form.requisitionListId.value,
			partNumber: form.skuAdd.value.replace(/^\s+|\s+$/g, ''),
			quantity: form.quantityAdd.value.replace(/^\s+|\s+$/g, ''),
			operation: "addItem",
			storeId: this.storeId,
			catalogId: this.catalogId,
			langId: this.langId			
			};
			/*For Handling multiple clicks. */
			if(!submitRequest()){
				return;
			}			
			cursor_wait();
			wcService.invoke('requisitionListAddItem',params);
		},
	
		/**
		 * Updates the quantities of each item in the requisition list, if the quantities are changed.
		 * This function is automatically called by the sucessHandler of requisitionListUpdate.
		 * @see RequisitionList.updateReqList()
		 * @see MyAccountServiceDeclaration.js requisitionListUpdate declaration
		 * @param (string) requisitionListId The ID of the requisition list to update.
		 */
		updateItemQuantity:function (qtyDiv, orderItemId, row) {
		
			var params={
			requisitionListId: this.requisitionListId,
			quantity: $(qtyDiv).val(),
			orderItemId: orderItemId,
			storeId: this.storeId,
			catalogId: this.catalogId,
			langId: this.langId,
			operation: "updateQty",
			row: row
			};
			if(!submitRequest()){
				return;
			}
			cursor_wait();
			wcService.invoke('requisitionListUpdateItem',params);
		},

		/**
		* Shows the "quantity updated" message next to quantity input
		* @param {Integer} row The row number of the quantity input in the table
		*/		
		showUpdatedMessage: function(row) {
			$('#reqItem_msg_qty_updated_'+row).css('display','block');
			$('#table_r'+row+'_input2').css('border','1px solid #006ecc');
			setTimeout("ReqListItemsJS.hideUpdatedMessage("+row+")", 5000);
		},

		/**
		* Hides the "quantity updated" message next to quantity input
		* @param {Integer} row The row number of the quantity input in the table
		*/		
		hideUpdatedMessage: function(row) {
			$('#reqItem_msg_qty_updated_'+row).css('display','none');
			$('#table_r'+row+'_input2').css('border','1px solid #b7b7b7');
		},
		
		/**
		 * Deletes an item from the requisition list for the Ajax flow.
		 * @param (string) orderItemId The item to delete from the requisition list.
		 */
		deleteItemFromReqList:function (orderItemId) {
			var params = {
			requisitionListId: this.requisitionListId,
			orderItemId: orderItemId,
			quantity: "0",
			storeId: this.storeId,
			catalogId: this.catalogId,
			langId: this.langId,	
			operation: "deleteItem"
			};
			/*For Handling multiple clicks. */
			if(!submitRequest()){
				return;
			}			
			cursor_wait();
			wcService.invoke('requisitionListDeleteItem',params);
		},

		/**
		 * Adds all of the order items from the current requisition list to the current order.
		 * Checks whether the current requisition list contains items.
		 */
		addListToOrder:function () {
			var form = document.forms["RequisitionListAddToCartForm"];
			var formElements = form.elements;
			var params = {};

			for(var i = 0; i < formElements.length; i++) {
				if (formElements[i].name.indexOf("quantity") == -1 && formElements[i].name.indexOf("ProductInfo") == -1) {
					// ingore all hidden "quantity" and "ProductInfo" inputs - do not add to params
					params[formElements[i].name] = formElements[i].value;
				}
			}
									
			MessageHelper.hideAndClearMessage();
	
			//For Handling multiple clicks
			if(!submitRequest()){
				return;
			} 
			
			cursor_wait();
			service = wcService.getServiceById('requisitionListAjaxPlaceOrder');
			service.formId = form;
			wcService.invoke('requisitionListAjaxPlaceOrder', params);
		},			

		/**
		 * Adds selected item from the current requisition list to the current order.
		 * @param (String) catEntryId catentry id of the item to be added to the current order
		 * @param (String) partNumber part number of the item to be added to the current order
		 * @param (String) row row number of the item in the requisition list
		 */
		addItemToOrder:function (catEntryId,partNumber,row) {
			var form = document.forms["RequisitionListAddToCartForm"];
			var formElements = form.elements;
			var params = {};
			
			for(var i = 0; i < formElements.length; i++) {
				if (formElements[i].name.indexOf("quantity") != -1) {
					if(formElements[i].name.indexOf("quantity_"+row) != -1) {
						// just add quantity of the specified row to params
						params["quantity"] = formElements[i].value;
					}
				} else if (formElements[i].name.indexOf("ProductInfo") == -1) {
					// ingore all hidden "ProductInfo" inputs - do not add to params
					params[formElements[i].name] = formElements[i].value;
				}
			}
			params["partNumber"] = partNumber;
			params["inventoryValidation"] = true;
			params["orderId"] = ".";
			
			// used by mini shopcart
			var selectedAttrList = new Object();
			shoppingActionsJS.saveAddedProductInfo(params["quantity"], catEntryId, catEntryId, selectedAttrList);
			
			MessageHelper.hideAndClearMessage();
	
			//For Handling multiple clicks
			if(!submitRequest()){
				return;
			} 
			
			cursor_wait();
			wcService.invoke('ReqListAddOrderItem',params);
			
			// close action dropdown
			hideMenu($('#RequisitionListItems_actionButton'+row));
			hideMenu($('#RequisitionListItems_actionDropdown'+row));
		},	
			
		/**
		* This function is called when user selects a different page from the current page
		* @param (Object) data The object that contains data used by pagination control 
		*/
		showResultsPage:function(data){
			var pageNumber = data['pageNumber'];
			var pageSize = data['pageSize'];
			pageNumber = Number(pageNumber);
			pageSize = Number(pageSize);

			setCurrentId(data["linkId"]);

			if(!submitRequest()){
				return;
			}

			var beginIndex = pageSize * ( pageNumber - 1 );
			cursor_wait();

			wcRenderContext.updateRenderContext('RequisitionListItemTable_Context', {"beginIndex": beginIndex, "requisitionListId":this.requisitionListId});
			MessageHelper.hideAndClearMessage();
		},
		
		/**
		 * Checks if the string is an integer.
		 * @param (string) str The string to check.
		 * @return (boolean) Indicates whether the string is a number.
		 */
		isNumber:function (str) {
			if ((str*0)==0) return true;
			else return false;
		},		
		
		/**
		 * Checks if a string is null or empty.
		 * @param (string) str The string to check.
		 * @return (boolean) Indicates whether the string is empty.
		 */
		isEmpty: function(str) {
			var reWhiteSpace = new RegExp(/^\s+$/);
			if (str == null || str =='' || reWhiteSpace.test(str) ) {
				return true;
			}
			return false;
		},

	}//-----------------------------------------------------------------
// Licensed Materials - Property of IBM
//
// WebSphere Commerce
//
// (C) Copyright IBM Corp. 2014 All Rights Reserved.
//
// US Government Users Restricted Rights - Use, duplication or
// disclosure restricted by GSA ADP Schedule Contract with
// IBM Corp.
//-----------------------------------------------------------------

/** 
 * @fileOverview This file provides all the functions and variables to manage requisition lists and the items within.
 * This file is included in all pages with requisition list actions.
 */


/**
 * This class defines the functions and variables that customers can use to create, update, and view their requisition lists.
 * @class The RequisitionListJS class defines the functions and variables that customers can use to manage their requisition lists, 
 */
RequisitionListJS ={		
		
	/** 
	 * This variable stores the ID of the language that the store currently uses. Its default value is set to -1, which corresponds to United States English.
	 * @private
	 */
	langId: "-1",
	
	/** 
	 * This variable stores the ID of the current store. Its default value is empty.
	 * @private
	 */
	storeId: "",
	
	/** 
	 * This variable stores the ID of the catalog. Its default value is empty.
	 * @private
	 */
	catalogId: "",					
	
	/**
	 * Sets the common parameters for the current page. 
	 * For example, the language ID, store ID, and catalog ID.
	 *
	 * @param {Integer} langId The ID of the language that the store currently uses.
	 * @param {Integer} storeId The ID of the current store.
	 * @param {Integer} catalogId The ID of the catalog.
	 */
	setCommonParameters:function(langId,storeId,catalogId){
		this.langId = langId;
		this.storeId = storeId;
		this.catalogId = catalogId;
		cursor_clear();
	},	
	
	/**
	 * Initialize the URL of Requisition List widget controller. 	 
	 *
	 * @param {object} widgetUrl The controller's URL.
	 */
	initRequisitionListUrl:function(widgetUrl){
		$("#RequisitionListTable_Widget").refreshWidget("updateUrl", widgetUrl);
	},
		
	/**
	 * Creates an empty requisition list.
	 * @param (object) formName The form which contains the name and type of the requisition list.
	 * @param (object) widgetName The widget name.
	 */
	createNewList:function() {			
		var form_name = document.getElementById("RequisitionList_NewListForm_Name");
		if (form_name !=null && this.isEmpty(form_name.value)) {
			MessageHelper.formErrorHandleClient(form_name.id,MessageHelper.messages["LIST_TABLE_NAME_EMPTY"]); return;
		}				
		service = wcService.getServiceById('requisitionListCreate');
		service.setFormId("newListDropdown");
		var params = {
		editable: "true",
		storeId: this.storeId,
		catalogId: this.catalogId,
		langId: this.langId
		};
			
		/*For Handling multiple clicks. */
		if(!submitRequest()){
			return;
		}			
		cursor_wait();
		wcService.invoke('requisitionListCreate',params);		
	},
	/**
	 * Deletes a requisition list
	 * @param (string) requisitionListId The identifier of the selected requisition list.
	 */
	deleteList:function (requisitionListId) {
		var params = {
		requisitionListId: requisitionListId,
		filterOption: "All",
		storeId: this.storeId,
		catalogId: this.catalogId,
		langId: this.langId		
		};
		/*For Handling multiple clicks. */
		if(!submitRequest()){
			return;
		}			
		cursor_wait();
		wcService.invoke('AjaxRequisitionListDelete',params);
	},
	
	/**
	 * Create a duplicated requisition list.
	 * @param (object) name The name of the new requisition.
	 * @param (object) status The status of the new requisition.
	 * @param (string) orderId The order to create the requisition list from.
	 */
	duplicateReqList:function (name,status,orderId) {
		MessageHelper.hideAndClearMessage();
						
		var params = {
		editable: "true",
		storeId: this.storeId,
		catalogId: this.catalogId,
		langId: this.langId,
		orderId: orderId,	
		name: name,
		status: status
		};
			
		if(!submitRequest()){
			return;
		}
		cursor_wait();
		wcService.invoke('requisitionListCopy',params);		
	},		
	
	/**
	 * This function sets the url for AjaxRequisitionListSubmit service and then it invokes the service to copy the old order.
	 * @param {string} AddToCartURL The url for the order copy service.
	 */
	addReqListToCart:function(AddToCartURL){

		/*For Handling multiple clicks. */
		if(!submitRequest()){
			return;
		}   		
		cursor_wait();
		
		wcService.getServiceById("addRequisitionListToCart").setUrl(AddToCartURL);
		wcService.invoke("addRequisitionListToCart");
	},
	
	/**
	 * Checks if a string is null or empty.
	 * @param (string) str The string to check.
	 * @return (boolean) Indicates whether the string is empty.
	 */
	isEmpty:function (str) {
		var reWhiteSpace = new RegExp(/^\s+$/);
		if (str == null || str =='' || reWhiteSpace.test(str) ) {
			return true;
		}
		return false;
	},
	
	/**
	 * Uploads a new requisition list file for processing.
	 * @param (object) formObj A reference to a form element containing the new requisition list CSV to upload.
	 * @param (object) inputObject A reference to an input element to show an error message against.
	 */		
	submitAndUploadReqList:function(formObj, inputObject) {
		MessageHelper.hideAndClearMessage();
		
		if (formObj.UpLoadedFile.value=='') {
			if (inputObject) {
				MessageHelper.formErrorHandleClient(inputObject.id,MessageHelper.messages["ERROR_REQUISITION_UPLOAD_FILENAME_EMPTY"]); 
			}
			return;
		}
		formObj.submit();
	},

	/**
	 * Show requisition list results based on page number
	 * @param (object) data The object contains page number, page size, linkId
	 */
	showResultsPageNumberForRequisitionList:function(data){
		var pageNumber = data['pageNumber'];
		var pageSize = data['pageSize'];
		pageNumber = Number(pageNumber);
		pageSize = Number(pageSize);
		
		setCurrentId(data["linkId"]);
		if(!submitRequest()){
			return;
		}
		
		var beginIndex = pageSize * (pageNumber -1);
		cursor_wait();
		wcRenderContext.updateRenderContext("RequisitionListTable_Context", {"beginIndex":beginIndex , "orderBy":""},"");
	}
}

/** 
 * Add a click event listener to the <i>uploadButton</i> on the requisition list page 
 * only if the browser is not IE.
*/ 
$( document ).ready(function() { 
    var ie_version = Utils.get_IE_version();
    if (!ie_version ) {
		var RequisitionListWidgetDom = $('#RequisitionListTable_Widget');
		if (RequisitionListWidgetDom) {		
				$(RequisitionListWidgetDom).on("click", "#uploadButton", function(e){
				$('#UpLoadedFile').click();
				if (e.preventDefault) {
					e.preventDefault();
				}				
			});
		}
	};
});
//-----------------------------------------------------------------
// Licensed Materials - Property of IBM
//
// WebSphere Commerce
//
// (C) Copyright IBM Corp. 2014 All Rights Reserved.
//
// US Government Users Restricted Rights - Use, duplication or
// disclosure restricted by GSA ADP Schedule Contract with
// IBM Corp.
//-----------------------------------------------------------------


/**
 * Declares a new render context for creating a new list.
 */


/**
 * Declares a new refresh controller for creating a new List.
 */
function declareRequisitionListTableRefreshArea() {
    var myWidgetObj = $("#RequisitionListTable_Widget");
    wcRenderContext.declare("RequisitionListTable_Context", ["RequisitionListTable_Widget"], {
        "beginIndex": "0",
        "orderBy": ""
    }, "");




    var myRCProperties = wcRenderContext.getRenderContextProperties("RequisitionListTable_Context");


    var renderContextChangedHandler = function () {
        myWidgetObj.refreshWidget("refresh", myRCProperties);
    };
	   
    wcTopic.subscribe(['requisitionListCreate', 'AjaxRequisitionListDelete', 'requisitionListCopy'], function () {
        myWidgetObj.refreshWidget("refresh", myRCProperties);

    });

	/** 
     * Clears the progress bar*/

     var postRefreshHandler = function() {
		 cursor_clear();
		 
		 toggleMobileView();
	}
        // initialize widget
    myWidgetObj.refreshWidget({
        renderContextChangedHandler: renderContextChangedHandler,
        postRefreshHandler: postRefreshHandler
});
};
//-----------------------------------------------------------------
// Licensed Materials - Property of IBM
//
// WebSphere Commerce
//
// (C) Copyright IBM Corp. 2014 All Rights Reserved.
//
// US Government Users Restricted Rights - Use, duplication or
// disclosure restricted by GSA ADP Schedule Contract with
// IBM Corp.
//-----------------------------------------------------------------

/**
 * @fileOverview This javascript is used by the Requisition List pages to handle the services for
 * creating/deleting/updating requisition lists and adding/removing/updating items from a requisition list.
 * @version 1.10
 */


/**
 * This service allows customer to create a new requisition list
 * @constructor
 */
wcService.declare({
	id:"requisitionListCreate",
	actionId:"requisitionListCreate",
	url:"AjaxRESTRequisitionListCreate",
	formId:""

	 /**
	 * Hides all the messages and the progress bar.
	 * @param (object) serviceResponse The service response object, which is the
	 * JSON object returned by the service invocation.
	 */
	,successHandler: function(serviceResponse) {
		MessageHelper.hideAndClearMessage();
		cursor_clear();
		MessageHelper.displayStatusMessage(MessageHelper.messages["MYACCOUNT_REQUISITIONLIST_CREATE_SUCCESS"]);
	}

	/**
	 * display an error message.
	 * @param (object) serviceResponse The service response object, which is the
	 * JSON object returned by the service invocation.
	 */
	,failureHandler: function(serviceResponse) {

		if (serviceResponse.errorMessage) {
			MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
		}
		else {
			 if (serviceResponse.errorMessageKey) {
				MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
			 }
		}
		cursor_clear();
	}
}),
/**
 * This service deletes an existing requisition list.
 * @constructor
 */
wcService.declare({
	id:"AjaxRequisitionListDelete",
	actionId:"AjaxRequisitionListDelete",
	url:"AjaxRESTRequisitionListDelete",
	formId:""

	 /**
	 * Hides all the messages and the progress bar.
	 * @param (object) serviceResponse The service response object, which is the
	 * JSON object returned by the service invocation.
	 */
	,successHandler: function(serviceResponse) {
		MessageHelper.hideAndClearMessage();
		cursor_clear();
		MessageHelper.displayStatusMessage(MessageHelper.messages["MYACCOUNT_REQUISITIONLIST_DELETE_SUCCESS"]);
	}

	/**
	 * display an error message.
	 * @param (object) serviceResponse The service response object, which is the
	 * JSON object returned by the service invocation.
	 */
	,failureHandler: function(serviceResponse) {

		if (serviceResponse.errorMessage) {
			MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
		}
		else {
			 if (serviceResponse.errorMessageKey) {
				MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
			 }
		}
		cursor_clear();
	}
}),

/**
* This service allows customer to add a requisition list to shopping cart.
* @constructor
*/
wcService.declare({
	id: "addRequisitionListToCart",
	actionId: "addRequisitionListToCart",
	url: "AjaxRESTRequisitionListSubmit",
	formId: ""

	 /**
	  *  Copies all the items from the existing order to the shopping cart.
	  *  @param (object) serviceResponse The service response object, which is the
	  *  JSON object returned by the service invocation.
	  */
	,successHandler: function(serviceResponse) {
		for (var prop in serviceResponse) {
			console.debug(prop + "=" + serviceResponse[prop]);
		}
		setDeleteCartCookie();
		cursor_clear();
		document.location.href="RESTOrderCalculate?calculationUsage=-1,-2,-3,-4,-5,-6,-7&updatePrices=1&doConfigurationValidation=Y&errorViewName=AjaxOrderItemDisplayView&orderId=.&langId="+serviceResponse.langId+"&storeId="+serviceResponse.storeId+"&catalogId="+serviceResponse.catalogId+"&URL=AjaxCheckoutDisplayView";
	}
	/**
	 * display an error message.
	 * @param (object) serviceResponse The service response object, which is the
	 * JSON object returned by the service invocation.
	 */
	,failureHandler: function(serviceResponse) {
		if (serviceResponse.errorMessageKey == "_ERR_PROD_NOT_ORDERABLE") {
			MessageHelper.displayErrorMessage(MessageHelper.messages["PRODUCT_NOT_BUYABLE"]);
		} else if (serviceResponse.errorMessageKey == "_ERR_INVALID_ADDR") {
			MessageHelper.displayErrorMessage(MessageHelper.messages["INVALID_CONTRACT"]);
		}else {
			if (serviceResponse.errorMessage) {
				MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
			}
			else {
				 if (serviceResponse.errorMessageKey) {
					MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
				 }
			}
		}
		cursor_clear();
	}
}),

/**
* This service allows customer to create a requisition list from an existing requisition list.
* @constructor
*/
wcService.declare({
	id:"requisitionListCopy",
	actionId:"requisitionListCopy",
	url:"AjaxRESTRequisitionListCopy",
	formId:""

	 /**
	* Hides all the messages and the progress bar.
	* @param (object) serviceResponse The service response object, which is the
	* JSON object returned by the service invocation.
	*/
	,successHandler: function(serviceResponse) {
		MessageHelper.hideAndClearMessage();
		cursor_clear();
		MessageHelper.displayStatusMessage(MessageHelper.messages["MYACCOUNT_REQUISITIONLIST_CREATE_SUCCESS"]);
	}

	/**
	* display an error message.
	* @param (object) serviceResponse The service response object, which is the
	* JSON object returned by the service invocation.
	*/
	,failureHandler: function(serviceResponse) {

		if (serviceResponse.errorMessage) {
			var errorMsg = serviceResponse.errorMessage;
			//If the errorMessage param is the generic error message
			//Display the systemMessage instead
			if(errorMsg.search("CMN3101E") != -1){
				//If systemMessage is not empty, display systemMessage
				if(serviceResponse.systemMessage){
					MessageHelper.displayErrorMessage(serviceResponse.systemMessage);
				} else {
					//If systemMessage is empty, then just display the generic error message
					MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
				}
			} else {
				//If errorMessage is not generic, display errorMessage
				MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
			}
		}
		else {
			 if (serviceResponse.errorMessageKey) {
				MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
			 }
		}
		cursor_clear();
	}
})
//-----------------------------------------------------------------
// Licensed Materials - Property of IBM
//
// WebSphere Commerce
//
// (C) Copyright IBM Corp. 2014, 2016 All Rights Reserved.
//
// US Government Users Restricted Rights - Use, duplication or
// disclosure restricted by GSA ADP Schedule Contract with
// IBM Corp.
//-----------------------------------------------------------------

/**
 *@fileOverview This javascript file defines all the javascript functions used by saved order detail widget
 */

	SavedOrderInfoJS = {

			/** 
			 * This variable stores the ID of the language that the store currently uses. Its default value is set to -1, which corresponds to United States English.
			 * @private
			 */
			langId: "-1",
			
			/** 
			 * This variable stores the ID of the current store. Its default value is empty.
			 * @private
			 */
			storeId: "",
			
			/** 
			 * This variable stores the ID of the catalog. Its default value is empty.
			 * @private
			 */
			catalogId: "",

			/** 
			 * This variable stores the order ID of the saved order. Its default value is empty.
			 */
			orderId : "",
			
			/**
			 * Sets the common parameters for the current page. 
			 * For example, the language ID, store ID, and catalog ID.
			 *
			 * @param {Integer} langId The ID of the language that the store currently uses.
			 * @param {Integer} storeId The ID of the current store.
			 * @param {Integer} catalogId The ID of the catalog.
			 */
			setCommonParameters:function(langId,storeId,catalogId){
				this.langId = langId;
				this.storeId = storeId;
				this.catalogId = catalogId;
			},
	
			/**
			 * Updates the name/description of a saved order.
			 * @param (object) formName The form that contains the saved order name.
			 * 
			 */
			updateDescription: function(formName) {
				MessageHelper.hideAndClearMessage();
				var form = document.forms[formName];
				
				form.savedOrderInfo_name.value = trim(form.savedOrderInfo_name.value);
				form.oldSavedOrderInfo_name.value = trim(form.oldSavedOrderInfo_name.value);
				
				var desc = form.savedOrderInfo_name;
				var oldDesc = form.oldSavedOrderInfo_name;

				// Check to see if the order description has really changed by comparing it to the original value.
				if (desc != oldDesc) {
					//Need to give the service declaration the form with all info about saved order name info
					service = wcService.getServiceById("savedOrderUpdateDescription");
					service.setFormId(formName);
					
					if(!submitRequest()){
						return;
					}
					cursor_wait();
					
					//This updates the name/description of the saved order		
					wcService.invoke('savedOrderUpdateDescription');
				}

			},

			/**
			* Toggles the edit area of saved order info section
			*/
			toggleEditInfo:function() {
				if ($("#savedOrderCurrentInfo").css("display") === "none") {
					$("#savedOrderCurrentInfo").css("display", "block");
					$("#editSavedOrderInfo").css("display", "none");
				} else {
					$("#savedOrderCurrentInfo").css("display", "none");				
					$("#editSavedOrderInfo").css("display", "block");	
				}
			},
			
			/**
			 * Checks if a string is null or empty.
			 * @param (string) str The string to check.
			 * @return (boolean) Indicates whether the string is empty.
			 */
			isEmpty: function(str) {
				var reWhiteSpace = new RegExp(/^\s+$/);
				if (str == null || str =='' || reWhiteSpace.test(str) ) {
					return true;
				}
				return false;
			},
      
                        /**
                         *This method toggles the lock set on the order. It submits the 'savedOrderToggleLockForm' form declared.
                         *Based on the action defined in the form, the order is either locked or unlocked.                         
                         */                                                       
                        toggleOrderLock: function(){
                                document.forms['savedOrderToggleLockForm'].URL.value = document.location.href;
                                document.forms['savedOrderToggleLockForm'].submit();
                                return true;
                        }
	}
  
//-----------------------------------------------------------------
// Licensed Materials - Property of IBM
//
// WebSphere Commerce
//
// (C) Copyright IBM Corp. 2014, 2016 All Rights Reserved.
//
// US Government Users Restricted Rights - Use, duplication or
// disclosure restricted by GSA ADP Schedule Contract with
// IBM Corp.
//-----------------------------------------------------------------

/**
 *@fileOverview This javascript file defines all the javascript functions used by saved order detail widget
 */

	SavedOrderItemsJS = {

			/** 
			 * This variable stores the ID of the language that the store currently uses. Its default value is set to -1, which corresponds to United States English.
			 * @private
			 */
			langId: "-1",
			
			/** 
			 * This variable stores the ID of the current store. Its default value is empty.
			 * @private
			 */
			storeId: "",
			
			/** 
			 * This variable stores the ID of the catalog. Its default value is empty.
			 * @private
			 */
			catalogId: "",

			/** 
			 * This variable stores the order ID of the saved order. Its default value is empty.
			 */
			orderId : "",
			
			/**
			 * This variable stores the current order ID. Its default value is empty.
			 */
			currentOrderId : "",
			
			/** The currently selected row. **/
			currentRow : "",
			
			/** The URL of the shopping cart used to forward the page when an order is converted to the current order. **/
			shoppingCartURL : "",
			
			/**
			 * Sets the common parameters for the current page. 
			 * For example, the language ID, store ID, and catalog ID.
			 *
			 * @param {Integer} langId The ID of the language that the store currently uses.
			 * @param {Integer} storeId The ID of the current store.
			 * @param {Integer} catalogId The ID of the catalog.
			 * @param {Integer} orderId The ID of the saved order.
			 */
			setCommonParameters:function(langId,storeId,catalogId,orderId){
				this.langId = langId;
				this.storeId = storeId;
				this.catalogId = catalogId;
				this.orderId = orderId;
			},

			/**
			 * Returns the current row.
			 * @returns {String} The current row number.
			 **/
			getCurrentRow:function() {
				return this.currentRow;
			},
			
			/**
			 * Resets the current row variable.
			 **/
			resetCurrentRow:function() {
				this.currentRow = "";
			},
			
			/**
			 * Sets the URL of the current shopping cart view.
			 *
			 * @param shoppingCartURL The URL of the shopping cart view.
			 */
			setCurrentShoppingCartURL : function(shoppingCartURL)
			{
				this.shoppingCartURL = shoppingCartURL;
			},
			
			/**
			 * Returns the URL of the shopping cart view.
			 * @returns {String} The URL of the shopping cart view.
			 **/
			getCurrentShoppingCartURL:function() {
				return this.shoppingCartURL;
			},
			
			/**
			 * Initialize the URL of Saved Order Items widget controller. 	 
			 *
			 * @param {object} widgetUrl The controller's URL.
			 */
			initSavedOrderItemsUrl:function(widgetUrl){
				$("#SavedOrderItemTable_Widget").attr("refreshurl", widgetUrl);
			},

			/**
			 * This function validates the SKU input values and their corresponding quantities 
			 * before sending the request to the server to add the SKUs to the saved order.
			 * An error message would be displayed if the inputs are invalid and the requested will be stopped.
			 * @param (object) formName The form that contains the items to add to the requisition list.
			 */
			addItemToSavedOrder:function(formName){
				MessageHelper.hideAndClearMessage();
				var form = document.forms[formName];
				if (form.skuAdd != null && this.isEmpty(form.skuAdd.value)) {
					MessageHelper.formErrorHandleClient(form.skuAdd.id,MessageHelper.messages["SAVED_ORDER_EMPTY_SKU"]); return;
				}else if (form.quantityAdd != null && this.isEmpty(form.quantityAdd.value)) {
					form.quantityAdd.value = "1";
				}else if (isNaN(form.quantityAdd.value) || form.quantityAdd.value <= 0) {
					MessageHelper.formErrorHandleClient(form.quantityAdd.id,MessageHelper.messages["ERROR_SAVED_ORDER_QUANTITY_ONE_OR_MORE"]); return;
				}
				
				var params = {
					orderId: form.orderId.value,
					partNumber: form.skuAdd.value,
					quantity: form.quantityAdd.value,
					calculationUsage : form.calculationUsage.value,
					calculateOrder: "1",
					storeId : this.storeId,
					catalogId : this.catalogId,
					langId : this.langId
				};
				
				/*For Handling multiple clicks. */
				if(!submitRequest()){
					return;
				}
				cursor_wait();
				wcService.invoke('AjaxAddSavedOrderItem',params);
			},

			/**
			 * Adds item to the current order
			 * @param {Integer} partNumber The partNumber of the item to add to the current order.
			 * @param (string) row The row number of the quantity input in the table.
			 * @param (string) catEntryId The catentry ID of the item
			 */
			addItemToCurrentOrder:function(partNumber, row, catEntryId){
				var params = {
					storeId: this.storeId,
					catalogId: this.catalogId,
					langId: this.langId,
					calculationUsage: "-1,-2,-3,-4,-5,-6,-7",
					calculateOrder: "0",
					mergeToCurrentPendingOrder: "Y",
					URL: "",
					partNumber: partNumber,
					inventoryValidation: true,
					orderId: ".",
					quantity: $("#orderItem_input_" + row).val()
				};
				
				// used by mini shopcart
				var selectedAttrList = new Object();
				shoppingActionsJS.saveAddedProductInfo(params["quantity"], catEntryId, catEntryId, selectedAttrList);
				
				MessageHelper.hideAndClearMessage();
				
				/*For Handling multiple clicks. */
				if(!submitRequest()){
					return;
				}
				cursor_wait();
				wcService.invoke('AddOrderItem',params);
				// close action dropdown
				hideMenu($('#actionButton' + row)[0]);
				hideMenu($('#actionDropdown' + row)[0]);
			},

			/**
			 * This function deletes an order item from a saved order.
			 * @param {Integer} orderItemId The ID of the order item to delete.
			 */
			deleteItem:function(orderItemId){ 
				var params = {
					orderItemId: orderItemId,
					storeId : this.storeId,
					catalogId : this.catalogId,
					langId : this.langId,
					orderId : Utils.existsAndNotEmpty(this.orderId) ? this.orderId : ".",
					calculationUsage : "-1,-2,-3,-4,-5,-6,-7",
					check: "*n"
				};
				
				//For handling multiple clicks
				if(!submitRequest()){
					return;
				}
				
				cursor_wait();
				wcService.invoke("AjaxSavedOrderDeleteItem", params);
				
			},
			
			/**
			 * Updates the quantities of each item in the saved order, if the quantities are changed.
			 * @param (string) qty The quantity value to update to.
			 * @param (string) orderItemId The ID of the saved order to update.
			 * @param (string) row The row number of the quantity input in the table.
			 */
			updateItemQuantity:function (qty, orderItemId, row) {
				if(isNaN(qty)){
					$("#orderItem_input_"+row).val($("#oldOrderItem_input_"+row).val());
					MessageHelper.displayErrorMessage(MessageHelper.messages["ERROR_SAVED_ORDER_QUANTITY_ONE_OR_MORE"]);
					return;
				} else {
					var params = {
						orderId : Utils.existsAndNotEmpty(this.orderId) ? this.orderId : ".",
						quantity: qty,
						orderItemId: orderItemId,
						storeId : this.storeId,
						catalogId : this.catalogId,
						langId : this.langId,
						calculationUsage : "-1,-2,-3,-4,-5,-6,-7",
						check: "*n",
						calculateOrder: "1"
					};
					
					this.currentRow = row;
					if(!submitRequest()){
						return;
					}
					cursor_wait();
					wcService.invoke('AjaxSavedOrderUpdateItem',params);
				}
				
			},
			
			/**
			 * Sets the selected saved order as the current order when the <b>Set as Current Order and Checkout</b> button is clicked.
			 * This method updates the current order in the database to match the order in the shopping cart.
			 *
			 * @param orderId The ID of the saved order.
			 * **/
			setCurrentOrderAndCheckout : function(orderId) {
				if (Utils.isNullOrUndefined(this.orderId)) {
					this.orderId = orderId;
				}
				
				var params = {
					storeId : this.storeId,
					catalogId : this.catalogId,
					langId : this.langId,
					URL : "AjaxOrderItemDisplayView",
					orderId : this.orderId,
					nextAction: true
				};
				
				//For handling multiple clicks
				if(!submitRequest()){
					return;
				}
				cursor_wait();
				wcService.invoke("AjaxUpdatePendingOrder", params);
			},
			
			/**
			 * Display saved order items for pagination
             * TODO: check if this is unused, it appears to be ...
			 */
			showResultsPage:function(data){
				var pageNumber = data['pageNumber'];
				var pageSize = data['pageSize'];
				pageNumber = parseInt(pageNumber);
				pageSize = parseInt(pageSize);
		
				setCurrentId(data["linkId"]);
		
				if(!submitRequest()){
					return;
				}
		
				console.debug(wcRenderContext.getRenderContextProperties("SavedOrderItemTable_Context"));
				var beginIndex = pageSize * ( pageNumber - 1 );
				cursor_wait();
				wcRenderContext.updateRenderContext('SavedOrderItemTable_Context', {'beginIndex':beginIndex});
				MessageHelper.hideAndClearMessage();
			},

			/**
			* Shows the "quantity updated" message next to quantity input
			* This function is automatically called by the successHandler of AjaxUpdateOrderItem.
			*/
			showUpdatedMessage: function() {
				$("#orderItem_msg_qty_updated_"+this.currentRow).css("display", "block");
				$("#orderItem_input_"+this.currentRow).css("border", "1px solid #006ecc");
				setTimeout("SavedOrderItemsJS.hideUpdatedMessage("+this.currentRow+")", 3000);
			},

			/**
			* Hides the "quantity updated" message next to quantity input
			* @param {Integer} row The row number of the quantity input in the table
			*/		
			hideUpdatedMessage: function(row) {
				$("#orderItem_msg_qty_updated_"+row).css("display", "none");
				$("#orderItem_input_"+row).css("border", "1px solid #b7b7b7");
			},
						
			/**
			 * Checks if a string is null or empty.
			 * @param (string) str The string to check.
			 * @return (boolean) Indicates whether the string is empty.
			 */
			isEmpty: function(str) {
				var reWhiteSpace = new RegExp(/^\s+$/);
				if (str == null || str =='' || reWhiteSpace.test(str) ) {
					return true;
				}
				return false;
			}
	}//-----------------------------------------------------------------
// Licensed Materials - Property of IBM
//
// WebSphere Commerce
//
// (C) Copyright IBM Corp. 2014, 2016 All Rights Reserved.
//
// US Government Users Restricted Rights - Use, duplication or
// disclosure restricted by GSA ADP Schedule Contract with
// IBM Corp.
//-----------------------------------------------------------------

/** 
 * @fileOverview This file provides all the functions and variables to manage member group within.
 * This file is included in all pages with organization users member group actions.
 */

/**
 * This service allow administrator to update roles of member
 * @constructor
 */
wcService.declare({
	id:"RESTUserMbrGrpMgtMemberUpdate",
	actionId:"RESTUserMbrGrpMgtMemberUpdate",
	url:"RESTupdateMemberUser",
	formId:""

	 /**
     * Hides all the messages and the progress bar.
     * @param (object) serviceResponse The service response object, which is the
     * JSON object returned by the service invocation.
     */
	,successHandler: function(serviceResponse) {
		MessageHelper.hideAndClearMessage();
		
		cursor_clear();
		MessageHelper.displayStatusMessage(MessageHelper.messages["USERMEMBERGROUPMANAGEMENT_UPDATE_SUCCESS"]);
	}
		
	/**
     * display an error message.
     * @param (object) serviceResponse The service response object, which is the
     * JSON object returned by the service invocation.
     */
	,failureHandler: function(serviceResponse) {

		if (serviceResponse.errorMessage) {
			MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
		} 
		else {
			 if (serviceResponse.errorMessageKey) {
				MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
			 }
		}
		cursor_clear();
	}			
});

/**
 * This class defines the functions and variables that customers can use to create, update, and view their buyers list.
 * @class The UserMemberGroupManagementJS class defines the functions and variables that customers can use to manage their buyers list, 
 */
UserMemberGroupManagementJS = {		
	
	/**
	 * the widget name
	 * @private
	 */
	widgetShortName: "UserMemberGroupManagement",
	/** 
	 * This variable stores the ID of the language that the store currently uses. Its default value is set to -1, which corresponds to United States English.
	 * @private
	 */
	langId: "-1",
	
	/** 
	 * This variable stores the ID of the current store. Its default value is empty.
	 * @private
	 */
	storeId: "",
	
	/** 
	 * This variable stores the ID of the catalog. Its default value is empty.
	 * @private
	 */
	catalogId: "",
	
	/**
	 * The member group form Id.
	 * @private
	 */
	formId: "",
	
	/**
	 * The element Id for inclusion member group select dropdown widget.
	 * @private
	 */
	includeGrpDropdownId: "",
	
	/**
	 * The element id for exclusion member group select dropdown widget.
	 * @private
	 */
	excludeGrpDropdownId: "",
	
	/**
	 * The array of assigned include member group IDs.
	 * @private
	 */
	assignedIncGroups: new Array(),
	
	/**
	 * The array of assigned exclude member group IDs.
	 * @private
	 */
	assignedExcGroups: new Array(),
			
	/**
	 * Sets the common parameters for the current page. 
	 * For example, the language ID, store ID, and catalog ID.
	 * 
	 * @param {Integer} langId The ID of the language that the store currently uses.
	 * @param {Integer} storeId The ID of the current store.
	 * @param {Integer} catalogId The ID of the catalog.
	 * @param {String} formId The ID of the member group form.
	 * @param {String} includeGrpDropdownId The ID of the inclusive member group select option dropdown.
	 * @param {String} excludeGrpDropdownId The ID of the exclusive member group select option dropdown.
	 */
	setCommonParameters: function(langId,storeId,catalogId, formId, includeGrpDropdownId, excludeGrpDropdownId){
		this.langId = langId;
		this.storeId = storeId;
		this.catalogId = catalogId;
		this.formId = formId;
		this.includeGrpDropdownId = includeGrpDropdownId;
		this.excludeGrpDropdownId = excludeGrpDropdownId;
		cursor_clear();
	},
	
	/**
	 * Initialize assignedIncGroups and assignedExcGroups array on page load and after refresh.
	 */
	initializeData: function(){
		var form = document.getElementById(this.formId);
		var _this = this;
		if (form !== undefined && form !== null){
			
			_this.assignedExcGroups = [];
			_this.assignedIncGroups = [];

			$(form).find("input[name='addAsExplicitInclusionToMemberGroupId']").each( $.proxy(function(i, incGrp) {
				_this.assignedIncGroups.push($(incGrp).val().replace(/^\s+|\s+$/g, ''));
			}, _this));

			$(form).find("input[name='addAsExplicitExclusionToMemberGroupId']").each( $.proxy(function(i, excGrp) {
				_this.assignedExcGroups.push($(excGrp).val().replace(/^\s+|\s+$/g, ''));
			}, _this));

		}
	},
	
	/**
	 * Initialize the URL for controller 'declareUserMemberGroupManagement_controller'. 	 
	 *
	 * @param {object} widgetUrl The URL for declareUserMemberGroupManagement_controller.
	 */
	initializeControllerUrl:function(widgetUrl){
		$('#UserMemberGroupManagement').attr("refreshurl", widgetUrl);
	},
	
	/**
	 * Subscribe to press cancel button event
	 */
	subscribeToToggleCancel: function(){
		var topicName = "sectionToggleCancelPressed";
 		var scope = this;

		wcTopic.subscribe( topicName, function(data) {
			if (data.target === 'WC_UserMemberGroupManagement_pageSection'){
				scope.doCancel();
			}
		});
	},
	
	/**
	 * Handle select a include group from include group select dropdown
	 * @param (Integer) grpId The ID of the member group to select
	 */
	selectIncGrp: function(grpId){
		var _this = this;
		if (grpId != ''){
			//create the corresponding input
			var formNode = $("#" + _this.formId);
			formNode.append("<input type='hidden' name='addAsExplicitInclusionToMemberGroupId' value='" + grpId + "'/>");
			//disable corresponding entry in select dropdown
			var includeGrpDropdown = $("#" + _this.includeGrpDropdownId);
			includeGrpDropdown.val("");
			includeGrpDropdown.find("[value='" + grpId + "']").attr("disabled", true);
			includeGrpDropdown.Select("refresh");

			var excludeGrpDropdown = $("#" + _this.excludeGrpDropdownId);
			excludeGrpDropdown.find("[value='" + grpId + "']").attr("disabled", true);
			excludeGrpDropdown.Select("refresh");
			
			$(".includeMbrGrp .entryField[data-grpId='"+grpId+"']").attr("aria-hidden", "false");
		}
	},
	
	/**
	 * Handle click on a cross icon of a member group in Include member group section
	 * @param (Integer) grpId The ID of the member group to de-select
	 */
	deselectIncGrp: function(grpId){
		var _this = this;

		var formNode = $("#" + _this.formId);
		//remove the corresponding input
		$("#"+_this.formId+" input[value='"+grpId+"']").each(function(){
			this.parentNode.removeChild(this);
		});
		
		//update the select dropdown
		var includeGrpDropdown = $("#" + _this.includeGrpDropdownId);
		includeGrpDropdown.find("[value='" + grpId + "']").attr("disabled", false);
		includeGrpDropdown.Select("refresh");
		
		var excludeGrpDropdown = $("#" + _this.excludeGrpDropdownId);
		excludeGrpDropdown.find("[value='" + grpId + "']").attr("disabled", false);
		excludeGrpDropdown.Select("refresh");

		$(".includeMbrGrp .entryField[data-grpId='"+grpId+"']").attr("aria-hidden", "true");
	},
	
	/**
	 * Handle select a excluding group from exclude group select dropdown
	 * @param (Integer) grpId The ID of the member group to select 
	 */
	selectExcGrp: function(grpId){
		var _this = this;
		if (grpId != ''){
			//create the corresponding input
			var formNode = $("#" + _this.formId);
			formNode.append("<input type='hidden' name='addAsExplicitExclusionToMemberGroupId' value='" + grpId + "'/>");
			//disable corresponding entry in select dropdown
			var includeGrpDropdown = $("#" + _this.includeGrpDropdownId);
			includeGrpDropdown.find("[value='"+grpId+"']").attr("disabled", true);
			includeGrpDropdown.Select("refresh");
			
			var excludeGrpDropdown = $("#" + _this.excludeGrpDropdownId);
			excludeGrpDropdown.val("");
			excludeGrpDropdown.find("[value='"+grpId+"']").attr("disabled", true);
			excludeGrpDropdown.Select("refresh");

			$(".excludeMbrGrp .entryField[data-grpId='"+grpId+"']").attr("aria-hidden", "false");
		}
	},
	
	/**
	 * Handle click on a cross icon of a member group in Exclude member group section
	 * @param (Integer) grpId The ID of the member group to de-select
	 */
	deselectExcGrp: function(grpId){
		var _this = this;

		var formNode = $("#" + _this.formId);
		//remove the corresponding input
		formNode.children("input[value='"+grpId+"']").each(function(){
			this.parentNode.removeChild(this);
		});
		
		var includeGrpDropdown = $("#" + _this.includeGrpDropdownId);
		includeGrpDropdown.find("[value='" + grpId + "']").attr("disabled", false);
		includeGrpDropdown.Select("refresh");
		
		var excludeGrpDropdown = $("#" + _this.excludeGrpDropdownId);
		excludeGrpDropdown.find("[value='" + grpId + "']").attr("disabled", false);
		excludeGrpDropdown.Select("refresh");
		
		$(".excludeMbrGrp .entryField[data-grpId='"+grpId+"']").attr("aria-hidden", "true");
	},
	
	/**
	 * Handle cancel call back when click on 'cancel' button
	 */
	doCancel: function(){
		var scope = this;
			
		// set disable to "false" for all options
		var includeGrpDropdown = $("#" + scope.includeGrpDropdownId);
		var excludeGrpDropdown = $("#" + scope.excludeGrpDropdownId);
		includeGrpDropdown.find("option").each(function(){
			$(this).attr("disabled", false);
		});
		excludeGrpDropdown.find("option").each(function(){
			$(this).attr("disabled", false);
		});
		
		var formNode = $("#" + scope.formId);
		formNode.find("input[name='addAsExplicitInclusionToMemberGroupId']").each(function(i, incGrp) {
			incGrp.parentNode.removeChild(incGrp);
		});
		formNode.find("input[name='addAsExplicitExclusionToMemberGroupId']").each(function(i, excGrp) {
			excGrp.parentNode.removeChild(excGrp);
		});
		
		//set disabled to true for select groups
		$(scope.assignedIncGroups).each( $.proxy(function(index, incGrp){
			includeGrpDropdown.find("[value='" + incGrp + "']").attr("disabled", true);
			excludeGrpDropdown.find("[value='" + incGrp + "']").attr("disabled", true);
			var formNode = $("#" + this.formId);
			formNode.append("<input type='hidden' name='addAsExplicitInclusionToMemberGroupId' value='" + incGrp + "'/>");
		}, scope));
		
		$(scope.assignedExcGroups).each( $.proxy(function(index, excGrp){
			includeGrpDropdown.find("[value='" + excGrp + "']").attr("disabled", true);
			excludeGrpDropdown.find("[value='" + excGrp + "']").attr("disabled", true);
			var formNode = $("#" + this.formId);
			formNode.append("<input type='hidden' name='addAsExplicitExclusionToMemberGroupId' value='" + excGrp + "'/>");
		}, scope));
		
		$(".includeMbrGrp .entryField").each( $.proxy(function(index, entry){
			var grpId = $(entry).attr("data-grpId");
			if (this.assignedIncGroups.indexOf(grpId) < 0 ){
				$(entry).attr("aria-hidden", "true");
			}
			else {
				$(entry).attr("aria-hidden", "false");
			}
		}, scope));
		$(".excludeMbrGrp .entryField").each( $.proxy(function(index, entry){
			var grpId = $(entry).attr("data-grpId");
			if (this.assignedExcGroups.indexOf(grpId) < 0 ){
				$(entry).attr("aria-hidden", "true");
			}
			else {
				$(entry).attr("aria-hidden", "false");
			}
		}, scope));
		
		includeGrpDropdown.Select("refresh");
		excludeGrpDropdown.Select("refresh");
	},
	
	/**
	 * Save changes when press "Save" button
	 */
	saveChange: function(){
		
		var params = {};
		params.removeFromMemberGroupId =  this.assignedExcGroups.concat(this.assignedIncGroups);
		wcService.getServiceById('RESTUserMbrGrpMgtMemberUpdate').setFormId(this.formId);
		if(!submitRequest()){
			return;
		}
		cursor_wait();
		wcService.invoke('RESTUserMbrGrpMgtMemberUpdate', params);
	}
};
//-----------------------------------------------------------------
// Licensed Materials - Property of IBM
//
// WebSphere Commerce
//
// (C) Copyright IBM Corp. 2014, 2016 All Rights Reserved.
//
// US Government Users Restricted Rights - Use, duplication or
// disclosure restricted by GSA ADP Schedule Contract with
// IBM Corp.
//-----------------------------------------------------------------



/**
 * Declares a new refresh controller for update member group select.
 */
function declareUserMemberGroupManagement_controller() {
	var myWidgetObj = $("#UserMemberGroupManagement");
	
	/** 
	 * Refreshes the organization users list display if a list item is updated
	 * This function is called when a modelChanged event is detected. 
	 */
	wcTopic.subscribe(["RESTUserMbrGrpMgtMemberUpdate","UserRoleManagementUpdate"], function() {
		myWidgetObj.refreshWidget("refresh");
	});
	
	myWidgetObj.refreshWidget({
		/** 
		 * Clears the progress bar
		 */
		postRefreshHandler: function() {
			widgetCommonJS.removeSectionOverlay();
			cursor_clear();
			UserMemberGroupManagementJS.initializeData();
			//Initialize toggle events after page refresh
			widgetCommonJS.initializeEditSectionToggleEvent();
		}
	});
};
//-----------------------------------------------------------------
// Licensed Materials - Property of IBM
//
// WebSphere Commerce
//
// (C) Copyright IBM Corp. 2014, 2016 All Rights Reserved.
//
// US Government Users Restricted Rights - Use, duplication or
// disclosure restricted by GSA ADP Schedule Contract with
// IBM Corp.
//-----------------------------------------------------------------

/** 
 * @fileOverview This file provides all the functions and variables to manage user roles within.
 * This file is included in all pages with organization users role assignment actions.
 */
/* global KeyCodes */

/**
 * This service allow administrator to assign roles of member
 * @constructor
 */
wcService.declare({
	id:"UserRoleManagementAssign",
	actionId:"UserRoleManagementAssign",
	url:"AjaxRESTMemberRoleAssign",
	formId:""

	 /**
     * Hides all the messages and the progress bar.
     * @param (object) serviceResponse The service response object, which is the
     * JSON object returned by the service invocation.
     */
	,successHandler: function(serviceResponse) {
		if (UserRoleManagementJS.paramsToUnAssign !== undefined && UserRoleManagementJS.paramsToUnAssign !== null){
			wcService.invoke('UserRoleManagementUnassign',UserRoleManagementJS.paramsToUnAssign);
		}
		else {
			MessageHelper.hideAndClearMessage();
			UserRoleManagementJS.updateAssignedRolesMap();
			UserRoleManagementJS.updateReadOnlySummary();
			widgetCommonJS.toggleEditSection(document.getElementById('WC_UserRoleManagement_pageSection'));
			cursor_clear();
			MessageHelper.displayStatusMessage(MessageHelper.messages["USERROLEMANAGEMENT_UPDATE_SUCCESS"]);
		}
	}
		
	/**
     * display an error message.
     * @param (object) serviceResponse The service response object, which is the
     * JSON object returned by the service invocation.
     */
	,failureHandler: function(serviceResponse) {

		if (serviceResponse.errorMessage) {
			MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
		} 
		else {
			 if (serviceResponse.errorMessageKey) {
				MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
			 }
		}
		cursor_clear();
	}			
});

/**
 * This service allow administrator to un assign roles of member
 * @constructor
 */
wcService.declare({
	id:"UserRoleManagementUnassign",
	actionId:"UserRoleManagementUnassign",
	url:"AjaxRESTMemberRoleUnassign",
	formId:""

	 /**
     * Hides all the messages and the progress bar.
     * @param (object) serviceResponse The service response object, which is the
     * JSON object returned by the service invocation.
     */
	,successHandler: function(serviceResponse) {
		MessageHelper.hideAndClearMessage();
		if (UserRoleManagementJS.removingAdminRole){
			cursor_clear();
			MessageHelper.displayStatusMessage(MessageHelper.messages["USERROLEMANAGEMENT_UPDATE_SUCCESS"]);
			document.location.href = UserRoleManagementJS.myAccountURL;
		}
		else {
			UserRoleManagementJS.updateAssignedRolesMap();
			UserRoleManagementJS.updateReadOnlySummary();
			widgetCommonJS.toggleEditSection(document.getElementById('WC_UserRoleManagement_pageSection'));
			cursor_clear();
			UserRoleManagementJS.paramsToUnAssign = null;
			MessageHelper.displayStatusMessage(MessageHelper.messages["USERROLEMANAGEMENT_UPDATE_SUCCESS"]);
		}
	}
		
	/**
     * display an error message.
     * @param (object) serviceResponse The service response object, which is the
     * JSON object returned by the service invocation.
     */
	,failureHandler: function(serviceResponse) {

		if (serviceResponse.errorMessage) {
			MessageHelper.displayErrorMessage(MessageHelper.messages["USERROLEMANAGEMENT_UNASSIGN_FAIL"] + serviceResponse.errorMessage);
		} 
		else {
			 if (serviceResponse.errorMessageKey) {
				 MessageHelper.displayErrorMessage(MessageHelper.messages["USERROLEMANAGEMENT_UNASSIGN_FAIL"] + serviceResponse.errorMessageKey);
			 }
		}
		cursor_clear();
	}			
});

/**
 * This service allow administrator to update roles of member
 * @constructor
 */
wcService.declare({
	id:"ChainedUserRoleManagementAssign",
	actionId:"ChainedUserRoleManagementAssign",
	url:"AjaxRESTMemberRoleAssign",
	formId:""

	 /**
     * Hides all the messages and the progress bar.
     * @param (object) serviceResponse The service response object, which is the
     * JSON object returned by the service invocation.
     */
	,successHandler: function(serviceResponse) {
		MessageHelper.hideAndClearMessage();
		
		document.location.href = OrganizationUserInfoJS.getChainedServiceRediretUrl();
		cursor_clear();		
		MessageHelper.displayStatusMessage(MessageHelper.messages["ORGANIZATIONUSER_CREATE_SUCCESS"]);
	}
		
	/**
     * display an error message.
     * @param (object) serviceResponse The service response object, which is the
     * JSON object returned by the service invocation.
     */
	,failureHandler: function(serviceResponse) {

		if (serviceResponse.errorMessage) {
			MessageHelper.displayErrorMessage(MessageHelper.messages["USERROLEMANAGEMENT_CHAINCREATE_FAIL"] + serviceResponse.errorMessage);
		} 
		else {
			 if (serviceResponse.errorMessageKey) {
				MessageHelper.displayErrorMessage(MessageHelper.messages["USERROLEMANAGEMENT_CHAINCREATE_FAIL"] + serviceResponse.errorMessageKey);
			 }
		}
		cursor_clear();
	}			
});
  	
/**
 * This class defines the functions and variables that customers can use to create, update, and view their buyers list.
 * @class The OrganizationUsersListJS class defines the functions and variables that customers can use to manage their buyers list, 
 */
UserRoleManagementJS = {		
	
	/**
	 * the widget name
	 * @private
	 */
	widgetShortName: "UserRoleManagement",
	
	/**
	 * the name of Buyer Administrator Role
	 * @private
	 */
	buyerAdmin: "Buyer Administrator",
	
	/** 
	 * This variable stores the ID of the language that the store currently uses. Its default value is set to -1, which corresponds to United States English.
	 * @private
	 */
	langId: "-1",
	
	/** 
	 * This variable stores the ID of the current store. Its default value is empty.
	 * @private
	 */
	storeId: "",
	
	/** 
	 * This variable stores the ID of the catalog. Its default value is empty.
	 * @private
	 */
	catalogId: "",
	
	/** 
	 * This variable stores the ID of member.
	 * @private
	 */
	memberId: "",
	
	/** 
	 * This variable stores the ID of the buyer admin.
	 * @private
	 */
	adminId: "",
	
	/**
	 * The id of selected Org.
	 * @private
	 */
	selectedOrg: "",
	
	/**
	 * The map contains Organization IDs and corresponding name, 
	 * at least one of the roles in the Organization is assigned to member.
	 * The key is Organization ID, value is name of a Organization.
	 */
	assignedOrgNameMap: new Object(),
	
	/**
	 * The map contains role IDs and corresponding name for roles that are
	 * currently assigned to the member.
	 * The key is Role ID, value is an array contains name of a Role and 
	 * frequence of the name appears in assigned roles. [name, freqence]
	 */
	assignedRoleNameMap: new Object(),
	
	/**
	 * The map contains Organization IDs and corresponding name, 
	 * at least one of the roles in the Organization is selected for the member.
	 * The map is initialized to assignedOrgNameMap
	 * on page load, and is updated correspondingly upon selection change
	 * The key is Organization ID, value is name of a Organization.
	 */
	selectedOrgNameMap: new Object(),
	
	/**
	 * The map contains Organization IDs and corresponding name, 
	 * for the Organizaiton currently displayed in the table.
	 * The map is initialized to assignedOrgNameMap
	 * on page load, and is updated correspondingly upon selection change
	 * The key is Organization ID, value is name of a Organization.
	 */
	currentOrgNameMap: new Object(),
	
	/**
	 * The map contains role IDs and corresponding name for roles that are
	 * currently selected for the member. The map is initialized to assignedRoleNameMap
	 * on page load, and is updated correspondingly upon selection change
	 * The key is Role ID, value is an array contains name of a Role and 
	 * frequence of the name appears in select roles. [name, freqence]
	 * the name will be removed from map is frequence equals 0
	 */
	selectedRoleNameMap: new Object(),
	
	/**
	 * The map contains role IDs and corresponding name for roles that are
	 * currently show in role selector column for a selected Organization
	 * The key is Role ID, value is name of a Role.
	 */
	selectedOrgRoleNameMap: new Object(),
	
	/**
	 * The map stores the all but hidden roles that the user has, roles in this map can be unassigned by current Admin. 
	 * The key of the map is Organization ID, the value is an array of role IDs
	 */
	assignedRolesMap: new Object(),
	
	/**
	 * The map stores the all roles that are selected by Admin for the user. 
	 * The key of the map is Organization ID, the value is an array of role IDs
	 */
	selectedRolesMap: new Object(),
	
	/**
	 * The display pattern of Org and Role for Selection summary column 
	 * The pattern is loaded from corresponding resource bundle define in widgetText
	 */
	orgDisplayPattern: "",
	
	/**
	 * The display pattern of Role for Selection summary column 
	 * The pattern is loaded from corresponding resource bundle define in widgetText
	 */
	roleDisplayPattern: "",
	
	/**
	 * The Checkbox column children html template
	 * The template is defined in UI jspf file
	 */
	roleCheckboxTemplate: "",
	
	/**
	 * The selection summary column children html template
	 * The template is defined in UI jspf file
	 */
	selectionSummaryTemplate: "",
	
	/**
	 * The read only summary view html template
	 * The template is defined in UI jspf file
	 */
	summaryViewTemplate: "",
	
	/**
	 * The prepared params for unAssign service command
	 */
	paramsToUnAssign: null,
	
	/**
	 * Indicates if we are removing admin role for the buyer him/herself, default value is false
	 */
	removingAdminRole: false,
	
	/**
	 * The URL to my account page.
	 */
	myAccountURL: "",
	
	/**
	 * Sets the common parameters for the current page. 
	 * For example, the language ID, store ID, and catalog ID.
	 *
	 * @param {Integer} langId The ID of the language that the store currently uses.
	 * @param {Integer} storeId The ID of the current store.
	 * @param {Integer} catalogId The ID of the catalog.
	 * @param {Integer} memberId The ID of the member.
	 * @param {Integer} authToken The authToken for current user to perform operation on server.
	 * @param (String) myAccountURL The url for MyAcount page
	 */
	setCommonParameters: function(langId,storeId,catalogId, memberId, adminId, authToken, myAccountURL){
		this.langId = langId;
		this.storeId = storeId;
		this.catalogId = catalogId;
		this.memberId = memberId;
		this.adminId = adminId;
		this.authToken = authToken;
		this.myAccountURL = myAccountURL;
		cursor_clear();
	},
	
	/**
	 * Initialize the URL of Role Assignment widget controller. 	 
	 *
	 * @param {object} roleSelectorUrl The roleSelector checkbox region controller's URL.
	 * @param {object} orgListUrl The  controller's URL for roleSelector region, which refreshes after org list change.
	 */
	initUserRoleManagementControllerUrl:function(roleSelectorUrl, orgListUrl){
		$('#UserRoleManagement_RoleSelector').attr("refreshurl", roleSelectorUrl);
		$('#UserRoleManagement_OrgList').attr("refreshurl", orgListUrl);
	},
	
	/**
	 * Handle press cancel button
	 */
	subscribeToToggleCancel: function(){
		var topicName = "sectionToggleCancelPressed";
		var scope = this;
		wcTopic.subscribe( topicName , $.proxy( function(data){
			if (data.target === 'WC_UserRoleManagement_pageSection'){
				this.selectedRolesMap = JSON.parse(JSON.stringify(this.assignedRolesMap));
				this.selectedRoleNameMap = JSON.parse(JSON.stringify(this.assignedRoleNameMap));
				this.selectedOrgNameMap = JSON.parse(JSON.stringify(this.assignedOrgNameMap));
				this.updateSelectionSummary();
				this.removingAdminRole = false;
				if (this.selectedOrg != ""){
					this.updateSelectorCheckbox(this.selectedOrg);
				}
			}
		}, this));
	},
	
	/**
	 * Upon success service response, copy the selectedRolesMap to assignedRolesMap
	 */
	updateAssignedRolesMap: function(){
		this.assignedRolesMap = JSON.parse(JSON.stringify(this.selectedRolesMap));
		this.assignedRoleNameMap = JSON.parse(JSON.stringify(this.selectedRoleNameMap));
		this.assignedOrgNameMap = JSON.parse(JSON.stringify(this.selectedOrgNameMap));
	},
	
	/**
	 * orgDisplayPattern, roleDisplayPattern
	 */
	loadDisplayPattern: function(orgPattern, rolePattern){
		this.roleDisplayPattern = rolePattern;
		this.orgDisplayPattern = orgPattern;
	},
	
	/**
	 * Read only Summary view template
	 */
	loadSummaryViewTemplate: function(orgPattern, rolePattern){
		this.summaryViewTemplate = $("#WC_UserRoleManagement_read_template").html().replace(/^\s+|\s+$/g, '');
	},
	
	/**
	 * Update currentOrgNameMap after Org list refresh
	 */
	updateCurrentOrgNameMap: function(){
		var incurrentOrgNameMap = JSON.parse($("#currentOrgNameMap").html());
		if (incurrentOrgNameMap !== undefined && incurrentOrgNameMap !== null){
			this.currentOrgNameMap = JSON.parse(JSON.stringify(incurrentOrgNameMap));
		}
	},
	
	/**
	 * assignedOrgNameMap, assignedRoleNameMap,selectedOrgNameMap, 
	 * selectedRoleNameMap, 
	 * currentOrgNameMap, 
	 * userHiddenRolesMap, assignedRolesMap, selectedRolesMap
	 * summaryViewTemplate, selectionSummary column template
	 */
	initializeDataForView: function(){
		var inassignedOrgNameMap = JSON.parse($("#assignedOrgNameMap").html());
		var inassignedRoleNameMap = JSON.parse($("#assignedRoleNameMap").html());
		var incurrentOrgNameMap = JSON.parse($("#currentOrgNameMap").html());
		if (inassignedOrgNameMap !== undefined && inassignedOrgNameMap !== null){
			this.assignedOrgNameMap = JSON.parse(JSON.stringify(inassignedOrgNameMap));
			this.selectedOrgNameMap = JSON.parse(JSON.stringify(inassignedOrgNameMap));
		}
		if (inassignedRoleNameMap !== undefined && inassignedRoleNameMap !== null){
			this.assignedRoleNameMap = JSON.parse(JSON.stringify(inassignedRoleNameMap));
			this.selectedRoleNameMap = JSON.parse(JSON.stringify(inassignedRoleNameMap));
		}
		if (incurrentOrgNameMap !== undefined && incurrentOrgNameMap !== null){
			this.currentOrgNameMap = JSON.parse(JSON.stringify(incurrentOrgNameMap));
		}
		var inSelectedOrgRoleNameMap = JSON.parse($("#selectedOrgRoleNameMap").html());
		if (inSelectedOrgRoleNameMap !== undefined && inSelectedOrgRoleNameMap !== null){
			this.selectedOrgRoleNameMap = JSON.parse(JSON.stringify(inSelectedOrgRoleNameMap));
		}
		this.selectionSummaryTemplate = $("#WC_UserRoleManagement_edit_additionalRoles_selectionSummary_panel_template").html().replace(/^\s+|\s+$/g, '');
		
		//for edit buyer
		this.assignedRolesMap = JSON.parse($("#userRoles").html());
		this.selectedRolesMap = JSON.parse($("#userRoles").html());
		
		var templateDom = $("#WC_UserRoleManagement_read_template");
		if (templateDom[0] !== undefined && templateDom[0] !== null){
			this.summaryViewTemplate = templateDom.html().replace(/^\s+|\s+$/g, '');
		}
	},
	
	/**
	 * Set role Name map in Selected Org after selecting a Org.
	 */
	setSelectedOrgRoleNameMap: function(){
		
		var inSelectedOrgRoleNameMap = JSON.parse($("#selectedOrgRoleNameMap").html());
		if (inSelectedOrgRoleNameMap !== undefined && inSelectedOrgRoleNameMap !== null){
			this.selectedOrgRoleNameMap = JSON.parse(JSON.stringify(inSelectedOrgRoleNameMap));
		}
	},
	
	/**
	 * Helper function to set userRoles and userHiddenRoles map
	 */
	setUserRolesMap:function(inArray, targetMap){
		if (inArray !== undefined && inArray !== null){
			for (var i=0; i < inArray.length; i++ ){
				var key = inArray[i][1]; //org id
				var value = inArray[i][0]; //role id
				if(Object.prototype.hasOwnProperty.call(targetMap, key)){
					if ( targetMap[key].indexOf(value)=== -1){
						targetMap[key].push(value);
					}
				}
				else{
					targetMap[key] = [value];
				}
			}
		}
	},
	
	/**
	 * Handle click on Role selector checkbox.
	 */
	toggleRoleCheckbox: function(role){
		var org = this.selectedOrg;
		this.updateSelectedRole(org, role);
		this.updateSelectorCheckbox();
		this.updateSelectionSummary();
	},
	
	/**
	 * Update selected roles and corresponding role name map
	 */
	updateSelectedRole: function(org, role){
		if (Object.prototype.hasOwnProperty.call(this.selectedRolesMap,org)){
			// has role in this org
			var index = this.selectedRolesMap[org].indexOf(role);
			if (index > -1){//exists , so remove it
				this.selectedRolesMap[org].splice(index, 1);
				if (this.selectedRolesMap[org].length == 0){//remove empty org
					delete this.selectedRolesMap[org];
					delete this.selectedOrgNameMap[org];
				}
				if (this.selectedRoleNameMap[role][1] == 1){
					delete this.selectedRoleNameMap[role];
				}
				else {
					this.selectedRoleNameMap[role][1] = this.selectedRoleNameMap[role][1] - 1;
				}
			}
			else {//does have the role, add to selected map
				this.selectedRolesMap[org].push(role);
				
				if (!Object.prototype.hasOwnProperty.call(this.selectedRoleNameMap,role)){
					this.selectedRoleNameMap[role] = [this.selectedOrgRoleNameMap[role].displayName, 1];
				}
				else{
					this.selectedRoleNameMap[role][1] = this.selectedRoleNameMap[role][1] + 1;
				}
			}
		}
		else{
			// no role was assigned from this org, create a new array for this org.
			this.selectedRolesMap[org] = [role];
			this.selectedOrgNameMap[org] = this.currentOrgNameMap[org];
			if (!Object.prototype.hasOwnProperty.call(this.selectedRoleNameMap,role)){
				this.selectedRoleNameMap[role] = [this.selectedOrgRoleNameMap[role].displayName, 1];
			}
			else{
				this.selectedRoleNameMap[role][1] = this.selectedRoleNameMap[role][1] + 1;
			}
		}
		
	}, 
	
	/**
	 * Select an Organization
	 */
	selectOrg: function(orgId){
		if (this.selectedOrg == orgId) {
			return;
		}

		$('#WC_UserRoleManagement_edit_additionalRoles_organizations div[data-orgid]').each(function(index, node){
			if (node.getAttribute('data-orgid') == orgId ){
				$(node).addClass("highlight");
				Utils.scrollIntoView(node);
			}
			else {
				$(node).removeClass("highlight");
			}
		});
		//normal select case
		if (Object.prototype.hasOwnProperty.call(this.currentOrgNameMap,orgId)){
			this.selectedOrg = orgId;
			if(!submitRequest()){
				return;
			}			
			cursor_wait();
			wcRenderContext.updateRenderContext("UserRoleManagement_RoleSelector_Context", {"orgId": orgId});
		}
		//select from summary column where the Org is not in current page, switch to search;
		else{
			this.selectedOrg = "";
			var orgNameSearch = this.selectedOrgNameMap[orgId];
			var searchInputFieldId = 'WC_UserRoleManagement_edit_additionalRoles_searchInput';
			var searchInput = document.getElementById(searchInputFieldId);
			searchInput.value = orgNameSearch;
			this.showClearFilter();
			this.updateOrgListContext(orgNameSearch, orgId, "5");// "5" is exact match search type.
		}
	},
	
	/**
	 * Update view of selector check box area, check or uncheck, highlight or not etc.
	 */
	updateSelectorCheckbox: function(){
		var panelParent = $("#WC_UserRoleManagement_edit_additionalRoles_roleSelector_panel");
		panelParent.removeClass("highlight");
		var foundCheckbox = false;
		panelParent.find(".checkBoxer").each($.proxy( function(index, aCheckbox){
			var role = aCheckbox.getAttribute("data-userRoleId");
			var org = this.selectedOrg;
			foundCheckbox = true;
			if (Object.prototype.hasOwnProperty.call(this.selectedRolesMap,org) && this.selectedRolesMap[org].indexOf(role)!== -1){
				aCheckbox.setAttribute("aria-checked", "true");
			}
			else{
				aCheckbox.setAttribute("aria-checked", "false");
			}
		}, this));
		if(foundCheckbox){
			panelParent.addClass("highlight");
		}
	},
	
	/**
	 * Update view of selection summary column.
	 */
	updateSelectionSummary: function(){
		var panelParent = $("#WC_UserRoleManagement_edit_additionalRoles_selectionSummary_panel");
		panelParent.empty();
		var selectedSummary = null;
		for ( var key in this.selectedRolesMap){
			//key is Org Id
			var displayString = "";
			var orgName = this.selectedOrgNameMap[key];
			var roleName = "";
			var roleArray = this.selectedRolesMap[key];
			$(roleArray).each( $.proxy( function(index, role){
				var rn = this.selectedRoleNameMap[role][0];
				if (roleName.length === 0){
					roleName = rn;
				}
				else {
					roleName = Utils.substituteStringWithMap(this.roleDisplayPattern, {0: roleName, 1: rn});
				}
			}, this));
			if (roleName.length > 0){
				displayString = Utils.substituteStringWithMap(this.orgDisplayPattern, {0: this.selectedOrgNameMap[key], 1: roleName});
			}
			if (displayString.length > 0){
				var aSummary = $(Utils.substituteStringWithMap(this.selectionSummaryTemplate, {0: displayString}));
				if (key == this.selectedOrg){
					aSummary.addClass("highlight");
					selectedSummary = aSummary;
				}
				aSummary.find("a").each($.proxy( function(index, a){
					var k = key; //orgId, variable in forEach scope only
					if ($(a).hasClass("icon")){
						if (k == this.selectedOrg){
							$(a).removeClass("nodisplay");
							$(a).on("click", $.proxy( function(e){
								$(this.selectedRolesMap[k]).each( $.proxy( function(index, r){
									if (this.selectedRoleNameMap[r][1] == 1){
										delete this.selectedRoleNameMap[r];
									}
									else {
										this.selectedRoleNameMap[r][1] = this.selectedRoleNameMap[r][1] -1;
									}
								}, this));
								delete this.selectedRolesMap[k];
								delete this.selectedOrgNameMap[k];
								this.updateSelectorCheckbox();
								this.updateSelectionSummary();
								e.preventDefault();
								e.stopPropagation();
							}, this));
						}
					}
					else if ($(a).hasClass("roleName")){
						$(a).on("click", $.proxy( function(e){
							this.selectOrg(k);
							e.preventDefault();
							e.stopPropagation();
						}, this));
					}
				}, this));
				panelParent.append(aSummary);
			}
		}
		if (selectedSummary != null ){
			Utils.scrollIntoView(selectedSummary);
		}
	},
	
	/**
	 * Update view of Read only summary according to assigned role map.
	 */
	updateReadOnlySummary: function(){
		
		var sectionParent = $("#WC_UserRoleManagement_read");
		if (sectionParent !== undefined && sectionParent !== null){

			sectionParent.empty();
			
			for ( var key in this.assignedRolesMap){
				//key is Org Id
				var displayString = "";
				var orgName = this.assignedOrgNameMap[key];
				var roleArray = this.assignedRolesMap[key];
				$(roleArray).each( $.proxy( function(i, role){
					var invisibleString = "<span style='visibility: hidden'>&nbsp;</span>";
					var roleName = this.assignedRoleNameMap[role][0];
					
					if ( i == 0){
						var nodeChild = $(Utils.substituteStringWithMap(this.summaryViewTemplate, {0: orgName, 1: roleName}));
					}
					else {
						var nodeChild = $(Utils.substituteStringWithMap(this.summaryViewTemplate, {0: invisibleString, 1:roleName}));
					}

					sectionParent.append(nodeChild);
					
				}, this));
			}
		}
	},
	
	updateView: function(){
		var searchInputFieldId = 'WC_UserRoleManagement_edit_additionalRoles_searchInput';
		this.updateReadOnlySummary();
		if(this.currentOrgNameMap.first !== undefined && this.currentOrgNameMap.first !== null ){
			this.selectedOrg = this.currentOrgNameMap.first;
		}
		$("#" + searchInputFieldId).on("keydown", $.proxy( function(e){
			var charOrCode = e.charCode || e.keyCode;
			if (charOrCode == KeyCodes.ENTER){
				this.doSearch();
			}
		}, this));
		this.updateOrganizationPanel();
		this.updateSelectionSummary();
		this.updateSelectorCheckbox();
		
		$('#WC_UserRoleManagement').on("keydown", ".roleSelector .checkField .checkBoxer", $.proxy( function(e){
			var charOrCode = e.charCode || e.keyCode;
			if (charOrCode == KeyCodes.SPACE || charOrCode == KeyCodes.ENTER){
				
				var checkbox = $( $(e.target).parents(".checkField")[0] ).find(".checkBoxer")[0];
				var role = checkbox.getAttribute("data-userRoleId");
				var ariaChecked = checkbox.getAttribute("aria-checked");
				if (this.adminId == this.memberId && ariaChecked == "true" && this.selectedOrgRoleNameMap[role].name == this.buyerAdmin){
					wcTopic.subscribeOnce( "adminRoleRemoveConfirmed" , $.proxy( function(data){
						if (data.action == "YES"){
							this.toggleRoleCheckbox(role);
							this.removingAdminRole = true;
						}
					}, this), this);	
					MessageHelper.showConfirmationDialog("adminRoleRemoveConfirmed",
							Utils.substituteStringWithMap(MessageHelper.messages['USERROLEMANAGEMENT_CONFIRMATIONDIALOGMESSAGE'], {0: this.selectedOrgRoleNameMap[role].displayName}));
				}else {
					this.toggleRoleCheckbox(role);
					if (this.adminId == this.memberId &&  ariaChecked != "true" && this.selectedOrgRoleNameMap[role].name == this.buyerAdmin){
						this.removingAdminRole = false;
					}
				}
				e.preventDefault();
				e.stopPropagation();
			}
		}, this));
		$('#WC_UserRoleManagement').on("click", ".roleSelector .checkField .checkBoxer", $.proxy( function(e){
			var checkbox = $( $(e.target).parents(".checkField")[0] ).find(".checkBoxer")[0];
			var role = checkbox.getAttribute("data-userRoleId");
			var ariaChecked = checkbox.getAttribute("aria-checked");
			if (this.adminId == this.memberId && ariaChecked == "true" && this.selectedOrgRoleNameMap[role].name == this.buyerAdmin){
				wcTopic.subscribeOnce( "adminRoleRemoveConfirmed" , $.proxy( function(data){
					if (data.action == "YES"){
						this.toggleRoleCheckbox(role);
						this.removingAdminRole = true;
					}
				}, this), this);
				MessageHelper.showConfirmationDialog("adminRoleRemoveConfirmed",
						Utils.substituteStringWithMap(MessageHelper.messages['USERROLEMANAGEMENT_CONFIRMATIONDIALOGMESSAGE'], {0: this.selectedOrgRoleNameMap[role].displayName}));
			}else {
				this.toggleRoleCheckbox(role);
				if (this.adminId == this.memberId && ariaChecked != "true" && this.selectedOrgRoleNameMap[role].name == this.buyerAdmin){
					this.removingAdminRole = false;
				}
			}
			e.preventDefault();
			e.stopPropagation();
		}, this));
	},
	
	/**
	 * handle Seach button press
	 */
	doSearch: function(){
		var inputFieldId = 'WC_UserRoleManagement_edit_additionalRoles_searchInput';
		var input = document.getElementById(inputFieldId);
		var orgNameSearch = input.value;
		if (orgNameSearch.replace(/^\s+|\s+$/g, '') != ""){
			this.selectedOrg = "";
			this.showClearFilter();
			this.updateOrgListContext(orgNameSearch, "");
		}
	},
	
	/**
	 * Update context to show page according specific number.
	 * 
	 * @param data The data for updating context.
	 */
	showPage:function(data){
		var pageNumber = data['pageNumber'];
		var pageSize = data['pageSize'];
			pageNumber = parseInt(pageNumber);
			pageSize = parseInt(pageSize);
		var beginIndex = pageSize * ( pageNumber - 1 );

		if(!submitRequest()){
			return;
		}			
		cursor_wait();
		wcRenderContext.updateRenderContext("UserRoleManagement_OrgList_Context", {"selectOrgId":"", "beginIndex" : beginIndex});
	},
	
	/**
	 * clear the search when press clear filter button
	 */
	clearSearch: function(){
		var inputFieldId = 'WC_UserRoleManagement_edit_additionalRoles_searchInput';
		var input = document.getElementById(inputFieldId);
		input.value='';
		this.selectedOrg = "";
		this.hideClearFilter();
		this.updateOrgListContext('', '');
	},
	
	updateOrgListContext: function(orgNameSearch, selectOrgIdTokeep, searchType){
		if (searchType === undefined || searchType === null){
			searchType = "4"; //ignore case, containing
		}
		var beginIndex = "0";
		if(!submitRequest()){
			return;
		}			
		cursor_wait();
		wcRenderContext.updateRenderContext("UserRoleManagement_OrgList_Context", {"orgNameSearch": orgNameSearch, "selectOrgId":selectOrgIdTokeep, "searchType": searchType, "beginIndex" : beginIndex});
	},
	
	/**
	 * Update to show clear filter button
	 */
	showClearFilter: function(){
		var filterButtonId = 'WC_UserRoleManagement_edit_clearFilter';
		var filterButton = $("#" + filterButtonId);
		filterButton.attr("aria-hidden", "false");
	},
	
	/**
	 * Update to hide clear filter button
	 */
	hideClearFilter: function(){
		var filterButtonId = 'WC_UserRoleManagement_edit_clearFilter';
		var filterButton = $("#" + filterButtonId);
		filterButton.attr("aria-hidden", "true");			
	},
	
	/**
	 * Update the Organizations panel after refresh, pre-select Organization
	 */
	updateOrganizationPanel: function() {
		$('#WC_UserRoleManagement_edit_additionalRoles_organizations div[data-orgid]').each($.proxy( function(index, node){
			if (node.getAttribute('data-orgid') == this.selectedOrg ){
				$(node).addClass("highlight");
				Utils.scrollIntoView(node);
			}
			else {
				$(node).removeClass("highlight");
			}
		}, this));
	},
	
	/**
	 * Save the assigned and unassigned roles to server
	 */
	saveChange: function(){
		
		var params = {};
		
		this.prepareSelectedRoleParam(params);
		
		if (params['paramsToUnAssign'] !== undefined && params['paramsToUnAssign'] !== null) {
			this.paramsToUnAssign = JSON.parse(JSON.stringify(params['paramsToUnAssign']));
		}
		
		if (params['paramsToAssign'] !== undefined && params['paramsToAssign'] !== null) {
			if(!submitRequest()){
				return;
			}
			cursor_wait();
			wcService.invoke('UserRoleManagementAssign',params['paramsToAssign']);
		}
		else if (params['paramsToUnAssign'] !== undefined && params['paramsToUnAssign'] !== null) {
			if(!submitRequest()){
				return;
			}
			cursor_wait();
			wcService.invoke('UserRoleManagementUnassign',params['paramsToUnAssign']);
		} else {
			return;
		}
		
	},

	/**
	 * The function is called by successHandler of service chainedAjaxUserRegistrationAdminAdd
	 * to assign additional roles to the member just created.
	 * @param memberId the id of the member the role to assign
	 */
	chainedAssignRole: function(memberId){
		this.memberId = memberId;
		var params = {};
		this.prepareSelectedRoleParam(params);
		// the caller (userInfo widget service successHandler) will check if any role is selected for 
		// the member, so it is guaranteed that the params['paramsToAssign'] is not null or undefined.
		wcService.invoke('ChainedUserRoleManagementAssign',params['paramsToAssign']);
	},
	
	/**
	 * Function to test if the selectedRolesMap is empty.
	 * @return (Boolean) true if this selectedRolesMap is empty, false otherwise 
	 */
	isEmptySelectedRoles: function() {
		for (var k in this.selectedRolesMap){
			return false;
		}
		return true;
	},
	
	/**
	 * Helper function for saveChange
	 */
	prepareSelectedRoleParam: function(params){
		var paramsToAssign = {};
		var paramsToUnAssign = {};
		var n1 = 0;
		var n2 = 0;
		for ( var key in this.selectedRolesMap){
			var roles = this.selectedRolesMap[key];
			for ( var i = 0; i < roles.length; i++){
				if (undefined == this.assignedRolesMap[key] || null == this.assignedRolesMap[key] 
					|| this.assignedRolesMap[key].indexOf(roles[i]) === -1 ){
					n1 = n1 + 1;
					paramsToAssign['orgEntityId' + n1] = key;
					paramsToAssign['roleId' + n1] = roles[i];
				}
			}
		}
		
		for ( var key in this.assignedRolesMap){
			var roles = this.assignedRolesMap[key];
			for ( var i = 0; i < roles.length; i++){
				if (undefined === this.selectedRolesMap[key] || null === this.selectedRolesMap[key] 
					|| this.selectedRolesMap[key].indexOf(roles[i]) === -1 ){
					n2 = n2 + 1;
					paramsToUnAssign['orgEntityId' + n2] = key;
					paramsToUnAssign['roleId' + n2] = roles[i];
				}
			}
		}
		 
		if (n1 > 0 ){
			paramsToAssign.URL = "StoreView";//old command still check the presence of the 'URL' parameter
			paramsToAssign.storeId = this.storeId;
			paramsToAssign.langId = this.langId;
			paramsToAssign.memberId = this.memberId;
			paramsToAssign.authToken = this.authToken;
			params.paramsToAssign = paramsToAssign;
		}
		if (n2 > 0){
			paramsToUnAssign.URL = "StoreView";
			paramsToUnAssign.storeId = this.storeId;
			paramsToUnAssign.langId = this.langId;
			paramsToUnAssign.memberId = this.memberId;
			paramsToUnAssign.authToken = this.authToken;
			params.paramsToUnAssign = paramsToUnAssign;
		}
	}
	
};//-----------------------------------------------------------------
// Licensed Materials - Property of IBM
//
// WebSphere Commerce
//
// (C) Copyright IBM Corp. 2014, 2016 All Rights Reserved.
//
// US Government Users Restricted Rights - Use, duplication or
// disclosure restricted by GSA ADP Schedule Contract with
// IBM Corp.
//-----------------------------------------------------------------

/**
 * Declares a new render context for role assignment role selector check box area.
 */
wcRenderContext.declare("UserRoleManagement_RoleSelector_Context",["UserRoleManagement_RoleSelector"],{"orgId":""});
/**
 * searchType: 
 * 		4 containing, ignore case
 * 		5 match case, exact match
 * 	
 */
wcRenderContext.declare("UserRoleManagement_OrgList_Context",["UserRoleManagement_OrgList"],{"beginIndex":"0", "orgNameSearch":"", "selectOrgId":"", "searchType":"4"});


/**
 * Declares a new refresh controller for update role selector check box.
 */
function declareUserRoleManagement_RoleSelector_controller() {
	var myWidgetObj = $("#UserRoleManagement_RoleSelector");

	var myRCProperties = wcRenderContext.getRenderContextProperties("UserRoleManagement_RoleSelector_Context");
	
	myWidgetObj.refreshWidget({
		/** 
		 * Refreshes the list table display if an item is updated.
		 * This function is called when a render context event is detected. 
		 */    	   
		renderContextChangedHandler: function() {					
			myWidgetObj.refreshWidget("refresh", myRCProperties);
	    },
		
		/** 
		 * Clears the progress bar
		 */
		postRefreshHandler: function() {
			UserRoleManagementJS.setSelectedOrgRoleNameMap();
			UserRoleManagementJS.updateSelectorCheckbox();
			UserRoleManagementJS.updateSelectionSummary();
			cursor_clear();			 
		}
	});
};

/**
 * Declares a new refresh controller for update organization list in .
 */
function declareUserRoleManagement_OrgList_controller() {
	var myWidgetObj = $("#UserRoleManagement_OrgList");
	
	var myRCProperties = wcRenderContext.getRenderContextProperties("UserRoleManagement_OrgList_Context");
	
	myWidgetObj.refreshWidget({
		/** 
		 * Refreshes the list table display if an item is updated.
		 * This function is called when a render context event is detected. 
		 */    	   
		renderContextChangedHandler: function() {
			myWidgetObj.refreshWidget("refresh", myRCProperties);
	    },
		
		/** 
		 * Clears the progress bar
		 * 
		 * @param {object} widget The registered refresh area
		 */
		postRefreshHandler: function(widget) {
	
			UserRoleManagementJS.updateCurrentOrgNameMap();
			UserRoleManagementJS.setSelectedOrgRoleNameMap();
			
			if (myRCProperties.selectOrgId != ''){
				//select the org preselected by user in selection summary column
				UserRoleManagementJS.selectedOrg = myRCProperties.selectOrgId;
			}else if (UserRoleManagementJS.currentOrgNameMap.first !== undefined && UserRoleManagementJS.currentOrgNameMap.first !== null){
				//select the first org in the list shown
				UserRoleManagementJS.selectedOrg = UserRoleManagementJS.currentOrgNameMap.first;
			}else {
				UserRoleManagementJS.selectedOrg = "";
			}
			UserRoleManagementJS.updateSelectorCheckbox();
			UserRoleManagementJS.updateSelectionSummary();
			UserRoleManagementJS.updateOrganizationPanel();
			cursor_clear();
		}
	});
};
//-----------------------------------------------------------------
// Licensed Materials - Property of IBM
//
// WebSphere Commerce
//
// (C) Copyright IBM Corp. 2016 All Rights Reserved.
//
// US Government Users Restricted Rights - Use, duplication or
// disclosure restricted by GSA ADP Schedule Contract with
// IBM Corp.
//-----------------------------------------------------------------


/** 
 * @fileOverview This file contains all the global variables and JavaScript functions needed for wish list page in My Account section.
 * This JavaScript file defines all the functions used  by the AccountWishDisplay.jsp file.
 * @version 1.0
 */

/* Declare the namespace if it does not already exist. */
if (WishListDetailJS == null || typeof(WishListDetailJS) != "object") {
	/**
	 * @class This WishListDetailJS class defines all the variables and functions for the wish list page of My account section.
	 * The wish list page displays all the wish list item of an user and provides functions like remove from the wish list, add to cart, etc.
	 *
	 */
	var WishListDetailJS = {	
		/* Global variables used in the CompareProductDisplay page. */
			
		/** The contextChanged is a boolean flag indicating whether the context was changed and if there is a need to refresh the wish list result. */
		contextChanged:false, 

		/**
		* This function is called when user selects a different page from the current page
		* @param (Object) data The object that contains data used by pagination control 
		*/
		showResultsPage:function(data){
			var pageNumber = parseInt(data['pageNumber']) - 1,
				pageSize = parseInt(data['pageSize']),
				beginIndex = pageSize * pageNumber;

			setCurrentId(data["linkId"]);

			if(!submitRequest()){
				return;
			}

			cursor_wait();

			if($("#WishlistDisplay_Widget").length){
				wcRenderContext.updateRenderContext("WishlistDisplay_Context", {startIndex: beginIndex, currentPage: pageNumber});
			}

			if($("#SharedWishlistDisplay_Widget").length) {	
				wcRenderContext.updateRenderContext("SharedWishlistDisplay_Context", {startIndex: beginIndex, currentPage: pageNumber});
			}
			MessageHelper.hideAndClearMessage();
		},

		/**
		 * Updates the ContentURL and does not cause an Ajax refresh. 
		 * 
		 * @param {string} contentURL  the value of the controller URL.
		 */
		updateContentURL: function(contentURL) {
			if($("#WishlistDisplay_Widget").length){
				$("#WishlistDisplay_Widget").refreshWidget("updateUrl", contentURL);
			}

			if($("#SharedWishlistDisplay_Widget").length) {
				$("#SharedWishlistDisplay_Widget").refreshWidget("updateUrl", contentURL);
			}
		},

		/**
		* Updates the ContentURL and causes an Ajax refresh. 
		* 
		* @param {string} contentURL  the value of the controller URL.
		*/
		loadContentURL:function(contentURL){
			/* Handles multiple clicks */
			if(!submitRequest()){
				return;
			}   	
			cursor_wait();
			if($("#WishlistDisplay_Widget").length){
				$("#WishlistDisplay_Widget").refreshWidget("updateUrl", contentURL);
				wcRenderContext.updateRenderContext("WishlistDisplay_Context");
			}

			if($("#SharedWishlistDisplay_Widget").length) {
				$("#SharedWishlistDisplay_Widget").refreshWidget("updateUrl", contentURL);		
				wcRenderContext.updateRenderContext("SharedWishlistDisplay_Context");
			}
		}
	};
}
//-----------------------------------------------------------------
// Licensed Materials - Property of IBM
//
// WebSphere Commerce
//
// (C) Copyright IBM Corp. 2016 All Rights Reserved.
//
// US Government Users Restricted Rights - Use, duplication or
// disclosure restricted by GSA ADP Schedule Contract with
// IBM Corp.
//-----------------------------------------------------------------

/** 
 * @fileOverview This file contains all the global variables and JavaScript functions needed for wish list email widget used in My Account section.
 * This JavaScript file defines all the functions used by the WishListEmail.jsp file.
 * @version 1.0
 */

/* Declare the namespace if it does not already exist. */
if (WishListEmailJS == null || typeof(WishListEmailJS) != "object") {
	/**
	 * @class This WishListEmailJS class defines all the variables and functions for the wish list email widget used in the My account section.
	 *
	 */
	var WishListEmailJS = {
		/**
		* This function is used to clear some of the fields in the email form in wish list page after InterestItemListMessage is invoked.
		* @param {string} formId  the id of the email form in WishList page.
		*/	
		clearWishListEmailForm:function(formId){
			var form = document.getElementById(formId);
			form.recipient.value = "";
			form.sender_name.value = "";
			form.sender_email.value = "";
			form.wishlist_message.value="";
		}
	}
}




//-----------------------------------------------------------------
// Licensed Materials - Property of IBM
//
// WebSphere Commerce
//
// (C) Copyright IBM Corp. 2014, 2016 All Rights Reserved.
//
// US Government Users Restricted Rights - Use, duplication or
// disclosure restricted by GSA ADP Schedule Contract with
// IBM Corp.
//-----------------------------------------------------------------

/** 
 * @fileOverview This javascript is used by the Approval List pages to control the refresh areas.
 * @version 1.2
 */
var declareOrderApprovalListRefreshArea = function() {
    var myWidgetObj = $("#OrderApprovalTable_Widget");

    wcRenderContext.declare("OrderApprovalTable_Context", ["OrderApprovalTable_Widget"], {"beginIndex":"0", "orderId": "", "firstName": "", "lastName":"","startDate":"","endDate":"","approvalStatus":"0"});

    wcTopic.subscribe(["AjaxApproveOrderRequest","AjaxRejectOrderRequest"], function() {
        myWidgetObj.refreshWidget("refresh", wcRenderContext.getRenderContextProperties("OrderApprovalTable_Context"));
    });

    myWidgetObj.refreshWidget({
        renderContextChangedHandler: function() {
            myWidgetObj.refreshWidget("refresh", wcRenderContext.getRenderContextProperties("OrderApprovalTable_Context"));
        }, 
        postRefreshHandler: function() {
            OrderApprovalListJS.restoreToolbarStatus();
            cursor_clear();
        }
    });
}        
 
/**
 * Declares a new refresh controller for buyer approval.
 */
var declareBuyerApprovalTableRefreshArea = function() {
	var myWidgetObj = $("#BuyerApprovalTable_Widget");
    
    /**
     * Declares a new render context for buyer approval list table
     */
	wcRenderContext.declare("BuyerApprovalTable_Context", ["BuyerApprovalTable_Widget"], {
        "beginIndex": "0",
        "approvalId": "",
        "firstName": "",
        "lastName": "",
        "startDate": "",
        "endDate": "",
        "approvalStatus": "0"
	});
  	
	wcTopic.subscribe(["AjaxApproveBuyerRequest","AjaxRejectBuyerRequest"], function() {
		myWidgetObj.refreshWidget("refresh", wcRenderContext.getRenderContextProperties("BuyerApprovalTable_Context"));
	});
    
	myWidgetObj.refreshWidget({
		renderContextChangedHandler: function () {
            myWidgetObj.refreshWidget("refresh", wcRenderContext.getRenderContextProperties("BuyerApprovalTable_Context"));
        },

        postRefreshHandler: function() {
        	BuyerApprovalListJS.restoreToolbarStatus();
            cursor_clear();
        }
	});
}

/**
 * Declares a new refresh controller for buyer approval comment.
 */
var declareApprovalCommentController = function() {    
    var myWidgetObj = $("#ApprovalComment_Widget");
    
    /**
     * Declares a new render context for approval comments widget
     */
    wcRenderContext.declare("ApprovalComment_Context", ["ApprovalComment_Widget"], {
       "approvalStatus": "all"
    });
    
    /** 
	* Refreshes the approval comment widget if a request is approved/rejected.
	* This function is called when a modelChanged event is detected. 
	* 
	* @param {string} message The model changed event message
	* @param {object} widget The registered refresh area
	*/    
    wcTopic.subscribe(["AjaxApproveRequest","AjaxRejectRequest"], function() {
		myWidgetObj.refreshWidget("refresh", wcRenderContext.getRenderContextProperties("ApprovalComment_Context"));
	});
    
    myWidgetObj.refreshWidget({
        /** 
        * This function is called when a render context changed event is detected. 
        * 
        * @param {string} message The render context changed event message
        * @param {object} widget The registered refresh area
        */
        renderContextChangedHandler: function () {
            myWidgetObj.refreshWidget("refresh", wcRenderContext.getRenderContextProperties("ApprovalComment_Context"));
        }
    });
};//-----------------------------------------------------------------
// Licensed Materials - Property of IBM
//
// WebSphere Commerce
//
// (C) Copyright IBM Corp. 2014 All Rights Reserved.
//
// US Government Users Restricted Rights - Use, duplication or
// disclosure restricted by GSA ADP Schedule Contract with
// IBM Corp.
//-----------------------------------------------------------------

/** 
 * @fileOverview This javascript is used by the Approval List Pages to handle the services for 
 * approving/rejecting a buyer/order approval record.
 * @version 1.10
 */

/**
 * This service allows approvers and admins to approve a order request
 * @constructor
 */
wcService.declare({
	id:"AjaxApproveOrderRequest",
	actionId:"AjaxApproveOrderRequest",
	url:"AjaxRESTHandleApproval",
	formId:""

	 /**
     * Hides all the messages and the progress bar.
     * @param (object) serviceResponse The service response object, which is the
     * JSON object returned by the service invocation.
     */
	,successHandler: function(serviceResponse) {
		MessageHelper.hideAndClearMessage();
		cursor_clear();
		MessageHelper.displayStatusMessage(MessageHelper.messages["APPROVAL_APPROVE_SUCCESS"]);
	}
	
	/**
     * display an error message.
     * @param (object) serviceResponse The service response object, which is the
     * JSON object returned by the service invocation.
     */
	,failureHandler: function(serviceResponse) {

		if (serviceResponse.errorMessage) {
			MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
		} 
		else {
			 if (serviceResponse.errorMessageKey) {
				MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
			 }
		}
		cursor_clear();
	}	
}),

/**
 * This service allows approvers and admins to approve a order request
 * @constructor
 */
wcService.declare({
	id:"AjaxRejectOrderRequest",
	actionId:"AjaxRejectOrderRequest",
	url:"AjaxRESTHandleApproval",
	formId:""

	 /**
     * Hides all the messages and the progress bar.
     * @param (object) serviceResponse The service response object, which is the
     * JSON object returned by the service invocation.
     */
	,successHandler: function(serviceResponse) {
		MessageHelper.hideAndClearMessage();
		cursor_clear();
		MessageHelper.displayStatusMessage(MessageHelper.messages["APPROVAL_REJECT_SUCCESS"]);
	}
	
	/**
     * display an error message.
     * @param (object) serviceResponse The service response object, which is the
     * JSON object returned by the service invocation.
     */
	,failureHandler: function(serviceResponse) {

		if (serviceResponse.errorMessage) {
			MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
		} 
		else {
			 if (serviceResponse.errorMessageKey) {
				MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
			 }
		}
		cursor_clear();
	}	
}),

/**
 * This service allows approvers and admins to approve a buyer request
 * @constructor
 */
wcService.declare({
	id:"AjaxApproveBuyerRequest",
	actionId:"AjaxApproveBuyerRequest",
	url:"AjaxRESTHandleApproval",
	formId:""

	 /**
     * Hides all the messages and the progress bar.
     * @param (object) serviceResponse The service response object, which is the
     * JSON object returned by the service invocation.
     */
	,successHandler: function(serviceResponse) {
		MessageHelper.hideAndClearMessage();
		cursor_clear();
		MessageHelper.displayStatusMessage(MessageHelper.messages["APPROVAL_APPROVE_SUCCESS"]);
	}
	
	/**
     * display an error message.
     * @param (object) serviceResponse The service response object, which is the
     * JSON object returned by the service invocation.
     */
	,failureHandler: function(serviceResponse) {

		if (serviceResponse.errorMessage) {
			MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
		} 
		else {
			 if (serviceResponse.errorMessageKey) {
				MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
			 }
		}
		cursor_clear();
	}	
}),

/**
 * This service allows approvers and admins to approve a buyer request
 * @constructor
 */
wcService.declare({
	id:"AjaxRejectBuyerRequest",
	actionId:"AjaxRejectBuyerRequest",
	url:"AjaxRESTHandleApproval",
	formId:""

	 /**
     * Hides all the messages and the progress bar.
     * @param (object) serviceResponse The service response object, which is the
     * JSON object returned by the service invocation.
     */
	,successHandler: function(serviceResponse) {
		MessageHelper.hideAndClearMessage();
		cursor_clear();
		MessageHelper.displayStatusMessage(MessageHelper.messages["APPROVAL_REJECT_SUCCESS"]);
	}
	
	/**
     * display an error message.
     * @param (object) serviceResponse The service response object, which is the
     * JSON object returned by the service invocation.
     */
	,failureHandler: function(serviceResponse) {

		if (serviceResponse.errorMessage) {
			MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
		} 
		else {
			 if (serviceResponse.errorMessageKey) {
				MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
			 }
		}
		cursor_clear();
	}	
}),

/**
 * This service allows approvers and admins to approve a request
 * @constructor
 */
wcService.declare({
	id:"AjaxApproveRequest",
	actionId:"AjaxApproveRequest",
	url:"AjaxRESTHandleApproval",
	formId:""

	 /**
     * Hides all the messages and the progress bar.
     * @param (object) serviceResponse The service response object, which is the
     * JSON object returned by the service invocation.
     */
	,successHandler: function(serviceResponse) {
		MessageHelper.hideAndClearMessage();
		cursor_clear();
		MessageHelper.displayStatusMessage(MessageHelper.messages["APPROVAL_APPROVE_SUCCESS"]);
	}
	
	/**
     * display an error message.
     * @param (object) serviceResponse The service response object, which is the
     * JSON object returned by the service invocation.
     */
	,failureHandler: function(serviceResponse) {

		if (serviceResponse.errorMessage) {
			MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
		} 
		else {
			 if (serviceResponse.errorMessageKey) {
				MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
			 }
		}
		cursor_clear();
	}	
}),

/**
 * This service allows approvers and admins to approve a request
 * @constructor
 */
wcService.declare({
	id:"AjaxRejectRequest",
	actionId:"AjaxRejectRequest",
	url:"AjaxRESTHandleApproval",
	formId:""

	 /**
     * Hides all the messages and the progress bar.
     * @param (object) serviceResponse The service response object, which is the
     * JSON object returned by the service invocation.
     */
	,successHandler: function(serviceResponse) {
		MessageHelper.hideAndClearMessage();
		cursor_clear();
		MessageHelper.displayStatusMessage(MessageHelper.messages["APPROVAL_REJECT_SUCCESS"]);
	}
	
	/**
     * display an error message.
     * @param (object) serviceResponse The service response object, which is the
     * JSON object returned by the service invocation.
     */
	,failureHandler: function(serviceResponse) {

		if (serviceResponse.errorMessage) {
			MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
		} 
		else {
			 if (serviceResponse.errorMessageKey) {
				MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
			 }
		}
		cursor_clear();
	}	
})

	

//-----------------------------------------------------------------
// Licensed Materials - Property of IBM
//
// WebSphere Commerce
//
// (C) Copyright IBM Corp. 2013, 2017 All Rights Reserved.
//
// US Government Users Restricted Rights - Use, duplication or
// disclosure restricted by GSA ADP Schedule Contract with
// IBM Corp.
//-----------------------------------------------------------------

productDisplayJS = {

    /** The language ID currently in use **/
    langId: "-1",

    /** The store ID currently in use **/
    storeId: "",

    /** The catalog ID currently in use **;/
    catalogId: "",

    /** Holds the current user type such as guest or registered user. Allowed values are 'G' for guest and 'R' for registered.**/
    userType: "",

    /** A boolean used in a variety of the add to cart methods to tell whether or not the base item was added to the cart. **/
    baseItemAddedToCart: false,

    /** An array of entitled items which is used in various methods throughout ShoppingActions.js **/
    entitledItems: [],

    /** a JSON object that holds attributes of an entitled item **/
    entitledItemJsonObject: null,

    /** A map of attribute name value pairs for the currently selected attribute values **/
    selectedAttributesList: {},

    /** A map of currently selected attribute values for a catalog entry **/
    selectedAttributeValues: {},

    /** A map of HTML element ids associated with an attribute name **/
    registeredAttributeIds: {},

    /** A variable used to form the url dynamically for the more info link in the Quickinfo popup */
    moreInfoUrl: "",

    /**
     * A boolean used to to determine is it from a Qick info popup or not. 
     **/
    isPopup: false,

    /**
     * A boolean used to to determine whether or not to display the price range when the catEntry is selected. 
     **/
    displayPriceRange: true,

    /**
     * This array holds the json object returned from the service, holding the price information of the catEntry.
     **/
    itemPriceJsonOject: [],

    /** 
     * stores all name and value of all swatches 
     * this is a 2 dimension array and each record i contains the following information:
     * allSwatchesArray[i][0] - attribute name of the swatch
     * allSwatchesArray[i][1] - attribute value of the swatch
     * allSwatchesArray[i][2] - image1 of swatch (image to use for enabled state)
     * allSwatchesArray[i][3] - image2 of swatch (image to use for disabled state)
     * allSwatchesArray[i][4] - onclick action of the swatch when enabled
     **/
    allSwatchesArrayList: {},

    /**
     * stores all name and id of all dropdowns 
     **/
    allDropdownsList: {},

    /**
     * Holds the ID of the image used for swatch
     **/
    skuImageId: "",

    /**
     * The prefix of the cookie key that is used to store item IDs. 
     */
    cookieKeyPrefix: "CompareItems_",

    /**
     * The delimiter used to separate item IDs in the cookie.
     */
    cookieDelimiter: ";",

    /**
     * The maximum number of items allowed in the compare zone. 
     */
    maxNumberProductsAllowedToCompare: 4,

    /**
     * The minimum number of items allowed in the compare zone. 
     */
    minNumberProductsAllowedToCompare: 2,

    /**
     * Id of the base catalog entry. 
     */
    baseCatalogEntryId: 0,

    /**
     * An map which holds the attributes of a set of products
     */
    selectedProducts: {},

    /**
     * An array to keep the quantity of the products in a list (bundle)
     */
    productList: {},

    /**
     * stores the currency symbol
     */
    currencySymbol: "",

    /**
     * stores the compare return page name
     */
    compareReturnName: "",
    /**
     * stores the search term
     */
    searchTerm: "",

    search01: "'",

    search02: '"',

    replaceStr01: /\\\'/g,

    replaceStr02: /\\\"/g,

    ampersandChar: /&/g,

    ampersandEntityName: "&amp;",

    singleSKUProductWithoutDefiningAttribute: false,

    replaceStr001: "&#039;",
    replaceStr002: "&#034;",

    setCommonParameters: function (langId, storeId, catalogId, userType, currencySymbol) {
        productDisplayJS.langId = langId;
        productDisplayJS.storeId = storeId;
        productDisplayJS.catalogId = catalogId;
        productDisplayJS.userType = userType;
        productDisplayJS.currencySymbol = currencySymbol;
    },

    setEntitledItems: function (entitledItemArray) {
        productDisplayJS.entitledItems = entitledItemArray;
    },

    getCatalogEntryId: function (entitledItemId) {
        var attributeArray = [];
        var selectedAttributes = productDisplayJS.selectedAttributesList[entitledItemId];
        for (attribute in selectedAttributes) {
            attributeArray.push(attribute + "_|_" + selectedAttributes[attribute]);
        }
        // there are no selected attribute and no entitled item, this must be a single sku item without defining attribute
        if (selectedAttributes == null && this.entitledItems == null) {
            return entitledItemId.substring(entitledItemId.indexOf("_") + 1);
        }
        return productDisplayJS.resolveSKU(attributeArray);
    },

    /**
     * getCatalogEntryIdforProduct Returns the catalog entry ID for a catalog entry that has the same attribute values as a specified product's selected attributes as passed in via the selectedAttributes parameter.
     *
     * @param {String[]} selectedAttributes The array of selected attributes upon which to resolve the SKU.
     *
     * @return {String} catalog entry ID of the SKU.
     *
     **/
    getCatalogEntryIdforProduct: function (selectedAttributes) {
        var attributeArray = [];
        for (attribute in selectedAttributes) {
            attributeArray.push(attribute + "_|_" + selectedAttributes[attribute]);
        }
        return productDisplayJS.resolveSKU(attributeArray);
    },

    /**
     * retrieves the entitledItemJsonObject
     */
    getEntitledItemJsonObject: function () {
        return productDisplayJS.entitledItemJsonObject;
    },

    /**
     * resolveSKU Resolves a SKU using an array of defining attributes.
     *
     * @param {String[]} attributeArray An array of defining attributes upon which to resolve a SKU.
     *
     * @return {String} catentry_id The catalog entry ID of the SKU.
     *
     **/
    resolveSKU: function (attributeArray) {
        console.debug("Resolving SKU >> " + attributeArray + ">>" + this.entitledItems);
        var catentry_id = "";
        var attributeArrayCount = attributeArray.length;

        // if there is only one item, no need to check the attributes to resolve the sku
        if (this.entitledItems.length == 1) {
            return this.entitledItems[0].catentry_id;
        }
        for (x in this.entitledItems) {
            var catentry_id = this.entitledItems[x].catentry_id;
            var Attributes = this.entitledItems[x].Attributes;
            var attributeCount = 0;
            for (index in Attributes) {
                attributeCount++;
            }

            // Handle special case where a catalog entry has one sku with no attributes
            if (attributeArrayCount == 0 && attributeCount == 0) {
                return catentry_id;
            }
            if (attributeCount != 0 && attributeArrayCount >= attributeCount) {
                var matchedAttributeCount = 0;

                for (attributeName in attributeArray) {
                    var attributeValue = attributeArray[attributeName];
                    if (attributeValue in Attributes) {
                        matchedAttributeCount++;
                    }
                }

                if (attributeCount == matchedAttributeCount) {
                    console.debug("CatEntryId:" + catentry_id + " for Attribute: " + attributeArray);
                    this.disableBuyButtonforUnbuyable(x);
                    return catentry_id;
                }
            }
        }
        return null;
    },

    /**
     * disables add2cart button in case where the buyable flag is set to false
     */
    disableBuyButtonforUnbuyable: function (entitledItemIndex) {
        var buyableFlag = this.entitledItems[entitledItemIndex].buyable;
        //disable the add to cart button
        var btn = document.getElementById("add2CartBtn");
        if (buyableFlag != null && btn != null) {
            if (buyableFlag == 'false') {
                btn.className += " add2CartButtonDisabled";
            } else {
                btn.className = btn.className.replace(" add2CartButtonDisabled", "");
            }
        }
    },

    /**
     * registerAttributeIds Register the ids of HTML attributes that are associated with the specified attribute.
     *
     * @param {String} attributeName The name of the attribute.
     * @param {String} entitledItemId The element id where the json object of the sku is stored
     * @param {Object} ids Map of named HTML element ids
     *
     **/
    registerAttributeIds: function (attributeName, entitledItemId, ids) {
        var attributeIds = productDisplayJS.registeredAttributeIds[entitledItemId];
        if (attributeIds == null) {
            attributeIds = {};
            productDisplayJS.registeredAttributeIds[entitledItemId] = attributeIds;
        }

        attributeIds[productDisplayJS.removeQuotes(attributeName)] = ids;
    },

    /**
     * getAttributeIds Get the map of ids of HTML attributes that are associated with the specified attribute.
     *
     * @param {String} attributeName The name of the attribute.
     * @param {String} entitledItemId The element id where the json object of the sku is stored
     *
     * @return {Object} ids Map of named HTML element ids
     *
     **/
    getAttributeIds: function (attributeName, entitledItemId) {
        var ids = null;
        var attributeIds = productDisplayJS.registeredAttributeIds[entitledItemId];
        if (attributeIds != null) {
            ids = attributeIds[productDisplayJS.removeQuotes(attributeName)];
        }
        return ids;
    },

    /**
     * setSelectedAttribute Sets the selected attribute value for a particular attribute not in reference to any catalog entry.
     *					   One place this function is used is on CachedProductOnlyDisplay.jsp where there is a drop down box of attributes.
     *					   When an attribute is selected from that drop down this method is called to update the selected value for that attribute.
     *
     * @param {String} selectedAttributeName The name of the attribute.
     * @param {String} selectedAttributeValue The value of the selected attribute.
     * @param {String} entitledItemId The element id where the json object of the sku is stored
     * @param {String} skuImageId This is optional. The element id of the product image - image element id is different in product page and category list view. Product page need not pass it because it is set separately
     * @param {String} imageField This is optional. The json field from which image should be picked. Pass value if a different size image need to be picked
     * @param {String} selectedAttributeDisplayValue This is optional. The attribute display value formatted with UOM
     *
     **/
    setSelectedAttribute: function (selectedAttributeName, selectedAttributeValue, entitledItemId, skuImageId, imageField, selectedAttributeDisplayValue) {
        var selectedAttributes = productDisplayJS.selectedAttributesList[entitledItemId];
        if (selectedAttributes == null) {
            selectedAttributes = {};
        }
        selectedAttributeValue = selectedAttributeValue.replace(productDisplayJS.replaceStr001, productDisplayJS.search01);
        selectedAttributeValue = selectedAttributeValue.replace(productDisplayJS.replaceStr002, productDisplayJS.search02);
        selectedAttributeValue = selectedAttributeValue.replace(productDisplayJS.replaceStr01, productDisplayJS.search01);
        selectedAttributeValue = selectedAttributeValue.replace(productDisplayJS.replaceStr02, productDisplayJS.search02);
        selectedAttributeValue = selectedAttributeValue.replace(productDisplayJS.ampersandChar, productDisplayJS.ampersandEntityName);
        selectedAttributes[selectedAttributeName] = selectedAttributeValue;
        productDisplayJS.moreInfoUrl = productDisplayJS.moreInfoUrl + '&' + selectedAttributeName + '=' + selectedAttributeValue;
        productDisplayJS.selectedAttributesList[entitledItemId] = selectedAttributes;
        if (skuImageId != undefined) {
            productDisplayJS.setSKUImageId(skuImageId);
        }
        var entitledItemJSON;
        if ($("#" + entitledItemId).length && !productDisplayJS.isPopup) {
            //the json object for entitled items are already in the HTML. 
            entitledItemJSON = eval('(' + $("#" + entitledItemId).html() + ')');
        } else {
            //if $("#" + entitledItemId).length is 0, that means there's no <div> in the HTML that contains the JSON object. 
            //in this case, it must have been set in catalogentryThumbnailDisplay.js when the quick info
            entitledItemJSON = productDisplayJS.getEntitledItemJsonObject();
        }
        productDisplayJS.setEntitledItems(entitledItemJSON);
        var attributeIds = productDisplayJS.getAttributeIds(selectedAttributeName, entitledItemId);
        if (attributeIds != null) {
            var usedFilterValue = $("#" + attributeIds.usedFilterValueId);
            if (usedFilterValue != null) {
                if (selectedAttributeDisplayValue) {
                    $(usedFilterValue).html(selectedAttributeDisplayValue);
                } else {
                    $(usedFilterValue).html(selectedAttributeValue);
                }
            }
            if (selectedAttributeValue === "") {
                $("#" + attributeIds.usedFilterId).removeClass("visible");
                var hideCurrentUsedFilters = true;
                var dropdownList = this.allDropdownsList[entitledItemId];
                for (var i in dropdownList) {
                    if (selectedAttributes[dropdownList[i].name] !== "") {
                        hideCurrentUsedFilters = false;
                        break;
                    }
                }
                if (hideCurrentUsedFilters) {
                    $("#currentUsedFilters_" + entitledItemId).addClass("hidden");
                }
            } else {
                $("#" + attributeIds.usedFilterId).addClass("visible");
                $("#currentUsedFilters_" + entitledItemId).removeClass("hidden");
                var selectedAttributeNameId = selectedAttributeName.replace(productDisplayJS.search01, "\\\'").replace(productDisplayJS.search02, '\\\"');
                $("[id='attr_" + entitledItemId + '_' + selectedAttributeNameId + "']").addClass("hidden");
            }

            productDisplayJS.makeDropdownSelection(selectedAttributeName, selectedAttributeValue, entitledItemId);
        }
    },

    /**
     * resetSelectedAttribute Resets the the selected attribute value for the specified attribute.
     *
     * @param {String} attributeName The name of the attribute.
     * @param {String} entitledItemId The element id where the json object of the sku is stored
     * @param {String} productUrl The url of the parent product
     *
     **/
    resetSelectedAttribute: function (attributeName, entitledItemId) {
        var attributeName = attributeName.replace(productDisplayJS.search01, "\\\'").replace(productDisplayJS.search02, '\\\"');
        $("[id='attr_" + entitledItemId + '_' + attributeName + "']").removeClass("hidden");

        var attributeIds = productDisplayJS.getAttributeIds(attributeName, entitledItemId);
        if (attributeIds != null) {
            var selectWidget = $(attributeIds.selectAttributeValueId);
            if (selectWidget.length) {
                selectWidget.val("");
                selectWidget.Select("refresh");
            }
        }

        var dropdownList = this.allDropdownsList[entitledItemId];
        var remainingSelectedAttributes = {};

        for (var i = 0; i < dropdownList.length; i++) {
            if (dropdownList[i].name.replace(/\\'/g, "'") == attributeName.replace(/\\'/g, "'")) {
                $(dropdownList[i].node).removeClass("hidden");
                $(dropdownList[i].node).val('');
                $(dropdownList[i].node).Select("refresh");
                $(dropdownList[i].node).change();
            } else {
                for (var j = 0; j < dropdownList[i].options.length; j++) {
                    if (dropdownList[i].options[j].selected === true) {
                        remainingSelectedAttributes[dropdownList[i].name] = dropdownList[i].options[j].value;
                    }
                }
            }
        }

        var urlWithoutParams = document.location.href.split('?')[0];
        var params = "?";

        var productUrl = "";
        if ($("#ProductDisplayURL").length) {
            productUrl = $("#ProductDisplayURL").html();
        }

        var displaySKUContextData = false;
        if ($("#displaySKUContextData").length) {
            displaySKUContextData = eval('(' + $("#displaySKUContextData").html() + ')');
        }

        if (displaySKUContextData && urlWithoutParams !== productUrl) {
            for (attr in remainingSelectedAttributes) {
                if (remainingSelectedAttributes.hasOwnProperty(attr)) {
                    params += attr + '=' + remainingSelectedAttributes[attr] + '&';
                }
            }

            params = params.slice(0, -1);
            params = params.replace("\\\'", "'").replace('\\\"', '"');
            document.location.replace(productUrl + params);
        }
    },

    /**
     * setSelectedAttributeName Set the selected attribute name and make the drop-down associated with the attribute visible.
     *
     * @param {String} attributeName The name of the attribute.
     * @param {String} entitledItemId The element id where the json object of the sku is stored
     *
     **/
    setSelectedAttributeName: function (attributeName, entitledItemId) {
        var oldSelectedAttributeValuesId = productDisplayJS.selectedAttributeValues[entitledItemId];
        if (oldSelectedAttributeValuesId != null && oldSelectedAttributeValuesId !== "") {
            $("#" + oldSelectedAttributeValuesId).addClass("mobileHidden");
        }
        var selectedAttributeValuesId = null;
        var attributeIds = productDisplayJS.getAttributeIds(attributeName, entitledItemId);
        if (attributeIds != null) {
            selectedAttributeValuesId = attributeIds.attributeValuesId;
        }
        if (selectedAttributeValuesId != null && selectedAttributeValuesId !== "") {
            $("#" + selectedAttributeValuesId).removeClass("mobileHidden");
        }
        productDisplayJS.selectedAttributeValues[entitledItemId] = selectedAttributeValuesId;
    },

    /**
     * Add2ShopCartAjax This function is used to add a catalog entry to the shopping cart using an AJAX call. This will resolve the catentryId using entitledItemId and adds the item to the cart.
     *				This function will resolve the SKU based on the entitledItemId passed in and call {@link productDisplayJS.AddItem2ShopCartAjax}.
     * @param {String} entitledItemId A DIV containing a JSON object which holds information about a catalog entry. You can reference CachedProductOnlyDisplay.jsp to see how that div is constructed.
     * @param {int} quantity The quantity of the item to add to the cart.
     * @param {String} isPopup If the value is true, then this implies that the function was called from a quick info pop-up. 	
     * @param {Object} customParams - Any additional parameters that needs to be passed during service invocation.
     *
     **/
    Add2ShopCartAjax: function (entitledItemId, quantity, isPopup, customParams) {
        var dialog = $('#quick_cart_container').data("wc-WCDialog");
        if (dialog) {
            dialog.close();
        }
        if (browseOnly) {
            MessageHelper.displayErrorMessage(Utils.getLocalizationMessage('ERROR_ADD2CART_BROWSE_ONLY'));
            return;
        }
        var entitledItemJSON;

        if ($("#" + entitledItemId).length) {
            //the json object for entitled items are already in the HTML. 
            entitledItemJSON = eval('(' + $("#" + entitledItemId).html() + ')');
        } else {
            //if $("#" + entitledItemId).length is 0, that means there's no <div> in the HTML that contains the JSON object. 
            //in this case, it must have been set in catalogentryThumbnailDisplay.js when the quick info
            entitledItemJSON = this.getEntitledItemJsonObject();
        }

        productDisplayJS.setEntitledItems(entitledItemJSON);
        var catalogEntryId = productDisplayJS.getCatalogEntryId(entitledItemId);

        if (catalogEntryId != null) {
            var productId = entitledItemId.substring(entitledItemId.indexOf("_") + 1);
            productDisplayJS.AddItem2ShopCartAjax(catalogEntryId, quantity, customParams, productId);
            productDisplayJS.baseItemAddedToCart = true;

        } else if (isPopup == true) {
            $('#second_level_category_popup').css("zIndex", '1');
            MessageHelper.formErrorHandleClient('addToCartLinkAjax', Utils.getLocalizationMessage('ERR_RESOLVING_SKU'));
        } else {
            MessageHelper.displayErrorMessage(Utils.getLocalizationMessage('ERR_RESOLVING_SKU'));
            productDisplayJS.baseItemAddedToCart = false;
        }
    },

    AddItem2ShopCartAjax: function (catEntryIdentifier, quantity, customParams, productId) {
        if (browseOnly) {
            MessageHelper.displayErrorMessage(Utils.getLocalizationMessage('ERROR_ADD2CART_BROWSE_ONLY'));
            return;
        }
        var params = {
            storeId: this.storeId,
            catalogId: this.catalogId,
            langId: this.langId,
            orderId: "."
        };
        // Remove calculations for performance
        // params.calculationUsage = "-1,-2,-5,-6,-7";
        params.inventoryValidation = "true";
        params.calculateOrder = "0";
        var ajaxShopCartService = "AddOrderItem";

        shoppingActionsJS.productAddedList = {};
        if (Array.isArray(catEntryIdentifier) && Array.isArray(quantity)) {
            for (var i = 0; i < catEntryIdentifier.length; i++) {
                if (!isPositiveInteger(quantity[i])) {
                    MessageHelper.displayErrorMessage(Utils.getLocalizationMessage('QUANTITY_INPUT_ERROR'));
                    return;
                }
                params["catEntryId_" + (i + 1)] = catEntryIdentifier[i];
                params["quantity_" + (i + 1)] = quantity[i];
            }
        } else {
            if (!isPositiveInteger(quantity)) {
                MessageHelper.displayErrorMessage(Utils.getLocalizationMessage('QUANTITY_INPUT_ERROR'));
                return;
            }
            params.catEntryId = catEntryIdentifier;
            params.quantity = quantity;

            var selectedAttrList = {};
            for (attr in productDisplayJS.selectedAttributesList['entitledItem_' + productId]) {
                selectedAttrList[attr] = productDisplayJS.selectedAttributesList['entitledItem_' + productId][attr];
            }

            if (productId == undefined) {
                shoppingActionsJS.saveAddedProductInfo(quantity, catEntryIdentifier, catEntryIdentifier, selectedAttrList);
            } else {
                shoppingActionsJS.saveAddedProductInfo(quantity, productId, catEntryIdentifier, selectedAttrList);
            }
        }

        //Pass any other customParams set by other add on features
        if (customParams != null && customParams != 'undefined') {
            for (i in customParams) {
                params[i] = customParams[i];
            }
            if (customParams['catalogEntryType'] == 'dynamicKit') {
                ajaxShopCartService = "AddPreConfigurationToCart";
            }
        }

        var contractIdElements = document.getElementsByName('contractSelectForm_contractId');
        if (contractIdElements != null && contractIdElements != "undefined") {
            for (i = 0; i < contractIdElements.length; i++) {
                if (contractIdElements[i].checked) {
                    params.contractId = contractIdElements[i].value;
                    break;
                }
            }
        }

        //For Handling multiple clicks
        if (!submitRequest()) {
            return;
        }
		
		cursor_wait();
		var addToCartEventConsumed = false;

		if(typeof callCenterIntegrationJS != 'undefined' && callCenterIntegrationJS != undefined && callCenterIntegrationJS != null){
			var catEntry = productDisplayJS.itemPriceJsonOject[params.catEntryId].catalogEntry;
			var partNumber = catEntry.catalogEntryIdentifier.externalIdentifier.partNumber;
			var wccParams = {};
			wccParams["partNumber"] = partNumber;
			addToCartEventConsumed = callCenterIntegrationJS.consumeAddToCartEvent(params,wccParams);
		}

		if(!addToCartEventConsumed) {
			wcService.invoke(ajaxShopCartService, params);
		}
        productDisplayJS.baseItemAddedToCart = true;

        if (document.getElementById("headerShopCartLink") && document.getElementById("headerShopCartLink").style.display != "none") {
            $("#headerShopCart").focus();
        } else {
            $("#headerShopCart1").focus();
        }
    },

    /* SwatchCode start */

    /**
     * Sets the ID of the image to use for swatch.
     * @param {String} skuImageId The ID of the full image element.
     **/
    setSKUImageId: function (skuImageId) {
        productDisplayJS.skuImageId = skuImageId;
    },

    /**
     * getImageForSKU Returns the full image of the catalog entry with the selected attributes as specified in the {@link productDisplayJS.selectedAttributes} value.
     *					This method uses resolveImageForSKU to find the SKU image with the selected attributes values.
     *
     * @param {String} imageField, the field name from which the image should be picked
     * @return {String} path to the SKU image.
     * 
     *
     **/
    getImageForSKU: function (entitledItemId, imageField) {
        var attributeArray = [];
        var selectedAttributes = productDisplayJS.selectedAttributesList[entitledItemId];
        for (attribute in selectedAttributes) {
            attributeArray.push(attribute + "_|_" + selectedAttributes[attribute]);
        }
        return productDisplayJS.resolveImageForSKU(attributeArray, imageField);
    },

    /**
     * resolveImageForSKU Resolves image of a SKU using an array of defining attributes.
     *
     * @param {String[]} attributeArray An array of defining attributes upon which to resolve a SKU.
     * @param {String} imageField, the field name from which the image should be picked
     *
     * @return {String} imagePath The location of SKU image.
     *
     **/
    resolveImageForSKU: function (attributeArray, imageField) {
        console.debug("Resolving SKU >> " + attributeArray + ">>" + this.entitledItems);
        var imagePath = "";
        var attributeArrayCount = attributeArray.length;

        for (x in this.entitledItems) {
            if (null != imageField) {
                var imagePath = this.entitledItems[x][imageField];
            } else {
                var imagePath = this.entitledItems[x].ItemImage467;
            }

            var Attributes = this.entitledItems[x].Attributes;
            var attributeCount = 0;
            for (index in Attributes) {
                attributeCount++;
            }

            // Handle special case where a catalog entry has one sku with no attributes
            if (attributeArrayCount == 0 && attributeCount == 0) {
                return imagePath;
            }
            if (attributeCount != 0 && attributeArrayCount >= attributeCount) {
                var matchedAttributeCount = 0;

                for (attributeName in attributeArray) {
                    var attributeValue = attributeArray[attributeName];
                    if (attributeValue in Attributes) {
                        matchedAttributeCount++;
                    }
                }

                if (attributeCount == matchedAttributeCount) {
                    console.debug("ItemImage:" + imagePath + " for Attribute: " + attributeArray);
                    var imageArray = [];
                    imageArray.push(imagePath);
                    imageArray.push(this.entitledItems[x].ItemThumbnailImage);
                    if (this.entitledItems[x].ItemAngleThumbnail != null && this.entitledItems[x].ItemAngleThumbnail != undefined) {
                        imageArray.push(this.entitledItems[x].ItemAngleThumbnail);
                        imageArray.push(this.entitledItems[x].ItemAngleFullImage);
                        imageArray.push(this.entitledItems[x].ItemAngleThumbnailShortDesc);
                    }
                    return imageArray;
                }
            }
        }
        return null;
    },


    /**
     * changeViewImages Updates the angle views of the SKU.
     *
     * @param {String[]} itemAngleThumbnail An array of SKU view thumbnails.
     * @param {String[]} itemAngleFullImage An array of SKU view full images.
     * @param {String[]} itemAngleThumbnailShortDesc An array of short description for the SKU view thumbnails.
     **/
    changeViewImages: function (itemAngleThumbnail, itemAngleFullImage, itemAngleThumbnailShortDesc) {
        var imageCount = 0;
        for (x in itemAngleThumbnail) {
            var prodAngleCount = imageCount;
            imageCount++;

            var thumbnailWidgets = $("ul[id^='ProductAngleImagesAreaList']");
            if ($(thumbnailWidgets).length) {
                for (var i = 0; i < thumbnailWidgets.length; i++) {
                    if (null != thumbnailWidgets[i]) {
                        var angleThumbnail = document.createElement("li");
                        var angleThumbnailLink = document.createElement("a");
                        var angleThumbnailImg = document.createElement("img");

                        angleThumbnail.id = "productAngleLi" + prodAngleCount;

                        angleThumbnailLink.href = "JavaScript:changeThumbNail('productAngleLi" + prodAngleCount + "','" + itemAngleFullImage[x] + "');";
                        angleThumbnailLink.id = "WC_CachedProductOnlyDisplay_links_1_" + imageCount;
                        if (itemAngleThumbnailShortDesc != 'undefined' && itemAngleThumbnailShortDesc != null) {
                            angleThumbnailLink.title = itemAngleThumbnailShortDesc[x];
                        }

                        angleThumbnailImg.src = itemAngleThumbnail[x];
                        angleThumbnailImg.id = "WC_CachedProductOnlyDisplay_images_1_" + imageCount;
                        if (itemAngleThumbnailShortDesc != 'undefined' && itemAngleThumbnailShortDesc != null) {
                            angleThumbnailImg.alt = itemAngleThumbnailShortDesc[x];
                        }

                        if (prodAngleCount == 0) {
                            $(thumbnailWidgets[i]).empty();
                        }

                        angleThumbnailLink.appendChild(angleThumbnailImg);
                        angleThumbnail.appendChild(angleThumbnailLink);
                        thumbnailWidgets[i].appendChild(angleThumbnail);
                    }
                }
            }
        }

        var displayImageArea = "";
        if (imageCount > 0) {
            displayImageArea = 'block';
        } else {
            displayImageArea = 'none';
        }
        var angleImageArea = $("div[id^='ProductAngleImagesArea']");
        if (angleImageArea.length) {
            for (var i = 0; i < angleImageArea.length; i++) {
                if (null != angleImageArea[i]) {
                    $(angleImageArea[i]).css("display", displayImageArea);
                }
            }
        }
    },

    /**
     * Updates the swatches selections on list view.
     * Sets up the swatches array and sku images, then selects a default swatch value.
     **/
    updateSwatchListView: function () {
        var swatchArray = $("a[id^='swatch_array_']");
        for (var i = 0; i < swatchArray.length; i++) {
            var swatchArrayElement = $(swatchArray[i]);
            eval($(swatchArrayElement).attr("href"));
        }

        var swatchSkuImage = $("a[id^='swatch_setSkuImage_']");
        for (var i = 0; i < swatchSkuImage.length; i++) {
            var swatchSkuImageElement = $(swatchSkuImage[i]);
            eval(swatchSkuImageElement.attr("href"));
        }

        var swatchDefault = $("a[id^='swatch_selectDefault_']");
        for (var i = 0; i < swatchDefault.length; i++) {
            var swatchDefaultElement = swatchDefault[i];
            eval(swatchDefaultElement.attr("href"));
        }
    },

    /**
     * Handles the case when a swatch is selected. Set the border of the selected swatch.
     * @param {String} selectedAttributeName The name of the selected swatch attribute.
     * @param {String} selectedAttributeValue The value of the selected swatch attribute.
     * @param {String} entitledItemId The ID of the SKU
     * @param {String} doNotDisable The name of the swatch attribute that should never be disabled.
     * @param {String} imageField, the field name from which the image should be picked
     * @return boolean Whether the swatch is available for selection
     **/
    selectSwatch: function (selectedAttributeName, selectedAttributeValue, entitledItemId, doNotDisable, selectedAttributeDisplayValue, skuImageId, imageField) {
        if ($("#swatch_" + entitledItemId + "_" + selectedAttributeValue).hasClass("color_swatch_disabled")) {
            return;
        }
        var selectedAttributes = this.selectedAttributesList[entitledItemId];
        for (attribute in selectedAttributes) {
            if (attribute == selectedAttributeName) {
                // case when the selected swatch is already selected with a value, if the value is different than
                // what's being selected, reset other swatches and deselect the previous value and update selection
                if (selectedAttributes[attribute] != selectedAttributeValue) {
                    // deselect previous value and update swatch selection
                    var swatchElement = document.getElementById("swatch_" + entitledItemId + "_" + selectedAttributes[attribute]);
                    swatchElement.className = "color_swatch";
                    swatchElement.src = swatchElement.src.replace("_disabled.png", "_enabled.png");

                    //change the title text of the swatch link
                    document.getElementById("swatch_link_" + entitledItemId + "_" + selectedAttributes[attribute]).title = swatchElement.alt;
                }
            }
            $("#swatch_link_" + entitledItemId + "_" + selectedAttributes[attribute]).attr("aria-checked", "false");
        }
        this.makeSwatchSelection(selectedAttributeName, selectedAttributeValue, entitledItemId, doNotDisable, selectedAttributeDisplayValue, skuImageId, imageField);
    },

    /**
     * Make swatch selection - add to selectedAttribute, select image, and update other swatches and SKU image based on current selection.
     * @param {String} swatchAttrName The name of the selected swatch attribute.
     * @param {String} swatchAttrValue The value of the selected swatch attribute.
     * @param {String} entitledItemId The ID of the SKU.
     * @param {String} doNotDisable The name of the swatch attribute that should never be disabled.	
     * @param {String} skuImageId This is optional. The element id of the product image - image element id is different in product page and category list view. Product page need not pass it because it is set separately
     * @param {String} imageField This is optional. The json field from which image should be picked. Pass value if a different size image need to be picked
     **/
    makeSwatchSelection: function (swatchAttrName, swatchAttrValue, entitledItemId, doNotDisable, selectedAttributeDisplayValue, skuImageId, imageField) {
        productDisplayJS.setSelectedAttribute(swatchAttrName, swatchAttrValue, entitledItemId, skuImageId, imageField);
        document.getElementById("swatch_" + entitledItemId + "_" + swatchAttrValue).className = "color_swatch_selected";
        $("#swatch_link_" + entitledItemId + "_" + swatchAttrValue).attr("aria-checked", "true");
        document.getElementById("swatch_selection_label_" + entitledItemId + "_" + swatchAttrName).className = "header color_swatch_label";
        if ($("#swatch_selection_" + entitledItemId + "_" + swatchAttrName).css("display") == "none") {
            document.getElementById("swatch_selection_" + entitledItemId + "_" + swatchAttrName).style.display = "inline";
        }
        if (selectedAttributeDisplayValue != null) {
            $("#swatch_selection_" + entitledItemId + "_" + swatchAttrName).html(selectedAttributeDisplayValue);
        } else {
            $("#swatch_selection_" + entitledItemId + "_" + swatchAttrName).html(swatchAttrValue);
        }
        productDisplayJS.updateSwatchImages(swatchAttrName, entitledItemId, doNotDisable, imageField);
    },

    /**
     * Make dropdown selection.
     * @param {String} selectedAttrName The name of the selected dropdown attribute.
     * @param {String} selectedAttrValue The value of the selected dropdown attribute.
     * @param {String} entitledItemId The ID of the SKU.
     **/
    makeDropdownSelection: function (selectedAttrName, selectedAttrValue, entitledItemId) {
        //Add indexOf function to arrays for IE8
        if (!Array.prototype.indexOf) {
            Array.prototype.indexOf = function (obj, start) {
                for (var i = (start || 0), j = this.length; i < j; i++) {
                    if (this[i] === obj) {
                        return i;
                    }
                }
                return -1;
            };
        }

        var dropdownsToUpdate = [];
        var selectedAttributes = productDisplayJS.selectedAttributesList[entitledItemId];
        var selectedAttrValues = selectedAttributes[selectedAttrName];
        var dropdownList = productDisplayJS.allDropdownsList[entitledItemId];

        // finds out which dropdowns needs to be updated, add to dropdownsToUpdate array
        for (var i = 0; i < dropdownList.length; i++) {
            if (productDisplayJS.removeQuotes(dropdownList[i].name) != productDisplayJS.removeQuotes(selectedAttrName)) {
                dropdownsToUpdate.push(dropdownList[i]);
            }
        }

        //Finds out which attributes are entitled and add them to list of enabled
        var attributesToEnable = {};
        for (var x in productDisplayJS.entitledItems) {
            var Attributes = productDisplayJS.entitledItems[x].Attributes;

            // Turn Attributes into object
            var attrList = {};
            for (var y in Attributes) {
                var index = y.indexOf("_|_");
                var entitledDropdownName = y.substring(0, index);
                var entitledDropdownValue = y.substring(index + 3);

                attrList[entitledDropdownName] = entitledDropdownValue;
            }

            for (var attrName in attrList) {
                //the current entitled item has the selected attribute value
                if (productDisplayJS.removeQuotes(attrName) == productDisplayJS.removeQuotes(selectedAttrName) && (attrList[attrName] == selectedAttrValue || selectedAttrValue === '')) {
                    //go through the other attributes that are available to the selected attribute
                    for (var attrName2 in attrList) {
                        var attrName2NQ = productDisplayJS.removeQuotes(attrName2);
                        //only check the non-selected attribute
                        if (productDisplayJS.removeQuotes(attrName) != attrName2NQ) {
                            // Find all entitled items that match the current list of selected attributes other than attrName2
                            var matchSelectedAttributes = true;
                            for (var selected in selectedAttributes) {
                                if (productDisplayJS.removeQuotes(selected) != attrName2NQ) {
                                    if (selectedAttributes[selected] && selectedAttributes[selected] !== attrList[selected]) {
                                        matchSelectedAttributes = false;
                                    }
                                }
                            }

                            // Find all enabled values for the unselected attributes
                            if (matchSelectedAttributes && attrList[attrName2]) {
                                if (!attributesToEnable[attrName2NQ]) {
                                    attributesToEnable[attrName2NQ] = [];
                                }
                                if (attributesToEnable[attrName2NQ].indexOf(attrList[attrName2].replace(/^\s+|\s+$/g, '')) == -1) {
                                    attributesToEnable[attrName2NQ].push(attrList[attrName2].replace(/^\s+|\s+$/g, ''));
                                }
                            }
                        }
                    }
                }
            }
        }

        //Flag all attributes that should be enabled as enabled
        for (var i in dropdownsToUpdate) {
            var attrValues = attributesToEnable[productDisplayJS.removeQuotes(dropdownsToUpdate[i].name)];
            if (attrValues) {
                for (var j = 0; j < dropdownsToUpdate[i].options.length; j++) {
                    var dropdownToUpdateOption = dropdownsToUpdate[i].options[j];
                    if (attrValues.indexOf(dropdownToUpdateOption.value.replace(/^\s+|\s+$/g, '')) != -1 || dropdownToUpdateOption.value === '') {
                        dropdownToUpdateOption.enabled = true;
                    }
                }
            }
        }

        //Set all dropdown options that are enabled to disabled = false, others to disabled = true
        for (var i in dropdownsToUpdate) {
            if (dropdownsToUpdate[i].options) {
                for (var j = 0; j < dropdownsToUpdate[i].options.length; j++) {
                    var dropdownToUpdateOption = dropdownsToUpdate[i].options[j];

                    if (dropdownToUpdateOption.enabled) {
                        dropdownToUpdateOption.disabled = false;
                    } else {
                        dropdownToUpdateOption.disabled = true;
                    }

                    delete dropdownToUpdateOption.enabled;
                }

                var dropdown = $(dropdownsToUpdate[i].node);
                dropdown.Select("refresh");
            }
        }
    },

    /**
     * Constructs record and add to this.allSwatchesArray.
     * @param {String} swatchName The name of the swatch attribute.
     * @param {String} swatchValue The value of the swatch attribute.	
     * @param {String} swatchImg1 The path to the swatch image.
	* @param {String} swatchImg2 The path to the swatch image representing disabled state.
     **/
	addToAllSwatchsArray: function(swatchName, swatchValue, swatchImg1, entitledItemId, swatchDisplayValue, swatchImg2) {
        var swatchList = this.allSwatchesArrayList[entitledItemId];
        if (swatchList == null) {
            swatchList = [];;
        }
        if (!this.existInAllSwatchsArray(swatchName, swatchValue, swatchList)) {
            var swatchRecord = [];
            swatchRecord[0] = swatchName;
            swatchRecord[1] = swatchValue;
            swatchRecord[2] = swatchImg1;
            swatchRecord[3] = swatchImg2;
            swatchRecord[4] = document.getElementById("swatch_link_" + entitledItemId + "_" + swatchValue).onclick;
            swatchRecord[5] = null;
            swatchRecord[6] = swatchDisplayValue;
            swatchList.push(swatchRecord);
            this.allSwatchesArrayList[entitledItemId] = swatchList;
        }
    },

    /**
     * Constructs record and add to this.allDropdownsArray.
     * @param {String} attributeName The name of the dropdown attribute.
     * @param {String} dropdownId The id of the dropdown.	
     **/
    addToAllDropdownsArray: function (attributeName, dropdownId, entitledItemId) {
        var dropdownList = this.allDropdownsList[entitledItemId];
        if (dropdownList == null) {
            dropdownList = [];
        }

        var dropdownNode = productDisplayJS.findDropdownById(dropdownId);

        if (!this.existInAllDropdownsArray(attributeName, dropdownId, dropdownList)) {
            dropdownList.push({
                name: attributeName,
                id: dropdownId,
                node: dropdownNode,
                options: $(dropdownNode).find("option"),
            });
            this.allDropdownsList[entitledItemId] = dropdownList;
        }
    },

    /**
     * Checks if a swatch is already exist in this.allSwatchesArray.
     * @param {String} swatchName The name of the swatch attribute.
     * @param {String} swatchValue The value of the swatch attribute.		
     * @return boolean Value indicating whether or not the specified swatch name and value exists in the allSwatchesArray.
     */
    existInAllSwatchsArray: function (swatchName, swatchValue, swatchList) {
        for (var i = 0; i < swatchList.length; i++) {
            var attrName = swatchList[i][0];
            var attrValue = swatchList[i][1];
            if (attrName == swatchName && attrValue == swatchValue) {
                return true;
            }
        }
        return false;
    },

    /**
     * Checks if a dropdown already exists in this.allDropdownsArray.
     * @param {String} dropdownName The name of the dropdown.
     * @param {String} dropdownId The id of the dropdown.		
     * @return boolean Value indicating whether or not the specified dropdown name and value exists in the allDropdownsArray.
     */
    existInAllDropdownsArray: function (dropdownName, dropdownId, dropdownsList) {
        for (var i = 0; i < dropdownsList.length; i++) {
            if (dropdownsList[i].name == dropdownName && dropdownsList[i].id == dropdownId) {
                return true;
            }
        }
        return false;
    },

    /**
     * Check the entitledItems array and pre-select the first entitled SKU as the default swatch selection.
     * @param {String} entitledItemId The ID of the SKU.
     * @param {String} doNotDisable The name of the swatch attribute that should never be disabled.		
     **/
    makeDefaultSwatchSelection: function (entitledItemId, doNotDisable) {
        if (this.entitledItems.length == 0) {
            if ($("#" + entitledItemId).length) {
                entitledItemJSON = eval('(' + $("#" + entitledItemId).html() + ')');
            }
            productDisplayJS.setEntitledItems(entitledItemJSON);
        }

        // need to make selection for every single swatch
        for (x in this.entitledItems) {
            var Attributes = this.entitledItems[x].Attributes;
            for (y in Attributes) {
                var index = y.indexOf("_|_");
                var swatchName = y.substring(0, index);
                var swatchValue = y.substring(index + 3);
                this.makeSwatchSelection(swatchName, swatchValue, entitledItemId, doNotDisable, null, imageField);
            }
            break;
        }
    },

    /**
     * Update swatch images - this is called after selection of a swatch is made, and this function checks for
     * entitlement and disable swatches that are not available
     * @param {String} selectedAttrName The attribute that is selected
     * @param {String} entitledItemId The ID of the SKU.
     * @param {String} doNotDisable The name of the swatch attribute that should never be disabled.	
     **/
    updateSwatchImages: function (selectedAttrName, entitledItemId, doNotDisable, imageField) {
        var swatchToUpdate = [];
        var selectedAttributes = productDisplayJS.selectedAttributesList[entitledItemId];
        var selectedAttrValue = selectedAttributes[selectedAttrName];
        var swatchList = productDisplayJS.allSwatchesArrayList[entitledItemId];

        // finds out which swatch needs to be updated, add to swatchToUpdate array
        for (var i = 0; i < swatchList.length; i++) {
            var attrName = swatchList[i][0];
            var attrValue = swatchList[i][1];
            var attrImg1 = swatchList[i][2];
            var attrImg2 = swatchList[i][3];
            var attrOnclick = swatchList[i][4];
            var attrDisplayValue = swatchList[i][6];

            if (attrName != doNotDisable && attrName != selectedAttrName) {
                var swatchRecord = [];
                swatchRecord[0] = attrName;
                swatchRecord[1] = attrValue;
                swatchRecord[2] = attrImg1;
                swatchRecord[3] = attrImg2;
                swatchRecord[4] = attrOnclick;
                swatchRecord[5] = false;
                swatchRecord[6] = attrDisplayValue;
                swatchToUpdate.push(swatchRecord);
            }
        }

        // finds out which swatch is entitled, if it is, image should be set to enabled
        // go through entitledItems array and find out swatches that are entitled 
        for (x in productDisplayJS.entitledItems) {
            var Attributes = productDisplayJS.entitledItems[x].Attributes;

            for (y in Attributes) {
                var index = y.indexOf("_|_");
                var entitledSwatchName = y.substring(0, index);
                var entitledSwatchValue = y.substring(index + 3);

                //the current entitled item has the selected attribute value
                if (entitledSwatchName == selectedAttrName && entitledSwatchValue == selectedAttrValue) {
                    //go through the other attributes that are available to the selected attribute
                    //exclude the one that is selected
                    for (z in Attributes) {
                        var index2 = z.indexOf("_|_");
                        var entitledSwatchName2 = z.substring(0, index2);
                        var entitledSwatchValue2 = z.substring(index2 + 3);

                        if (y != z) { //only check the attributes that are not the one selected
                            for (i in swatchToUpdate) {
                                var swatchToUpdateName = swatchToUpdate[i][0];
                                var swatchToUpdateValue = swatchToUpdate[i][1];

                                if (entitledSwatchName2 == swatchToUpdateName && entitledSwatchValue2 == swatchToUpdateValue) {
                                    swatchToUpdate[i][5] = true;
                                }
                            }
                        }
                    }
                }
            }
        }

        // Now go through swatchToUpdate array, and update swatch images
        var disabledAttributes = [];
        for (i in swatchToUpdate) {
            var swatchToUpdateName = swatchToUpdate[i][0];
            var swatchToUpdateValue = swatchToUpdate[i][1];
            var swatchToUpdateImg1 = swatchToUpdate[i][2];
            var swatchToUpdateImg2 = swatchToUpdate[i][3];
            var swatchToUpdateOnclick = swatchToUpdate[i][4];
            var swatchToUpdateEnabled = swatchToUpdate[i][5];

            if (swatchToUpdateEnabled) {
                if (document.getElementById("swatch_" + entitledItemId + "_" + swatchToUpdateValue).className != "color_swatch_selected") {
                    var swatchElement = document.getElementById("swatch_" + entitledItemId + "_" + swatchToUpdateValue);
                    swatchElement.className = "color_swatch";
                    if (swatchToUpdateImg1 != "" && swatchToUpdateImg2 != "") {
                    	swatchElement.src = swatchToUpdateImg1;
                    }
                    else {
                    	swatchElement.src = swatchElement.src.replace("_disabled.png","_enabled.png");
                    }

                    //change the title text of the swatch link
                    document.getElementById("swatch_link_" + entitledItemId + "_" + swatchToUpdateValue).title = swatchElement.alt;
                }
                $("#swatch_link_" + entitledItemId + "_" + swatchToUpdateValue).attr("aria-disabled", "false");
                document.getElementById("swatch_link_" + entitledItemId + "_" + swatchToUpdateValue).onclick = swatchToUpdateOnclick;
            } else {
                if (swatchToUpdateName != doNotDisable) {
                    var swatchElement = document.getElementById("swatch_" + entitledItemId + "_" + swatchToUpdateValue);
                    var swatchLinkElement = document.getElementById("swatch_link_" + entitledItemId + "_" + swatchToUpdateValue);
                    swatchElement.className = "color_swatch_disabled";
                    swatchLinkElement.onclick = null;
                    if (swatchToUpdateImg1 != "" && swatchToUpdateImg2 != "") {
                    	swatchElement.src = swatchToUpdateImg2;
                    }
                    else {
                    	swatchElement.src = swatchElement.src.replace("_enabled.png","_disabled.png");
                    }

                    //change the title text of the swatch link
                    var titleText = Utils.getLocalizationMessage("INV_ATTR_UNAVAILABLE", [swatchElement.alt]);


                    $("#swatch_link_" + entitledItemId + "_" + swatchToUpdateValue).attr("aria-disabled", "true");

                    //The previously selected attribute is now unavailable for the new selection
                    //Need to switch the selection to an available value
                    if (selectedAttributes[swatchToUpdateName] == swatchToUpdateValue) {
                        disabledAttributes.push(swatchToUpdate[i]);
                    }
                }
            }
        }

        //If there were any previously selected attributes that are now unavailable
        //Find another available value for that attribute and update other attributes according to the new selection
        for (i in disabledAttributes) {
            var disabledAttributeName = disabledAttributes[i][0];
            var disabledAttributeValue = disabledAttributes[i][1];

            for (i in swatchToUpdate) {
                var swatchToUpdateName = swatchToUpdate[i][0];
                var swatchToUpdateValue = swatchToUpdate[i][1];
                var swatchToUpdateDisplayValue = swatchToUpdate[i][6];
                var swatchToUpdateEnabled = swatchToUpdate[i][5];

                if (swatchToUpdateName == disabledAttributeName && swatchToUpdateValue != disabledAttributeValue && swatchToUpdateEnabled) {
                    productDisplayJS.makeSwatchSelection(swatchToUpdateName, swatchToUpdateValue, entitledItemId, doNotDisable, swatchToUpdateDisplayValue, imageField);
                    break;
                }
            }
        }
    },
    /* SwatchCode end */

    /** 
     * Displays price of the attribute selected with the catalog entry id.
     * 
     * @param {string} catEntryId The identifier of the sku.
     * @param {string} productId The identifier of the product.
     */
    displayPrice: function (catEntryId, productId) {
        var catEntry = productDisplayJS.itemPriceJsonOject[catEntryId].catalogEntry;

        var tempString;
        var popup = productDisplayJS.isPopup;

        if (popup == true) {
            $("#productPrice").html(catEntry.offerPrice);
        }

        if (popup == false) {
            var innerHTML = "";

            if (!catEntry.listPriced || catEntry.listPrice <= catEntry.offerPrice) {
                innerHTML = "<span id='offerPrice_" + catEntry.catalogEntryIdentifier.uniqueID + "' class='price'>" + catEntry.offerPrice + "</span>";
            } else {
                innerHTML = "<span id='listPrice_" + catEntry.catalogEntryIdentifier.uniqueID + "' class='old_price'>" + catEntry.listPrice + "</span>" +
                    "<span id='offerPrice_" + catEntry.catalogEntryIdentifier.uniqueID + "' class='price'>" + catEntry.offerPrice + "</span>";
            }
            if (document.getElementById('price_display_' + productId)) {
                document.getElementById('price_display_' + productId).innerHTML = innerHTML + "<input type='hidden' id='ProductInfoPrice_" + catEntry.catalogEntryIdentifier.uniqueID + "' value='" + catEntry.offerPrice.replace(/"/g, "&#034;").replace(/'/g, "&#039;") + "'/>";
            } else if (document.getElementById('price_display_' + catEntryId)) {
                document.getElementById('price_display_' + catEntryId).innerHTML = innerHTML + "<input type='hidden' id='ProductInfoPrice_" + catEntry.catalogEntryIdentifier.uniqueID + "' value='" + catEntry.offerPrice.replace(/"/g, "&#034;").replace(/'/g, "&#039;") + "'/>";
            }

            innerHTML = "";
            if (productDisplayJS.displayPriceRange == true) {
                for (var i in catEntry.priceRange) {
                    if (catEntry.priceRange[i].endingNumberOfUnits == catEntry.priceRange[i].startingNumberOfUnits) {
                        tempString = Utils.getLocalizationMessage('PQ_PRICE_X', {
                            0: catEntry.priceRange[i].startingNumberOfUnits
                        });
                        innerHTML = innerHTML + "<p>" + tempString;
                    } else if (catEntry.priceRange[i].endingNumberOfUnits != 'null') {
                        tempString = Utils.getLocalizationMessage('PQ_PRICE_X_TO_Y', {
                            0: catEntry.priceRange[i].startingNumberOfUnits,
                            1: catEntry.priceRange[i].endingNumberOfUnits
                        });
                        innerHTML = innerHTML + "<p>" + tempString;
                    } else {
                        tempString = Utils.getLocalizationMessage('PQ_PRICE_X_OR_MORE', {
                            0: catEntry.priceRange[i].startingNumberOfUnits
                        });
                        innerHTML = innerHTML + "<p>" + tempString;
                    }
                    innerHTML = innerHTML + " <span class='price'>" + catEntry.priceRange[i].localizedPrice + "</span></p>";
                }
            }
            // Append productId so that element is unique in bundle page, where there can be multiple components
            if (document.getElementById('price_display_' + productId) && innerHTML !== '') {
                $("#price_display_" + productId).html($('#price_display_' + productId).html() + '<div class="item_spacer_3px"></div><div id="priceRange_' + productId + '" class="quantity_discount">' + Utils.getLocalizationMessage('PQ_PURCHASE') + innerHTML + '</div>');
            }
        }
    },

    /** 
     * Updates the product name in the NameAndPrice widget. 
     * 
     * @param {string} catEntryId The identifier of the sku.
     * @param {string} productId The identifier of the product.
     */
    updateProductName: function (catEntryId, productId) {
        var catEntry = productDisplayJS.itemPriceJsonOject[catEntryId].catalogEntry;

        if (productDisplayJS.isPopup == true) {
            $("#productName").html(catEntry.description[0].name);
        } else {
            if ($(".top > div[id^='PageHeading_']") != null) {
                $(".top > div[id^='PageHeading_']").each(function (i, node) {
                    if (node.childNodes != null && node.childNodes.length == 3) {
                        node.childNodes[1].innerHTML = catEntry.description[0].name;
                    }
                });
            }

            var productInfoWidgets = $("input[id^='ProductInfoName_" + productId + "']");
            if (productInfoWidgets != null) {
                for (var i = 0; i < productInfoWidgets.length; i++) {
                    if (productInfoWidgets[i] != null) {
                        $(productInfoWidgets[i]).val(catEntry.description[0].name);
                    }
                }
            }
        }
    },

    /** 
     * Updates the product part number in the NameAndPrice widget. 
     * 
     * @param {string} catEntryId The identifier of the sku.
     * @param {string} productId The identifier of the product.
     */
    updateProductPartNumber: function (catEntryId, productId) {
        var catEntry = productDisplayJS.itemPriceJsonOject[catEntryId].catalogEntry;

        if (productDisplayJS.isPopup == true) {
            $("#productSKUValue").html(catEntry.catalogEntryIdentifier.externalIdentifier.partNumber);
        } else {
            var partnumWidgets = $("span[id^='product_SKU_" + productId + "']");
            if (partnumWidgets != null) {
                for (var i = 0; i < partnumWidgets.length; i++) {
                    if ($(partnumWidgets[i])) {
                        $(partnumWidgets[i]).html(Utils.getLocalizationMessage('SKU') + " " + catEntry.catalogEntryIdentifier.externalIdentifier.partNumber);
                    }
                }
            }
        }
    },

    /** 
     * Updates the product short description in the ShortDescription widget. 
     * 
     * @param {string} catEntryId The identifier of the sku.
     * @param {string} productId The identifier of the product.
     */
    updateProductShortDescription: function (catEntryId, productId) {
        var catEntry = productDisplayJS.itemPriceJsonOject[catEntryId].catalogEntry;

        var shortDescWidgets = $("p[id^='product_shortdescription_" + productId + "']");
        if (shortDescWidgets != null) {
            for (var i = 0; i < shortDescWidgets.length; i++) {
                if (shortDescWidgets[i]) {
                    shortDescWidgets[i].innerHTML = catEntry.description[0].shortDescription;
                }
            }
        }
    },

    /** 
     * Updates the product long description in the LongDescription widget. 
     * 
     * @param {string} catEntryId The identifier of the sku.
     * @param {string} productId The identifier of the product.
     */
    updateProductLongDescription: function (catEntryId, productId) {
        var catEntry = productDisplayJS.itemPriceJsonOject[catEntryId].catalogEntry;

        var longDescWidgets = $("p[id^='product_longdescription_" + productId + "']");
        if (longDescWidgets != null) {
            for (var i = 0; i < longDescWidgets.length; i++) {
                if (longDescWidgets[i]) {
                    longDescWidgets[i].innerHTML = catEntry.description[0].longDescription;
                }
            }
        }
    },

    /** 
     * Updates the product discounts in the Discounts widget. 
     * 
     * @param {string} catEntryId The identifier of the sku.
     * @param {string} productId The identifier of the product.
     */
    updateProductDiscount: function (catEntryId, productId) {
        var catEntry = productDisplayJS.itemPriceJsonOject[catEntryId].catalogEntry;

        var newHtml = '';
        if (typeof catEntry.discounts != 'undefined') {
            for (var i = 0; i < catEntry.discounts.length; i++) {
                if (i > 0) {
                    newHtml += '<div class="clear_float"></div><div class="item_spacer_2px"></div>';
                }
                /* catEntry.discounts[i].description comes from short description associated with the promotion.
                 * If it is blank or missing, the link text is blank, thus is not clickable or displayed.
                 */
                newHtml += '<a class="promotion" href="' + catEntry.discounts[i].url + '">' + catEntry.discounts[i].description + '</a>';
            }
        }

        var discountWidgets = $("div[id^='Discounts_']");
        if (discountWidgets != null) {
            for (var i = 0; i < discountWidgets.length; i++) {
                if (discountWidgets[i]) {
                    discountWidgets[i].innerHTML = newHtml;
                }
            }
        }
    },

    /** 
     * Updates the product full image and angle images in the FullImage widget. 
     * 
     * @param {string} catEntryId The identifier of the sku.
     * @param {string} productId The identifier of the product.
     */
    updateProductImage: function (catEntryId, productId) {
        var newFullImage = null;
        var newAngleThumbnail = null;
        var newAngleFullImage = null;
        var newAngleThumbnailShortDesc = null;

        var skuFullImageFromService = null;
        var catEntry = null;
        if (productDisplayJS.itemPriceJsonOject[catEntryId] != null) {
            catEntry = productDisplayJS.itemPriceJsonOject[catEntryId].catalogEntry;
        }
        if (catEntry != null) {
            skuFullImageFromService = catEntry.description[0].fullImage;
        }

        var entitledItemId = "entitledItem_" + productId;
        var imageArr = productDisplayJS.getImageForSKU(entitledItemId);
        if (imageArr != null) {
            newAngleThumbnail = imageArr[2];
            newAngleFullImage = imageArr[3];
            newAngleThumbnailShortDesc = imageArr[4];
        }

        if (catEntryId != null) {
            newFullImage = imageArr[0];
            if (skuFullImageFromService != null && skuFullImageFromService !== "") {
                newFullImage = skuFullImageFromService;
            }
        } else if (productId != null && productDisplayJS.singleSKUProductWithoutDefiningAttribute) {
            newFullImage = productDisplayJS.entitledItems[0].ItemImage467;
            if (skuFullImageFromService != null && skuFullImageFromService !== "") {
                newFullImage = skuFullImageFromService;
            }
            newAngleThumbnail = productDisplayJS.entitledItems[0].ItemAngleThumbnail;
            newAngleFullImage = productDisplayJS.entitledItems[0].ItemAngleFullImage;
            newAngleThumbnailShortDesc = productDisplayJS.entitledItems[0].ItemAngleThumbnailShortDesc;
        } else {
            var imageFound = false;
            var selectedAttributes = productDisplayJS.selectedAttributesList[entitledItemId];
            for (x in productDisplayJS.entitledItems) {
                var Attributes = productDisplayJS.entitledItems[x].Attributes;

                for (attribute in selectedAttributes) {
                    var matchingAttributeFound = false;
                    if (selectedAttributes[attribute] !== '') {
                        for (y in Attributes) {
                            var index = y.indexOf("_|_");
                            var entitledSwatchName = y.substring(0, index);
                            var entitledSwatchValue = y.substring(index + 3);

                            if (entitledSwatchName == attribute && entitledSwatchValue == selectedAttributes[attribute]) {
                                matchingAttributeFound = true;
                                break;
                            }
                        }

                        // No matching attributes found, so this is not the correct SKU
                        if (!matchingAttributeFound) {
                            imageFound = false;
                            break;
                        }
                        imageFound = true;
                    }
                }

                // imageFound will only be true if all attributes have been matched (so the first correct SKU)
                if (imageFound) {
                    newFullImage = productDisplayJS.entitledItems[x].ItemImage467;
                    newAngleThumbnail = productDisplayJS.entitledItems[x].ItemAngleThumbnail;
                    newAngleFullImage = productDisplayJS.entitledItems[x].ItemAngleFullImage;
                    newAngleThumbnailShortDesc = productDisplayJS.entitledItems[x].ItemAngleThumbnailShortDesc;
                    break;
                }
            }
        }

        var imgWidgets = $("img[id^='" + productDisplayJS.skuImageId + "']");
        for (var i = 0; i < imgWidgets.length; i++) {
            if (imgWidgets[i] != null && newFullImage != null) {
                imgWidgets[i].src = newFullImage;
            }
        }

        var productImgWidgets = $("input[id^='ProductInfoImage_" + productId + "']");
        for (var i = 0; i < productImgWidgets.length; i++) {
            if (productImgWidgets[i] != null && newFullImage != null) {
                productImgWidgets[i].value = newFullImage;
            }
        }

        var prodAngleImageArea = $("div[id^='ProductAngleProdImagesArea']");
        var skuAngleImageArea = $("div[id^='ProductAngleImagesArea']");

        if (newAngleThumbnail != null && newAngleFullImage != null) {
            if (prodAngleImageArea.length) {
                for (var i = 0; i < prodAngleImageArea.length; i++) {
                    if (null != prodAngleImageArea[i]) {
                        $(prodAngleImageArea[i]).css("display", 'none');
                    }
                }
            }
            productDisplayJS.changeViewImages(newAngleThumbnail, newAngleFullImage, newAngleThumbnailShortDesc);
        } else {
            var prodDisplayClass = 'block';
            var selectedAttributes = productDisplayJS.selectedAttributesList[entitledItemId];
            for (attribute in selectedAttributes) {
                if (null != selectedAttributes[attribute] && '' != selectedAttributes[attribute]) {
                    prodDisplayClass = 'none';
                }
            }

            if (prodAngleImageArea.length) {
                for (var i = 0; i < prodAngleImageArea.length; i++) {
                    if (prodAngleImageArea[i].length) {
                        $(prodAngleImageArea[i]).css("display", prodDisplayClass);
                    }
                }
            }

            if (skuAngleImageArea != null) {
                for (var i = 0; i < skuAngleImageArea.length; i++) {
                    if (skuAngleImageArea[i].length) {
                        $(skuAngleImageArea[i]).css("display", 'none');
                    }
                }
            }
        }
    },

    /** 
     * To notify the change in attribute to other components that is subscribed to 'DefiningAttributes_Changed' or 'DefiningAttributes_Resolved' event.
     * 
     * @param {string} productId The identifier of the product.
     * @param {string} entitledItemId The identifier of the entitled item.
     * @param {boolean} isPopup If the value is true, then this implies that the function was called from a quick info pop-up.
     * @param {boolean} displayPriceRange A boolean used to to determine whether or not to display the price range when the catEntry is selected. 	
     */
    notifyAttributeChange: function (productId, entitledItemId, isPopup, displayPriceRange) {
        productDisplayJS.baseCatalogEntryId = productId;
        var selectedAttributes = productDisplayJS.selectedAttributesList[entitledItemId];

        productDisplayJS.displayPriceRange = displayPriceRange;
        productDisplayJS.isPopup = isPopup;

        var catalogEntryId = null;
        if (productDisplayJS.selectedProducts[productId]) {
            catalogEntryId = productDisplayJS.getCatalogEntryIdforProduct(productDisplayJS.selectedProducts[productId]);
        } else {
            catalogEntryId = productDisplayJS.getCatalogEntryId(entitledItemId);
        }

        if (catalogEntryId != null) {
            wcTopic.publish('DefiningAttributes_Resolved_' + productId, catalogEntryId, productId);

            //check if the json object is already present for the catEntry.
            var catEntry = productDisplayJS.itemPriceJsonOject[catalogEntryId];

            if (catEntry != null && catEntry != undefined) {
                productDisplayJS.publishAttributeResolvedEvent(catalogEntryId, productId);
            }
            //if json object is not present, call the service to get the details.
            else {
                var parameters = {
                    storeId: productDisplayJS.storeId,
                    langId: productDisplayJS.langId,
                    catalogId: productDisplayJS.catalogId,
                    catalogEntryId: catalogEntryId,
                    productId: productId
                };

                //Declare a service for retrieving catalog entry detailed information for an item...
                wcService.declare({
                    id: "getCatalogEntryDetails",
                    actionId: "getCatalogEntryDetails",
                    url: getAbsoluteURL() + appendWcCommonRequestParameters("GetCatalogEntryDetailsByIDView"),
                    formId: ""

                    ,
                    successHandler: function (serviceResponse, ioArgs) {
                        productDisplayJS.publishAttributeResolvedEventServiceResponse(serviceResponse, ioArgs);
                    }

                    ,
                    failureHandler: function (serviceResponse, ioArgs) {
                        console.debug("productDisplayJS.notifyAttributeChange: Unexpected error occurred during an xhrPost request.");
                    }

                });
                wcService.invoke("getCatalogEntryDetails", parameters);
            }
        } else {
            wcTopic.publish('DefiningAttributes_Changed', catalogEntryId, productId);
            wcTopic.publish('DefiningAttributes_Changed_' + productId, catalogEntryId, productId);
            console.debug("Publishing event 'DefiningAttributes_Changed' with params: catEntryId=" + catalogEntryId + ", productId=" + productId);
        }
    },

    /** 
     * Publishes the 'DefiningAttributes_Resolved' event using the JSON object returned from the server.
     * 
     * @param {object} serviceRepsonse The JSON response from the service.
     * @param {object} ioArgs The arguments from the service call.
     */
    publishAttributeResolvedEventServiceResponse: function (serviceResponse, ioArgs) {
        var productId = ioArgs.productId;
        //stores the json object, so that the service is not called when same catEntry is selected.
        productDisplayJS.itemPriceJsonOject[serviceResponse.catalogEntry.catalogEntryIdentifier.uniqueID] = serviceResponse;

        productDisplayJS.publishAttributeResolvedEvent(serviceResponse.catalogEntry.catalogEntryIdentifier.uniqueID, productId);
    },

    /** 
     * Publishes the 'DefiningAttributes_Resolved' event with the necessary parameters. 
     * 
     * @param {string} catEntryId The identifier of the sku.
     * @param {string} productId The identifier of the product.
     */
    publishAttributeResolvedEvent: function (catEntryId, productId) {
        if (!productDisplayJS.isPopup) {
            if (this.entitledItems) {
                for (x in this.entitledItems) {
                    var sku = this.entitledItems[x];
                    if (sku.catentry_id === catEntryId) {
                        if (sku.displaySKUContextData === 'true') {
                            if (document.location.href !== sku.seo_url) {
                                document.location.replace(sku.seo_url);
                            } else {
                                wcTopic.publish('DefiningAttributes_Resolved', catEntryId, productId);
                                console.debug("Publishing event 'DefiningAttributes_Resolved' with params: catEntryId=" + catEntryId + ", productId=" + productId);
                            }
                        } else {
                            wcTopic.publish('DefiningAttributes_Resolved', catEntryId, productId);
                            console.debug("Publishing event 'DefiningAttributes_Resolved' with params: catEntryId=" + catEntryId + ", productId=" + productId);
                        }
                    }
                }
            } else {
                console.debug("Publishing event 'DefiningAttributes_Resolved' with params: catEntryId=" + catEntryId + ", productId=" + productId);
                wcTopic.publish('DefiningAttributes_Resolved', catEntryId, productId);
            }
        }
    },

    /**
     * To notify the change in quantity to other components that is subscribed to ShopperActions_Changed event.
     */
    notifyQuantityChange: function (quantity) {
        wcTopic.publish('ShopperActions_Changed', quantity);
        console.debug("Publishing event 'ShopperActions_Changed' with params: quantity=" + quantity);
    },

    /**
     * To display attachment page.
     */
    showAttachmentPage: function (data) {
        var pageNumber = data['pageNumber'];
        var pageSize = data['pageSize'];
        pageNumber = Number(pageNumber);
        pageSize = Number(pageSize);

        setCurrentId(data["linkId"]);

        if (!submitRequest()) {
            return;
        }

        var beginIndex = pageSize * (pageNumber - 1);
        cursor_wait();
        wcRenderContext.updateRenderContext('AttachmentPagination_Context', {
            'beginIndex': beginIndex
        });
        MessageHelper.hideAndClearMessage();
    },

    /**
     * Register mouse down event 
     */
    registerMouseDown: function (node) {
        $(node).on("mousedown",
            function () {
                productDisplayJS.calculateScrollingHeight(node);
            }
        );
    },

    /**
     * Calculate scrolling height.
     */
    calculateScrollingHeight: function (node) {
        var selectedNode = productDisplayJS.findDropdownById(node);
        var nodePosition = null;
        if (selectedNode) {
            nodePosition = Utils.position(selectedNode);
        } else {
            return;
        }
        var windowHeight = window.innerHeight;
        if (windowHeight - nodePosition.y > nodePosition.y) {
            var newHeight = windowHeight - nodePosition.y;
        } else {
            var newHeight = nodePosition.y;
        }
        if ($("#" + node + "_dropdown").length) {
            if (windowHeight - nodePosition.y > nodePosition.y) {
                var newHeight = windowHeight - nodePosition.y;
            } else {
                var newHeight = nodePosition.y;
            }
            var dropdownHeight = $("#" + node + "_dropdown").clientHeight;
            if (dropdownHeight > newHeight) {
                $("#" + node + "_dropdown").css("height", newHeight + "px");
            }
        } else {
            //			$("#" + node + "_dropdown").css("height", windowHeight + "px");
        }
    },

    findDropdownById: function (node) {
        var newNode = productDisplayJS.removeQuotes(node);
        var nodes = $('[id^=attrValue_]');
        var foundNode = null;

        $(nodes).each(function (key, domNode) {
            var id = productDisplayJS.removeQuotes(domNode.id);
            if (newNode === id) {
                foundNode = domNode;
            }
        });

        return foundNode;
    },

    removeQuotes: function (str) {
        if (str) {
            return str.replace(/&#039;/g, '').replace(/\\'/g, '').replace(/'/g, '');
        } else {
            return str;
        }
    }
}
$(document).ready(function () {
    var ie_version = Utils.get_IE_version();
    if (ie_version < 9) {
        $(document).on("click", ".compare_target > input[type=\"checkbox\"]", function (event) {
            this.blur();
            this.focus();
        });
    }
});
//-----------------------------------------------------------------
// Licensed Materials - Property of IBM
//
// WebSphere Commerce
//
// (C) Copyright IBM Corp. 2014, 2016 All Rights Reserved.
//
// US Government Users Restricted Rights - Use, duplication or
// disclosure restricted by GSA ADP Schedule Contract with
// IBM Corp.
//-----------------------------------------------------------------

/** 
 * @fileOverview This javascript is used by the AjaxRecommendation pages to control the refresh areas.
 * @version 1.0
 */

//Declare refresh controller function used by the Ajax recommendation refresh area
var declareAjaxRecommendationRefresh_controller = function(emsName) {
    var myWidgetObj = $("#AjaxRecommendation_Widget_" + emsName);

    wcRenderContext.declare("AjaxRecommendationRefresh_Context_" + emsName, ["AjaxRecommendation_Widget_" + emsName], {});
    var myRCProperties = wcRenderContext.getRenderContextProperties("AjaxRecommendationRefresh_Context_" + emsName);
    
    // initialize widget
    myWidgetObj.refreshWidget({
        renderContextChangedHandler: function() {
            myWidgetObj.refreshWidget("refresh", myRCProperties);
        },

        /**
         * Clears the progress bar after a successful refresh.
         */
        postRefreshHandler: function() {
            cursor_clear();
            wcTopic.publish("CMPageRefreshEvent");
        }
    });
};//-----------------------------------------------------------------
// Licensed Materials - Property of IBM
//
// WebSphere Commerce
//
// (C) Copyright IBM Corp. 2016 All Rights Reserved.
//
// US Government Users Restricted Rights - Use, duplication or
// disclosure restricted by GSA ADP Schedule Contract with
// IBM Corp.
//-----------------------------------------------------------------

//
// Simple AJAX framework - START
//

// Make a simple AJAX call
// args: JSON - {requestType, requestUrl, requestParameters, async}
// Returns: JSON - {status : success, data} or {status : error, args, error};
function simpleAjax(args) {
	var out = null;
	this.xhr = new XMLHttpRequest();
	var requestURL = args.requestUrl;
	if (args.requestType === 'GET') {
		requestURL = requestURL + args.requestParameters;
	}
	this.xhr.open(args.requestType, requestURL, args.async);
	this.xhr.onreadystatechange = function() {
		if (this.readyState === this.DONE) {
			if (this.status === 200) {
				var jsonText = this.responseText.replace(/(\/\*|\*\/)/g, '');
				var resp = JSON.parse(jsonText);
				var responseError = responseHasErrorCode(resp);
				if (responseError != null) {
					out = handleError(responseError, args);
				} else {
					out = {"status" : STATUS_SUCCESS, "data" : resp};
				}
			} else {
				out = handleError(createError(null, null, MessageHelper.messages["ajaxError"] + this.status));
			}
		}
	}
	if (args.requestType === 'GET') {
		this.xhr.send();
	} else {
		this.xhr.setRequestHeader("Content-type", "application/x-www-form-urlencoded;charset=utf-8");
		this.xhr.send(args.requestParameters);
	}
	return out;
}
function responseHasErrorCode(resp) {
	if (resp.errorMessageKey) {
		return createError(resp.errorCode, resp.errorMessageKey, resp.errorMessage);
	}
	else {
		return null;
	}
}
function handleError(error, args) {
	return {"status" : STATUS_ERROR, "args" : args, "error" : error};
}
function createError(errorCode, errorMessageKey, errorMessage) {
	return {"errorCode" : errorCode, "errorMessageKey" : errorMessageKey, "errorMessage" : errorMessage};
}
//
// Simple AJAX framework - END
//

//
// Global ApplePay MerchantIdentifier - START
//
function getMerchantIdentifier() {
	if (sessionStorage.getItem('merchantIdentifier') == null || sessionStorage.getItem('merchantIdentifier') === "") {
		var result = simpleAjax({
			requestType: 'GET',
			requestUrl: getAbsoluteURL() + 'GetApplePayMerchantInfoV2?',
			requestParameters: getCommonParameters(),
			async: false
		});
		if (result.status === STATUS_SUCCESS) {
			sessionStorage.setItem('merchantIdentifier', result.data.merchantIdentifier);
		}
		else {
			displayError("getMerchantIdentifier", result.error);
		};
	}
	return sessionStorage.getItem('merchantIdentifier');
}
//
// Global ApplePay MerchantIdentifier - END
//

//
// Global WC authToken - START
//
var authToken = null;
function initAuthToken() {
	if (authToken == null || authToken === "") {
		var currentURL = document.URL;
		var currentProtocol = "";
		if (currentURL.indexOf("://") != -1) {
			currentProtocol = currentURL.substring(0, currentURL.indexOf("://"));
		}
		if (currentProtocol == 'https') {
			authToken = document.getElementById("csrf_authToken");
			if (authToken) {
				return authToken = encodeURIComponent(authToken.value);
			}
			else {
				var result = simpleAjax({
					requestType: 'GET',
					requestUrl: getAbsoluteURL() + 'GetCSRFAuthTokenV2?',
					requestParameters: getCommonParameters(),
					async: false
				});
				if (result.status === STATUS_SUCCESS) {
					return authToken = encodeURIComponent(result.data.authToken);
				}
				else {
					displayError("initAuthToken", result.error);
					return null;
				};
			}
		}
		// Apple Pay isn't allowed on non-https, so this should not happen
		return null;
	} else {
		return authToken;
	}
}
function getAuthTokenUrlParameter() {
	initAuthToken();
	if (authToken) {
		return '&authToken=' + authToken;
	}
	else {
		// Missing authToken error probably already handled
		return null;
	}
}
//
// Global WC authToken - END
//

//
// Global order ID - START
//
var currentOrderId = "";
function getOrderIdUrlParameter(orderId) {
	var id;
	if (this.isEmpty(orderId)) {
		if (this.isEmpty(currentOrderId)) {
			displayError("getOrderIdUrlParameter", handleError(createError(null, null, MessageHelper.messages["ajaxError"] + this.status)));
		}
		else {
			id = currentOrderId;
		}
	}
	else {
		id = orderId;
	}
	return "&orderId=" + id;
}
//
// Global order ID - END
//

//
// Global BOPIS parameters - START
//
var mobileBOPISShipModeId = "";
var mobileBOPISStoreId = "";
function setMobileBOPISShipMode(inMobileShipModeId) {
	mobileBOPISShipModeId = inMobileShipModeId;
}
function setMobileBOPISStore(inMobileStoreId) {
	mobileBOPISStoreId = inMobileStoreId;
}

function getBOPISParameters() {
	var urlParamStr = "";
	if (isBOPISCheckout() && document.getElementById("shipmodeForm") && PhysicalStoreCookieJS) {
		var shipModeIdBOPIS = "";
		var physicalStoreLocationId = "";
		shipModeIdBOPIS = document.getElementById("shipmodeForm").BOPIS_shipmode_id.value;
		physicalStoreLocationId = document.getElementById("physicalStoreForm").BOPIS_physicalstore_id.value;
		urlParamStr = '&shipModeId='+shipModeIdBOPIS+'&physicalStoreId='+physicalStoreLocationId;
	} else if (mobileBOPISShipModeId != '') {
		urlParamStr = '&shipModeId='+mobileBOPISShipModeId+'&physicalStoreId='+mobileBOPISStoreId;
	}
	return urlParamStr;
}
//
// Global BOPIS parameters - END
//

function getCommonParameters() {
	//  Always call this first for URL parameters
	return 'storeId='+WCParamJS.storeId+'&catalogId='+WCParamJS.catalogId+'&langId='+WCParamJS.langId+'&requesttype=ajax';
}


var isReturnDefaults = "false";
function setIsReturnDefaults(inReturnDefaults) {
	isReturnDefaults = inReturnDefaults;
}
function getIsReturnDefaults() {
	return isReturnDefaults;
}
function getIsReturnDefaultsParameter() {
	var urlParamStr = "";
	urlParamStr = '&returnDefaults='+isReturnDefaults;
	return urlParamStr;
}

function getDefaultShippingParameter() {
	return '&shipModeId='+defaultShipModeId+"&addressId="+defaultAddressId;
}

function IsShipModeValid() {
	return shipModeValid;
}

function getUnboundPIIdParameter() {
	var unboundPIParamStr = "";
	if (unboundPIId !== "") {
		unboundPIParamStr = "&unboundPIId=" + unboundPIId;
	}
	return unboundPIParamStr;
}

//
// Apple Pay button and payment sheet rendering - START
//
var paymentRequest = null;
var shipModeValid = false;
var defaultShipModeId = "";
var defaultAddressId = "";
var unboundPIId = "";
document.addEventListener("DOMContentLoaded", function()  {
	if (window.ApplePaySession) {
		if (getMerchantIdentifier() != null) {
			var promise = ApplePaySession.canMakePaymentsWithActiveCard(getMerchantIdentifier());
			promise.then(function(canMakePayments) {
				if (showDebug) {
					console.log("call back method called..." + canMakePayments);
				}
				if (canMakePayments) {
					showApplePayButtons();
				}
			}, function(reject) {
				console.log("canMakePaymentsWithActiveCard promise rejected");
			});
		}
	}
});

function toggleApplePayButtonInMiniCart() {
	// Show Apple Pay button when there is an order in the mini shop cart, otherwise, hide it
	var d = document.getElementById("applePayButtonDiv_minishopcart");
	if (d !== null) {
		if (document.querySelector("#currentOrderId") && document.querySelector("#currentOrderQuantity")
			&& !this.isEmpty(document.querySelector("#currentOrderId").value)
			&& !this.isEmpty(document.querySelector("#currentOrderQuantity").value)
			&& document.querySelector("#currentOrderQuantity").value !== "0") {
				d.classList.add("visible");
		}
		else {
			d.classList.remove("visible");
		}
	}
}

function showApplePayButtons() {
	if (window.ApplePaySession) {
		var x = document.getElementsByClassName("apple-pay-button");
		var i;
		for (i = 0; i < x.length; i++) {
			x[i].classList.add("visible");
		}

		if (!this.isEmpty(document.getElementById("applePayButtonDiv_minishopcart"))) {
			// Deal with the Apple Pay button in the mini shop cart as a special case
			toggleApplePayButtonInMiniCart();
		}
	}
}

function applePayButtonClicked(entitledItemJSONId, quantity, catentryId, pageType, baseItemElement, ma_index) {
	if (typeof CSRWCParamJS !== 'undefined' && CSRWCParamJS.env_shopOnBehalfSessionEstablished === 'true') {
		// WC V8+ CSR enabled and currently either buyer admin or CSR.  Stop CSR/buyer admin here.
		displayError("applePayButtonClicked", handleError(createError(null, null, MessageHelper.messages["csrNotSupported"])));
	}
	else {
		// Normal flow
		if (((entitledItemJSONId && quantity && parseInt(quantity) > 0) || (catentryId) || pageType) ) {
			// Paying for a specific product, based on Add2ShopCartAjax()
			var catalogEntriesArray = new Object();
			if (catentryId) {
				//package or item
				catalogEntryId = catentryId;
				var oneCatEntry = [catentryId, quantity];
				catalogEntriesArray[catentryId] = oneCatEntry;
			} else {
				if (pageType === "plp") {
					//PLP - single product
					var entitledItemJSON = eval(document.getElementById(entitledItemJSONId).innerHTML);
					shoppingActionsJS.setEntitledItems(entitledItemJSON);
					var oneCatEntry = [shoppingActionsJS.getCatalogEntryId(entitledItemJSONId), quantity];
					catalogEntriesArray[shoppingActionsJS.getCatalogEntryId(entitledItemJSONId)] = oneCatEntry;
				} 
				else if (pageType === "bundle") {
					//bundle - N products
					for(productId in shoppingActionsJS.productList){
						var productDetails = shoppingActionsJS.productList[productId];
						var quantityForProduct = Utils.parseNumber(productDetails.quantity);
						if (quantityForProduct == 0) {
							continue;
						}
						if(productDetails.id == 0){
							MessageHelper.displayErrorMessage(Utils.getLocalizationMessage('ERR_RESOLVING_SKU'));
							return;
						}
						if(isNaN(quantityForProduct) || quantityForProduct < 0){
							MessageHelper.displayErrorMessage(Utils.getLocalizationMessage('QUANTITY_INPUT_ERROR'));
							return;
						}
						var oneCatEntry = [productDetails.id, quantityForProduct];
						catalogEntriesArray[productDetails.id] = oneCatEntry;
					}
				}
				else if (pageType === "ma") {
					//merchandising association - deal with the associated product and a product page one
					//validation of associated product
					MerchandisingAssociationJS.associationIndex = ma_index;
					MerchandisingAssociationJS.validate();
					if(!isPositiveInteger(quantity)){
						MessageHelper.displayErrorMessage(Utils.getLocalizationMessage('QUANTITY_INPUT_ERROR'));
						return;
					}
					
					//Add the product page one to the cart.
					if(MerchandisingAssociationJS.baseItemParams.type == 'ItemBean'
						|| MerchandisingAssociationJS.baseItemParams.type == 'PackageBean'
						|| MerchandisingAssociationJS.baseItemParams.type == 'DynamicKitBean'){
						var oneCatEntry = [MerchandisingAssociationJS.baseItemParams.id, Math.abs(MerchandisingAssociationJS.baseItemParams.quantity)];
						catalogEntriesArray[MerchandisingAssociationJS.baseItemParams.id] = oneCatEntry;
					} else if(MerchandisingAssociationJS.baseItemParams.type=='BundleBean'){
						// Add items in the bundle
						for(idx=0;idx<MerchandisingAssociationJS.baseItemParams.components.length;idx++){
							var oneCatEntry = [MerchandisingAssociationJS.baseItemParams.components[idx].id, MerchandisingAssociationJS.baseItemParams.components[idx].quantity];
							catalogEntriesArray[MerchandisingAssociationJS.baseItemParams.components[idx].id] = oneCatEntry;
						}
					} else {
						// Resolve ProductBean to an ItemBean based on the attributes in the main page
						var sku = MerchandisingAssociationJS.resolveSKU();
						if(-1 == sku){
							MessageHelper.displayErrorMessage(Utils.getLocalizationMessage('ERR_RESOLVING_SKU'));
							return;
						} else {
							var oneCatEntry = [sku, Math.abs(MerchandisingAssociationJS.baseItemParams.quantity)];
							catalogEntriesArray[sku] = oneCatEntry;
						}
					}
					
					//Add the associated product to the cart.
					if (MerchandisingAssociationJS.merchandisingAssociations[MerchandisingAssociationJS.associationIndex].type=='ItemBean'
						|| MerchandisingAssociationJS.merchandisingAssociations[MerchandisingAssociationJS.associationIndex].type=='PackageBean'
						|| MerchandisingAssociationJS.merchandisingAssociations[MerchandisingAssociationJS.associationIndex].type=='DynamicKitBean'){
						var oneCatEntry = [MerchandisingAssociationJS.merchandisingAssociations[MerchandisingAssociationJS.associationIndex].id, quantity];
						catalogEntriesArray[MerchandisingAssociationJS.merchandisingAssociations[MerchandisingAssociationJS.associationIndex].id] = oneCatEntry;	
					} else if(MerchandisingAssociationJS.merchandisingAssociations[MerchandisingAssociationJS.associationIndex].type=='BundleBean'){
						// Add items in the bundle
						for(idx=0;idx<MerchandisingAssociationJS.merchandisingAssociations[MerchandisingAssociationJS.associationIndex].components.length;idx++){
							var oneCatEntry = [MerchandisingAssociationJS.merchandisingAssociations[MerchandisingAssociationJS.associationIndex].components[idx].id, MerchandisingAssociationJS.baseItemParams.components[idx].quantity];
							catalogEntriesArray[MerchandisingAssociationJS.merchandisingAssociations[MerchandisingAssociationJS.associationIndex].components[idx].id] = oneCatEntry;
						}
					} else {
						// Resolve ProductBean to an ItemBean based on the attributes selected
						var entitledItemJSON = null;
						if ($("#" + entitledItemJSONId).length) {
							//the json object for entitled items are already in the HTML. 
							entitledItemJSON = eval('(' + $("#" + entitledItemJSONId).html() + ')');
						} else {
							//if $("#" + entitledItemJSONId) is null, that means there's no <div> in the HTML that contains the JSON object. 
							//in this case, it must have been set in catalogentryThumbnailDisplay.js when the quick info
							entitledItemJSON = shoppingActionsJS.getEntitledItemJsonObject();
						}
						shoppingActionsJS.setEntitledItems(entitledItemJSON);
						var catEntryID_MA_SKU = shoppingActionsJS.getCatalogEntryId(entitledItemJSONId);
						if(null == catEntryID_MA_SKU){
							MessageHelper.displayErrorMessage(Utils.getLocalizationMessage('ERR_RESOLVING_SKU'));
							return;
						} else {
							var oneCatEntry = [catEntryID_MA_SKU, quantity];
							catalogEntriesArray[catEntryID_MA_SKU] = oneCatEntry;
						}
					}
					// end ma
				}
				else {
					//Product or Item - single product
					var entitledItemJSON = eval(document.getElementById(entitledItemJSONId).innerHTML);
					productDisplayJS.setEntitledItems(entitledItemJSON);
					var oneCatEntry = [productDisplayJS.getCatalogEntryId(entitledItemJSONId), quantity];
					catalogEntriesArray[productDisplayJS.getCatalogEntryId(entitledItemJSONId)] = oneCatEntry;
				}
			}
			if (catalogEntriesArray) {
				var catEntryParametersToAdd = '';
				var counter = 0;
				for(i in catalogEntriesArray){
					counter++;
					catEntryParametersToAdd = catEntryParametersToAdd + '&catEntryId_' + counter + '=' + catalogEntriesArray[i][0] + '&quantity_' + counter + '=' + catalogEntriesArray[i][1];
				}
				var addToOrder = simpleAjax({
					requestType: 'POST',
					requestUrl: getAbsoluteURL() + 'AjaxRESTOrderItemAdd?',
					requestParameters: getCommonParameters() + '&inventoryValidation=true&calculateOrder=0' +
						getOrderIdUrlParameter("**") + catEntryParametersToAdd + 
						'&attributeName_ord=isPDP&attributeValue_ord=1',
					async: false
				});
				if (addToOrder.status === STATUS_SUCCESS) {
					currentOrderId = addToOrder.data.orderId;
					
					if (supportPaymentTypePromotions) {
						addUnboundPI();
					}
					prepareOrder().then(function(success) {
						retrieveWCOrderInformation().then(function(success) {
							if (IsShipModeValid()) {
								renderPaymentSheet();
							}
							else {
								updateShipMode().then(function(success) {
									retrieveWCOrderInformation().then(function(success) {
										renderPaymentSheet();
									})
									.catch(function(err) {
										displayError("DirectProductBuy: fail retrieve order information 2", err)
									});
								})
								.catch(function(err) {
									displayError("DirectProductBuy: fail update shipping", err)
								});
							}
						})
						.catch(function(err) {
							displayError("DirectProductBuy: fail retrieve order information", err)
						});
					})
					.catch(function(err) {
						displayError("DirectProductBuy: fail prepare order", err)
					});
				}
				else {
					displayError("DirectProductBuy: no catentry id 2", addToOrder, MessageHelper.messages["badCatentryId"]);
				}
			}
			else {
				displayError("DirectProductBuy: no catentry id", handleError(createError(null, null, MessageHelper.messages["badCatentryId"])));
			}
		}
		else {
			// Paying for whatever is in the shopping cart
			currentOrderId = ".";
			if (isBOPISCheckout()) {
				// BOPIS flow
				openStoreLocatorPopup();
			}
			else {
				// Shipping flow
				if (supportPaymentTypePromotions) {
					addUnboundPI();
				}
				setIsReturnDefaults("true");
				retrieveWCOrderInformation().then(function(success) {
					setIsReturnDefaults("false");
					updateShipMode().then(function(success) {
						prepareOrder().then(function(success) {
							retrieveWCOrderInformation().then(function(success) {
								renderPaymentSheet();
							})
							.catch(function(err) {
								displayError("fail LAST retrieve order information", err);
							});
						})
						.catch(function(err) {
							displayError("fail prepare order", err);
						});
					})
					.catch(function(err) {
						displayError("fail update shipping information", err);
					});
				})
				.catch(function(err) {
					setIsReturnDefaults("false");
					displayError("fail retrieve order information", err);
				});
			}
		}
	}
}

function mobileBOPISFlow(bopisShipMode, bopisStoreId) {
	// Paying for whatever is in the mobile shopping cart
	currentOrderId = ".";
	setMobileBOPISShipMode(bopisShipMode);
	setMobileBOPISStore(bopisStoreId);
	updateOrderForBOPIS().then(function(success) {
		prepareOrder().then(function(success) {
			retrieveWCOrderInformation().then(function(success) {
				renderPaymentSheet();
			})
			.catch(function(err) {
				displayError("mobileBOPIS: fail retrieve order information", err);
			});
		})
		.catch(function(err) {
			displayError("mobileBOPIS: fail prepare order", err);
		});
	})
	.catch(function(err) {
		displayError("mobileBOPIS: fail update shipping for BOPIS", err);
	});
}

function startApplePayBOPISFlow() {
	if (validateBOPISParameters()) {
		if (supportPaymentTypePromotions) {
			addUnboundPI();
		}
		updateOrderForBOPIS().then(function(success) {
			prepareOrder().then(function(success) {
				retrieveWCOrderInformation().then(function(success) {
					renderPaymentSheet();
				})
				.catch(function(err) {
					displayError("BOPIS: fail retrieve order information", err);
				});
			})
			.catch(function(err) {
				displayError("BOPIS: fail prepare order", err);
			});
		})
		.catch(function(err) {
			displayError("BOPIS: fail update shipping", err);
		});
	}
	else {
		displayError("BOPIS not valid", handleError(createError(null, null, MessageHelper.messages["noStoreSelected"])));
	}
}

function renderPaymentSheet() {
	if (showDebug) {
		console.log("In renderPaymentSheet");
	}
	var session = new ApplePaySession(1, paymentRequest);
	session.begin();

	session.onvalidatemerchant = function (event) {
		if (showDebug) {
			console.log('onvalidatemerchant called...url is ' + event.validationURL);
		}
		performMerchantValidation(event.validationURL)
			.then(function(merchantSession) {
				if (showDebug) {
					//console.log(merchantSession.merchantSession);
				}
				session.completeMerchantValidation(JSON.parse(merchantSession.merchantSession));
			}, function(error) {
				displayError("performMerchantValidation", error);
				abortSession(error);
		   });
	}

	session.onshippingcontactselected = function (event) {
		if (showDebug) {
			console.log('onshippingcontactselected called');
		}
		saveShippingContact(event.shippingContact)
			.then(prepareOrder)
			.then(retrieveWCOrderInformation)
			.then(function() {
				if (!shipModeValid) {
					updateShipMode()
						.then(prepareOrder)
						.then(retrieveWCOrderInformation)
						.then(function() {
							session.completeShippingContactSelection(ApplePaySession.STATUS_SUCCESS, paymentRequest.shippingMethods, paymentRequest.total, paymentRequest.lineItems);
						})
						.catch(function(err) {
							displayError("updateShipModeAndOrder", err);
							session.completeShippingContactSelection(ApplePaySession.STATUS_INVALID_SHIPPING_POSTAL_ADDRESS);
						});
				}
				else {
					session.completeShippingContactSelection(ApplePaySession.STATUS_SUCCESS, paymentRequest.shippingMethods, paymentRequest.total, paymentRequest.lineItems);
				}
			})
			.catch(function(err) {
				displayError("saveShippingContact", err);
				session.completeShippingContactSelection(ApplePaySession.STATUS_INVALID_SHIPPING_POSTAL_ADDRESS);
			});
	}

	session.onshippingmethodselected = function (event) {
		if (showDebug) {
			console.log('onshippingmethodselected called');
			console.log(event.shippingMethod);
		}
		saveShippingMethod(event.shippingMethod)
			.then(prepareOrder)
			.then(retrieveWCOrderInformation)
			.then(function() {
				session.completeShippingMethodSelection(ApplePaySession.STATUS_SUCCESS, paymentRequest.total, paymentRequest.lineItems);
			})
			.catch(function(err) {
				displayError("saveShippingMethod", err);
				abortSession(err);
				session.completeShippingMethodSelection(ApplePaySession.STATUS_FAILURE);
			});
	}

	session.onpaymentmethodselected = function(event) {
		if (showDebug) {
			console.log('onpaymentmethodselected called');
			console.log(event.paymentMethod);
		}
		session.completePaymentMethodSelection(paymentRequest.total, paymentRequest.lineItems);
	}

	session.onpaymentauthorized = function(event) {
		if (showDebug) {
			console.log('onpaymentauthorized called');
			console.log(event.payment);
		}
		sendPaymentToken(event.payment)
			.then(function (success) {
				currentOrderId = success.orderId;
				if (showDebug) {
					console.log("currentOrderId=" + currentOrderId);
				}
				if (!this.isEmpty(currentOrderId)) {
					session.completePayment(ApplePaySession.STATUS_SUCCESS);
					setDeleteCartCookie();
					showConfirmation();
				} else {
					cancelApplePayOrder();
					session.completePayment(ApplePaySession.STATUS_FAILURE);
					displayError("sendPaymentToken", handleError(createError(null, null, MessageHelper.messages["failureSendPayment"])));
				}
			}, function(error) {
				if (error.errorMessageKey === "INVALID_SHIPPING_CONTACT") {
					session.completePayment(ApplePaySession.STATUS_INVALID_SHIPPING_CONTACT);
				}
				else if (error.errorMessageKey === "INVALID_BILLING_CONTACT") {
					session.completePayment(ApplePaySession.STATUS_INVALID_BILLING_POSTAL_ADDRESS);
				}
				else {
					session.completePayment(ApplePaySession.STATUS_FAILURE);
				}
				cancelApplePayOrder();
				displayError("sendPaymentToken", error);
			});
	}

	session.oncancel = function (event) {
		cancelApplePayOrder()
			.then(function(success) {
				if (showDebug) {
					console.log('Order cancel success');
				}
			})
			.catch(function(error) {
				displayError(CANCEL_METHOD, error);
			});
	}
}
//
// Apple Pay button and payment sheet rendering - END
//


//
// Apple Pay callback method implementations - START
//
function performMerchantValidation(appleServerURL) {
	return new Promise(function(resolve, reject) {
		var merchantValidate = simpleAjax({
			requestType: 'POST',
			requestUrl: getAbsoluteURL() + 'AjaxApplePayMerchantValidation?',
			requestParameters: getCommonParameters() + getAuthTokenUrlParameter() + '&paymentSystem=ApplePaySystem&paymentConfigGroup=default&validationURL='+appleServerURL,
			async: false
		});
		if (merchantValidate.status === STATUS_SUCCESS) {
			resolve(merchantValidate.data);
		}
		else {
			reject(merchantValidate);
		}
	});
}

function getContactAddressParameters(contact) {
	var address = '&city=' + encodeURIComponent(contact.locality) +
	'&state=' + encodeURIComponent(contact.administrativeArea) +
	'&country=' + encodeURIComponent(contact.country) +
	'&zipCode=' + encodeURIComponent(contact.postalCode) ;

	return address;
}

function getShippingAndBillingContactParameters(payment) {
	var address='' ;
	if (!this.isEmpty(payment.shippingContact)) {
		if (!this.isEmpty(payment.shippingContact.givenName)) {
			address += '&firstName_s=' + encodeURIComponent(payment.shippingContact.givenName);
		}
		if (!this.isEmpty(payment.shippingContact.familyName)) {
			address += '&lastName_s=' + encodeURIComponent(payment.shippingContact.familyName);
		}
		if (!this.isEmpty(payment.shippingContact.locality)) {
			address += '&city_s=' + encodeURIComponent(payment.shippingContact.locality);
		}
		if (!this.isEmpty(payment.shippingContact.postalCode)) {
			address += '&zipCode_s=' + encodeURIComponent(payment.shippingContact.postalCode);
		}
		if (!this.isEmpty(payment.shippingContact.addressLines) && !this.isEmpty(payment.shippingContact.addressLines[0])) {
			address += '&address1_s=' + encodeURIComponent(payment.shippingContact.addressLines[0]);
		}
		if (!this.isEmpty(payment.shippingContact.addressLines) && !this.isEmpty(payment.shippingContact.addressLines[1])) {
			address += '&address2_s=' + encodeURIComponent(payment.shippingContact.addressLines[1]);
		}
		if (!this.isEmpty(payment.shippingContact.phoneNumber)) {
			address += '&phone1_s=' + encodeURIComponent(payment.shippingContact.phoneNumber);
		}
		if (!this.isEmpty(payment.shippingContact.administrativeArea)) {
			address += '&state_s=' + encodeURIComponent(payment.shippingContact.administrativeArea);
		}
		if (!this.isEmpty(payment.shippingContact.country)) {
			address += '&country_s=' + encodeURIComponent(payment.shippingContact.country);
		}
		if (!this.isEmpty(payment.shippingContact.emailAddress)) {
			address += '&email1_s=' + encodeURIComponent(payment.shippingContact.emailAddress);
		}
	}
	if (!this.isEmpty(payment.billingContact)) {
		if (!this.isEmpty(payment.billingContact.givenName)) {
			address += '&firstName_b=' + encodeURIComponent(payment.billingContact.givenName);
		}
		if (!this.isEmpty(payment.billingContact.familyName)) {
			address += '&lastName_b=' + encodeURIComponent(payment.billingContact.familyName);
		}
		if (!this.isEmpty(payment.billingContact.locality)) {
			address += '&city_b=' + encodeURIComponent(payment.billingContact.locality);
		}
		if (!this.isEmpty(payment.billingContact.postalCode)) {
			address += '&zipCode_b=' + encodeURIComponent(payment.billingContact.postalCode);
		}
		if (!this.isEmpty(payment.billingContact.addressLines) && !this.isEmpty(payment.billingContact.addressLines[0])) {
			address += '&address1_b=' + encodeURIComponent(payment.billingContact.addressLines[0]);
		}
		if (!this.isEmpty(payment.billingContact.addressLines) && !this.isEmpty(payment.billingContact.addressLines[1])) {
			address += '&address2_b=' + encodeURIComponent(payment.billingContact.addressLines[1]);
		}
		if (!this.isEmpty(payment.billingContact.phoneNumber)) {
			address += '&phone1_b=' + encodeURIComponent(payment.billingContact.phoneNumber);
		}
		if (!this.isEmpty(payment.billingContact.administrativeArea)) {
			address += '&state_b=' + encodeURIComponent(payment.billingContact.administrativeArea);
		}
		if (!this.isEmpty(payment.billingContact.country)) {
			address += '&country_b=' + encodeURIComponent(payment.billingContact.country);
		}
		if (!this.isEmpty(payment.billingContact.emailAddress)) {
			address += '&email1_b=' + encodeURIComponent(payment.billingContact.emailAddress);
		}
	}

	return address;
}

function getPaymentTokenParameters(token){
	var paymentToken = '&applepay_paymentData_data=' + encodeURIComponent(token.paymentData.data)
		+ '&applepay_paymentData_header_publicKeyHash=' + encodeURIComponent(token.paymentData.header.publicKeyHash)
		+ '&applepay_paymentData_header_ephemeralPublicKey=' + encodeURIComponent(token.paymentData.header.ephemeralPublicKey)
		+ '&applepay_paymentData_header_transactionId=' + encodeURIComponent(token.paymentData.header.transactionId)
		+ '&applepay_paymentData_signature=' + encodeURIComponent(token.paymentData.signature)
		+ '&applepay_paymentData_version=' + encodeURIComponent(token.paymentData.version)
		+ '&applepay_paymentMethod_displayName=' + encodeURIComponent(token.paymentMethod.displayName)
		+ '&applepay_paymentMethod_network=' + encodeURIComponent(token.paymentMethod.network)
		+ '&applepay_paymentMethod_type=' + encodeURIComponent(token.paymentMethod.type)
		+ '&applepay_paymentMethod_paymentPass=' + encodeURIComponent(token.paymentMethod.paymentPass)
		+ '&applepay_transactionIdentifier=' + encodeURIComponent(token.transactionIdentifier);

	return paymentToken;
}

function saveShippingContact(shippingContact) {
	return new Promise(function(resolve, reject) {
		if (!validateInitialShippingContact(shippingContact)) {
			// Stop if contact information needed for shipping costs are not present
			reject(handleError(createError(null, "INVALID_SHIPPING_CONTACT", MessageHelper.messages["invalidShippingContact"])));
			return;
		}
		else {
			if (showDebug) {
				console.log("Update shipping Contact: " + JSON.stringify(shippingContact));
			}
			var saveResult = simpleAjax({
				requestType: 'POST',
				requestUrl: getAbsoluteURL() + 'AjaxApplePayOrderUpdate',
				requestParameters: getCommonParameters() + getContactAddressParameters(shippingContact) + getAuthTokenUrlParameter() + getOrderIdUrlParameter(),
				async: false
			});
			if (saveResult.status === STATUS_SUCCESS) {
				resolve();
			}
			else {
				reject(saveResult);
			}
		}
	});
}

function saveShippingMethod(shippingMethod) {
	return new Promise(function(resolve, reject) {
		if (showDebug) {
			console.log("New Shipping Method: " + shippingMethod.identifier);
		}
		var saveResult = simpleAjax({
			requestType: 'POST',
			requestUrl: getAbsoluteURL() + 'AjaxApplePayOrderUpdate',
			requestParameters: getCommonParameters() + '&shipModeId=' + shippingMethod.identifier + getAuthTokenUrlParameter() + getOrderIdUrlParameter(),
			async: false
		});
		if (saveResult.status === STATUS_SUCCESS) {
			resolve();
		}
		else {
			reject(saveResult);
		}
	});
}

function validateInitialShippingContact(sc) {
	// Validate basic shipping contact for shipping costs
	if (this.isEmpty(sc)) {
		return false;
	}
	else {
		if (this.isEmpty(sc.locality)) {
			return false;
		}
		if (this.isEmpty(sc.postalCode)) {
			return false;
		}
		if (this.isEmpty(sc.administrativeArea)) {
			return false;
		}
		if (this.isEmpty(sc.country)) {
			return false;
		}
	}
	return true;
}
function validateFinalShippingContact(sc) {
	// Validate full contact for address book
	if (!validateInitialShippingContact) {
		return false;
	}
	else {
		if (this.isEmpty(sc.familyName)) {
			return false;
		}
		if (this.isEmpty(sc.addressLines) || this.isEmpty(sc.addressLines[0])) {
			return false;
		}
		if (this.isEmpty(sc.emailAddress)) {
			return false;
		}
	}
	return true;
}

function validateBillingContact(bc) {
	// Validate full billing contact
	if (this.isEmpty(bc)) {
		return false;
	}
	else {
		if (this.isEmpty(bc.familyName)) {
			return false;
		}
		if (this.isEmpty(bc.locality)) {
			return false;
		}
		if (this.isEmpty(bc.postalCode)) {
			return false;
		}
		if (this.isEmpty(bc.addressLines || this.isEmpty(bc.addressLines[0]))) {
			return false;
		}
		if (this.isEmpty(bc.administrativeArea)) {
			return false;
		}
		if (this.isEmpty(bc.country)) {
			return false;
		}
	}
	return true;
}

function sendPaymentToken(payment) {
	return new Promise(function(resolve, reject) {
		if (showDebug) {
			console.log("Sending payment token...");
		}
		if (!isBOPISCheckout()) {
			if (!validateFinalShippingContact(payment.shippingContact)) {
				reject(handleError(createError(null, "INVALID_SHIPPING_CONTACT", MessageHelper.messages["invalidShippingContact"])));
				return;
			}
		}
		if (!validateBillingContact(payment.billingContact)) {
			reject(handleError(createError(null, "INVALID_BILLING_CONTACT", MessageHelper.messages["invalidBillingContact"])));
			return;
		} else {
			var applePayOrderProcess = simpleAjax({
				requestType: 'POST',
				requestUrl: getAbsoluteURL() + 'AjaxApplePayOrderProcess?',
				requestParameters: getCommonParameters() + '&notifyMerchant=1&notifyShopper=1&notifyOrderSubmitted=1' + getOrderIdUrlParameter(".") + 
					getAuthTokenUrlParameter() + getPaymentTokenParameters(payment.token) + getShippingAndBillingContactParameters(payment) + getUnboundPIIdParameter(),
				async: false
			});
			if (applePayOrderProcess.status === STATUS_SUCCESS) {
				resolve(applePayOrderProcess.data);
			}
			else {
				reject(applePayOrderProcess);
			}
		}
	});
}

function cancelApplePayOrder() {
	return new Promise(function(resolve, reject) {
		if (showDebug) {
			console.log("Cancelling order...");
		}
		var cancelOrder = simpleAjax({
			requestType: 'POST',
			requestUrl: getAbsoluteURL() + 'AjaxApplePayOrderCancel?',
			requestParameters: getCommonParameters() + getAuthTokenUrlParameter() + getOrderIdUrlParameter("."),
			async: false
		});
		if (cancelOrder.status === STATUS_SUCCESS) {
			resolve(cancelOrder.data);
		}
		else {
			reject(cancelOrder);
		}
	});
}
//
// Apple Pay callback method implementations - END
//


//
// Global WC reusable task methods - START
//
var STATUS_SUCCESS = "success";
var STATUS_ERROR = "error";
var showDebug = false; // NOTE Set to false to turn off debug
var CANCEL_METHOD = "cancelApplePayOrder";

function isEmpty(v) {
	if (typeof v === "object") {
		if (Array.isArray(v)) {
			return !(v.length > 0);
		}
		else {
			return false;
		}
	}
	return !(typeof v === "string" && v.length > 0);
}

function isBOPISCheckout() {
	return this.getShippingSelection() === "pickUp";
}
function getShippingSelection() {
	var result = "shopOnline";
	if (document.BOPIS_FORM != undefined){
		for (var i=0; i < document.BOPIS_FORM.shipType.length; i++) {
			if (document.BOPIS_FORM.shipType[i].checked) {
				if (showDebug) {
					console.log("Selected checkout option - " + document.BOPIS_FORM.shipType[i].value);
				}
				result = document.BOPIS_FORM.shipType[i].value;
			}
		}
	} else if (mobileBOPISShipModeId != "" && mobileBOPISStoreId != "") {
		result = "pickUp";
	}
	return result;
}
function validateBOPISParameters() {
	var shipModeIdBOPIS = "";
	var physicalStoreLocationId = "";
	var orderItemId = "";
	if (document.getElementById("shipmodeForm") && PhysicalStoreCookieJS) {
		shipModeIdBOPIS = document.getElementById("shipmodeForm").BOPIS_shipmode_id.value;
		if (PhysicalStoreCookieJS.getStoreIdsFromCookie().indexOf(",") == -1) {
			physicalStoreLocationId = PhysicalStoreCookieJS.getStoreIdsFromCookie();
		}
		orderItemId = document.getElementById("OrderFirstItemId").value;
		return !this.isEmpty(shipModeIdBOPIS) && !this.isEmpty(physicalStoreLocationId) && !this.isEmpty(orderItemId);
	}
}

function updateOrderForBOPIS() {
	return new Promise(function(resolve, reject) {
		var updateBOPIS = simpleAjax({
			requestType: 'POST',
			requestUrl: getAbsoluteURL() + 'AjaxApplePayOrderUpdate?',
			requestParameters: getCommonParameters() + getAuthTokenUrlParameter() + getOrderIdUrlParameter() + getBOPISParameters(),
			async: false
		});
		if (updateBOPIS.status === STATUS_SUCCESS) {
			currentOrderId = updateBOPIS.data.orderId;
			resolve(updateBOPIS);
		}
		else {
			reject(updateBOPIS);
		}
	});
}

function updateShipMode() {
	if (showDebug) {
		console.log("In updateShipMode");
	}
	return new Promise(function(resolve, reject) {
		var updateShipModeId = simpleAjax({
			requestType: 'POST',
			requestUrl: getAbsoluteURL() + 'AjaxApplePayOrderUpdate?',
			requestParameters: getCommonParameters() + getAuthTokenUrlParameter() + getOrderIdUrlParameter() + getDefaultShippingParameter(),
			async: false
		});
		if (updateShipModeId.status === STATUS_SUCCESS) {
			currentOrderId = updateShipModeId.data.orderId;
			resolve(updateShipModeId);
		}
		else {
			reject(updateShipModeId);
		}
	});
}

function addUnboundPI() {
	if (showDebug) {
		console.log("In addUnboundPI");
	}
	return new Promise(function(resolve, reject) {
		var addUnboundPICall = simpleAjax({
			requestType: 'POST',
			requestUrl: getAbsoluteURL() + 'AjaxRESTOrderPIAdd?',
			requestParameters: getCommonParameters() + getAuthTokenUrlParameter() + getOrderIdUrlParameter() + '&payMethodId=ApplePay&unbound=true',
			async: false
		});
		if (addUnboundPICall.status === STATUS_SUCCESS) {
			unboundPIId = addUnboundPICall.data.paymentInstruction[0].piId;
			resolve(addUnboundPICall);
		}
		else {
			reject(addUnboundPICall);
		}
	});
}

function prepareOrder() {
	if (showDebug) {
		console.log("In prepareOrder");
	}
	return new Promise(function(resolve, reject) {
		var applePayPrepare = simpleAjax({
			requestType: 'POST',
			requestUrl: getAbsoluteURL() + 'AjaxRESTOrderPrepare?',
			requestParameters: getCommonParameters() + getAuthTokenUrlParameter() + getOrderIdUrlParameter(),
			async: false
		});
		if (applePayPrepare.status === STATUS_SUCCESS) {
			if (showDebug) {
				console.log("Successful order prepare - " + applePayPrepare.data.orderId);
			}
			currentOrderId = applePayPrepare.data.orderId;
			resolve(applePayPrepare);
		}
		else {
			reject(applePayPrepare);
		}
	});
}
function retrieveWCOrderInformation() {
	if (showDebug) {
		console.log("In retrieveWCOrderInformation");
	}
	var urlParameters = "";
	if (getIsReturnDefaults() === "true") {
		urlParameters = getCommonParameters() + getBOPISParameters() + getIsReturnDefaultsParameter();
	} else {
		urlParameters = getCommonParameters() + getOrderIdUrlParameter() + getBOPISParameters() + getIsReturnDefaultsParameter();
	}
	return new Promise(function(resolve, reject) {
		var wcOrderInfo = simpleAjax({
			requestType: 'GET',
			requestUrl: getAbsoluteURL() + 'GetOrderInfoForApplePayV2?',
			requestParameters: urlParameters,
			async: false
		});
		if (wcOrderInfo.status === STATUS_SUCCESS) {
			if (wcOrderInfo.data.defaultShipModeId) {
				shipModeValid = false;
				defaultShipModeId = wcOrderInfo.data.defaultShipModeId;
				defaultAddressId = wcOrderInfo.data.defaultAddressId;
			} else {
				shipModeValid = true;
				paymentRequest = wcOrderInfo.data;
			}
			if (showDebug) {
				console.log("shipModeValid - " + shipModeValid);
			}
			resolve(wcOrderInfo);
		}
		else {
			reject(wcOrderInfo);
		}
	});
}

function showConfirmation() {
	if (showDebug) {
		console.log("In showConfirmation");
	}
	document.location.href = appendWcCommonRequestParameters("OrderShippingBillingConfirmationView?" + getCommonParameters() + getOrderIdUrlParameter());
}
function displayError(location, error, customMessage) {
	console.log("Error in " + location);
	console.log(JSON.stringify(error.error));
	if (typeof error.args !== 'undefined') {
		if (showDebug) {
			console.log(JSON.stringify(error.args));
		}
	}
	MessageHelper.displayErrorMessage(customMessage ? customMessage : error.error.errorMessage);

}
function abortSession(e) {
	var promise = cancelApplePayOrder();
	promise.then(function(success) {
		if (showDebug) {
			console.log('Order cancel success');
		}
	}, function(error) {
		displayError(CANCEL_METHOD, error);
	});
	session.abort();
}
//
// Global WC reusable task methods - END
//
//-----------------------------------------------------------------
// Licensed Materials - Property of IBM
//
// WebSphere Commerce
//
// (C) Copyright IBM Corp. 2013, 2016 All Rights Reserved.
//
// US Government Users Restricted Rights - Use, duplication or
// disclosure restricted by GSA ADP Schedule Contract with
// IBM Corp.
//-----------------------------------------------------------------

OnBehalfUtilities = function(){

	this.startCustomerService = function(node){
		var URL = node.getAttribute("data-customer-service-url");
		var buyOnBehalfName = getCookie("WC_BuyOnBehalf_"+WCParamJS.storeId);
		if(CSRWCParamJS.env_shopOnBehalfSessionEstablished === "true" && CSRWCParamJS.env_shopOnBehalfEnabled_CSR === "true"){
			//onbehalf session established by CSR. Show warning dialog before terminating it.
			wcTopic.subscribeOnce("onBehalfSessionTerminate", function(data){
				if (data.action === "YES"){
					document.location.href = URL;
				}
				if(data.action === "NO"){
				}
			});
			MessageHelper.showConfirmationDialog("onBehalfSessionTerminate",
						Utils.getLocalizationMessage('CSR_SESSION_TERMINATE_WARNING_MESSAGE', {0: escapeXml(buyOnBehalfName, true)}));
		} else {
			// Customer session is not yet started. Redirect to landing page.
			document.location.href = URL;
		}
	};

	this.updateUIAndRenderContext = function(response, masterContextName){
		
		//masterContextName - Name of the renderContext which was used to update user Status.
		// userStatus can be updated in FindOrders section or FindRegisteredCustomers section.
		// masterContext will contain the updated data.

		var userId1, userId2, updatedStatusOrder, updatedStatusUser = null;
		var contextExist = wcRenderContext.checkIdDefined("UserRegistrationAdminUpdateStatusContext");
		if (contextExist) {
			userId1 = wcRenderContext.getRenderContextProperties("UserRegistrationAdminUpdateStatusContext")["userId"];
			updatedStatusUser = wcRenderContext.getRenderContextProperties("UserRegistrationAdminUpdateStatusContext")[userId1+"_userStatus"];
		}
		
		contextExist = wcRenderContext.checkIdDefined("UserRegistrationAdminUpdateStatusContextCSR");
		if(contextExist) {
			userId2 = wcRenderContext.getRenderContextProperties("UserRegistrationAdminUpdateStatusContextCSR")["userId"];
			updatedStatusOrder = wcRenderContext.getRenderContextProperties("UserRegistrationAdminUpdateStatusContextCSR")[userId2+"_userStatus"];
		}

		var updatedStatus = null;
		var userId = null;
		if(masterContextName === "UserRegistrationAdminUpdateStatusContext"){
			updatedStatus = updatedStatusUser;
			userId = userId1;
		} else if(masterContextName === "UserRegistrationAdminUpdateStatusContextCSR") {
			updatedStatus = updatedStatusOrder;
			userId = userId2;
		}

		// Save it in context for future use.
		if(typeof(renderContextUser) !== 'undefined'){
			renderContextUser.properties[userId+"_updatedStatus"] = updatedStatus; 
		}
		if(typeof(renderContextOrder) !== 'undefined'){
			renderContextOrder.properties[userId+"_updatedStatus"] = updatedStatus; 
		}

		
		var userStatusText = Utils.getLocalizationMessage('DISABLE_CUSTOMER_ACCOUNT');
		if(updatedStatus === '0'){
			userStatusText = Utils.getLocalizationMessage('ENABLE_CUSTOMER_ACCOUNT');
		}
		// Update widget text...
		var toggleUserStatusControl = $("div[data-toggle-userStatus = 'userStatus_" + userId + "']");
		toggleUserStatusControl.forEach(function(node, index, arr){
			node.innerHTML = userStatusText;
		});
	};


	this.cancelOrder = function(orderId, reloadURL, onBehalf, authToken){
		//TODO - do we need forced cancel. ?
		wcRenderContext.getRenderContextProperties("onBehalfCommonContext")['cancelReloadURL'] = reloadURL;

		var service = wcService.getServiceById('AjaxCancelOrderAdministrator');
		if(onBehalf != null && onBehalf === 'true'){
			service.setUrl(getAbsoluteURL() +  "AjaxRESTCSROrderCancelOnbehalf");
		} else {
			service.setUrl(getAbsoluteURL() +  "AjaxRESTCSROrderCancelAsAdmin");
		}
		
		var params = [];
		params.orderId = orderId;
		params["storeId"] = WCParamJS.storeId;
		params["catalogId"] = WCParamJS.catalogId;
		params["langId"] = WCParamJS.langId;
		params["forcedCancel"] = "true";
		
		wcService.invoke("AjaxCancelOrderAdministrator", params);
	
	};

	this.unLockOrder = function(orderId, forceUnlock){
		if(forceUnlock != null && forceUnlock !== "" && forceUnlock === 'true'){
			// The order is locked by someone.. Need to first take over the lock and then unlock.
			this.takeOverLock(orderId, 'true');
			var removeHandler = wcTopic.subscribe("orderTakeOverSuccess", function(data){
				removeHandler.remove();
				// Now unlock the order.
				onBehalfUtilitiesJS.unLockOrder(orderId, "false");
			});

			return;
		}
		var service = this.getLockUnLockCartService('AjaxRESTOrderLockUnlockOnBehalf', getAbsoluteURL()+'AjaxRESTOrderUnlockOnBehalf', 'SUCCESS_ORDER_UNLOCK');
		var params = [];
		params["orderId"] = orderId;
		params["filterOption"] = "All";
		params["storeId"] = WCParamJS.storeId;
		params["catalogId"] = WCParamJS.catalogId;
		params["langId"] = WCParamJS.langId;	

		/*For Handling multiple clicks. */
		if(!submitRequest()){
			return;
		}			
		cursor_wait();
		wcService.invoke(service.getParam("id"), params);
	};

	this.lockOrder = function(orderId){
		var service = this.getLockUnLockCartService('AjaxRESTOrderLockUnlockOnBehalf', getAbsoluteURL()+'AjaxRESTOrderLockOnBehalf', 'SUCCESS_ORDER_LOCK');
		var params = [];
		params["orderId"] = orderId;
		params["filterOption"] = "All";
		params["storeId"] = WCParamJS.storeId;
		params["catalogId"] = WCParamJS.catalogId;
		params["langId"] = WCParamJS.langId;	

		/*For Handling multiple clicks. */
		if(!submitRequest()){
			return;
		}			
		cursor_wait();
		wcService.invoke(service.getParam("id"), params);
	};


	this.takeOverLock = function(orderId,publishTopic){
		var service = this.getLockUnLockCartService('AjaxRESTOrderLockUnlockOnBehalf', getAbsoluteURL()+'AjaxRESTOrderLockTakeOverOnBehalf',
				'SUCCESS_ORDER_TAKE_OVER', publishTopic);
		var params = [];
		params["orderId"] = orderId;
		params["filterOption"] = "All";
		params["takeOverLock"] = "Y"
		params["storeId"] = WCParamJS.storeId;
		params["catalogId"] = WCParamJS.catalogId;
		params["langId"] = WCParamJS.langId;	

		/*For Handling multiple clicks. */
		if(!submitRequest()){
			return;
		}			
		cursor_wait();
		wcService.invoke(service.getParam("id"), params);
	};

	this.getLockUnLockCartService = function(actionId,url,messageKey,publishTopic){

		var service = wcService.getServiceById('AjaxRESTOrderLockUnlockOnBehalf');

		if(service == null || service === undefined){

			wcService.declare({
				id: "AjaxRESTOrderLockUnlockOnBehalf",
				actionId: "AjaxRESTOrderLockUnlockOnBehalf",
				url: "",
				formId: "",
				successMessageKey:"",
				publishTopic:""
				
				/**
				 * Clear messages on the page.
				 * @param (object) serviceResponse The service response object, which is the JSON object returned by the service invocation
				 */
				,successHandler: function(serviceResponse) {
					cursor_clear();
					if(service.getParam("publishTopic") === 'true'){
						wcTopic.publish("orderTakeOverSuccess", serviceResponse);
						return;
					}
					MessageHelper.hideAndClearMessage();
					MessageHelper.displayStatusMessage(Utils.getLocalizationMessage(service.getParam("successMessageKey")));
					setDeleteCartCookie(); // Mini Cart cookie should be refreshed to display updated cart lock status....
					if($('#quick_cart_container').length) {
						$('#quick_cart_container').hide();
					}
				}
				
				/**
				 * Displays an error message on the page if the request failed.
				 * @param (object) serviceResponse The service response object, which is the JSON object returned by the service invocation.
				 */
				,failureHandler: function(serviceResponse) {
					if (serviceResponse.errorMessage) {
						MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
					} else {
						if (serviceResponse.errorMessageKey) {
							MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
						}
					}
				}
			});
			service = wcService.getServiceById('AjaxRESTOrderLockUnlockOnBehalf');
		}
		if(actionId != null && actionId !== 'undefined'){
			service.setActionId(actionId);
		}
		if(messageKey != null && messageKey !== 'undefined'){
			service.setParam("successMessageKey", messageKey);
		}
		if(publishTopic != null && publishTopic !== 'undefined'){
			service.setParam("publishTopic", publishTopic);
		} else {
			service.setParam("publishTopic", null);
		}
		if(url != null && url !== 'undefined'){
			service.setUrl(url);
		} else {
			service.setUrl(null);
		}
		return service;
	};
};


$(document).ready(function() {
	onBehalfUtilitiesJS = new OnBehalfUtilities();
});

wcRenderContext.declare("onBehalfCommonContext", [], {});
wcRenderContext.declare("orderLockStatusContext", ["orderLockStatusRefreshArea"], {});

var declareOrderLockStatusRefreshArea = function(){
	// ============================================
	// div: orderLockStatusRefreshArea refresh area
	// Declares a new refresh controller for the fetching order Lock status.
	var myWidgetObj = $("#orderLockStatusRefreshArea");
	myWidgetObj.refreshWidget("updateUrl", getAbsoluteURL() + "OrderLockStatusView?" + getCommonParametersQueryString());
	var myRCProperties = wcRenderContext.getRenderContextProperties("orderLockStatusContext");

	// model change
	wcTopic.subscribe("AjaxRESTOrderLockUnlockOnBehalf", function() {
		console.debug("modelChangedHandler of orderLockStatusController");
		myWidgetObj.refreshWidget("refresh", myRCProperties);
	});

	var postRefreshHandler = function () {
		console.debug("Post refresh handler of orderLockStatus");
		cursor_clear();
	};

	// initialize widget
	myWidgetObj.refreshWidget({postRefreshHandler: postRefreshHandler});
};

wcService.declare({
	id: "AjaxRESTMemberPasswordResetByAdminOnBehalfForBuyer",
	actionId: "AjaxRESTMemberPasswordResetByAdminOnBehalfForBuyer",
	url: getAbsoluteURL() +  "AjaxRESTMemberPasswordResetByAdminOnBehalf",
	formId: ""

	 /**
	  *  This method refreshes the panel 
	  *  @param (object) serviceResponse The service response object, which is the
	  *  JSON object returned by the service invocation.
	  */
	,successHandler: function(serviceResponse) {
		MessageHelper.displayStatusMessage(Utils.getLocalizationMessage("RESET_PASSWORD_SUCCESS"));
		cursor_clear();
	}
	
	/**
	* display an error message.
	* @param (object) serviceResponse The service response object, which is the
	* JSON object returned by the service invocation.
	*/
	,failureHandler: function(serviceResponse) {
		 var errorMessage = Utils.getLocalizationMessage(serviceResponse.errorMessageKey);
		 if(errorMessage == null){
			if (serviceResponse.errorMessage) {
				errorMessage = serviceResponse.errorMessage;
			} else if (serviceResponse.errorMessageKey) {
				errorMessage = serviceResponse.errorMessageKey;
			}
		 }
		MessageHelper.displayErrorMessage(errorMessage);
	}

});

wcService.declare({
	id: "AjaxRESTMemberPasswordResetByAdminOnBehalf",
	actionId: "AjaxRESTMemberPasswordResetByAdminOnBehalf",
	url: getAbsoluteURL() +  "AjaxRESTMemberPasswordResetByAdminOnBehalf",
	formId: ""

	 /**
	  *  This method refreshes the panel 
	  *  @param (object) serviceResponse The service response object, which is the
	  *  JSON object returned by the service invocation.
	  */
	,successHandler: function(serviceResponse) {
		MessageHelper.displayStatusMessage(Utils.getLocalizationMessage("RESET_PASSWORD_SUCCESS"));
		if(typeof(registeredCustomersJS) !== 'undefined'){
			registeredCustomersJS.onResetPasswordByAdminSuccess();
		}
		cursor_clear();
	}
	
	/**
	* display an error message.
	* @param (object) serviceResponse The service response object, which is the
	* JSON object returned by the service invocation.
	*/
	,failureHandler: function(serviceResponse) {
		var errorMessage = "";
		if(typeof(registeredCustomersJS) !== 'undefined'){
			 errorMessage = Utils.getLocalizationMessage(serviceResponse.errorMessageKey);
			 if(errorMessage == null){
				if (serviceResponse.errorMessage) {
					errorMessage = serviceResponse.errorMessage;
				} else if (serviceResponse.errorMessageKey) {
					errorMessage = serviceResponse.errorMessageKey;
				}
			 }
			registeredCustomersJS.onResetPasswordByAdminError(errorMessage,serviceResponse);
		}
	}

});

wcService.declare({
	id: "AjaxRESTMemberPasswordResetByAdmin",
	actionId: "AjaxRESTMemberPasswordResetByAdmin",
	url: getAbsoluteURL() +  "AjaxRESTMemberPasswordResetByAdmin",
	formId: ""

	 /**
	  *  This method refreshes the panel 
	  *  @param (object) serviceResponse The service response object, which is the
	  *  JSON object returned by the service invocation.
	  */
	,successHandler: function(serviceResponse) {
		MessageHelper.displayStatusMessage(Utils.getLocalizationMessage("RESET_PASSWORD_SUCCESS"));
		cursor_clear();
	}
	
	/**
	* display an error message.
	* @param (object) serviceResponse The service response object, which is the
	* JSON object returned by the service invocation.
	*/
	,failureHandler: function(serviceResponse) {
		MessageHelper.displayErrorMessage(Utils.getLocalizationMessage("ERROR_RESET_PASSWORD_ACCESS_ACCOUNT_TO_RESET"));
	}

});

wcService.declare({
	id: "AjaxCancelOrderAdministrator",
	actionId: "AjaxCancelOrderAdministrator",
	url: getAbsoluteURL() +  "AjaxRESTCSROrderCancelAsAdmin"+"?"+getCommonParametersQueryString()+"&forcedCancel=true",
	formId: ""

	 /**
	  *  This method refreshes the panel 
	  *  @param (object) serviceResponse The service response object, which is the
	  *  JSON object returned by the service invocation.
	  */
	,successHandler: function(serviceResponse) {
		MessageHelper.displayStatusMessage(Utils.getLocalizationMessage("ORDER_CANCEL_SUCCESS"));
        var reloadURL = wcRenderContext.getRenderContextProperties("onBehalfCommonContext")['cancelReloadURL'];
		if(reloadURL !== '' && typeof(reloadURL) !== 'undefined'){
			document.location.href = reloadURL;
		} else {
			window.location.reload(1);
		}
		cursor_clear();
	}
	
	/**
	* display an error message.
	* @param (object) serviceResponse The service response object, which is the
	* JSON object returned by the service invocation.
	*/
	,failureHandler: function(serviceResponse) {
		if (serviceResponse.errorMessage) {
			MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
		} else {
			if (serviceResponse.errorMessageKey) {
				MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
			}
		}
	}

});
//-----------------------------------------------------------------
// Licensed Materials - Property of IBM
//
// WebSphere Commerce
//
// (C) Copyright IBM Corp. 2013, 2016 All Rights Reserved.
//
// US Government Users Restricted Rights - Use, duplication or
// disclosure restricted by GSA ADP Schedule Contract with
// IBM Corp.
//-----------------------------------------------------------------


widgetCommonJS = {
    toggleDisplay: function(divId){
        if ($("#"+divId).css("display") === "none") {
            $("#"+divId).css("display", "block");
        } else {
            $("#"+divId).css("display", "none");
        }
    },

    toggleCustomCheckBox: function(cssClassForQuery,cssClassToToggle,node){
        $('.'+cssClassForQuery, node).toggleClass(cssClassToToggle);
        if(node.getAttribute("aria-checked") == 'true'){
            node.setAttribute("aria-checked","false");
        } else {
            node.setAttribute("aria-checked","true");
        }
    },

    toggleCustomCheckBoxKeyPress: function(cssClassForQuery,cssClassToToggle,node,event){
        var charOrCode = event.charCode || event.keyCode;
        console.debug(charOrCode);
        if (charOrCode == KeyCodes.SPACE) { 
            widgetCommonJS.toggleCustomCheckBox(cssClassForQuery,cssClassToToggle,node);
        }
    },

    toggleReadEditSection:function(editSectionId,showSection){
        var overlay = $("#overlay");
        var editSectionMain = $("#"+editSectionId+"Main");

        if(showSection == 'edit'){
            $('#'+editSectionId).css('display', 'block');
            $("#"+editSectionId+'Icon').css('display', 'none');
            $("#"+editSectionId+'Read').css('display','none');

            if (overlay){
                $(overlay).removeClass("nodisplay");
            }
            $(editSectionMain).addClass("editView lightedSection");
        } else if(showSection == 'read'){
            $('#'+editSectionId).css('display', 'none');
            $('#'+editSectionId+'Icon').css('display', 'inline-block');
            $("#"+editSectionId+'Read').css('display','block');

            if (overlay){
                $(overlay).addClass("nodisplay");
            }
            $(editSectionMain).removeClass("lightedSection editView");
        }
    },
    focusDiv: function(divId){
        $("#"+divId).addClass("dottedBorder");
    },

    blurDiv: function(divId){
        $("#"+divId).removeClass("dottedBorder");
    },
    
    toggleEditSection: function(target){
        $(target).toggleClass("readOnly editView");
        
        var editField = $(target).find(".editField");
        var readField = $(target).find(".readField");
        var overlay = $("#overlay");
        if ($(target).hasClass("readOnly")){
            $(editField).attr("aria-hidden", "true");
            $(readField).removeAttr("aria-hidden");
            $(target).removeClass("lightedSection")
            if (overlay){
                overlay.addClass("nodisplay");
            }
        }else {
            $(readField).attr("aria-hidden", "true");
            $(editField).removeAttr("aria-hidden");
            $(target).addClass("lightedSection")
            if (overlay){
                overlay.removeClass("nodisplay");
            }
        }
    },
    
    //can be invoked by postRefreshHandler upon update
    removeSectionOverlay: function(){
        var overlay = $("#overlay");
        if (overlay){
            $(overlay).addClass("nodisplay");
        }
    },
    
    redirect:function(url, queryParams){
        if(queryParams != null && queryParams != 'undefined'){
            if(url.indexOf('?') > -1){
                url = url +"&"+queryParams;
            } else {
                url = url +"?"+queryParams;
            }
        }
        document.location.href = url;
    },
    
    initializeEditSectionToggleEvent: function (){
        //toggle edit and readonly sections, see organization user info widget
    	Utils.onOnce($(".pageSection .pageSectionTitle .editIcon[data-section-toggle]"), "click", "EditSection", function(e){
            var target = this.getAttribute("data-section-toggle");
            widgetCommonJS.toggleEditSection(document.getElementById(target));
            Utils.stopEvent(e);
        });
        //cancle button
    	Utils.onOnce($(".pageSection .editField .button_footer_line a[data-section-toggle]"), "click", "EditSection", function(e){
            var target = this.getAttribute("data-section-toggle");
            widgetCommonJS.toggleEditSection(document.getElementById(target));
            var data = {"target": target};
            wcTopic.publish("sectionToggleCancelPressed", data);
            Utils.stopEvent(e);
        });
    }
};
	
//-----------------------------------------------------------------
// Licensed Materials - Property of IBM
//
// WebSphere Commerce
//
// (C) Copyright IBM Corp. 2013, 2016 All Rights Reserved.
//
// US Government Users Restricted Rights - Use, duplication or
// disclosure restricted by GSA ADP Schedule Contract with
// IBM Corp.
//-----------------------------------------------------------------


if (typeof (AutoSKUSuggestJS) == "undefined" || AutoSKUSuggestJS == null || !AutoSKUSuggestJS) {

    AutoSKUSuggestJS = {

        /**
         * This variable controls the timer handler before triggering the autoSuggest.  If the user types fast, intermittent requests will be cancelled.
         * The value is initialized to -1.
         */
        autoSuggestSKUTimer: -1,

        /**
         * This variable controls the delay of the timer in milliseconds between the keystrokes before firing the search request.
         * The value is initialized to 400.
         */
        autoSuggestSKUKeystrokeDelay: 400,

        /**
         * This variable indicates whether or not the user is hovering over the autoSuggest results popup display.
         * The value is initialized to false.
         */
        skuAutoSuggestHover: false,

        /**
         * This variable stores the old search term used in the auto suggest search box
         * The value is initialized to empty string.
         */
        skuAutoSuggestPreviousTerm: "",

        /**
         * This variable stores the index of the selected auto suggestion item when using up/down arrow keys.
         * The value is initialized to -1.
         */
        autoSelectOption: -1,

        /**
         * This variable stores the index offset of the first previous history term
         * The value is initialized to -1.
         */
        historyIndex: -1,

        /**
         * This variable controls when to trigger the auto suggest box.  The number of characters greater than this threshold will trigger the auto suggest functionality.
         * The static/cached auto suggest will be performed if this threshold is exceeded.
         * The value is initialized to 0.
         */
        AUTOSUGGEST_THRESHOLD: 0,

        /**
         * This variable controls when to trigger the dynamic auto suggest.  The number of characters greater than this threshold will trigger the request for keyword search.
         * The static/cached auto suggest will be be displayed if the characters exceed the above config parameter, but exceeding this threshold will additionally perform the dynamic search to add to the results in the static/cached results.
         * This value should be greater or equal than the AUTOSUGGEST_THRESHOLD, as the dynamic autosuggest is secondary to the static/cached auto suggest.
         * The value is initialized to 0.
         */
        DYNAMIC_AUTOSUGGEST_THRESHOLD: 0,

        /**
         * URL to retrieve auto suggest keywords
         */
        SearchAutoSuggestServletURL: "",

        /**
         * Timeout variable for suggestions dropdown list
         */
        searchSuggestionHoverTimeout: "",

        /**
         * Suffix for the SKU type ahead id
         */
        suffix: "",

        /**
         * SKU type ahead input field id
         */
        inputField: "",

        /**
         * SKU type ahead add button
         */
        addButton: "",

        /**
         * SKU type ahead add button text
         */
        addButtonText: "",

        /**
         * SKU type ahead add button CSS
         */
        addButtonDisableCss: "",

        /**
         * SKU type ahead add button text CSS
         */
        addButtonTextDisableCss: "",

        init: function (inputField) {
        	if(inputField != "" && $("#" + inputField).length) {
        		$("#" + inputField).on("focus", $.proxy(AutoSKUSuggestJS._onFocus, AutoSKUSuggestJS));
        		$("#" + inputField).on("blur", $.proxy(AutoSKUSuggestJS._onBlur, AutoSKUSuggestJS));
        		$("#" + inputField).on("keyup", $.proxy(AutoSKUSuggestJS._onKeyUp, AutoSKUSuggestJS));
        	}
        },

        setAddButton: function (addButton, addButtonText, addButtonDisableCss, addButtonTextDisableCss) {
            this.addButton = addButton;
            this.addButtonText = addButtonText;
            this.addButtonDisableCss = addButtonDisableCss;
            this.addButtonTextDisableCss = addButtonTextDisableCss;
        },

        showSKUSearchComponent: function () {
            var srcElement = document.getElementById("autoSuggestBySKU_Result_div" + this.suffix);
            if (srcElement != null) {
                srcElement.style.display = 'block';
            }
        },

        setAutoSuggestURL: function (url) {
            this.SearchAutoSuggestServletURL = getAbsoluteURL() + url;
        },

        _onFocus: function (evt) {
            var target = evt.target || evt.srcElement;
            this.inputField = target.id;
            this.suffix = "_" + target.id;
            var inputFieldElement = document.getElementById(this.inputField);
            if (inputFieldElement != null && !this.isEmpty(inputFieldElement.value)) {
                this.showSKUSearchComponent();
            }
        },

        _onBlur: function (evt) {
            var target = evt.target || evt.srcElement;
            this.inputField = target.id;
            this.suffix = "_" + target.id;
            clearTimeout(this.searchSuggestionHoverTimeout);
            this.searchSuggestionHoverTimeout = setTimeout("AutoSKUSuggestJS.showSKUAutoSuggest(false)", 200);
        },

        _onKeyUp: function (evt) {
            var target = evt.target || evt.srcElement;
            this.inputField = target.id;
            this.suffix = "_" + target.id;
            var srcElement = document.getElementById("autoSuggestBySKU_Result_div" + this.suffix);
            srcElement.style.display = 'block';
            this.doSKUAutoSuggest(evt, this.SearchAutoSuggestServletURL, document.getElementById(this.inputField).value);
        },

        doDynamicSKUAutoSuggest: function (url, searchTerm) {
            // if pending autosuggest triggered, cancel it.
            if (this.skuAutoSuggestSKUTimer != -1) {
                clearTimeout(this.skuAutoSuggestSKUTimer);
                this.skuAutoSuggestSKUTimer = -1;
            };

            // call the auto suggest
            this.skuAutoSuggestSKUTimer = setTimeout(function () {
                $("#autoSuggestBySKU_Result_div" + AutoSKUSuggestJS.suffix).refreshWidget("updateUrl", url + "&term=" + encodeURIComponent(searchTerm) + "&suffix=" + encodeURIComponent(AutoSKUSuggestJS.suffix));
                console.debug("update autosuggest " + url);
                wcRenderContext.updateRenderContext("AutoSuggestSKU_Context", {});
                this.skuAutoSuggestSKUTimer = -1;
            }, this.skuAutoSuggestSKUKeystrokeDelay);
        },

        showSKUAutoSuggest: function (display) {
            var autoSuggest_Result_div = document.getElementById("autoSuggestBySKU_Result_div" + this.suffix);
            if (autoSuggest_Result_div != null && autoSuggest_Result_div != 'undefined') {
                if (display) {
                    autoSuggest_Result_div.style.display = "block";
                } else {
                    autoSuggest_Result_div.style.display = "none";
                }
            }
        },

        showSKUAutoSuggestIfResults: function () {
            // if no results, hide the autosuggest box
            var scrElement = document.getElementById("skuAddSearch" + this.suffix);
            if (scrElement == null) {
                if (document.getElementById(this.addButton) != null && document.getElementById(this.addButtonText) != null && !$("#" + this.addButton).hasClass("formButtonDisabled") && !$("#" + this.addButtonText).hasClass("formButtonGreyOut")) {
                    $("#" + this.addButton).addClass("formButtonDisabled");
                    $("#" + this.addButtonText).addClass("formButtonGreyOut");
                }
            } else {
                if (document.getElementById("enableAddButton" + this.suffix) != null && document.getElementById("enableAddButton" + this.suffix).value == "false") {
                    if (document.getElementById(this.addButton) != null && document.getElementById(this.addButtonText) != null && !$("#" + this.addButton).hasClass("formButtonDisabled") && !$("#" + this.addButtonText).hasClass("formButtonGreyOut")) {
                        $("#" + this.addButton).addClass("formButtonDisabled");
                        $("#" + this.addButtonText).addClass("formButtonGreyOut");
                    }
                } else if (document.getElementById(this.addButton) != null && document.getElementById(this.addButtonText) != null && $("#" + this.addButton).hasClass("formButtonDisabled") && $("#" + this.addButtonText).hasClass("formButtonGreyOut")) {
                    $("#" + this.addButton).removeClass("formButtonDisabled");
                    $("#" + this.addButtonText).removeClass("formButtonGreyOut");
                }
            }
            if (scrElement != null && scrElement.style.display == 'block') {
                if (document.getElementById(this.inputField).value.length <= this.AUTOSUGGEST_THRESHOLD) {
                    this.showSKUAutoSuggest(false);
                } else {
                    this.showSKUAutoSuggest(true);
                }
            }
        },

        selectAutoSuggest: function (term) {
            var scrElement = document.getElementById("skuAddSearch" + this.suffix);
            if (scrElement != null && scrElement.style.display == 'block') {
                var searchBox = document.getElementById(this.inputField);
            }
            searchBox.value = term;
            searchBox.focus();
            this.skuAutoSuggestPreviousTerm = term;
            if (document.getElementById(this.addButton) != null && document.getElementById(this.addButtonText) != null && $("#" + this.addButton).hasClass("formButtonDisabled") && $("#" + this.addButtonText).hasClass("formButtonGreyOut")) {
                $("#" + this.addButton).removeClass("formButtonDisabled");
                $("#" + this.addButtonText).removeClass("formButtonGreyOut");
            }
            this.showSKUAutoSuggest(false);
        },

        highLightSelection: function (state, index) {
            var selection = document.getElementById("skuAutoSelectOption_" + index + this.suffix);
            if (selection != null && selection != 'undefined') {
                if (state) {
                    selection.className = "autoSuggestSelected";
                    var scrElement = document.getElementById("skuAddSearch" + this.suffix);
                    if (scrElement != null && scrElement.style.display == 'block') {
                        var searchBox = document.getElementById(this.inputField);
                    }
                    searchBox.setAttribute("aria-activedescendant", "suggestionSKU_" + index);
                    var totalDynamicResults = document.getElementById("dynamicAutoSuggestSKUTotalResults" + this.suffix);
                    if ((totalDynamicResults != null && totalDynamicResults != 'undefined' && index < totalDynamicResults.value) || (index >= this.historyIndex)) {
                        searchBox.value = selection.title;
                        this.skuAutoSuggestPreviousTerm = selection.title;
                    }
                } else {
                    selection.className = "skuSearchItem";
                }
                return true;
            } else {
                return false;
            }
        },

        resetSKUAutoSuggestKeyword: function () {
            var originalKeyedSearchTerm = document.getElementById("autoSuggestSKUOriginalTerm" + this.suffix);
            if (originalKeyedSearchTerm != null && originalKeyedSearchTerm != 'undefined') {
                var scrElement = document.getElementById("skuAddSearch" + this.suffix);
                if (scrElement != null && scrElement.style.display == 'block') {
                    var searchBox = document.getElementById(this.inputField);
                }
                searchBox.value = originalKeyedSearchTerm.value;
                this.skuAutoSuggestPreviousTerm = originalKeyedSearchTerm.value;
            }
        },


        clearSKUAutoSuggestResults: function () {
            this.showSKUAutoSuggest(false);
        },

        doSKUAutoSuggest: function (event, url, searchTerm) {
            if (searchTerm.length <= this.AUTOSUGGEST_THRESHOLD) {
                this.showSKUAutoSuggest(false);
            }

            if (event.keyCode === KeyCodes.TAB) {
                this.showSKUAutoSuggest(false);
                return;
            }

            if (event.keyCode === KeyCodes.ESCAPE) {
                this.showSKUAutoSuggest(false);
                return;
            }

            if (event.keyCode === KeyCodes.RETURN) {
                var searchBox = document.getElementById(this.inputField);
                if (searchBox != null) {
                    AutoSKUSuggestJS.selectAutoSuggest(searchBox.value);
                }
                return;
            }

            if (event.keyCode === KeyCodes.UP_ARROW) {
                if (this.highLightSelection(true, this.autoSelectOption - 1)) {
                    this.highLightSelection(false, this.autoSelectOption);
                    if (this.autoSelectOption == this.historyIndex) {
                        this.resetSKUAutoSuggestKeyword();
                    }
                    this.autoSelectOption--;
                }
                return;
            }

            if (event.keyCode === KeyCodes.DOWN_ARROW) {
                if (this.highLightSelection(true, this.autoSelectOption + 1)) {
                    this.highLightSelection(false, this.autoSelectOption);
                    this.autoSelectOption++;
                }
                return;
            }

            if (searchTerm.length > this.AUTOSUGGEST_THRESHOLD && searchTerm == this.skuAutoSuggestPreviousTerm) {
                return;
            } else {
                this.skuAutoSuggestPreviousTerm = searchTerm;
            }

            if (searchTerm.length <= this.AUTOSUGGEST_THRESHOLD) {
                return;
            };

            // cancel the dynamic search if one is pending
            if (this.skuAutoSuggestSKUTimer != -1) {
                clearTimeout(this.skuAutoSuggestSKUTimer);
                this.skuAutoSuggestSKUTimer = -1;
            }

            if (searchTerm != "") {
                this.autoSelectOption = -1;
                if (searchTerm.length > this.DYNAMIC_AUTOSUGGEST_THRESHOLD) {
                    this.doDynamicSKUAutoSuggest(url, searchTerm);
                } else {
                    // clear the dynamic results
                    document.getElementById("autoSuggestBySKU_Result_div" + this.suffix).innerHTML = "";
                }
            } else {
                this.clearSKUAutoSuggestResults();
            }
        },

        /**
         * Checks if a string is null or empty.
         * @param (string) str The string to check.
         * @return (boolean) Indicates whether the string is empty.
         */
        isEmpty: function (str) {
            var reWhiteSpace = new RegExp(/^\s+$/);
            if (str == null || str == '' || reWhiteSpace.test(str)) {
                return true;
            }
            return false;
        },


        /**
         * Declares a new render context for the AutoSuggest display.
         */


        autoSKUSuggest_controller_initProperties: function (suffix) {
            if (!wcRenderContext.checkIdDefined("AutoSuggestSKU_Context")) {
                wcRenderContext.declare("AutoSuggestSKU_Context", [], "");
            }
            var myWidgetObj = $("#autoSuggestBySKU_Result_div" + suffix);
            wcRenderContext.addRefreshAreaId("AutoSuggestSKU_Context", "autoSuggestBySKU_Result_div" + suffix);
            var myRCProperties = wcRenderContext.getRenderContextProperties("AutoSuggestSKU_Context");
            
            /**
             * Displays the keyword suggestions from the search index
             * This function is called when a render context changed event is detected.
             */
            var renderContextChangedHandler = function () {
                if (myWidgetObj.attr('id') == "autoSuggestBySKU_Result_div" + AutoSKUSuggestJS.suffix) {
                    myWidgetObj.refreshWidget("refresh", myRCProperties);
                }
            },

            /**
             * Display the results.
             */
            postRefreshHandler = function () {
                AutoSKUSuggestJS.showSKUAutoSuggestIfResults();
            }
            
            myWidgetObj.refreshWidget({
                renderContextChangedHandler: renderContextChangedHandler,
                postRefreshHandler: postRefreshHandler
            });
        }
    }
};
//-----------------------------------------------------------------
// Licensed Materials - Property of IBM
//
// WebSphere Commerce
//
// (C) Copyright IBM Corp. 2014, 2016 All Rights Reserved.
//
// US Government Users Restricted Rights - Use, duplication or
// disclosure restricted by GSA ADP Schedule Contract with
// IBM Corp.
//-----------------------------------------------------------------
/* global document, window, jQuery, KeyCodes, Utils, handleMouseDown, showMenu, hideMenu, 
toggleMenu, toggleExpand, eventActionsInitialization, toggleExpandedContent, toggleMobileView */

(function ($) {
    var activeMenuNode = null;
    var toggleControlNode = null;
    var NAMESPACE = "MyAccountList"; // Namespace to use for all event handlers in this file

    var registerMouseDown = function () {
        Utils.onOnce($(document.documentElement), "mousedown", NAMESPACE, handleMouseDown);
    };

    var unregisterMouseDown = function () {
        $(document.documentElement).off("mousedown." + NAMESPACE);
    };

    showMenu = function (target) {

        //Ensure All menus are closed on list table
        $("div.listTable a[table-parent='listTable']").each(function (i, node) {
            hideMenu(node);
        });

        $("div.listTable div[table-parent='listTable']").each(function (i, node) {
            hideMenu(node);
        });

        $("div.listTable form[table-parent='listTable']").each(function (i, node) {
            hideMenu(node);
        });

        $(target).addClass("active");
	activeMenuNode = target;
        var toggleControl = $("div.listTable a[table-toggle='" + target.id + "']");
        toggleControl.addClass("clicked");
        toggleControlNode = toggleControl[0];
        registerMouseDown();
    };

    hideMenu = function (target) {
        $(target).removeClass("active");
        $("div.listTable a[table-toggle='" + target.id + "']").removeClass("clicked");
        unregisterMouseDown();
        activeMenuNode = null;
        toggleControlNode = null;
    };

    handleMouseDown = function (evt) {
        if (activeMenuNode !== null) {
            var node = evt.target;
            if (node != document.documentElement) {
                var close = true;
                while (node && node != document.documentElement) {
                    if (node == activeMenuNode || node == toggleControlNode || $(node).hasClass("dijitPopup")) {
                        close = false;
                        break;
                    }
                    node = node.parentNode;
                }
                if (node === null) {
                    $("div", activeMenuNode).each(function (i, child) {
                        var position = Utils.position(child);
						if (evt.clientX >= position.left && evt.clientX < position.left + position.width() &&
							evt.clientY >= position.top && evt.clientY < position.top + position.height()) {
                            close = false;
                            return false; // breaks
                        }
                    });
                }
                if (close) {
                    hideMenu(activeMenuNode);
                }
            }
        }
    };

    toggleMenu = function (target) {
        if ($(target).hasClass("active")) {
            hideMenu(target);
        } else {
            showMenu(target);
        }
    };

    toggleExpand = function (target) {
        $("div.listTable div[row-expand]").each(function (i, node) {
            var resetNodeId = $(node).attr("row-expand");
            var resetNodeElement = document.getElementById(resetNodeId);
            if (resetNodeElement != target) {
                Utils.replaceAttr($(resetNodeElement), "src", function (oldSrc) {
                    return oldSrc.replace("sort_arrow_DN.png", "sort_arrow_OFF.png")
                        .replace("sort_arrow_UP.png", "sort_arrow_OFF.png");
                });
                $(resetNodeElement).removeClass("active");
            }
        });
        var $target = $(target);
        if ($target.hasClass("active")) {
            $target.removeClass("active");
            Utils.replaceAttr($target, "src", function (oldSrc) {
                return oldSrc.replace("sort_arrow_OFF.png", "sort_arrow_UP.png")
                    .replace("sort_arrow_DN.png", "sort_arrow_UP.png");
            });
        } else {
            $target.addClass("active");
            Utils.replaceAttr($target, "src", function (oldSrc) {
                return oldSrc.replace("sort_arrow_OFF.png", "sort_arrow_DN.png")
                    .replace("sort_arrow_UP.png", "sort_arrow_DN.png");
            });
        }
    };

    eventActionsInitialization = function () {
        Utils.onOnce($(document), "click", NAMESPACE, "div.listTable div[row-expand]", function (e) {
            var target = $(this).attr("row-expand");
            toggleExpand(document.getElementById(target));
            Utils.stopEvent(e);
        });

        Utils.onOnce($(document), "click", NAMESPACE, "div.listTable a[table-toggle]", function (e) {
            var target = $(this).attr("table-toggle");
            toggleMenu(document.getElementById(target));
            Utils.stopEvent(e);
        });

        Utils.onOnce($(document), "keydown", NAMESPACE, "div.listTable a[table-toggle]", function (e) {
            if (e.keyCode === KeyCodes.TAB || (e.keyCode === KeyCodes.TAB && e.shiftKey)) {
                var target = $(this).attr("table-toggle");
                if (target !== "newListDropdown" && target !== 'uploadListDropdown') {
                    hideMenu(document.getElementById(target));
                }
            } else if (e.keyCode === KeyCodes.RETURN) {
                var target = $(this).attr("table-toggle");
                toggleMenu(document.getElementById(target));
                Utils.stopEvent(e);
            } else if (e.keyCode === KeyCodes.DOWN_ARROW) {
                var target = $(this).attr("table-toggle");
                toggleMenu(document.getElementById(target));
                var targetElem = document.getElementById(target);
                var targetMenuItem = $('[role*="menuitem"]', targetElem)[0];
                if (targetMenuItem !== null) {
                    targetMenuItem.focus();
                }
                Utils.stopEvent(e);
            }
        });
    };

    /**
     * Toggle mobile view or full view depending on size of the table's container (if < 600, show mobile)
     **/
    toggleMobileView = function () {
        var containerWidth;
        $(".listTable").each(function (i, table) {
            if($(table).parent().parent().width() > 0) {
                containerWidth = $(table).parent().parent().width();
            }
        });
        
        if (containerWidth < 600) {
            $(".fullView").css("display", "none");
            $(".listTableMobile").css("display", "block");
        } else {
            $(".fullView").each(function (i, node) {
                var $node = $(node);
                if (!$node.hasClass("nodisplay")) {
                    $node.css("display", "block");
                }
            });

            $(".listTableMobile").css("display", "none");
        }
    };

    /**
     * Toggle expanded content to show or hide (e.g. when button is clicked)
     * @param widgetName the name of the widget
     * @param row The row on which the expanded content is contained
     **/
    toggleExpandedContent = function (widgetName, row) {
        $('#WC_' + widgetName + '_Mobile_ExpandedContent_' + row).toggleClass('nodisplay');
        $('#WC_' + widgetName + '_Mobile_TableContent_ExpandButton_' + row).toggleClass('nodisplay');
        $('#WC_' + widgetName + '_Mobile_TableContent_CollapseButton_' + row).toggleClass('nodisplay');
    };

    eventActionsInitialization();

    window.setTimeout(function () {

        // the code is shared by ItemTable_UI.jspf, the query for cancel button and newListButton
        // could be empty, use forEach to handle this case.
        $("#newListButton").each(function (i, newListButton) {
            $(newListButton).on("keydown", function (e) {
                if (e.keyCode === KeyCodes.RETURN) {
                    var target = $(this).attr("table-toggle");
                    toggleMenu(document.getElementById(target));
                    var targetElem = document.getElementById(target);
                    $('[class*="input_field"]', targetElem).first().focus();
                    Utils.stopEvent(e);
                }
            });
        });

        $("form.toolbarDropdown > .createTableList > .button_secondary").each(function (i, cancelButton) {
            $(cancelButton).on("keydown", function (e) {
                if (e.keyCode === KeyCodes.TAB || (e.keyCode === KeyCodes.TAB && e.shiftKey)) {
                    var targetId = $(this).attr("id");
                    var newTargetId = targetId.replace("_NewListForm_Cancel", "_NewListForm_Name");
                    $("#" + newTargetId).focus();
                    Utils.stopEvent(e);
                } else if (e.keyCode === KeyCodes.RETURN) {
                    var target = $(this).attr("table-toggle");
                    hideMenu(document.getElementById(target));
                    $("#newListButton").focus();
                    Utils.stopEvent(e);
                }
            });
        });

        $(".actionDropdown").each(function (i, actionMenu) {
            var actionMenuItems = $('[role*="menuitem"]', actionMenu);
            actionMenuItems.each(function (j, actionMenuItem) {
                $(actionMenuItem).on("keydown", function (e) {
                    if (e.keyCode === KeyCodes.TAB) {
                        hideMenu(document.getElementById(actionMenu.getAttribute("id")));
                    } else if (e.keyCode === KeyCodes.UP_ARROW) {
                        actionMenuItems[j === 0 ? actionMenuItems.length - 1 : j - 1].focus();
                        Utils.stopEvent(e);
                    } else if (e.keyCode === KeyCodes.DOWN_ARROW) {
                        actionMenuItems[(j + 1) % actionMenuItems.length].focus();
                        Utils.stopEvent(e);
                    }
                });
            });
        });
    }, 100);
})(jQuery);
//-----------------------------------------------------------------
// Licensed Materials - Property of IBM
//
// WebSphere Commerce
//
// (C) Copyright IBM Corp. 2007, 2013 All Rights Reserved.
//
// US Government Users Restricted Rights - Use, duplication or
// disclosure restricted by GSA ADP Schedule Contract with
// IBM Corp.
//-----------------------------------------------------------------

/**
 *@fileOverview This javascript file defines all the javascript functions used by OrderDetail_ItemTable widget
 */

	OrderDetailJS = {
			
		/** 
		 * This variable stores the ID of the language that the store currently uses. Its default value is set to -1, which corresponds to United States English.
		 * @private
		 */
		langId: "-1",
		
		/** 
		 * This variable stores the ID of the current store. Its default value is empty.
		 * @private
		 */
		storeId: "",
		
		/** 
		 * This variable stores the ID of the catalog. Its default value is empty.
		 * @private
		 */
		catalogId: "",
		
		/**
		* indicates whether the OrderDetail_ItemTable widget is not loaded, expanded or collapsed
		* possible values: "notLoaded", "expanded" or "collapsed"
		*/
		itemTableShown: "notLoaded",

		/**
		 * Sets the common parameters for the current page. 
		 * For example, the language ID, store ID, and catalog ID.
		 *
		 * @param {Integer} langId The ID of the language that the store currently uses.
		 * @param {Integer} storeId The ID of the current store.
		 * @param {Integer} catalogId The ID of the catalog.
		 * @param {Integer} orderId The ID of the order.
		 */
		setCommonParameters: function(langId,storeId,catalogId){
			this.langId = langId;
			this.storeId = storeId;
			this.catalogId = catalogId;
		},
	
		/**
		* By default the order item detail table isn't shown. This function will refresh the area so the table will
		* show.
		*/
		expandCollapseArea:function(){
			if (this.itemTableShown == "notLoaded") {
				/*For Handling multiple clicks. */
				if(!submitRequest()){
					return;
				}	
				cursor_wait();
				wcRenderContext.updateRenderContext('OrderDetailItemTable_Context', {"beginIndex": 0});
				this.itemTableShown = "expanded";
			} else if (this.itemTableShown == "expanded") {
				$("#orderSummaryContainer_plusImage").css("display", "inline");
				$("#orderSummaryContainer_plusImage_link").attr('tabindex', '0');

				$("#orderSummaryContainer_minusImage").css("display", "none");
				$("#orderSummaryContainer_minusImage_link").attr('tabindex', '-1');
				
				$("#OrderDetail_ItemTable_table").css("display", "none");
				this.itemTableShown = "collapsed";
			} else if (this.itemTableShown == "collapsed") {
				$("#orderSummaryContainer_plusImage").css("display", "none");
				$("#orderSummaryContainer_plusImage_link").attr('tabindex', '-1');
				
				$("#orderSummaryContainer_minusImage").css("display", "inline");
				$("#orderSummaryContainer_minusImage_link").attr('tabindex', '0');
				
				$("#OrderDetail_ItemTable_table").css("display", "block");
				this.itemTableShown = "expanded";
			}
		},
		
		/**
		* This function is called when user selects a different page from the current page
		* @param (Object) data The object that contains data used by pagination control 
		*/
		showResultsPage:function(data){
			var pageNumber = data['pageNumber'];
			var pageSize = data['pageSize'];
			pageNumber = parseInt(pageNumber);
			pageSize = parseInt(pageSize);

			setCurrentId(data["linkId"]);

			if(!submitRequest()){
				return;
			}

			var beginIndex = pageSize * ( pageNumber - 1 );
			cursor_wait();

			wcRenderContext.updateRenderContext('OrderDetailItemTable_Context', {"beginIndex": beginIndex});
			MessageHelper.hideAndClearMessage();
		},
	}//-----------------------------------------------------------------
// Licensed Materials - Property of IBM
//
// WebSphere Commerce
//
// (C) Copyright IBM Corp. 2014 All Rights Reserved.
//
// US Government Users Restricted Rights - Use, duplication or
// disclosure restricted by GSA ADP Schedule Contract with
// IBM Corp.
//-----------------------------------------------------------------

/** 
 * @fileOverview This javascript is used by the Approval List pages to control the refresh areas.
 * @version 1.2
 */

/**
 * Declares a new refresh controller for order approval.
 */
var declareOrderDetailItemTableController = function() {
    var myWidgetObj = $("#OrderDetailItemTable_Widget");
    
    /**
     * Declares a new render context for order approval list table
     */
    wcRenderContext.declare("OrderDetailItemTable_Context", ["OrderDetailItemTable_Widget"], {
        "beginIndex": "0"
    });
    
    myWidgetObj.refreshWidget({
        /** 
        * Displays the previous/next page of order items in order approval details page
        * This function is called when a render context changed event is detected. 
        * 
        * @param {string} message The render context changed event message
        * @param {object} widget The registered refresh area
        */
        renderContextChangedHandler: function () {
            myWidgetObj.refreshWidget("refresh", wcRenderContext.getRenderContextProperties("OrderDetailItemTable_Context"));
        },

        /** 
         * Clears the progress bar
         * 
         * @param {object} widget The registered refresh area
         */
        postRefreshHandler: function(widget) {
            cursor_clear();
            $("#orderSummaryContainer_minusImage_link").focus();
        }
    });
};//-----------------------------------------------------------------
// Licensed Materials - Property of IBM
//
// WebSphere Commerce
//
// (C) Copyright IBM Corp. 2014 All Rights Reserved.
//
// US Government Users Restricted Rights - Use, duplication or
// disclosure restricted by GSA ADP Schedule Contract with
// IBM Corp.
//-----------------------------------------------------------------

/** 
 * @fileOverview This javascript defines all the render contexts needed for the Requisition List pages.
 * @version 1.2
 */


/**
 * Declares a new render context for requisition list item table
 */
wcRenderContext.declare("RequisitionListItemTable_Context",["RequisitionListItemTable_Widget"],{"beginIndex":"0","requisitionListId":""},"");//-----------------------------------------------------------------
// Licensed Materials - Property of IBM
//
// WebSphere Commerce
//
// (C) Copyright IBM Corp. 2014 All Rights Reserved.
//
// US Government Users Restricted Rights - Use, duplication or
// disclosure restricted by GSA ADP Schedule Contract with
// IBM Corp.
//-----------------------------------------------------------------

/** 
 * @fileOverview This javascript is used by the Requisition List pages to control the refresh areas.
 * @version 1.2
 */

if (typeof (RequistionListControllerDeclarationJS) == "undefined" || RequistionListControllerDeclarationJS == null || !RequistionListControllerDeclarationJS) {

    RequistionListControllerDeclarationJS = {
        suffix: "",
        /**
         * Declares a new refresh controller for creating a new Requisition List.
         */
        declareRequisitionListItemTableRefreshArea: function () {
            var myWidgetObj = $("#RequisitionListItemTable_Widget"),


                myRCProperties = wcRenderContext.getRenderContextProperties("RequisitionListItemTable_Context");



            wcTopic.subscribe(["requisitionListAddItem", "requisitionListDeleteItem"], function (returnAction) {
                myRCProperties["requisitionListId"] = returnAction.data.requisitionListId[0];
                myWidgetObj.refreshWidget("refresh", myRCProperties);
            });


            var renderContextChangedHandler = function () {
                myWidgetObj.refreshWidget("refresh", myRCProperties);
            };

            /** 
             * Clears the progress bar
             * 
             * @param {object} widget The registered refresh area
             */
            var postRefreshHandler = function () {
                cursor_clear();
                //After adding/deleting/updating an item
                AutoSKUSuggestJS.autoSKUSuggest_controller_initProperties(RequistionListControllerDeclarationJS.suffix);
            };
            // initialize widget
            myWidgetObj.refreshWidget({
                renderContextChangedHandler: renderContextChangedHandler,
                postRefreshHandler: postRefreshHandler
            });
        }
    }
};
//-----------------------------------------------------------------
// Licensed Materials - Property of IBM
//
// WebSphere Commerce
//
// (C) Copyright IBM Corp. 2014 All Rights Reserved.
//
// US Government Users Restricted Rights - Use, duplication or
// disclosure restricted by GSA ADP Schedule Contract with
// IBM Corp.
//-----------------------------------------------------------------

/** 
 * @fileOverview This javascript is used by the Requisition List pages to handle the services for 
 * adding/removing/updating items from a requisition list.
 * @version 1.10
 */


/**
 * This service allows customer to update an existing requisition list
 * @constructor
 */
wcService.declare({
	id:"requisitionListUpdate",
	actionId:"requisitionListUpdate",
	url:"AjaxRESTRequisitionListUpdate",
	formId:""

	 /**
     * Hides all the messages and the progress bar.
     * @param (object) serviceResponse The service response object, which is the
     * JSON object returned by the service invocation.
     */
	,successHandler: function(serviceResponse) {
		MessageHelper.hideAndClearMessage();
		requestSubmitted = false;
		document.location.href="RequisitionListDetailView?storeId="+serviceResponse.storeId+"&langId="+serviceResponse.langId+"&catalogId="+serviceResponse.catalogId+"&requisitionListId="+serviceResponse.requisitionListId+"&createdBy="+serviceResponse.createdBy;				
	}
	
	/**
     * display an error message.
     * @param (object) serviceResponse The service response object, which is the
     * JSON object returned by the service invocation.
     */
	,failureHandler: function(serviceResponse) {

		if (serviceResponse.errorMessage) {
			MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
		} 
		else {
			 if (serviceResponse.errorMessageKey) {
				MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
			 }
		}
		cursor_clear();
	}	
}),

/**
 * This service allows customer to create add/update an item to an existing requisition list
 * @constructor
 */
wcService.declare({
	id:"requisitionListAddItem",
	actionId:"requisitionListAddItem",
	url:"AjaxRESTRequisitionListItemUpdate",
	formId:""

	 /**
     * Hides all the messages and the progress bar.
     * @param (object) serviceResponse The service response object, which is the
     * JSON object returned by the service invocation.
     */
	,successHandler: function(serviceResponse) {
		MessageHelper.hideAndClearMessage();
		cursor_clear();
		
		if(serviceResponse.operation == "addItem"){
			MessageHelper.displayStatusMessage(MessageHelper.messages["REQUISITIONLIST_ADD_SUCCESS"]);
		} else if (serviceResponse.operation == "deleteItem"){
			MessageHelper.displayStatusMessage(MessageHelper.messages["REQUISITIONLIST_ITEM_DELETE_SUCCESS"]);
		} else if (serviceResponse.operation == "updateQty") {
			ReqListItemsJS.showUpdatedMessage(serviceResponse.row);
		}
	}
		
	/**
     * display an error message.
     * @param (object) serviceResponse The service response object, which is the
     * JSON object returned by the service invocation.
     */
	,failureHandler: function(serviceResponse) {

		if (serviceResponse.errorMessage) {
			var errorMsg = serviceResponse.errorMessage;
			//If the errorMessage param is the generic error message
			//Display the systemMessage instead
			if (errorMsg.search("CMN1009E") !=-1 ) {
				MessageHelper.displayErrorMessage(MessageHelper.messages["ERROR_REQUISITION_LIST_INVALID_SKU"]);
			}else if(errorMsg.search("CMN3101E") != -1){
				//If systemMessage is not empty, display systemMessage
				if(serviceResponse.systemMessage){
					if (serviceResponse.errorMessageKey!=null) {
						var msgKey = serviceResponse.errorMessageKey;
						if (msgKey == '_ERR_GETTING_SKU' || msgKey =='_ERR_PROD_NOT_EXISTING') {
							MessageHelper.displayErrorMessage(MessageHelper.messages["ERROR_REQUISITION_LIST_INVALID_SKU"]);
						}else {
							MessageHelper.displayErrorMessage(serviceResponse.systemMessage);
						}
					}else{					
						MessageHelper.displayErrorMessage(serviceResponse.systemMessage);
					}
				} else {
					//If systemMessage is empty, then just display the generic error message
					MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
				}
			} else {
				//If errorMessage is not generic, display errorMessage
				MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
			}
		} 
		else {
			 if (serviceResponse.errorMessageKey) {
				MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
			 }
		}
		cursor_clear();
	}			
}),

/**
 * This service allows customer to create update an item in an existing requisition list
 * @constructor
 */
wcService.declare({
	id:"requisitionListUpdateItem",
	actionId:"requisitionListUpdateItem",
	url:"AjaxRESTRequisitionListUpdateItem",
	formId:""

	 /**
     * Hides all the messages and the progress bar.
     * @param (object) serviceResponse The service response object, which is the
     * JSON object returned by the service invocation.
     */
	,successHandler: function(serviceResponse) {
		MessageHelper.hideAndClearMessage();
		cursor_clear();
		if(serviceResponse.operation == "addItem"){
			MessageHelper.displayStatusMessage(MessageHelper.messages["REQUISITIONLIST_ADD_SUCCESS"]);
		} else if (serviceResponse.operation == "deleteItem"){
			MessageHelper.displayStatusMessage(MessageHelper.messages["REQUISITIONLIST_ITEM_DELETE_SUCCESS"]);
		} else if (serviceResponse.operation == "updateQty") {
			ReqListItemsJS.showUpdatedMessage(serviceResponse.row);
		}
	}
	
	/**
     * display an error message.
     * @param (object) serviceResponse The service response object, which is the
     * JSON object returned by the service invocation.
     */
	,failureHandler: function(serviceResponse) {
		if (serviceResponse.errorMessage) {
			var errorMsg = serviceResponse.errorMessage;
			//If the errorMessage param is the generic error message
			//Display the systemMessage instead
			if (errorMsg.search("CMN1009E") !=-1 ) {
				MessageHelper.displayErrorMessage(MessageHelper.messages["ERROR_REQUISITION_LIST_INVALID_SKU"]);
			}else if(errorMsg.search("CMN3101E") != -1){
				//If systemMessage is not empty, display systemMessage
				if(serviceResponse.systemMessage){
					if (serviceResponse.errorMessageKey!=null) {
						var msgKey = serviceResponse.errorMessageKey;
						if (msgKey == '_ERR_GETTING_SKU' || msgKey =='_ERR_PROD_NOT_EXISTING') {
							MessageHelper.displayErrorMessage(MessageHelper.messages["ERROR_REQUISITION_LIST_INVALID_SKU"]);
						}else {
							MessageHelper.displayErrorMessage(serviceResponse.systemMessage);
						}
					}else{					
						MessageHelper.displayErrorMessage(serviceResponse.systemMessage);
					}
				} else {
					//If systemMessage is empty, then just display the generic error message
					MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
				}
			} else {
				//If errorMessage is not generic, display errorMessage
				MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
			}
		} 
		else {
			 if (serviceResponse.errorMessageKey) {
				MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
			 }
		}
		cursor_clear();
	},			
}),

/**
 * This service allows customer to delete an item to an existing requisition list
 * @constructor
 */
wcService.declare({
	id:"requisitionListDeleteItem",
	actionId:"requisitionListDeleteItem",
	url:"AjaxRESTRequisitionListItemDelete",
	formId:""

	 /**
     * Hides all the messages and the progress bar.
     * @param (object) serviceResponse The service response object, which is the
     * JSON object returned by the service invocation.
     */
	,successHandler: function(serviceResponse) {
		MessageHelper.hideAndClearMessage();
		cursor_clear();
		if (serviceResponse.operation == "deleteItem"){
			MessageHelper.displayStatusMessage(MessageHelper.messages["REQUISITIONLIST_ITEM_DELETE_SUCCESS"]);
		}
	}
		
	/**
     * display an error message.
     * @param (object) serviceResponse The service response object, which is the
     * JSON object returned by the service invocation.
     */
	,failureHandler: function(serviceResponse) {

		if (serviceResponse.errorMessage) {
			var errorMsg = serviceResponse.errorMessage;
			//If the errorMessage param is the generic error message
			//Display the systemMessage instead
			if (errorMsg.search("CMN1009E") !=-1 ) {
				MessageHelper.displayErrorMessage(MessageHelper.messages["ERROR_REQUISITION_LIST_INVALID_SKU"]);
			}else if(errorMsg.search("CMN3101E") != -1){
				//If systemMessage is not empty, display systemMessage
				if(serviceResponse.systemMessage){
					if (serviceResponse.errorMessageKey!=null) {
						var msgKey = serviceResponse.errorMessageKey;
						if (msgKey == '_ERR_GETTING_SKU' || msgKey =='_ERR_PROD_NOT_EXISTING') {
							MessageHelper.displayErrorMessage(MessageHelper.messages["ERROR_REQUISITION_LIST_INVALID_SKU"]);
						}else {
							MessageHelper.displayErrorMessage(serviceResponse.systemMessage);
						}
					}else{					
						MessageHelper.displayErrorMessage(serviceResponse.systemMessage);
					}
				} else {
					//If systemMessage is empty, then just display the generic error message
					MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
				}
			} else {
				//If errorMessage is not generic, display errorMessage
				MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
			}
		} 
		else {
			 if (serviceResponse.errorMessageKey) {
				MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
			 }
		}
		cursor_clear();
	}			
}),

/**
 * this services allows users to submit a requisition list for order processing.
 */
wcService.declare({
	id:"requisitionListAjaxPlaceOrder",
	actionId:"AjaxAddOrderItem",
	url:"AjaxRESTRequisitionListSubmit",
	formId:""

	 /**
    * Hides all the messages and the progress bar, and redirect to the shopping cart page 
    * @param (object) serviceResponse The service response object, which is the
    * JSON object returned by the service invocation.
    */
	,successHandler: function(serviceResponse) {
		MessageHelper.hideAndClearMessage();
		document.location.href="RESTOrderCalculate?calculationUsage=-1,-2,-3,-4,-5,-6,-7&updatePrices=1&doConfigurationValidation=Y&errorViewName=AjaxOrderItemDisplayView&orderId=.&langId="+serviceResponse.langId+"&storeId="+serviceResponse.storeId+"&catalogId="+serviceResponse.catalogId+"&URL=AjaxOrderItemDisplayView";
	}	
	/**
    * display an error message.
    * @param (object) serviceResponse The service response object, which is the
    * JSON object returned by the service invocation.
    */
	,failureHandler: function(serviceResponse) {
		 if (serviceResponse.errorMessage) {
		 	if(serviceResponse.errorMessageKey == "_ERR_NO_ELIGIBLE_TRADING"){
		 		MessageHelper.displayErrorMessage(MessageHelper.messages["ERROR_CONTRACT_EXPIRED_GOTO_ORDER"]);
		 	} else if (serviceResponse.errorMessageKey == "_ERR_RETRIEVE_PRICE") {
 					MessageHelper.displayErrorMessage(MessageHelper.messages["ERROR_RETRIEVE_PRICE"]);
			} else {
				MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
			}
		 } else {
			 if (serviceResponse.errorMessageKey) {
				MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
			 }
		}
		cursor_clear();
	}			
}), 

/**
* Add an item to a shopping cart in Ajax mode. A message is displayed after the service call.
* The URL "AjaxRESTOrderAddPreConfigurationToCart" is a superset of the URL
* "AjaxRESTOrderItemAdd", allowing dynamic kit partnumbers to be entered into the quick order form.
*/
wcService.declare({
		id: "ReqListAddOrderItem",
		actionId: "AddOrderItem",
		url: "AjaxRESTOrderAddPreConfigurationToCart",
		formId: ""
		
		/**
		* display a success message
		* @param (object) serviceResponse The service response object, which is the
		* JSON object returned by the service invocation
		*/
		,successHandler: function(serviceResponse) {
			MessageHelper.hideAndClearMessage();
			cursor_clear();
			// MessageHelper.displayStatusMessage(MessageHelper.messages["ADDED_TO_ORDER"]);
		}
		
		/**
		* display an error message
		* @param (object) serviceResponse The service response object, which is the
		* JSON object returned by the service invocation
		*/
		,failureHandler: function(serviceResponse) {

			if (serviceResponse.errorMessage) {
			 	if(serviceResponse.errorMessageKey == "_ERR_NO_ELIGIBLE_TRADING"){
			 		MessageHelper.displayErrorMessage(MessageHelper.messages["ERROR_CONTRACT_EXPIRED_GOTO_ORDER"]);
			 	} else if (serviceResponse.errorMessageKey == "_ERR_RETRIEVE_PRICE") {
 					MessageHelper.displayErrorMessage(MessageHelper.messages["ERROR_RETRIEVE_PRICE"]);
 				} else {
 					MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
 				}
			} 
			else {
				 if (serviceResponse.errorMessageKey) {
					MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
				 }
			}
			cursor_clear();
		}

	})//-----------------------------------------------------------------
// Licensed Materials - Property of IBM
//
// WebSphere Commerce
//
// (C) Copyright IBM Corp. 2014, 2016 All Rights Reserved.
//
// US Government Users Restricted Rights - Use, duplication or
// disclosure restricted by GSA ADP Schedule Contract with
// IBM Corp.
//-----------------------------------------------------------------


/** 
 * @fileOverview This javascript is used by the Saved Order pages to control the refresh areas.
 * @version 1.1
 */

/**
 * List of all the services that result in changes to a saved order
 * @static
 */
var savedorder_updated = [
    'AjaxSavedOrderDeleteItem',
    'savedOrderUpdateDescription',
    'AjaxSavedOrderUpdateItem',
    'AjaxAddOrderItem'
];

/**
 * Declares a new render context for saved order details page item table.
 */
wcRenderContext.declare("SavedOrderItemTable_Context", ["SavedOrderItemTable_Widget"], {
    "beginIndex": "0"
});

/**
 * Declares a new refresh controller for the Saved Order Items table display.
 */
var declareSavedOrderItemTableController = function() {
    var myWidgetObj = $("#SavedOrderItemTable_Widget");
    var myRCProperties = wcRenderContext.getRenderContextProperties("SavedOrderItemTable_Context");
    
    // model change
    wcTopic.subscribe(["AjaxSavedOrderDeleteItem", "AjaxSavedOrderUpdateItem", "AjaxAddOrderItem"], function(returnAction){
        myRCProperties["orderId"] = returnAction.data.orderId;
        myWidgetObj.refreshWidget("refresh", myRCProperties);
    });
    
    myWidgetObj.refreshWidget({
        renderContextChangedHandler: function() {
            myWidgetObj.refreshWidget("refresh", myRCProperties);
        },
        postRefreshHandler: function() {
            cursor_clear();
            if (Utils.existsAndNotEmpty(SavedOrderItemsJS.getCurrentRow())) {
                 SavedOrderItemsJS.showUpdatedMessage();
            }
            SavedOrderItemsJS.resetCurrentRow();
        }
    });
};

/**
 * Declares a new render context for saved order details page information area.
 */
wcRenderContext.declare("SavedOrderInfo_Context", ["SavedOrderInfo_Widget"], {});

/**
 * Declares a new refresh controller for the Saved Order Info display.
 */
var declareSavedOrderInfoController = function() {
    var widgetObj = $("#SavedOrderInfo_Widget");
    var myRCProperties = wcRenderContext.getRenderContextProperties("SavedOrderInfo_Context");
    
    /** 
     * Refreshes the saved order info display if name is updated
     * or an update/delete in the saved order items table occurs.
     * This function is called when a modelChanged event is detected. 
     */
    wcTopic.subscribe(savedorder_updated, function(returnAction) {
        // update actionId
        myRCProperties["orderId"] = returnAction.data.orderId;
        widgetObj.refreshWidget("refresh", myRCProperties);
    });
    
    widgetObj.refreshWidget({
        /** 
         * Refreshes the saved order info display if the name of the saved order is changed 
         * or an update/delete in the saved order items table occurs.
         * This function is called when a render context event is detected. 
         */
         renderContextChangedHandler: function () {
            widgetObj.refreshWidget("refresh", myRCProperties);
         },

        /** 
         * Clears the progress bar
         */
        postRefreshHandler: function() {
             cursor_clear();
        }
    });
};//-----------------------------------------------------------------
// Licensed Materials - Property of IBM
//
// WebSphere Commerce
//
// (C) Copyright IBM Corp. 2014 All Rights Reserved.
//
// US Government Users Restricted Rights - Use, duplication or
// disclosure restricted by GSA ADP Schedule Contract with
// IBM Corp.
//-----------------------------------------------------------------

/** 
 * @fileOverview This javascript is used by the Saved order details pages to handle the services for 
 * updating saved order info and adding/removing/updating items from a saved order.
 * @version 
 */

/**
 * This service allows customer to update an existing saved order info
 * @constructor
 */
wcService.declare({
	id:"savedOrderUpdateDescription",
	actionId:"savedOrderUpdateDescription",
	url: getAbsoluteURL() + "AjaxRESTOrderCopy",
	formId:""

	 /**
     * Hides all the messages and the progress bar.
     * @param (object) serviceResponse The service response object, which is the
     * JSON object returned by the service invocation.
     */
	,successHandler: function(serviceResponse) {
		MessageHelper.hideAndClearMessage();
		cursor_clear();
		MessageHelper.displayStatusMessage(MessageHelper.messages["SAVEDORDERINFO_UPDATE_SUCCESS"]);		
	}
	
	/**
     * display an error message.
     * @param (object) serviceResponse The service response object, which is the
     * JSON object returned by the service invocation.
     */
	,failureHandler: function(serviceResponse) {

		if (serviceResponse.errorMessage) {
			MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
		} 
		else {
			 if (serviceResponse.errorMessageKey) {
				MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
			 }
		}
		cursor_clear();
	}	
});


/**
 * This service removes an item from a saved order.
 * @constructor
 */
wcService.declare({
	id:"AjaxSavedOrderDeleteItem",
	actionId:"AjaxSavedOrderDeleteItem",
	url: getAbsoluteURL() + "AjaxRESTOrderItemDelete",
	formId:""

	 /**
     * Hides all the messages and the progress bar.
     * @param (object) serviceResponse The service response object, which is the
     * JSON object returned by the service invocation.
     */
	,successHandler: function(serviceResponse) {
		MessageHelper.hideAndClearMessage();
		cursor_clear();
		MessageHelper.displayStatusMessage(MessageHelper.messages["SAVEDORDERITEM_DELETE_SUCCESS"]);		
	}
	
	/**
     * display an error message.
     * @param (object) serviceResponse The service response object, which is the
     * JSON object returned by the service invocation.
     */
	,failureHandler: function(serviceResponse) {

		if (serviceResponse.errorMessage) {
			MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
		} 
		else {
			 if (serviceResponse.errorMessageKey) {
				MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
			 }
		}
		cursor_clear();
	}	
});

/**
 * Updates an order item in the saved order. 
 * A message is displayed after the service call.  
 * An error message will be displayed otherwise.
 * @constructor
*/
wcService.declare({
	id: "AjaxSavedOrderUpdateItem",
	actionId: "AjaxSavedOrderUpdateItem",
	url: getAbsoluteURL() + "AjaxRESTOrderItemUpdate",
	formId: ""
	
	/**
     * Hides all messages and the progress bar
     * @param (object) serviceResponse The service response object, which is the
     * JSON object returned by the service invocation
     */
	,successHandler: function(serviceResponse) {
		MessageHelper.hideAndClearMessage();
		cursor_clear();
	}

    /**
     * display an error message
     * @param (object) serviceResponse The service response object, which is the
     * JSON object returned by the service invocation
     */
	,failureHandler: function(serviceResponse) {

		if (serviceResponse.errorMessage) {
			if (serviceResponse.errorCode == "CMN1654E") {
				MessageHelper.displayErrorMessage(MessageHelper.messages["ERROR_SAVED_ORDER_QUANTITY_ONE_OR_MORE"]);
			} else {
				MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
			}
		} 
		else {
			 if (serviceResponse.errorMessageKey) {
				MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
			 }
		}
		cursor_clear();
	}
});

/**
* This service adds an item to a saved order. A message is displayed after the service call.
* The URL "AjaxRESTOrderAddPreConfigurationToCart" is a superset of the URL
* "AjaxRESTOrderItemAdd", allowing dynamic kit partnumbers to be added to the saved order.
* @constructor
*/
wcService.declare({
	id: "AjaxAddSavedOrderItem",
	actionId: "AjaxAddOrderItem",
	url: getAbsoluteURL() + "AjaxRESTOrderAddPreConfigurationToCart",
	formId: ""
	
	/**
     * Hides all messages and the progress bar
     * @param (object) serviceResponse The service response object, which is the
     * JSON object returned by the service invocation
     */
	,successHandler: function(serviceResponse) {
		MessageHelper.hideAndClearMessage();
		MessageHelper.displayStatusMessage(MessageHelper.messages["SAVEDORDERITEM_ADD_SUCCESS"]);
		cursor_clear();
	}

    /**
     * display an error message
     * @param (object) serviceResponse The service response object, which is the
     * JSON object returned by the service invocation
     */
	,failureHandler: function(serviceResponse) {

		if (serviceResponse.errorMessage) {
			if(serviceResponse.errorMessageKey == "_ERR_NO_ELIGIBLE_TRADING"){
				MessageHelper.displayErrorMessage(MessageHelper.messages["ERROR_SAVED_ORDER_CONTRACT_EXPIRED"]);
			} else if (serviceResponse.errorMessageKey == "_ERR_RETRIEVE_PRICE") {
				MessageHelper.displayErrorMessage(MessageHelper.messages["ERROR_SAVED_ORDER_RETRIEVE_PRICE"]);
			} else {
				MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
			}
		}  
		else {
			 if (serviceResponse.errorMessageKey) {
				MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
			 }
		}
		cursor_clear();
	}
});

/**
 * Set the current order to be that of a saved order.
 * Perform the service or command call.
 */
wcService.declare({
	id: "AjaxSetPendingOrder",
	actionId: "AjaxSetPendingOrder",
	url: "AjaxRESTSetPendingOrder",
	formId: ""

 /**
 * display a success message
 * @param (object) serviceResponse The service response object, which is the
 * JSON object returned by the service invocation
 */

	,successHandler: function(serviceResponse) {
		MessageHelper.hideAndClearMessage();
		cursor_clear();
		MessageHelper.displayStatusMessage(MessageHelper.messages["MYACCOUNT_SAVEDORDERLIST_SET_AS_CURRENT_SUCCESS"]);
	}
 /**
 * display an error message
 * @param (object) serviceResponse The service response object, which is the
 * JSON object returned by the service invocation
 */
	,failureHandler: function(serviceResponse) {
		if (serviceResponse.errorMessage) {
			 if (["CMN0409E", "CMN1024E"].indexOf(serviceResponse.errorCode) > -1)
			 {
				 MessageHelper.displayErrorMessage(MessageHelper.messages["MYACCOUNT_SAVEDORDERLIST_SET_AS_CURRENT_FAIL"]);
			 }
			 else
			 {
				 MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
			 }
		} 
		else {
			 if (serviceResponse.errorMessageKey) {
				MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
			 }
		}
		cursor_clear();
	}
});

/**
 * Updates the currently selected saved order setting it to the current shopping cart.
 * The main function of this service is to keep the cpendorder database table in line with the current shopping cart.
 * Perform the service or command call.
 * @constructor
 */
wcService.declare({
	id: "AjaxUpdatePendingOrder",
	actionId: "AjaxUpdatePendingOrder",
	url: getAbsoluteURL() + "AjaxRESTSetPendingOrder",
	formId: ""

 /**
 * There is nothing to do in the event of a success of this service since it is executed in the background.
 * @param (object) serviceResponse The service response object, which is the
 * JSON object returned by the service invocation
 */

	,successHandler: function(serviceResponse) {
		
		if (serviceResponse.nextAction != 'undefined' && serviceResponse.nextAction != null && serviceResponse.nextAction)
		{
			document.location.href = SavedOrderItemsJS.getCurrentShoppingCartURL();
		}
		
		cursor_clear();
	}
 /**
 * display an error message
 * @param (object) serviceResponse The service response object, which is the
 * JSON object returned by the service invocation
 */
	,failureHandler: function(serviceResponse) {
		
		if (serviceResponse.errorMessage) {
			if (serviceResponse.errorCode == "CMN0409E")
			 {
				 MessageHelper.displayErrorMessage(MessageHelper.messages["ERROR_SAVED_ORDER_NOT_SET_CURRENT"]);
			 }
			 else
			 {
				 MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
			 }
		} 
		else {
			 if (serviceResponse.errorMessageKey) {
				MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
			 }
		}
		cursor_clear();
	}

});
//-----------------------------------------------------------------
// Licensed Materials - Property of IBM
//
// WebSphere Commerce
//
// (C) Copyright IBM Corp. 2016 All Rights Reserved.
//
// US Government Users Restricted Rights - Use, duplication or
// disclosure restricted by GSA ADP Schedule Contract with
// IBM Corp.
//-----------------------------------------------------------------

////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Geolocation.js contains the JavaScript functions to call HTML5 Geolocation API
// to return the current device location coordinates
//
////////////////////////////////////////////////////////////////////////////////////////////////////////////

var GeolocationJS = {

    /**
     * Get the current coordinates
     * @param position      geolocation position returned by the device
     */
    showPosition: function(position) {
        if (position !== undefined && position != null) {
            storeLocatorJS.refreshResultsFromNearest(position.coords.latitude,position.coords.longitude);
        }
    },
    
    /**
     * Handle the error returned from geolocation call
     * @param error     the error returned by the device
     */
    locationError: function(error) {
        var errorMsgKey;
        switch (error.code) {
            case error.PERMISSION_DENIED:
                errorMsgKey = "LBS_ERROR_PERMISSION_DENIED";
                break;
            case error.POSITION_UNAVAILABLE:
                errorMsgKey = "LBS_ERROR_NO_USER_CURRENT_LOC";
                break;
            case error.TIMEOUT:
                errorMsgKey = "LBS_ERROR_TIMEOUT";
                break;
            default:
                break;
        }
        storeLocatorJS.refreshResultsWithLocationError(errorMsgKey);
    },
    
    /**
     * Call the HTML5 geolocation API with callback function
     */
    launch: function() {
        if (navigator.geolocation) {
            navigator.geolocation.getCurrentPosition(GeolocationJS.showPosition,GeolocationJS.locationError,{timeout:10000,enableHighAccuracy:true}); 
        }
    }

};//-----------------------------------------------------------------
// Licensed Materials - Property of IBM
//
// WebSphere Commerce
//
// (C) Copyright IBM Corp. 2016 All Rights Reserved.
//
// US Government Users Restricted Rights - Use, duplication or
// disclosure restricted by GSA ADP Schedule Contract with
// IBM Corp.
//-----------------------------------------------------------------

/**
 * @fileOverview This file contains functions that are used to manage the cookies that are used by the Store Locator
 * feature.
 *
 * @version 1.0
 *
 */
 
/**
 * The functions defined in the class are used for managing the physical store IDs and the store locator user 
 * inputs.  Both information is stored in the cookie.
 *
 * @class This PhysicalStoreCookieJS class defines all the variables and functions to add / update / delete physical
 * store IDs and store locator user inputs.
 *
 */
PhysicalStoreCookieJS = {
	/* the store array is used to store physical store IDs to the cookie */
	storeArray: null,
	
	/* the maximum number of physical store IDs to be saved */
	arrayMaxSize: 5,
	
	/**
	 * This function retrieves the physical store IDs from the cookie.  These physical stores IDs are saved
	 * in the store array.  If no physical store IDs is found in the cookie, an empty store array is created.
	 *
	 * @returns {Array} The store array that contains all physical store IDs saved in the cookie.
	 *
	 */
	getStoreIdsFromCookie:function() {
        var cookieValue = getCookie("WC_physicalStores");
		this.storeArray = new Array;
	
		if (cookieValue != null) {
			var subValue = "";
			var remainingString = cookieValue;
			var length = cookieValue.length;
			var end = remainingString.indexOf(",");
			
			/* more than 1 entry */
			if (end > 0) {
				while (end >=0) {
					subValue = remainingString.substring(0, end);
					this.addToStoreArray(subValue);
					remainingString = remainingString.substring(end+1,length);
					length = remainingString.length;
					end = remainingString.indexOf(",")
				}
				
				subValue = remainingString;
				this.addToStoreArray(subValue);
			}
			/* 0 to 1 entry */
			else {
				/* 1 entry */
				if (length > 0) {
					this.addToStoreArray(remainingString);
				}
			}
		}
		return this.storeArray;
	},
	
	/**
	 * This function checks whether adding one more physical store ID to the cookie will exceed the maximum
	 * number of stores allowed to be saved limit.  The function is default to return false; otherwise, true is
	 * returned. 
	 *
	 * @returns {boolean} The flag to indicate check result.
	 *
	 */
	isAddOneStoreIdExceedMax:function() {
		var exceedMax = false;
		
		if ((this.getNumStores() + 1) > this.arrayMaxSize) {
			exceedMax = true;
		}
		
		return exceedMax;
	},
	
	/**
	 * This function saves all the physical store IDs in the store array to the cookie.  It loops through the store 
	 * array and saves all physical store IDs into the cookie.  It also ensures the cookie do not expire after the 
	 * session closes.  
	 *
	 */
	setStoreIdsToCookie:function() {
		var newCookieValue = "";
		
		for (i=0; i<this.storeArray.length; i++) {
			newCookieValue = newCookieValue + this.storeArray[i];
			if (i < (this.storeArray.length-1)) {
				newCookieValue = newCookieValue + ",";
			}
		}
		
		if (newCookieValue.length == 0) {
			/* delete the cookie then */
			setCookie("WC_physicalStores", null, {path: "/", expires: -1, domain: cookieDomain});
		}
		else {
			/* add or update the cookie */
			setCookie("WC_physicalStores", newCookieValue, {path: "/", domain: cookieDomain});
		}
	},
	
	/**
	 * This function adds the store ID to the store array.  It ensures that the store array does contain the 
	 * information from the cookie and the store ID to be added does not exist in the store array.
	 *
	 * @param {String} record The physical store ID to be added. 
	 *
	 */
	addToStoreArray:function(record) {
		if (this.storeArray == null) {
			this.getStoreIdsFromCookie();
		}
		
		for (i=0; i<this.storeArray.length; i++) {
			if (this.storeArray[i] == record) {
				return;
			}
		}
		
		/* do not add the new record if the array has reached the max size */
		if (this.storeArray.length < this.arrayMaxSize) {
			this.storeArray.push(record);
		}
	},
	
	/**
	 * This function adds the store ID to the cookie by calling the following 2 functions:
	 *       addToStoreArray()
	 *       setStoreIdsToCookie()
	 *
	 * @param {String} record The physical store ID to be added. 
	 *
	 */
	addToCookie:function(record) {
		this.addToStoreArray(record);
		this.setStoreIdsToCookie();
	},
	
	/**
	 * This function removes the store ID from the store array.  It ensures that the store array does contain the
	 * information from the cookie and the store ID to be removed does exist in the store array.
	 *
	 * @param {String} record The physical store ID to be removed. 
	 *
	 */
	removeFromStoreArray:function(record) {
		if (this.storeArray == null) {
			this.getStoreIdsFromCookie();
		}
		
		var recordIndex = -1;
		
		for (i=0; i<this.storeArray.length; i++) {
			if (this.storeArray[i] == record) {
				recordIndex = i;
				i = this.storeArray.length;
			}
		}
				
		this.storeArray.splice(recordIndex, 1);
	},
	
	/**
	 * This function removes the store ID from the cookie by calling the following 2 functions:
	 *       removeFromStoreArray()
	 *       setStoreIdsToCookie()
	 *
	 * @param {String} record The physical store ID to be removed. 
	 *
	 */
	removeFromCookie:function(record) {
		this.removeFromStoreArray(record);
		this.setStoreIdsToCookie();
	},
	
	/**
	 * This function empties the store array.
	 *
	 */
	clearStoreArray:function() {
		this.storeArray = new Array;
	},
	
	/**
	 * This function updates the cookie with the empty store array.
	 *
	 */
	clearCookie:function() {
		this.clearStoreArray();
		this.setStoreIdsToCookie();
	},
	
	/**
	 * This function returns the number of physical stores saved in the cookie.  It ensures the store array contains 
	 * the information retrieved from the cookie before getting the number of stores.
	 *
	 * @returns {int} The number of physical stores saved.
	 *
	 */
	getNumStores:function() {
		if (this.storeArray == null) {	
			this.getStoreIdsFromCookie();
		}
		
		return this.storeArray.length;
	},
	
	/**
	 * This function retrieves the pick up store ID from the cookie.  If no pick up store ID is found in the cookie, 
	 * null is returned.
	 *
	 * @returns {String} The pick up store IDs.
	 *
	 */
	getPickUpStoreIdFromCookie:function() {
        var pickUpStoreId = getCookie("WC_pickUpStore");
		return pickUpStoreId;
	},

	/**
	 * This function adds or updates the pick up store ID to the cookie.
	 *
	 * @param {String} value The new pick up store ID. 
	 *
	 * @returns {element} .
	 *
	 */
	setPickUpStoreIdToCookie:function(value) {
		var newPickUpStoreId = value;
		if (newPickUpStoreId != null && newPickUpStoreId != "undefined" && newPickUpStoreId != "") {
			var currentPickUpStoreId = this.getPickUpStoreIdFromCookie();
			if (newPickUpStoreId != currentPickUpStoreId) {
				setCookie("WC_pickUpStore", null, {path: "/", expires: -1, domain: cookieDomain});
				setCookie("WC_pickUpStore", newPickUpStoreId, {path: "/", domain: cookieDomain});
			}
		}
	},

	/**
	 * This function clears the pick up store ID from the cookie when the parameter matches the current pick up 
	 * store ID in the cookie.
	 *
	 * @param {String} value The pick up store ID for comparison. 
	 *
	 */
	clearPickUpStoreIdFromCookie:function(value) {
		var newPickUpStoreId = value;
		if (newPickUpStoreId != null && newPickUpStoreId != "undefined" && newPickUpStoreId != "") {
			var currentPickUpStoreId = this.getPickUpStoreIdFromCookie();
			if (newPickUpStoreId == currentPickUpStoreId) {
				setCookie("WC_pickUpStore", null, {path: "/", expires: -1, domain: cookieDomain});
			}
		}
	},
	
	/**
	 * This generic function retrieves the value from the cookie based on the cookie key.  It is used to store 
	 * "country: WC_stCntry", "province: WC_stProv", "city: WC_stCity" and "search performed flag: WC_stFind".  If no 
	 * value is found in the cookie for the cookie key, null is returned.
	 *
	 * @param {String} cookieKey The key of the cookie. 
	 *
	 * @returns {String} The value obtained from the cookie.
	 *
	 */
	getValueFromCookie:function(cookieKey) {
        var cookieValue = getCookie(cookieKey);
		return cookieValue;
	},

	/**
	 * This function adds or updates the value to the cookie using the key provided.  It is used to store 
	 * "country: WC_stCntry", "province: WC_stProv", "city: WC_stCity" and "search performed flag: WC_stFind".
	 *
	 * @param {String} cookieKey The key of the cookie. 
	 * @param {String} cookieValue The new value of the cookie. 
	 *
	 */
	setValueToCookie:function(cookieKey, cookieValue) {
		var newValue = cookieValue;
		if (newValue != null && newValue != "undefined" && newValue != "") {
			var currentValue = this.getValueFromCookie(cookieKey);
			if (newValue != currentValue) {
				setCookie(cookieKey, null, {path: "/", expires: -1, domain: cookieDomain});
				setCookie(cookieKey, newValue, {path: "/", domain: cookieDomain});
			}
		}
	},

	/**
	 * This function clears the value referred by a key from the cookie.
	 *
	 * @param {String} cookieKey The key of the cookie. 
	 *
	 */
	clearValueFromCookie:function(cookieKey) {
		var currentValue = this.getValueFromCookie(cookieKey);
		if (currentValue != null && currentValue != "undefined") {
			setCookie(cookieKey, null, {path: "/", expires: -1, domain: cookieDomain});
		}
	}

}
//<%--
//********************************************************************
//*-------------------------------------------------------------------
//* Licensed Materials - Property of IBM
//*
//* WebSphere Commerce
//*
//* (c) Copyright IBM Corp.  2016
//* All Rights Reserved
//*
//* US Government Users Restricted Rights - Use, duplication or
//* disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
//*
//*-------------------------------------------------------------------
//*
//--%>

/**
 * @fileOverview This file contains functions that are used by Store Locator.
 *
 * @version 1.0
 *
 */


/**
 * The functions defined in the class are used for the Store Locator feature.
 *
 * @class This storeLocatorJS class defines all the functions to be used on pages that contain the Store Locator feature.
 *
 */
storeLocatorJS = {

    /**
     * This function initializes the state/province selection drop down list by extracting the selected value
     * of the country selection.  Nothing is done when no selected country is found.
     *
     */
    initProvinceSelections: function () {
        var countrySelectedIndex = $("#selectCountry").prop("selectedIndex");
        if (countrySelectedIndex > -1) {
            var indexToUse = countrySelectedIndex;
            var indexFromSavedId = storeLocatorJS.getSavedCountrySelectionIndex();

            if (indexFromSavedId != null && indexFromSavedId != countrySelectedIndex) {
                indexToUse = indexFromSavedId;
                $("#selectCountry")[0].options[indexToUse].selected = true;
            }
            wcRenderContext.updateRenderContext('provinceSelectionsAreaContext', {
                'countryId': $("#selectCountry")[0].options[indexToUse].value
            });
        }
    },

    /**
     * This function refreshes the city selection drop down list by extracting the selected value of the
     * state/province selection.  Nothing is done when no selected state/province is found.
     *
     */
    refreshCities: function () {
        var stateSelectedIndex = $("#selectState").prop("selectedIndex");
        if (stateSelectedIndex > -1) {
            var indexToUse = stateSelectedIndex;
            var indexFromSavedId = storeLocatorJS.getSavedProvinceSelectionIndex();
            if (indexFromSavedId != null && indexFromSavedId != stateSelectedIndex) {
                indexToUse = indexFromSavedId;
                $("#selectState")[0].options[indexToUse].selected = true;
            }
            wcRenderContext.updateRenderContext('citySelectionsAreaContext', {
                'provinceId': $("#selectState")[0].options[indexToUse].value
            });
        }
    },

    /**
     * This function refreshes the store location search results by extracting the selected value of the city
     * selection.  Nothing is done when no selected city is found.  Store location search results are refreshed
     * automatically once when a search intend (i.e. Find button is pressed) was done before.
     *
     * @param {String} fromPage Parameter value passed by the calling page.
     *
     */
    refreshSearchResults: function (fromPage) {
        var citySelectedIndex = $("#selectCity").selectedIndex;
        if (citySelectedIndex > -1) {
            var indexToUse = citySelectedIndex;
            var indexFromSavedId = storeLocatorJS.getSavedCitySelectionIndex();
            if (indexFromSavedId != null && indexFromSavedId != citySelectedIndex) {
                indexToUse = indexFromSavedId;
                $("#selectCountry")[0].options[indexToUse].value("selectCity").options[indexToUse].selected = true;
            }

            var performFindFlag = PhysicalStoreCookieJS.getValueFromCookie("WC_stFind");
            if (performFindFlag != null) {
                wcRenderContext.updateRenderContext('storeLocatorResultsAreaContext', {
                    'cityId': document.getElementById("selectCountry").options[indexToUse].value("selectCity").options[indexToUse].value,
                    'fromPage': fromPage
                });
            }
        }
    },

    /**
     * This function adds the user selected physical store to the cookie when the maximum number of physical
     * stores has not reached; otherwise, a message is displayed.
     *
     * @param {String} physicalStoreId The physical store Unique ID to be added.
     * @param {String} optionIndex The index of the physical store to be added.
     *
     * @returns {boolean} A flag to indicate whether the add is performed.
     *
     */
    addPhysicalStore: function (physicalStoreId, optionIndex) {
        if (PhysicalStoreCookieJS.isAddOneStoreIdExceedMax() == true) {
            if (document.getElementById("addPhysicalStoreToCookieButton" + optionIndex) != null) {
                MessageHelper.formErrorHandleClient("addPhysicalStoreToCookieButton" + optionIndex, MessageHelper.messages["EXCEED_PHYSICAL_STORE_SIZE"]);
                return false;
            } else {
                MessageHelper.displayErrorMessage(MessageHelper.messages["EXCEED_PHYSICAL_STORE_SIZE"]);
                return false;
            }
        }

        if (!submitRequest()) {
            return;
        }
        cursor_wait();

        PhysicalStoreCookieJS.addToCookie(physicalStoreId);
        storeLocatorJS.showRemoveOption(physicalStoreId);
        return true;
    },

    /**
     * This function removes the user selected physical store from the cookie.
     *
     * @param {String} physicalStoreId The physical store Unique ID to be removed.
     *
     */
    removePhysicalStore: function (physicalStoreId) {
        PhysicalStoreCookieJS.removeFromCookie(physicalStoreId);
        PhysicalStoreCookieJS.clearPickUpStoreIdFromCookie(physicalStoreId);
        storeLocatorJS.showAddOption(physicalStoreId);
    },

    /**
     * This function shows the disabled "add physical store" option and hides the "add physical store" option
     * of the physical store.
     *
     * @param {String} physicalStoreId The physical store Unique ID.
     *
     */
    showRemoveOption: function (physicalStoreId) {
        var addDisabledDiv = $("#addPhysicalStoreToCookieDisabled" + physicalStoreId);
        var addDiv = $("#addPhysicalStoreToCookie" + physicalStoreId);

        if (addDisabledDiv != null && addDisabledDiv != "undefined") {
            $(addDisabledDiv).css("display", "block");
        }

        if (addDiv != null && addDiv != "undefined") {
            $(addDiv).css("display", "none");
        }
    },

    /**
     * This function shows the "add physical store" option and hides the disabled "add physical store" option
     * of the physical store.
     *
     * @param {String} physicalStoreId The physical store Unique ID.
     *
     */
    showAddOption: function (physicalStoreId) {
        var addDisabledDiv = $("#addPhysicalStoreToCookieDisabled" + physicalStoreId);
        var addDiv = $("#addPhysicalStoreToCookie" + physicalStoreId);

        if (addDisabledDiv != null && addDisabledDiv != "undefined") {
            $(addDisabledDiv).css("display", "none");
        }

        if (addDiv != null && addDiv != "undefined") {
            $(addDiv).css("display", "block");
        }
    },

    /**
     * This function manages the cookie values when OK button is pressed from city search.
     *
     */
    manageCookieFromCity: function () {
        PhysicalStoreCookieJS.setValueToCookie('WC_stFind', 1);
    },

    /**
     * This function refreshes the result area when a city is selected.  It refreshes the physical store
     * information.
     *
     * @param form The form that contains the "city" selections.
     * @param {String} fromPage The fromPage parameter value passed by the calling page.
     *
     */
    refreshResultsFromCity: function (form, fromPage) {
        if (form.selectCity.selectedIndex < 0) {
            MessageHelper.formErrorHandleClient(form.selectCity.id, MessageHelper.messages["MISSING_CITY"]);
            return;
        }

        /* manage cookie values */
        storeLocatorJS.manageCookieFromCity();

        /* refresh the result area */
        wcRenderContext.updateRenderContext('storeLocatorResultsAreaContext', {
            'cityId': form.selectCity.options[form.selectCity.selectedIndex].value,
            'fromPage': fromPage,
            'geoCodeLatitude': '',
            'geoCodeLongitude': '',
            'errorMsgKey': ''
        });
    },

    /**
     * This function refreshes the result area when the geolocation feature is used.  It refreshes the
     * physical store information.
     *
     * @param {String} geoCodeLatitude The user's latitude coordinate.
     * @param {String} geoCodeLongitude The user's longitude coordinate.
     *
     */
    refreshResultsFromNearest: function (geoCodeLatitude, geoCodeLongitude) {
        PhysicalStoreCookieJS.clearValueFromCookie("WC_stCntry");
        PhysicalStoreCookieJS.clearValueFromCookie("WC_stProv");
        PhysicalStoreCookieJS.clearValueFromCookie("WC_stCity");
        PhysicalStoreCookieJS.clearValueFromCookie("WC_stFind");

        /* refresh the result area */
        wcRenderContext.updateRenderContext('storeLocatorResultsAreaContext', {
            'geoCodeLatitude': geoCodeLatitude,
            'geoCodeLongitude': geoCodeLongitude,
            'errorMsgKey': ''
        });
    },

    /**
     * This function refreshes the result area when the geolocation feature is used.  It refreshes the
     * physical store information.
     *
     * @param {String} errorMsgKey The resource key for the error message.
     *
     */
    refreshResultsWithLocationError: function (errorMsgKey) {
        PhysicalStoreCookieJS.clearValueFromCookie("WC_stFind");

        /* refresh the result area */
        wcRenderContext.updateRenderContext('storeLocatorResultsAreaContext', {
            'errorMsgKey': errorMsgKey
        });
    },

    /**
     * This function refreshes the store list area.
     *
     * @param {String} fromPage The fromPage parameter value passed by the calling page.
     *
     */
    refreshStoreList: function (fromPage) {
        /* refresh the store list area */
        wcRenderContext.updateRenderContext('selectedStoreListAreaContext', {
            'fromPage': fromPage
        });
    },

    removeFromStoreList: function (fromPage, tableRowId) {
        var numStores = PhysicalStoreCookieJS.getNumStores();
        if (numStores == 0) {
            // Refresh to remove complete table and display status message
            this.refreshStoreList(fromPage);
        } else {
            // Just remove store from the table.
            var tableRow = document.getElementById(tableRowId);
            tableRow.remove();
        }
    },

    /**
     * This function hides the store list area.
     *
     */
    hideStoreList: function () {
        var storeListDiv = $("#selectedStoreListArea");
        var showListHeaderDiv = $("#showStoreListHeader");
        var hideListHeaderDiv = $("#hideStoreListHeader");

        if (storeListDiv != null && storeListDiv != "undefined") {
            $(storeListDiv).css("display", "none");
        }
        if (showListHeaderDiv != null && showListHeaderDiv != "undefined") {
            $(showListHeaderDiv).css("display", "block");
        }
        if (hideListHeaderDiv != null && hideListHeaderDiv != "undefined") {
            $(hideListHeaderDiv).css("display", "none");
        }
    },

    /**
     * This function shows the store list area.
     *
     */
    showStoreList: function () {
        var storeListDiv = $("#selectedStoreListArea");
        var showListHeaderDiv = $("#showStoreListHeader");
        var hideListHeaderDiv = $("#hideStoreListHeader");

        if (storeListDiv != null && storeListDiv != "undefined") {
            $(storeListDiv).css("display", "block");
        }
        if (showListHeaderDiv != null && showListHeaderDiv != "undefined") {
            $(showListHeaderDiv).css("display", "none");
        }
        if (hideListHeaderDiv != null && hideListHeaderDiv != "undefined") {
            $(hideListHeaderDiv).css("display", "block");
        }
    },

    /**
     * This function is called after the counry selection list is changed.
     *
     * @param {String} countryId The unique ID of the selected country.
     *
     */
    changeCountrySelection: function (countryId) {
        PhysicalStoreCookieJS.setValueToCookie("WC_stCntry", countryId);
        PhysicalStoreCookieJS.clearValueFromCookie("WC_stProv");
        PhysicalStoreCookieJS.clearValueFromCookie("WC_stCity");
        PhysicalStoreCookieJS.clearValueFromCookie("WC_stFind");

        wcRenderContext.updateRenderContext("provinceSelectionsAreaContext", {
            "countryId": countryId
        });
    },

    /**
     * This function is called after the province selection list is changed.
     *
     * @param {String} provinceId The unique ID of the selected province.
     *
     */
    changeProvinceSelection: function (provinceId) {
        PhysicalStoreCookieJS.setValueToCookie("WC_stProv", provinceId);
        PhysicalStoreCookieJS.clearValueFromCookie("WC_stCity");
        PhysicalStoreCookieJS.clearValueFromCookie("WC_stFind");

        wcRenderContext.updateRenderContext("citySelectionsAreaContext", {
            "provinceId": provinceId
        });
    },

    /**
     * This function is called after the city selection list is changed.
     *
     * @param {String} cityId The unique ID of the selected city.
     *
     */
    changeCitySelection: function (cityId) {
        PhysicalStoreCookieJS.setValueToCookie("WC_stCity", cityId);
        PhysicalStoreCookieJS.clearValueFromCookie("WC_stFind");
    },

    /**
     * This function retrieves the index of the country selection list which has a value matches the one saved in
     * the cookie.  Null is returned when cookie does not contain any saved country ID.
     *
     * @returns {int} The index of the country selection list which has a value matches the one saved in the
     * cookie.
     *
     */
    getSavedCountrySelectionIndex: function () {
        var index = null;
        var savedCountryId = PhysicalStoreCookieJS.getValueFromCookie("WC_stCntry");
        if (savedCountryId != null) {
            /* search for matching ID */
            var selectedCountryList = $("#selectCountry");
            if (selectedCountryList != null && selectedCountryList != "undefined") {
                var listSize = selectedCountryList.length;
                for (i = 0; i < listSize; i++) {
                    if (savedCountryId == selectedCountryList[0].options[i].value) {
                        index = i;
                        i = listSize;
                    }
                }
            }
        }

        return index;
    },

    /**
     * This function retrieves the index of the province selection list which has a value matches the one saved in
     * the cookie.  Null is returned when cookie does not contain any saved province ID.
     *
     * @returns {int} The index of the province selection list which has a value matches the one saved in the
     * cookie.
     *
     */
    getSavedProvinceSelectionIndex: function () {
        var index = null;
        var savedProvinceId = PhysicalStoreCookieJS.getValueFromCookie("WC_stProv");
        if (savedProvinceId != null) {
            /* search for matching ID */
            var selectedProvinceList = $("#selectState");
            if (selectedProvinceList != null && selectedProvinceList != "undefined") {
                var listSize = selectedProvinceList.length;
                for (i = 0; i < listSize; i++) {
                    if (savedProvinceId == selectedProvinceList[0].options[i].value) {
                        index = i;
                        i = listSize;
                    }
                }
            }
        }

        return index;
    },

    /**
     * This function retrieves the index of the city selection list which has a value matches the one saved in
     * the cookie.  Null is returned when cookie does not contain any saved city ID.
     *
     * @returns {int} The index of the city selection list which has a value matches the one saved in the
     * cookie.
     *
     */
    getSavedCitySelectionIndex: function () {
        var index = null;
        var savedCityId = PhysicalStoreCookieJS.getValueFromCookie("WC_stCity");
        if (savedCityId != null) {
            /* search for matching ID */
            var selectedCityList = $("#selectCity");
            if (selectedCityList != null && selectedCityList != "undefined") {
                var listSize = selectedCityList[0].options.length;
                for (i = 0; i < listSize; i++) {
                    if (savedCityId == selectedCityList[0].options[i].value) {
                        index = i;
                        i = listSize;
                    }
                }
            }
        }

        return index;
    }

}
//<%--
//********************************************************************
//*-------------------------------------------------------------------
//* Licensed Materials - Property of IBM
//*
//* WebSphere Commerce
//*
//* (c) Copyright IBM Corp.  2016
//* All Rights Reserved
//*
//* US Government Users Restricted Rights - Use, duplication or
//* disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
//*
//*-------------------------------------------------------------------
//*
//--%>

/**
 * @fileOverview This file declares the contexts of the store locator.
 *
 * @version 1.0
 *
 */


/**
 * The functions defined in the class are used to initialize the common parameters of the contexts and set the 
 * properties of a specific context.
 *
 * @class This StoreLocatorContextsJS class defines all the variables and functions for manipuating the contexts
 * of the store locator.
 *
 */
StoreLocatorContextsJS = {
    /* common paramater declarations */
    langId: "-1",
    storeId: "",
    catalogId: "",
    orderId: "",
    fromPage: "StoreLocator",

    /**
     * This function initializes the common parameters. 
     *
     * @param {String} langId The language ID. 
     * @param {String} storeId The store ID.
     * @param {String} catalogId The catalog ID.
     * @param {String} orderId The order ID.
     * @param {String} fromPage The constants indicates what the calling page is.
     *
     */
    setCommonParameters: function (langId, storeId, catalogId, orderId, fromPage) {
        this.langId = langId;
        this.storeId = storeId;
        this.catalogId = catalogId;
        this.orderId = orderId;
        this.fromPage = fromPage;
    },

    /**
     * This function sets a property of a context. 
     *
     * @param {String} contextId The context identifier. 
     * @param {String} property The property name.
     * @param {String} value The property value.
     *
     */
    setContextProperty: function (contextId, property, value) {
        wcRenderContext.getRenderContextProperties(contextId)[property] = value;
    }

}


/* context declaration for "provinceSelectionsAreaContext" */
wcRenderContext.declare("provinceSelectionsAreaContext", ["provinceSelectionsArea"], ""),

    /* context declaration for "citySelectionsAreaContext" */
    wcRenderContext.declare("citySelectionsAreaContext", ["citySelectionsArea"], ""),

    /* context declaration for "storeLocatorResultsAreaContext" */
    wcRenderContext.declare("storeLocatorResultsAreaContext", ["storeLocatorResultsArea"], ""),

    /* context declaration for "selectedStoreListAreaContext" */
    wcRenderContext.declare("selectedStoreListAreaContext", ["selectedStoreListArea"], "")
//<%--
//********************************************************************
//*-------------------------------------------------------------------
//* Licensed Materials - Property of IBM
//*
//* WebSphere Commerce
//*
//* (c) Copyright IBM Corp.  2016
//* All Rights Reserved
//*
//* US Government Users Restricted Rights - Use, duplication or
//* disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
//*
//*-------------------------------------------------------------------
//*
//--%>

/**
 * @fileOverview This file declares the controllers of the store locator.
 *
 * @version 1.0
 *
 */

/**
 * The functions defined in the class are used to initialize the common parameters of the controllers and set the 
 * URL of a specific controller.
 *
 * @class This StoreLocatorContextsJS class defines all the variables and functions for manipuating the controllers
 * of the store locator.
 *
 */
StoreLocatorControllersDeclarationJS = {
    /* common paramater declarations */
    langId: "-1",
    storeId: "",
    catalogId: "",
    orderId: "",
    fromPage: "StoreLocator",

    /**
     * This function initializes the common parameters. 
     *
     * @param {String} langId The language ID. 
     * @param {String} storeId The store ID.
     * @param {String} catalogId The catalog ID.
     * @param {String} orderId The order ID.
     * @param {String} fromPage The constants indicates what the calling page is.
     *
     */
    setCommonParameters: function (langId, storeId, catalogId, orderId, fromPage) {
        this.langId = langId;
        this.storeId = storeId;
        this.catalogId = catalogId;
        this.orderId = orderId;
        this.fromPage = fromPage;
    }


}


/* refresh controller declaration for "provinceSelectionsController" */
var provinceSelectionsRefreshArea = function () {

    var myWidgetObj = $("#provinceSelectionsArea"),
        myRCProperties = wcRenderContext.getRenderContextProperties("provinceSelectionsAreaContext");

    myWidgetObj.refreshWidget({
        formId: "",


        renderContextChangedHandler: function () {

            cursor_wait();
            myWidgetObj.refreshWidget("refresh", myRCProperties);
        },

        postRefreshHandler: function () {

            storeLocatorJS.refreshCities();
            cursor_clear();
        }
    });
}

/* refresh controller declaration for "citySelectionsController" */
var citySelectionsRefreshController = function () {

    var myWidgetObj = $("#citySelectionsArea"),
        myRCProperties = wcRenderContext.getRenderContextProperties("citySelectionsAreaContext");

    myWidgetObj.refreshWidget({
        formId: "",


        renderContextChangedHandler: function () {

            cursor_wait();
            myWidgetObj.refreshWidget("refresh", myRCProperties);
        },


        postRefreshHandler: function (widget) {

            storeLocatorJS.refreshSearchResults(StoreLocatorControllersDeclarationJS.fromPage);
            cursor_clear();
        }

    });
}


/* refresh controller declaration for "storeLocatorResultsController" */
var storeLocatorResultsRefreshController = function () {

    var myWidgetObj = $("#storeLocatorResultsArea"),
        myRCProperties = wcRenderContext.getRenderContextProperties("storeLocatorResultsAreaContext");

    myWidgetObj.refreshWidget({
        formId: "",



        renderContextChangedHandler: function () {
            cursor_wait();
            myWidgetObj.refreshWidget("refresh", myRCProperties);
        },

        postRefreshHandler: function () {

            var bopisTable = $("#bopis_table");
            if (bopisTable != null && bopisTable != "undefined") {
                bopisTable.focus();
            }
            var noStoreMsg = $("#no_store_message");
            if (noStoreMsg != null && noStoreMsg != "undefined") {
                noStoreMsg.focus();
            }

            cursor_clear();
        }

    });
}

/* refresh controller declaration for "selectedStoreListController" */
var selectedStoreListRefreshController = function () {

    var myWidgetObj = $("#selectedStoreListArea"),
        myRCProperties = wcRenderContext.getRenderContextProperties("selectedStoreListAreaContext");

    myWidgetObj.refreshWidget({
        formId: "",


        renderContextChangedHandler: function () {

            cursor_wait();
            myWidgetObj.refreshWidget("refresh", myRCProperties);
        },

        postRefreshHandler: function () {

            var bopisTable = $("#bopis_table");
            if (bopisTable != null && bopisTable != "undefined") {
                bopisTable.focus();
            }

            cursor_clear();
        }

    })
}
//-----------------------------------------------------------------
// Licensed Materials - Property of IBM
//
// WebSphere Commerce
//
// (C) Copyright IBM Corp. 2009, 2016 All Rights Reserved.
//
// US Government Users Restricted Rights - Use, duplication or
// disclosure restricted by GSA ADP Schedule Contract with
// IBM Corp.
//-----------------------------------------------------------------


/**
 * @fileOverview This file triggers various Coremetrics events upon user actions. The following five events are supported:
 * 1. pageview: This event is triggered when a new page is loaded, part of a page is refreshed, or the mini shopping cart is accessed
 * 2. productview: This event is triggered when a catalog entry is viewed using Quick Info button
 * 3. cartview: This event is triggered when a user's cart is updated in any way, such as item being added, item being
 *    deleted, quantity being updated, shipping being updated, and payment being updated.
 * 4. element: This event is triggered when filtering criteria or sorting criteria in a fast finder is updated.
 * 5. registration: This event is triggered when the user updates his account information
 *
 * @version 1.0
 *
 **/

/**
* @class analyticsJS This class defines all the variables and functions used by the Analytics.js
* One and only one global analyticsJS should be created. Therefore, we create this object only when it is not present in
* in the global namespace.
*
**/

if(typeof(analyticsJS) === "undefined" || !analyticsJS || !analyticsJS.topicNamespace){
    analyticsJS = {
        /** The storeId this object is used for.**/
        storeId: 0,

        /** The catalogId the user uses **/
        catalogId: 0,

        /** The URL prefix used for invoking JSON views **/
        urlPath: null,

        /** The Mini Shopping cart title will be used in publishStoreAccordionPageView **/
        miniShopCartTitle: "MiniShoppingCart",

        /** The name of the view that will be used to retrieve JSON data for Coremetrics page view **/
        jsonPageView: "AnalyticsPageView",

        /** The name of the view that will be used to retrieve JSON data for Coremetrics product view **/
        jsonProductView: "AnalyticsProductView",

        /** The name of the view that will be used to retrieve JSON data for Coremetrics element view **/
        jsonElementView: "AnalyticsElementView",

        /** The name of the view that will be used to retrieve JSON data for Coremetrics cart view **/
        jsonShopcartView: "AnalyticsShopcartView",

        /** The name of the view that will be used to retrieve JSON data for Coremetrics add cart **/
        jsonAddCart: "AnalyticsShopcartView",

        /** The name of the view that will be used to retrieve JSON data for Coremetrics registration view **/
        jsonRegistrationView: "AnalyticsRegistrationView",

        /** The name of the view that will be used to retrieve JSON data for Coremetrics conversion event **/
        jsonConversionEventView: "AnalyticsConversionEventView",

        /** The namespace of any Commerce implementation of Coremetrics event. For example, if an element event
         *  will be of form "/wc/analytics/element". To generalize, each Coremetric topic/event follows this
         *   grammar: <topicNamespace><event name>
         */
        topicNamespace: "/wc/analytics/",

        /** The name of the page view event **/
        pageView: "pageview",

        /** The name of the product view event **/
        productView: "productview",

        /** The name of the cart view event **/
        cartView: "cartview",

        /** The name of the add cart event **/
        addCart: "addcart",

        /** The name of the element view **/
        element: "element",

        /** The name of the registration view **/
        registration: "registration",

        /** The name of the conversion event view **/
        conversionEvent: "conversionevent",

        /** A boolean flag to control the page views triggered through minishop cart views **/
        pageViewControl: false,

        incTaxInUnitPriceForCart: "F",

        /**
         * The list of service requests that should result in a cart view event. Each item in the list
         * is an legitimate action ID used in a service. Refer to the wcService.* for details.
         * Assumption: Each service topic will be of form "modelChanged/<actionID>".
         */
        cartViewActionIdList: [
            "AjaxDeleteOrderItem",
            "AjaxUpdateOrderItem"
        ],

        /**
         * The list of service requests that should result in a add cart event. Each item in the list
         * is an legitimate action ID used in a service. Refer to the wcService.* for details.
         * Assumption: Each service topic will be of form "modelChanged/<actionID>".
         */
        addCartActionIdList: [
            "AddOrderItem",
            "AjaxAddOrderItemWithShipingInfo",
        ],

        /** The list of service requests that should result in ajax wishlist update page view event.**/
        wishlistPageIdList: [
            "AjaxInterestItemAdd",
            "InterestItemDelete",
            "AjaxRestWishListAddItem",
            "AjaxRestWishListRemoveItem",
            "ShoppingListServiceAddItem"

        ],
        /** The list of service requests that should result in ajax multiple wishlist add conversionevent.**/
        conversionEventList : [
            "AjaxInterestItemAdd",
            "AjaxRestWishListAddItem",
            "AjaxInterestItemAddAndDeleteFromCart",
            "ShoppingListServiceAddItem",
            "AnalyticsConversionEvent"

        ],

        /**
        * This function retrieves all the required data for cart view event, and then publishes a  view event with the retrieved data
        *
        * @param {String} jsonViewName name of the view that will be called to get Coremetrics event data
        * @param {String} urlParams  The URL parameters passed to the jsonViewName when it is be called.For example: {storeId: 0, shopperStoreId: 10001}
        * @param {object} publisher  A function that takes a single parameter. The parameter will be the
        *                            retrieved data. It is up to this function to decide if a Coremetrics view
        *                            will be published. This function will be invoked under the context of this object. For example: function(data){this.publishTopic("/wc/analytics/cartview", data);}
        **/
        publishAnalyticsView: function(jsonViewName, urlParams, publisher){
            var scope = this;
            var kw = {
                url:        getAbsoluteURL() + jsonViewName,
                method:     'GET',
                dataType:   'json',
                data:       $.extend({storeId:scope.storeId, catalogId:scope.catalogId}, urlParams),
                error:      function(type, textStatus){
                                // Hidden tags should not interrupt user interactions. Therefore, no error will be reported to user.
                                wcTopic.publish("ajaxRequestCompleted");
                            },
                success:    function(data, textStatus){
                                publisher.call(scope, data);
                                wcTopic.publish("ajaxRequestCompleted");
                            }
            };
            wcTopic.publish("ajaxRequestInitiated");
            $.ajax(kw);
        },

       /**
        * This function publishes a topic with the given topic data
        * @param {String} topicName Topic name
        * @param {Object} topicData Topic data
        *
        */
        publishTopic: function(/*String*/topicName, /*Object*/topicData){
            var topic = this.makeTopic(topicName);
            wcTopic.publish(topic, topicData);
        },
        /**
         * This function publishes a page view event with page view data
         * @param {Object} pageViewData name-value pairs that contain all the page view event data
         *
         */
        publishPageView: function(/*Object*/pageViewData){
            var scope = this;
            this.publishAnalyticsView(
                scope.jsonPageView,
                pageViewData,
                function(data){
                    scope.publishTopic(scope.pageView, data);
                }
            );
        },

        /**
         * Publishes a non eCommerce conversion event with the event data.
         * @param {Object} conEventData name-value pairs that contain the conversion event data
         */
        publishConversionEventView: function(/*Object*/conEventData){
            var scope = this;
            this.publishAnalyticsView(
                scope.jsonConversionEventView,
                conEventData,
                function(data){
                    scope.publishTopic(scope.conversionEvent, data);
                }
            );
        },

        /**
         * This function publishes a cart view event with cart view data
         *
         */
        publishCartView: function(){
            var scope = this;
            this.publishAnalyticsView(
                scope.jsonShopcartView,
                {storeId:scope.storeId, incTaxInPrice: scope.incTaxInUnitPriceForCart },
                function(data){
                    scope.publishTopic(scope.cartView, data);
                }
            );
        },

        /**
         * This function publishes an add cart event with add cart data
         *
         */
        publishAddCart: function(){
            var scope = this;
            this.publishAnalyticsView(
                scope.jsonAddCart,
                {storeId:scope.storeId, incTaxInPrice: scope.incTaxInUnitPriceForCart },
                function(data){
                    scope.publishTopic(scope.addCart, data);
                }
            );
        },

        /**
         * This function publishes a registration view event with registration view data
         *
         */
        publishRegistrationView: function() {
            var scope = this;
            this.publishAnalyticsView(
                scope.jsonRegistrationView,
                {storeId:scope.storeId},
                function(data){
                    scope.publishTopic(scope.registration, data);
                }
            );
        },
        /**
         * This function assembles full topic  with the given topic name.
         * @param {String} topicName Topic name      *
         * @return {String} topicName A string of the form <topicNamespace><topicName>
         */
        makeTopic: function(/*String*/topicName){

            return [this.topicNamespace, topicName].join("")
        },
        /**
         * This function  is used to get the category of  mini shopping cart page view
         * @return {String} MiniShoppingCart  the page category of mini shopping cart page view
         */

        getMiniShopCartPageCategory: function(){
            return "MiniShoppingCart"
        },

        /**
         * This function is used to get the mini shopping cart page name.
         * @returns {String} MiniShoppingCart the mini shopping cart page name
         *
         */
        getMiniShopCartPageName: function(){
            return ["MiniShoppingCart: ", document.title].join("");
        },

        /**
         * This function is called to get the mini shopping cart view data
         * @param {String} miniShopCartTitle MiniShopCart Title
         * @returns {String} pagename: pageName, category: pageCategory the mini shopping cart page view data
         */
        getMiniShopCartPageViewData: function(miniShopCartTitle){
            var pageName = this.getMiniShopCartPageName();
            var pageCategory = this.getMiniShopCartPageCategory();

            return {pagename: pageName, category: pageCategory};
        },
        /**
         * This function publishes the mini shop cart page view
         * @param {String} miniShopCartTitle  MiniShopCart Title
         */
        publishMiniShopCartPageView: function(miniShopCartTitle) {
            var scope = this;
            if (!scope.pageViewControl) {
                scope.lockPageView();
                var pageViewData = this.getMiniShopCartPageViewData(miniShopCartTitle);
                this.publishPageView(pageViewData);
            }

        },

        /**
         * This function sets the pageview control flag in locked state for 3 seconds so that no extra page views are thrown
         * at the same time
         */
        lockPageView: function() {
            this.pageViewControl = true;
            setTimeout('analyticsJS.pageViewControl = false;', 3000);
        },




       /**
        * This function registers the mini shopping cart cart view whenever the user adds a item to the mini shopping cart
        */
        registerMiniShopCartCartView: function(){
            var scope = this;
            $(this.cartViewActionIdList).each( function(i, actionId){
                wcTopic.subscribe("modelChanged/"+actionId, function(){
                    scope.publishCartView();
                });
            });

           $(this.addCartActionIdList).each( function(i, actionId){
        	   wcTopic.subscribe("modelChanged/"+actionId, function(){
                    scope.publishAddCart();
                });
            });
        },

        /**
         * This function registers the shopping cart page view and cart view events
         * @param{boolean} incTaxInUP The boolean flag to indicate whether to include the sales tax in the unit price amount
         */
        loadShopCartHandler: function(/* boolean */ incTaxInUP){
            var scope = this;
            if (incTaxInUP === true) {
                scope.incTaxInUnitPriceForCart = "T";
            }
            scope.registerMiniShopCartCartView();

            scope.registerShopCartPaginationPageView();
            scope.registerShippingBillingAddressEditPageView();
        },


        /**
         * This function registers the shop cart page's pagination handler
         */
        loadShopCartPaginationHandler: function() {
            var scope = this;
            scope.registerShopCartPaginationPageView();
        },

        /**
         * Registers the shopping cart pagination event to trigger a page view tag
         */
        registerShopCartPaginationPageView: function() {
            var scope = this;
            wcTopic.subscribe("ShopCartPaginationDisplay_Context/RenderContextChanged", function(){
                var pageViewData = {pagename: document.title};
                scope.publishPageView(pageViewData);
            });
            wcTopic.subscribe("OrderItemPaginationDisplay_Context/RenderContextChanged", function(){
                var pageViewData = {pagename: document.title};
                scope.publishPageView(pageViewData);
            });
            wcTopic.subscribe("traditionalShipmentDetailsContext/RenderContextChanged", function(){
                var pageViewData = {pagename: document.title};
                scope.publishPageView(pageViewData);
            });
            wcTopic.subscribe("MSOrderItemPaginationDisplay_Context/RenderContextChanged", function(){
                var pageViewData = {pagename: document.title};
                scope.publishPageView(pageViewData);
            });
        },

        /**
         * Registers the shipping and billing address add/update event to trigger a page view tag
         */
        registerShippingBillingAddressEditPageView: function() {
            var scope = this;
            wcTopic.subscribe("editShippingAddressContext/RenderContextChanged", function(){
                var pageViewData = {pagename: document.title, category:"Shipping and biling address"};
                scope.publishPageView(pageViewData);
            });
        },


        /**
         * Registers the store locator event page views
         */
        registerStoreLocatorPageViews: function() {
            var scope = this;
            wcTopic.subscribe("selectedStoreListContext/RenderContextChanged", function(){
                var pageViewData = {pagename: document.title, category:"Store locator"};
                scope.publishPageView(pageViewData);
            });
            wcTopic.subscribe("storeLocatorResultsContext/RenderContextChanged", function(){
                var pageViewData = {pagename: document.title, category:"Store locator"};
                scope.publishPageView(pageViewData);
            });
        },

        /**
         * Loads the event handlers to generate coremetrics page view tags when the user interact with the
         * store locator page
         */
        loadStoreLocatorPageViews: function(){
            var scope = this;
            $(document).ready(function(){
                scope.registerStoreLocatorPageViews();
            });
        },

        /**
         * This function registers page view events when the shopper adds/removes items
         * from his personal wishlist
         */
        registerWishlistHandler: function() {
            var scope = this;
            var pageCategory = "MyAccountPage";
            var pageName = "Personal Wishlist:" + document.title;
            var pageViewData = {pagename: pageName, category: pageCategory};
            var cevData = {eventId: 'AddToWishlist'};


            $(this.conversionEventList).each( function(i, actionId){
                wcTopic.subscribe("modelChanged/"+actionId, function(){
                scope.publishConversionEventView(cevData);
               });
           });




        },

        /**
         * This function loads the event handlers for the Wishlist based events.
         *
         */
        loadWishlistHandler: function() {
            var scope = this;
            $(document).ready(function(){
                scope.registerWishlistHandler();
            });
        },

        /**
         * This function publishes the registration and cart tag when a guest shopper
         * tries to login from the checkout page
         */
        publishShopCartLoginTags: function() {
            var scope = this;
            $(document).ready(function(){
                scope.publishRegistrationView();
                scope.publishCartView();
            });
        },

        /**
         * This function registers the product view when the user clicks on the Quick info button
         */
        registerProductQuickInfoView: function() {

            var scope = this;
            if(typeof(QuickInfoJS) !== "undefined") {
            	Utils.aop_after(QuickInfoJS, "showDetails", function(args){
                    //console.debug("productId ", productId)
                    var catEntryId = args[0];
                    scope.publishAnalyticsView(
                        scope.jsonProductView,
                        {
                            productId: catEntryId,
                            storeId: scope.storeId
                        },
                        function(data){
                            scope.publishTopic(scope.productView, data);
                        }
                    );
                });
            }
        },
        /**
         * This function loads the Quick info event handlers
         */
        loadProductQuickInfoHandler: function () {

            var scope = this;
            $(document).ready(function(){
                scope.registerProductQuickInfoView();
            });
        },
        /**
         * This function loads the paging handler
         *
         */
        loadPagingHandler: function(){

            var scope = this;

            $(document).ready(function(){
                var movement = {forward: "page forward", backward: "page backward"};
                var monitoredEvents = [
                    ["Common", "goBack", movement.backward],
                    ["Common", "goForard", movement.forward],
                    ["Common.HistoryTracker.prototype", "back", movement.backward],
                    ["Common.HistoryTracker.prototype", "forward", movement.forward]
                ];

                $(monitoredEvents).each( function(i, target){
                    var srcObj = Utils.getObject(target[0]);
                    var srcFunc = target[1];
                    var movement = target[2];
                    $(srcObj).on( srcFunc, function(){
                        scope.publishPageView(
                            {pagename: document.title,
                             category: movement
                            }
                        );
                    });
                });
            });

        },
        /**
         * This function assumes that the related page view data is inside a DIV with ID = resultInfoDivId
         *  @param{String} resultInfoDivId  The ID of the DIV that contains information about search result.
         *  @param{Boolean} registerPageViewNow  A boolean flag to indicate whether to throw a page view when the handler is being loaded.
         *  @param{String} advSearchFormDivId  A DIV Id of the advanced search form display.
         *
         */

        registerSearchResultPageView: function(resultInfoDivId, registerPageViewNow, advSearchFormDivId){

            var realSearch = true;
            var scope = this;

            if (registerPageViewNow) {
                if ($("#" + resultInfoDivId).length) {
                    var resultInfo = eval('('+$("#" + resultInfoDivId).html()+')').searchResult;
                    var pageViewData = {pagename: document.title};

                    if (resultInfo.searchTerms !== "") {
                        if (resultInfo.totalResultCount !== '0') {
                            pageViewData = {pagename: "Search Successful:" + resultInfo.currentPageNumber};
                        } else {
                            pageViewData = {pagename: "Search Unsuccessful"};
                        }
                        if (resultInfo.searchTerms.length > 0) {
                            pageViewData.searchTerms = resultInfo.searchTerms;
                            pageViewData.searchCount = resultInfo.totalResultCount;
                        }
                        pageViewData.category = "Search Results";
                    }

                    pageViewData.attributes = resultInfo.attributes;
                    scope.publishPageView(pageViewData);
                }
            }
        },

        /**
         *  This function handles the Coremetrics event for searching.
         *  @param{String} resultInfoDivId  The ID of the DIV that contains information about search result.
         *  @param{Boolean} registerPageViewNow  A boolean flag to indicate whether to throw a page view when the handler is being loaded.
         *  @param{String} advSearchFormDivId  A DIV Id of the advanced search form display.
         */
        loadSearchResultHandler: function(/*String*/resultInfoDivId, registerPageViewNow, /*String*/ advSearchFormDivId){
            var scope = this;
            wcTopic.subscribe("CMPageRefreshEvent", function(){
                scope.registerSearchResultPageView(resultInfoDivId,registerPageViewNow, advSearchFormDivId);
            });
        },

        /**
         * This function will publish page view events when number of payment methods  changes. The category of page view event will be "payment method".
         * @param paymentController The paymentController object
         */
        registerPaymentPageView: function(/*Object*/paymentController){
            var scope = this;
            Utils.aop_after(paymentController, "setNumberOfPaymentMethods", function(args){
            	var selection = args[1];
            	scope.publishPageView({pagename:selection.value, category:"payment method"});
            	selection = null;
            });
        },

        /**
         * Loads the function that handles all the Coremetrics events for changing payments.
         * @param paymentController The paymentController object
         */
        loadPaymentPageView: function(/*Object*/paymentController){
            var scope = this;
            $(document).ready(function(){
                scope.registerPaymentPageView(paymentController);
            });
        }
    }
}
//-----------------------------------------------------------------
// Licensed Materials - Property of IBM
//
// WebSphere Commerce
//
// (C) Copyright IBM Corp. 2007, 2016 All Rights Reserved.
//
// US Government Users Restricted Rights - Use, duplication or
// disclosure restricted by GSA ADP Schedule Contract with
// IBM Corp.
//-----------------------------------------------------------------

//
//

/**
* @fileOverview This file holds methods to perform client side operations in relation to catalog browsing, usually at the category level.<b> 
* 			For example, this file holds methods to add items to the shopping cart, wish list and compare zone and to resolve SKUs.<b> 
*			This file is referenced in a collection of JSPs including all of the catalog entry display JSPs such as
*			CachedBundleDisplay.jsp, CachedItemDisplay.jsp , CachedPackageDisplay.jsp, CachedProductOnlyDisplay.jsp.
*			As well this file is included in CategoryOnlyResultsDisplay.jsp and in none catalog browsing pages such as 
*			CatalogSearchDisplay.jsp and MyAccountDisplay.jsp.
*
* @version 1.0
**/

/**
* @class categoryDisplayJS This class defines all the variables and functions used by the CategoryDisplay.js. Any page that will use a function in this file
*		can access that function thru this class. Pages that use categoryDisplayJS include CachedProductOnlyDisplay.jsp which is responsible for
*		displaying product details. As well CategoryOnlyResultsDisplay.jsp uses this page to facilitate the category browsing functionality such as add to cart, 
*		wish list and compare zone.
*
**/
categoryDisplayJS={
	
	/** An array of entitled items which is used in various methods throughout CategoryDisplay.js **/
	entitledItems:[],
	
	/** An map which holds the attributes of a set of products **/
	selectedProducts:{},
	
	/** A map of attribute name value pairs for the currently selected attribute values **/
	selectedAttributes:{},
	
	/** Can be used to hold a map of error messages **/
	errorMessages: {},
	
	/** The language ID currently in use **/
	langId: "-1",
	
	/** The store ID currently in use **/
	storeId: "",
	
	/** The catalog ID currently in use **/
	catalogId: "",
	
	/** The order ID currently in use if being called from the pending order details page.**/
	orderId: "",
	
	/** Can be used to indicate whether or not there has been a context change event **/
	contextChanged:false, 
	
	/** Set to true in the goBack and goForward methods **/
	isHistory:false,
	
	/** Holds an array of  JSON objects representing properties of merchandising associations **/
	merchandisingAssociationItems:[],
	
	/** Holds an array of JSON objects holding information about the parent catalog entries of merchandising associations **/
	baseCatalogEntryDetails:[],
	
	/** Used to determine the index of the next association to display and is used as a global storage variable to share data between methods. **/
	associationThumbnailIndex:1,
	
	/** A count of the number of merchandising associations available. **/
	totalAssociationCount:0,
	
	/** A boolean used in a variety of the add to cart methods to tell whether or not the base item was added to the cart. **/
	baseItemAddedToCart:false,
	
	/** A boolean used to determine whether or not to add merchandising associations to the cart **/
	merchandisingProductAssociationAddToCart:false,
	
	/** The form which holds information about merchandising associations to be added to the cart **/
	merchandisingProductAssociationForm:"",
	
	/** A boolean used to determine whether or not the parent catalog entry is a bundle bean. **/
	isParentBundleBean:false,
	
	/** Holds the current user type such as guest or registered user. Allowed values are 'G' for guest and 'R' for registered.**/
	userType:"",
	
	/** A variable used to form the url dynamically for the more info link in the Quickinfo popup */
	moreInfoUrl :"",
	/** The text to display as an alt to the image used on the MerchandisingAssociationDisplay.jsp to show the previous assoication **/
	displayPrevAssociation:"",
	
	/** The text to display as an alt to the image used on the MerchandisingAssociationDisplay.jsp to show the next assoication **/
	displayNextAssociation:"",
	
	/** A map holding a mapping between product IDs as its key and the first entitled item ID of that product as its value **/
	defaultItemArray:[],

	/** The type of the catalog page that the user is currently viewing **/
	currentPageType:"",

	/** The identifier of the catalog entry that the current page is displaying **/
	currentCatalogEntryId:"",
	
    /** a JSON object that holds attributes of an entitled item **/
    entitledItemJsonObject: null,

	/**
	* A boolean used to to determine is it from a Qick info popup or not. 
	**/
	isPopup : false,

	/**
	* A boolean used to to determine whether or not to diplay the price range when the catEntry is selected. 
	**/
	displayPriceRange : true,

	/**
	* This array holds the json object retured from the service, holding the price information of the catEntry.
	**/
	itemPriceJsonOject : [],
	
	/** 
	* stores all name and value of all swatches 
	* this is a 2 dimension array and each record i contains the following information:
	* allSwatchesArray[i][0] - attribute name of the swatch
	* allSwatchesArray[i][1] - attribute value of the swatch
	* allSwatchesArray[i][2] - image1 of swatch (image to use for enabled state)
	* allSwatchesArray[i][4] - onclick action of the swatch when enabled
	**/
	allSwatchesArray : [],
	
	/**
	* setCommonParameters This function initializes storeId, catalogId, and langId.
	*
	* @param {String} langId The language id to use.
	* @param {String} storeId The store id to use.
	* @param {String} catalogId The catalog id to use.
	* @param {String} userType The type of user. G for Guest user.
	* 
	**/
	setCommonParameters:function(langId,storeId,catalogId,userType){
		this.langId = langId;
		this.storeId = storeId;
		this.catalogId = catalogId;
		this.userType = userType;
	},
	
	/**
	* setEntitledItems Sets an array of entitled items for a product. The array that is generated is used later in {@link this.resolveSKU}.
	* 
	* @param {Object} entitledItemArray An object which holds both the catalog entry ID as well as an array of attributes for the entitled items of a product.
	*
	**/
	setEntitledItems : function(entitledItemArray){
		this.entitledItems = entitledItemArray;
	},

	/**
	* setSelectedAttribute Sets the selected attribute value for a particular attribute not in reference to any catalog entry.
	*					   One place this function is used is on CachedProductOnlyDisplay.jsp where there is a drop down box of attributes.
	*					   When an attribute is selected from that drop down this method is called to update the selected value for that attribute.
	*
	* @param {String} selectedAttributeName The name of the attribute.
	* @param {String} selectedAttributeValue The value of the selected attribute.
	*
	**/
	setSelectedAttribute : function(selectedAttributeName , selectedAttributeValue){ 
		console.debug(selectedAttributeName +" : "+ selectedAttributeValue);
		this.selectedAttributes[selectedAttributeName] = selectedAttributeValue;
		this.moreInfoUrl=this.moreInfoUrl+'&'+selectedAttributeName+'='+selectedAttributeValue;
	},

	/**
	* setSelectedAttributeJS Sets the selected attribute value for a particular attribute not in reference to any catalog entry.
	*					   One place this function is used is on the quick info pop up where there is a drop down box of attributes.
	*					   When an attribute is selected from that drop down this method is called to update the selected value for that attribute.
	*
	* @param {String} selectedAttributeName The name of the attribute.
	* @param {String} selectedAttributeValue The value of the selected attribute.
	*
	**/
	setSelectedAttributeJS : function(selectedAttributeName , selectedAttributeValue){ 
		console.debug(selectedAttributeName.replace(/'/g,"&#039;") +" : "+ selectedAttributeValue.replace(/'/g,"&#039;"));
		this.selectedAttributes[selectedAttributeName.replace(/'/g,"&#039;")] = selectedAttributeValue.replace(/'/g,"&#039;");
		this.moreInfoUrl=this.moreInfoUrl+'&'+selectedAttributeName.replace(/'/g,"&#039;") +'='+selectedAttributeValue.replace(/'/g,"&#039;");
	},

	/** 
	 * Displays price of the catEntry selected with the JSON objrct returned from the server.
	 * 
	 * @param {object} serviceRepsonse The JSON response from the service.
	 * @param {object} ioArgs The arguments from the service call.
	 */	
	 displayPriceServiceResponse : function(serviceResponse, ioArgs){
		
		//stores the json object, so that the service is not called when same catEntry is selected.
		categoryDisplayJS.itemPriceJsonOject[serviceResponse.catalogEntry.catalogEntryIdentifier.uniqueID] = serviceResponse;

		categoryDisplayJS.displayPrice(serviceResponse.catalogEntry);
	 },

	/** 
	 * Displays price of the attribute selected with the JSON oject.
	 * 
	 * @param {object} catEntry The JSON object with catalog entry details.
	 */	
	 displayPrice : function(catEntry){

		var tempString;
		var popup = categoryDisplayJS.isPopup;

		if(popup == true){
			$("#productPrice").html(catEntry.offerPrice);
			$("#productName").html(catEntry.description[0].name);
			$("#productSKUValue").html(catEntry.catalogEntryIdentifier.externalIdentifier.partNumber);
		}
		
		if(popup == false){
			var innerHTML = "";
			if(!catEntry.listPriced ||  catEntry.listPrice <= catEntry.offerPrice){
				innerHTML = "<span class='price bold'>"+MessageHelper.messages['PRICE']+" </span>" +
							"<span class='price bold'>" + catEntry.offerPrice + "</span>";
			}
			else{
				innerHTML = "<span class='price bold'>"+MessageHelper.messages['PRICE']+" </span>" +
							"<span class='price listPrice bold'>" + catEntry.listPrice + "</span>"+
							"<div class='price offerprice bold'>" + catEntry.offerPrice + "</div>";
			}

			innerHTML = innerHTML +	"<br />";
			
			if(categoryDisplayJS.displayPriceRange == true){
				for(var i in catEntry.priceRange){
					if(catEntry.priceRange[i].endingNumberOfUnits != 'null'){
						tempString = MessageHelper.messages['TieredPricingDisp'];
						tempString = tempString.replace('{0}',catEntry.priceRange[i].startingNumberOfUnits);
						tempString = tempString.replace('{1}',catEntry.priceRange[i].endingNumberOfUnits);
						tempString = tempString.replace('{2}',catEntry.priceRange[i].localizedPrice);
						innerHTML = innerHTML + "<span class='price bold'>" + tempString + "</span>";;
					}
					else{
						tempString = MessageHelper.messages['TieredPricingDispLast'];
						tempString = tempString.replace('{0}',catEntry.priceRange[i].startingNumberOfUnits);
						tempString = tempString.replace('{1}',catEntry.priceRange[i].localizedPrice);
						innerHTML = innerHTML + "<span class='price bold'>" + tempString + "</span>";;
					}
					innerHTML = innerHTML + "<br />";
				}
			}
			$("#WC_CachedProductOnlyDisplay_div_4").html(innerHTML);
			$("#catalog_link").html(catEntry.description[0].name);
		}
	 },	
	
	/**
	* setSelectedAttributeOfProduct Sets the selected attribute value for an attribute of a specified product.
	*								This function is used to set the assigned value of defining attributes to specific 
	*								products which will be stored in the selectedProducts map.
	*
	* @param {String} productId The catalog entry ID of the catalog entry to use.
	* @param {String} selectedAttributeName The name of the attribute.
	* @param {String} selectedAttributeValue The value of the selected attribute.
	*
	**/
	setSelectedAttributeOfProduct : function(productId,selectedAttributeName,selectedAttributeValue){
		
		selectedAttributesForProduct = {};

		if(this.selectedProducts[productId]) selectedAttributesForProduct = this.selectedProducts[productId];
		
		selectedAttributesForProduct[selectedAttributeName] = selectedAttributeValue;
		this.selectedProducts[productId] = selectedAttributesForProduct;
		
	},
	
	/**
	* getCatalogEntryId Returns the catalog entry ID of the catalog entry with the selected attributes as specified in the {@link this.selectedAttributes} value.
	*					This method uses {@link this.resolveSKU} to find the SKU with the selected attributes values.
	*
	* @see this.resolveSKU
	*
	* @return {String} catalog entry ID.
	*
	**/
	getCatalogEntryId : function(){
		var attributeArray = [];
		for(attribute in this.selectedAttributes){
			attributeArray.push(attribute + "_|_" + this.selectedAttributes[attribute]);
		}
		return this.resolveSKU(attributeArray);
	},
	
	/**
	* getImageForSKU Returns the full image of the catalog entry with the selected attributes as specified in the {@link this.selectedAttributes} value.
	*					This method uses resolveImageForSKU to find the SKU image with the selected attributes values.
	*
	* @return {String} path to the SKU image.
	*
	**/
	getImageForSKU : function(){
		var attributeArray = [];
		for(attribute in this.selectedAttributes){
			attributeArray.push(attribute + "_|_" + this.selectedAttributes[attribute]);
		}
		return this.resolveImageForSKU(attributeArray);
	},
	
	/**
	* getCatalogEntryIdforProduct Returns the catalog entry ID for a catalog entry that has the same attribute values as a specified product's selected attributes as passed in via the selectedAttributes parameter.
	*
	* @param {String[]} selectedAttributes The array of selected attributes upon which to resolve the SKU.
	*
	* @return {String} catalog entry ID of the SKU.
	*
	**/
	getCatalogEntryIdforProduct : function(selectedAttributes){
		var attributeArray = [];
		for(attribute in selectedAttributes){
			attributeArray.push(attribute + "_|_" + selectedAttributes[attribute]);
		}
		return this.resolveSKU(attributeArray);
	},


	/**
	* resolveSKU Resolves a SKU using an array of defining attributes.
	*
	* @param {String[]} attributeArray An array of defining attributes upon which to resolve a SKU.
	*
	* @return {String} catentry_id The catalog entry ID of the SKU.
	*
	**/
	resolveSKU : function(attributeArray){
	
		console.debug("Resolving SKU >> " + attributeArray +">>"+ this.entitledItems);
		var catentry_id = "";
		var attributeArrayCount = attributeArray.length;
		
		for(x in this.entitledItems){
			var catentry_id = this.entitledItems[x].catentry_id;
			var Attributes = this.entitledItems[x].Attributes;
			var attributeCount = 0;
			for(index in Attributes){
				attributeCount ++;
			}

			// Handle special case where a catalog entry has one sku with no attributes
			if (attributeArrayCount == 0 && attributeCount == 0){
				return catentry_id;
			}
			if(attributeCount != 0 && attributeArrayCount >= attributeCount){
				var matchedAttributeCount = 0;

				for(attributeName in attributeArray){
					var attributeValue = attributeArray[attributeName];
					if(attributeValue in Attributes){
						matchedAttributeCount ++;
					}
				}
				
				if(attributeCount == matchedAttributeCount){
					console.debug("CatEntryId:" + catentry_id + " for Attribute: " + attributeArray);
					return catentry_id;
				}
			}
		}
		return null;
	},

	/**
	* resolveImageForSKU Resolves image of a SKU using an array of defining attributes.
	*
	* @param {String[]} attributeArray An array of defining attributes upon which to resolve a SKU.
	*
	* @return {String} imagePath The location of SKU image.
	*
	**/
	resolveImageForSKU : function(attributeArray){
	
		console.debug("Resolving SKU >> " + attributeArray +">>"+ this.entitledItems);
		var imagePath = "";
		var attributeArrayCount = attributeArray.length;
		
		for(x in this.entitledItems){
			var imagePath = this.entitledItems[x].ItemImage;
			var Attributes = this.entitledItems[x].Attributes;
			var attributeCount = 0;
			for(index in Attributes){
				attributeCount ++;
			}

			// Handle special case where a catalog entry has one sku with no attributes
			if (attributeArrayCount == 0 && attributeCount == 0){
				return imagePath;
			}
			if(attributeCount != 0 && attributeArrayCount >= attributeCount){
				var matchedAttributeCount = 0;

				for(attributeName in attributeArray){
					var attributeValue = attributeArray[attributeName];
					if(attributeValue in Attributes){
						matchedAttributeCount ++;
					}
				}
				
				if(attributeCount == matchedAttributeCount){
					console.debug("ItemImage:" + imagePath + " for Attribute: " + attributeArray);
					return imagePath;
				}
			}
		}
		return null;
	},
	
	/**
	* updates the product image from the PDP page to use the selected SKU image
	* @param String entitledItemId the ID of the SKU
	**/
    /*
	changeProdImage: function(entitledItemId){
		if ($("#" + entitledItemId).length) {
			//the json object for entitled items are already in the HTML. 
			 entitledItemJSON = eval('('+ $("#" + entitledItemId).html() +')');
		}
		this.setEntitledItems(entitledItemJSON);
		var skuImage = categoryDisplayJS.getImageForSKU();
		if(skuImage != null){
			document.getElementById('productMainImage').src = skuImage;
		}
	}, */
		
	/**
	* Handles the case when a swatch is selected. Set the border of the selected swatch.
	* @param {String} selectedAttributeName The name of the selected swatch attribute.
	* @param {String} selectedAttributeValue The value of the selected swatch attribute.
	* @param {String} entitledItemId The ID of the SKU
	* @param {String} doNotDisable The name of the swatch attribute that should never be disabled.
	* @return boolean Whether the swatch is available for selection
	**/
    /*
	selectSwatch: function(selectedAttributeName, selectedAttributeValue, entitledItemId, doNotDisable) {
		for (attribute in this.selectedAttributes) {
			if (attribute == selectedAttributeName) {
				// case when the selected swatch is already selected with a value, if the value is different than
				// what's being selected, reset other swatches and deselect the previous value and update selection
				if (this.selectedAttributes[attribute] != selectedAttributeValue) {
					// deselect previous value and update swatch selection
					document.getElementById("swatch_" + this.selectedAttributes[attribute]).className = "swatch_normal";
				}
			}
		}
		this.makeSwatchSelection(selectedAttributeName, selectedAttributeValue, entitledItemId, doNotDisable);
	}, */

	/**
	* Make swatch selection - add to selectedAttribute, select image, and update other swatches and SKU image based on current selection.
	* @param {String} swatchAttrName The name of the selected swatch attribute.
	* @param {String} swatchAttrValue The value of the selected swatch attribute.
	* @param {String} entitledItemId The ID of the SKU.
	* @param {String} doNotDisable The name of the swatch attribute that should never be disabled.	
	**/
    /*
	makeSwatchSelection: function(swatchAttrName, swatchAttrValue, entitledItemId, doNotDisable) {
		this.setSelectedAttribute(swatchAttrName, swatchAttrValue);
		document.getElementById("swatch_" + swatchAttrValue).className = "swatch_selected";
		this.updateSwatchImages(swatchAttrName, entitledItemId, doNotDisable);
		this.changeProdImage(entitledItemId);
	},*/
		
	/**
	* Constructs record and add to this.allSwatchesArray.
	* @param {String} swatchName The name of the swatch attribute.
	* @param {String} swatchValue The value of the swatch attribute.	
	* @param {String} swatchImg1 The path to the swatch image.
	**/
	addToAllSwatchsArray: function(swatchName, swatchValue, swatchImg1) {
		if (!this.existInAllSwatchsArray(swatchName, swatchValue)) {
			var swatchRecord = [];
			swatchRecord[0] = swatchName;
			swatchRecord[1] = swatchValue;
			swatchRecord[2] = swatchImg1;
			swatchRecord[4] = document.getElementById("swatch_" + swatchValue).onclick;
			this.allSwatchesArray.push(swatchRecord);
		}
	},

	/**
	* Checks if a swatch is already exist in this.allSwatchesArray.
	* @param {String} swatchName The name of the swatch attribute.
	* @param {String} swatchValue The value of the swatch attribute.		
	* @return boolean Value indicating whether or not the specified swatch name and value exists in the allSwatchesArray.
	*/
	existInAllSwatchsArray: function(swatchName, swatchValue) {
		for(var i=0; i<this.allSwatchesArray.length; i++) {
			var attrName = this.allSwatchesArray[i][0];
			var attrValue = this.allSwatchesArray[i][1];
			if (attrName == swatchName && attrValue == swatchValue) {
				return true;
			}
		}
		return false;
	},
	
	/**
	* Check the entitledItems array and pre-select the first entited SKU as the default swatch selection.
	* @param {String} entitledItemId The ID of the SKU.
	* @param {String} doNotDisable The name of the swatch attribute that should never be disabled.		
	**/
    /*
	makeDefaultSwatchSelection: function(entitledItemId, doNotDisable) {
		if (this.entitledItems.length == 0) {
			if ($("#" + entitledItemId).length) {
				 entitledItemJSON = eval('('+ $("#" + entitledItemId).html() +')');
			}
			this.setEntitledItems(entitledItemJSON);
		}
		
		// need to make selection for every single swatch
		for(x in this.entitledItems){
			var Attributes = this.entitledItems[x].Attributes;
			for(y in Attributes){
				var index = y.indexOf("_|_");
				var swatchName = y.substring(0, index);
				var swatchValue = y.substring(index+3);
				this.makeSwatchSelection(swatchName, swatchValue, entitledItemId, doNotDisable);
			}
			break;
		}
	}, */
	
	/**
	* Update swatch images - this is called after selection of a swatch is made, and this function checks for
	* entitlement and disable swatches that are not available
	* @param selectedAttrName The attribute that is selected
	* @param {String} entitledItemId The ID of the SKU.
	* @param {String} doNotDisable The name of the swatch attribute that should never be disabled.	
	**/
    /*
	updateSwatchImages: function(selectedAttrName, entitledItemId, doNotDisable) {
		var swatchToUpdate = [];
		var selectedAttrValue = this.selectedAttributes[selectedAttrName];
		
		// finds out which swatch needs to be updated, add to swatchToUpdate array
		for(var i=0; i<this.allSwatchesArray.length; i++) {
			var attrName = this.allSwatchesArray[i][0];
			var attrValue = this.allSwatchesArray[i][1];
			var attrImg1 = this.allSwatchesArray[i][2];
			var attrImg2 = this.allSwatchesArray[i][3];
			var attrOnclick = this.allSwatchesArray[i][4];
			
			if (attrName != doNotDisable && attrName != selectedAttrName) {
				var swatchRecord = [];
				swatchRecord[0] = attrName;
				swatchRecord[1] = attrValue;
				swatchRecord[2] = attrImg1;
				swatchRecord[4] = attrOnclick;
				swatchRecord[5] = false;
				swatchToUpdate.push(swatchRecord);
			}
		}
		
		// finds out which swatch is entitled, if it is, image should be set to enabled
		// go through entitledItems array and find out swatches that are entitled 
		for (x in this.entitledItems) {
			var Attributes = this.entitledItems[x].Attributes;

			for(y in Attributes){
				var index = y.indexOf("_|_");
				var entitledSwatchName = y.substring(0, index);
				var entitledSwatchValue = y.substring(index+3);	
				
				//the current entitled item has the selected attribute value
				if (entitledSwatchName == selectedAttrName && entitledSwatchValue == selectedAttrValue) {
					//go through the other attributes that are available to the selected attribute
					//exclude the one that is selected
					for (z in Attributes) {
						var index2 = z.indexOf("_|_");
						var entitledSwatchName2 = z.substring(0, index2);
						var entitledSwatchValue2 = z.substring(index2+3);
						
						if(y != z){ //only check the attributes that are not the one selected
							for (i in swatchToUpdate) {
								var swatchToUpdateName = swatchToUpdate[i][0];
								var swatchToUpdateValue = swatchToUpdate[i][1];
								
								if (entitledSwatchName2 == swatchToUpdateName && entitledSwatchValue2 == swatchToUpdateValue) {
									swatchToUpdate[i][5] = true;
								}
							}
						}
					}
				}
			}
		}

		// Now go through swatchToUpdate array, and update swatch images
		var disabledAttributes = [];
		for (i in swatchToUpdate) {
			var swatchToUpdateName = swatchToUpdate[i][0];
			var swatchToUpdateValue = swatchToUpdate[i][1];
			var swatchToUpdateImg1 = swatchToUpdate[i][2];
			var swatchToUpdateImg2 = swatchToUpdate[i][3];
			var swatchToUpdateOnclick = swatchToUpdate[i][4];
			var swatchToUpdateEnabled = swatchToUpdate[i][5];		
			
			if (swatchToUpdateEnabled) {
				document.getElementById("swatch_" + swatchToUpdateValue).style.opacity = 1;
				document.getElementById("swatch_" + swatchToUpdateValue).style.filter = "";
				document.getElementById("swatch_" + swatchToUpdateValue).onclick = swatchToUpdateOnclick;
			} else {
				if(swatchToUpdateName != doNotDisable){
					document.getElementById("swatch_" + swatchToUpdateValue).style.opacity = 0.3;
					document.getElementById("swatch_" + swatchToUpdateValue).style.filter = 'alpha(opacity=30)';
					document.getElementById("swatch_" + swatchToUpdateValue).onclick = null;
					
					//The previously selected attribute is now unavailable for the new selection
					//Need to switch the selection to an available value
					if(this.selectedAttributes[swatchToUpdateName] == swatchToUpdateValue){
						disabledAttributes.push(swatchToUpdate[i]);
					}
				}
			}
		}
		
		//If there were any previously selected attributes that are now unavailable
		//Find another available value for that attribute and update other attributes according to the new selection
		for(i in disabledAttributes){
			var disabledAttributeName = disabledAttributes[i][0];
			var disabledAttributeValue = disabledAttributes[i][1];

			for (i in swatchToUpdate) {
				var swatchToUpdateName = swatchToUpdate[i][0];
				var swatchToUpdateValue = swatchToUpdate[i][1];
				var swatchToUpdateEnabled = swatchToUpdate[i][5];	
				
				if(swatchToUpdateName == disabledAttributeName && swatchToUpdateValue != disabledAttributeValue && swatchToUpdateEnabled){
						document.getElementById("swatch_" + disabledAttributeValue).className = "swatch_normal";
						this.makeSwatchSelection(swatchToUpdateName, swatchToUpdateValue, entitledItemId, doNotDisable);
					break;
				}
			}
		}
	},*/

	/**
	* updateParamObject This function updates the given params object with a key to value pair mapping.
	*				    If the toArray value is true, It creates an Array for duplicate entries otherwise it overwrites the old value.
	*			        This is useful while making a service call which accepts a few parameters of type array.
	*					This function is used to prepare a a map of parameters which can be passed to XMLHttpRequests. 
	* 					The keys in this parameter map will be the name of the parameter to send and the value is the corresponding value for each parameter key.
	* @param {Object} params The parameters object to add name value pairs to.
	* @param {String} key The new key to add.
	* @param {String} value The new value to add to the specified key.
	* @param {Boolean} toArray Set to true to turn duplicate keys into an array, or false to override previous values for a specified key.
	* @param {int} index The index in an array of values for a specified key in which to place a new value.
	*
	* @return {Object} params A parameters object holding name value pairs.
	*
	**/
	updateParamObject:function(params, key, value, toArray, index){
	
	   if(params == null){
		   params = [];
	   }

	   if(params[key] != null && toArray)
	   {
			if($.isArray(params[key]))
			{
				//3rd time onwards
			    if(index != null && index !== "")
				{
					//overwrite the old value at specified index
				     params[key][index] = value;
				}
				else
				{
				    params[key].push(value);
			     }
		    }
			else
			{
			     //2nd time
			     var tmpValue = params[key];
			     params[key] = [];
			     params[key].push(tmpValue);
			     params[key].push(value);
		    }
	   }
	   else
	   {
			//1st time
		   if(index != null && index !== "" && index != -1)
		   {
		      //overwrite the old value at specified index
		      params[key+"_"+index] = value;
		   }
		   else if(index == -1)
		   {
		      var i = 1;
		      while(params[key + "_" + i] != null)
			  {
			       i++;
		      }
		      params[key + "_" + i] = value;
		   }
		   else
		   {
		      params[key] = value;
		    }
	   }
	   return params;
	 },
	 
	 /**
	  *  This function associates the product id with its first entitledItemId.
	  *  @param {String} productId The id of the product.
	  *  @param {String} entitledItemId The id of the first entitledItem of the product.
	  */
	 setDefaultItem : function(productId,entitledItemId){
		this.defaultItemArray[productId] = entitledItemId;
		
},
	/*
     *	This function retrieves the first entitledItemId of the product.
	 *  @param {String} productId The id of the product.
	 *  
	 *  @return {String} The id of the first entitledItem of the product.
	 */
getDefaultItem : function(productId){
		return this.defaultItemArray[productId];
},


	/**
	* AddBundle2ShopCartAjax This function is used to add a bundle to the shopping cart. This is for the ajax flow which will take a form as input and retrieves all the items catentry IDs and adds them to the form.
	*						 
	* @param {form} form The form which contains all the inputs for the bundle.
	*					 The form is expected to have the following values: 
	*						numberOfProducts The number of products in the bundle.
	*						catEntryId_<index> where index is between 1 and numberOfProduct.
	*						quantity_<index> where index is between 1 and numberOfProduct.
	**/
	AddBundle2ShopCartAjax : function(form){
		
		if (browseOnly){
			MessageHelper.displayErrorMessage(Utils.getLocalizationMessage('ADD2CART_BROWSE_ONLY_ERROR')); 
			return;
		}
		var params = [];

		params.storeId		= this.storeId;
		params.catalogId	= this.catalogId;
		params.langId		= this.langId;
		params.orderId		= ".";
		// Remove calculations for performance
		// params.calculationUsage = "-1,-2,-5,-6,-7";
		params.calculateOrder="0";
		params.inventoryValidation = "true";
			
		var productCount = form["numberOfProduct"].value;
		for(var i = 1; i <= productCount; i++){
			var catEntryId = form["catEntryId_" + i].value;
			if(this.selectedProducts[catEntryId])
				catEntryId = this.getCatalogEntryIdforProduct(this.selectedProducts[catEntryId]);
			var qty = form["quantity_" + i].value;
			if(qty == null || qty === "" || qty<=0){ MessageHelper.displayErrorMessage(MessageHelper.messages['QUANTITY_INPUT_ERROR']); return;}
			if(qty!=null && qty !== '' && catEntryId!=null){
				this.updateParamObject(params,"catEntryId",catEntryId,false,-1);
				this.updateParamObject(params,"quantity",qty,false,-1);
				this.baseItemAddedToCart=true;
			}
			else{
				MessageHelper.displayErrorMessage(MessageHelper.messages['ERR_RESOLVING_SKU']);
				return;
			}
			var contractIdElements = document.getElementsByName('contractSelectForm_contractId_' + catEntryId);
			if (contractIdElements != null && contractIdElements != "undefined") {
				for (j=0; j<contractIdElements.length; j++) {
					if (contractIdElements[j].checked) {
						form["contractId_" + i].value = contractIdElements[j].value;
						break;
					}
				}
			}
			var contractId = form["contractId_" + i].value;
			if (contractId != null && contractId !== '') {
				this.updateParamObject(params,"contractId",contractId,false,-1);
			}
		}
		//For Handling multiple clicks
		if(!submitRequest()){
			return;
		}   		
		cursor_wait();		
		wcService.invoke("AjaxAddOrderItem", params);

	},


	/**
	* AddBundle2ShopCart This function is used to add a bundle to the shopping cart. This is for the non ajax flow which  will take a form as input and submits the form.
	*
	* @param {form} form The form which contains all the inputs for the bundle.
	*					 The form is expected to have the following values:
	*						numberOfProducts The number of products in the bundle.
	*						catEntryId_<index> where index is between 1 and numberOfProduct.
	*						quantity_<index> where index is between 1 and numberOfProduct. 
	*
	**/
	AddBundle2ShopCart : function(form){
		
		if (browseOnly){
			MessageHelper.displayErrorMessage(Utils.getLocalizationMessage('ADD2CART_BROWSE_ONLY_ERROR')); 
			return;
		}
		form.URL.value = "AjaxOrderItemDisplayView";
		var productCount = form["numberOfProduct"].value;
		for(var i = 1; i <= productCount; i++){
			var catEntryId = form["catEntryId_" + i].value;
			if(this.selectedProducts[catEntryId]){
				catEntryId = this.getCatalogEntryIdforProduct(this.selectedProducts[catEntryId]);
				if(catEntryId != null)
				form["catEntryId_" + i].value = catEntryId;
				else{
					MessageHelper.displayErrorMessage(MessageHelper.messages['ERR_RESOLVING_SKU']);
					return;
				}
			}
			var qty = form["quantity_" + i].value;
			if(qty == null || qty === "" || qty<=0){ MessageHelper.displayErrorMessage(MessageHelper.messages['QUANTITY_INPUT_ERROR']); return;}
			var contractIdElements = document.getElementsByName('contractSelectForm_contractId_' + catEntryId);
			if (contractIdElements != null && contractIdElements != "undefined") {
				for (j=0; j<contractIdElements.length; j++) {
					if (contractIdElements[j].checked) {
						form["contractId_" + i].value = contractIdElements[j].value;
						break;
					}
				}
			}
		}

		//For Handling multiple clicks
		if(!submitRequest()){
			return;
		}
		
		processAndSubmitForm(form);
	},
	
	
	/**
	* Add2ShopCart This function is used to add to a catalog entry to the shopping cart. This will resolve the catentryId using entitledItemId and adds the item to the cart.
	*			   This function will call AddItem2ShopCart after resolving the entitledItemId to a SKU.
	*
	* @param {String} entitledItemId A DIV containing a JSON object which holds information about a catalog entry. You can reference CachedProductOnlyDisplay.jsp to see how that div is constructed.
	* @param {form} form The form which contains all the inputs for the item. The catEntryId and productId values of the form you pass in
	*					 will be set to the catalog entry Id of the SKU resolved from the list of skus whos defining attributes match those in the {@link this.selectedAttributes} array.
	* @param {int} quantity quantity of the item.
	* @param {String} isPopup If the value is true, then this implies that the function was called from a quick info pop-up.				
	*
	**/
	Add2ShopCart : function(entitledItemId,form,quantity,isPopup){
		
		if (browseOnly){
			MessageHelper.displayErrorMessage(Utils.getLocalizationMessage('ADD2CART_BROWSE_ONLY_ERROR')); 
			return;
		}
		var entitledItemJSON;

		if ($("#" + entitledItemId).length) {
			//the json object for entitled items are already in the HTML. 
			 entitledItemJSON = eval('('+ $("#" + entitledItemId).html() +')');
		}else{
			//if $("#" + entitledItemId).length is 0, that means there's no <div> in the HTML that contains the JSON object. 
			//in this case, it must have been set in catalogentryThumbnailDisplay.js when the quick info
			entitledItemJSON = this.getEntitledItemJsonObject(); 
		}
		
		this.setEntitledItems(entitledItemJSON);
		var catalogEntryId = this.getCatalogEntryId();
		if(catalogEntryId!=null){
			if(this.merchandisingProductAssociationAddToCart){
				this.AddAssociation2ShopCart(catalogEntryId,quantity);
				return;
			}
			form.catEntryId.value = catalogEntryId;
			form.productId.value = catalogEntryId;
			this.AddItem2ShopCart(form,quantity);
			hidePopup('second_level_category_popup');
		} else if (isPopup == true){
			$('#second_level_category_popup').css('zIndex', '1');
			MessageHelper.formErrorHandleClient('addToCartLink', MessageHelper.messages['ERR_RESOLVING_SKU']);		
		} else{
			MessageHelper.displayErrorMessage(MessageHelper.messages['ERR_RESOLVING_SKU']);
		}

	},
	
	
	
	/**
	* AddItem2ShopCart This function is used to add a SKU to the shopping cart.
	*
	* @param {form} form The form which contains all the inputs for the item.
    * 					The form must have the following values:
    *						quantity The quantity of the item that you want to add to the cart.
	* @param {int} quantity The quantity of the item to add to the shopping cart.
	*
	**/
	AddItem2ShopCart : function(form,quantity){
		if (browseOnly){
			MessageHelper.displayErrorMessage(Utils.getLocalizationMessage('ADD2CART_BROWSE_ONLY_ERROR')); 
			return;
		}
		if(!isPositiveInteger(quantity)){
			MessageHelper.displayErrorMessage(MessageHelper.messages['QUANTITY_INPUT_ERROR']);
			return;
		}
		
		form.quantity.value = quantity;
		
		var contractIdElements = document.getElementsByName('contractSelectForm_contractId');
		if (contractIdElements != null && contractIdElements != "undefined") {
			for (i=0; i<contractIdElements.length; i++) {
				if (contractIdElements[i].checked) {
					form.contractId.value = contractIdElements[i].value;
					break;
				}
			}
		}
		//For Handling multiple clicks
		if(!submitRequest()){
			return;
		}
		processAndSubmitForm(form);
	},


	/**
	* Add2ShopCartAjax This function is used to add a catalog entry to the shopping cart using an AJAX call. This will resolve the catentryId using entitledItemId and adds the item to the cart.
	*				This function will resolve the SKU based on the entitledItemId passed in and call {@link this.AddItem2ShopCartAjax}.
	* @param {String} entitledItemId A DIV containing a JSON object which holds information about a catalog entry. You can reference CachedProductOnlyDisplay.jsp to see how that div is constructed.
	* @param {int} quantity The quantity of the item to add to the cart.
	* @param {String} isPopup If the value is true, then this implies that the function was called from a quick info pop-up. 	
	* @param {Object} customParams - Any additional parameters that needs to be passed during service invocation.
	*
	**/
	Add2ShopCartAjax : function(entitledItemId,quantity,isPopup,customParams){	
		if (browseOnly){
			MessageHelper.displayErrorMessage(Utils.getLocalizationMessage('ADD2CART_BROWSE_ONLY_ERROR')); 
			return;
		}
		var entitledItemJSON;

		if ($("#" + entitledItemId).length) {
			//the json object for entitled items are already in the HTML. 
			 entitledItemJSON = eval('('+ $("#" + entitledItemId).html() +')');
		}else{
			//if $("#" + entitledItemId).length is 0, that means there's no <div> in the HTML that contains the JSON object. 
			//in this case, it must have been set in catalogentryThumbnailDisplay.js when the quick info
			entitledItemJSON = this.getEntitledItemJsonObject(); 
		}
		
		this.setEntitledItems(entitledItemJSON);
		var catalogEntryId = this.getCatalogEntryId();
		if(catalogEntryId!=null){
			this.AddItem2ShopCartAjax(catalogEntryId , quantity,customParams);
			this.baseItemAddedToCart=true;
			hidePopup('second_level_category_popup');
		}
		else if (isPopup == true){
			$('#second_level_category_popup').css('zIndex', '1');
			MessageHelper.formErrorHandleClient('addToCartLinkAjax', MessageHelper.messages['ERR_RESOLVING_SKU']);			
		} else{
			MessageHelper.displayErrorMessage(MessageHelper.messages['ERR_RESOLVING_SKU']);
			this.baseItemAddedToCart=false;
		}
	},
    
	/**
	 * sets the entitledItemJsonObject
	 * @param (object) jsonObject the entitled item JSON objects
	 */
    setEntitledItemJsonObject: function(jsonObject) {
        this.entitledItemJsonObject = jsonObject;
    },
    
    /**
     * retrieves the entitledItemJsonObject
     */
    getEntitledItemJsonObject: function () {
    	return this.entitledItemJsonObject;
    },

	/**
	* ReplaceItemAjax This function is used to replace an item in the shopping cart when the AJAX Checkout flow is enabled. This will be called from the shopping cart and checkout pages.
	*
	* @param {String} entitledItemId A DIV containing a JSON object which holds information about a catalog entry. You can reference CachedProductOnlyDisplay.jsp to see how that div is constructed.
	* @param {int} quantity The quantity of the item to add to the shopping cart.
	*
	**/
	ReplaceItemAjax : function(entitledItemId,quantity){
	
		var entitledItemJSON;

		if ($("#" + entitledItemId).length) {
			//the json object for entitled items are already in the HTML. 
			 entitledItemJSON = eval('('+ $("#" + entitledItemId).html() +')');
		}else{
			//if $("#" + entitledItemId).length is 0, that means there's no <div> in the HTML that contains the JSON object. 
			//in this case, it must have been set in catalogentryThumbnailDisplay.js when the quick info
			entitledItemJSON = this.getEntitledItemJsonObject(); 
		}
		this.setEntitledItems(entitledItemJSON);
		var catalogEntryId = this.getCatalogEntryId();
		var removeOrderItemId = "";
		//if(entitledItemJSON[0] != null){
		//	removeOrderItemId = entitledItemJSON[0].orderItemId_remove;
		//}
		var removeOrderItemId = replaceOrderItemId;
		var typeId = document.getElementById("shipmentTypeId");
		var addressId = "";
		var shipModeId = "";
		if(typeId != null && typeId !== ""){
			if(typeId.value == "2"){
				//Multiple shipment..each orderItem will have its own addressId and shipModeId..
				addressId = document.getElementById("MS_ShipmentAddress_"+removeOrderItemId).value;
				shipModeId = document.getElementById("MS_ShippingMode_"+removeOrderItemId).value;
			}
			else {
				//Single Shipment..get the common addressId and shipModeId..
				addressId = $("#addressId_all").val();;
				shipModeId = $("#shipModeId_all").val();
			}
		}
		if(catalogEntryId!=null){
			if(removeOrderItemId !== ""){
				//Remove existing catEntryId and then add new one...
				this.ReplaceItemAjaxHelper(catalogEntryId,quantity,removeOrderItemId,addressId,shipModeId);
			}
		}else{
				MessageHelper.displayErrorMessage(MessageHelper.messages['ERR_RESOLVING_SKU']);
		}
	},

	/**
	* ReplaceItemNonAjax This function is used to replace an item in the shopping cart when the Non Ajax checkout flow is enabled. This will be called from shopcart and checkout pages.
	* 
	* @param {String} entitledItemId A DIV containing a JSON object which holds information about a catalog entry. You can reference CachedProductOnlyDisplay.jsp to see how that div is constructed.
	* @param {int} quantity The quantity of the item to replace in the shopping cart.
	* @param {form} form The form which contains all the inputs for the item.
	*
	**/ 
	ReplaceItemNonAjax : function(entitledItemId,quantity,form){
	
		var entitledItemJSON;

		if ($("#" + entitledItemId).length) {
			//the json object for entitled items are already in the HTML. 
			 entitledItemJSON = eval('('+ $("#" + entitledItemId).html() +')');
		}else{
			//if $("#" + entitledItemId).length is 0, that means there's no <div> in the HTML that contains the JSON object. 
			//in this case, it must have been set in catalogentryThumbnailDisplay.js when the quick info
			entitledItemJSON = this.getEntitledItemJsonObject(); 
		}
		this.setEntitledItems(entitledItemJSON);
		var catalogEntryId = this.getCatalogEntryId();
		var removeOrderItemId = "";
		//if(entitledItemJSON[0] != null){
		//	removeOrderItemId = entitledItemJSON[0].orderItemId_remove;
		//}
		var removeOrderItemId = replaceOrderItemId;
		if(catalogEntryId!=null){
			if(removeOrderItemId === ""){
				//Prepare form to just add this item.. This code will never be executed...
				//Needed only when we plan to show add to cart link also in the quick info..
				//form.action = "orderChangeServiceItemAdd";
				//form.submit();
			}
			else{
				//Else remove existing catEntryId and then add new one...
				form.orderItemId.value = removeOrderItemId;
				var addressId, shipModeId;
				if(quantity == 0){
					console.debug("An invalid quantity was selected");

				}
				if(form.shipmentTypeId != null && form.shipmenTypeId !== ""){
					if(form.shipmentTypeId.value == "2"){
						//Multiple shipment..each orderItem will have its own addressId and shipModeId..
						addressId = document.getElementById("MS_ShipmentAddress_"+removeOrderItemId).value;;
						shipModeId = document.getElementById("MS_ShippingMode_"+removeOrderItemId).value;;
					}
					else {
						//Single Shipment..get the common addressId and shipModeId..
						addressId = $("#addressId_all").val();;
						shipModeId = $("#shipModeId_all").val();
					}
					form.URL.value = "RESTOrderItemAdd?calculationUsage=-1,-2,-3,-4,-5,-6,-7&catEntryId="+catalogEntryId+"&quantity="+quantity+"&addressId="+addressId+"&shipModeId="+shipModeId+"&URL=RESTOrderShipInfoUpdate?URL="+form.URL.value;
			    }
				else{
					form.URL.value = "RESTOrderItemAdd?calculationUsage=-1,-2,-3,-4,-5,-6,-7&catEntryId="+catalogEntryId+"&quantity="+quantity+"&URL="+form.URL.value;
				}

				//For Handling multiple clicks
				if(!submitRequest()){
					return;
				}
				processAndSubmitForm(form);
			}
		}
		else{
			MessageHelper.displayErrorMessage(MessageHelper.messages['ERR_RESOLVING_SKU']);
		}
	},

	/**
	* AddItem2ShopCartAjax This function is used to add a single or multiple items to the shopping cart using an ajax call.
							If an array is passed for catEntryIdentifier and quantity parramters, then multiple items can be added.	In this case, catEntryIdentifier[i] corresponds to quantity[i]
							Else, catEntryIdentifier  and quantity parramters represent a single catalog entry.
	*
	* @param {Array|String} catEntryIdentifier An array of catalog entry identifiers or a single catalog entry ID of the item to add to the cart.
	* @param {Array|int} quantity An array of quantities corresponding to the catEntryIdentifier array or a single quantity of the item to add to the cart.
	* @param {Object} customParams - Any additional parameters that needs to be passed during service invocation.
	*
	**/
	AddItem2ShopCartAjax : function(catEntryIdentifier, quantity, customParams) {
		if (browseOnly){
			MessageHelper.displayErrorMessage(Utils.getLocalizationMessage('ADD2CART_BROWSE_ONLY_ERROR')); 
			return;
		}
		var params = {
			storeId: this.storeId,
			catalogId: this.catalogId,
			langId: this.langId,
			orderId: "."
		};
		// Remove calculations for performance
		// params.calculationUsage = "-1,-2,-5,-6,-7";
		params.calculateOrder="0";
		params.inventoryValidation = "true";
		var ajaxShopCartService = "AjaxAddOrderItem";
		var nonAjaxShopCartService = "AjaxAddOrderItem_shopCart";
		
		if($.isArray(catEntryIdentifier) && $.isArray(quantity)){
			for(var i=0; i<catEntryIdentifier.length; i++){
				if(!isPositiveInteger(quantity[i])){
					MessageHelper.displayErrorMessage(MessageHelper.messages['QUANTITY_INPUT_ERROR']);
					return;
				}
				params["catEntryId_" + (i+1)] = catEntryIdentifier[i];
				params["quantity_" + (i+1)]	= quantity[i];
			}
		}
		else{
			if(!isPositiveInteger(quantity)){
				MessageHelper.displayErrorMessage(MessageHelper.messages['QUANTITY_INPUT_ERROR']);
				return;
			}
			params.catEntryId	= catEntryIdentifier;
			params.quantity		= quantity;
		}		

		//Pass any other customParams set by other add on features
		if(customParams != null && customParams != 'undefined'){
			for(i in customParams){
				params[i] = customParams[i];
			}
			if(customParams['catalogEntryType'] == 'dynamicKit' ){
				ajaxShopCartService = "AjaxAddPreConfigurationToCart";
				nonAjaxShopCartService = "AjaxAddPreConfigurationToCart_shopCart";
			}
		}

		var contractIdElements = document.getElementsByName('contractSelectForm_contractId');
		if (contractIdElements != null && contractIdElements != "undefined") {
			for (i=0; i<contractIdElements.length; i++) {
				if (contractIdElements[i].checked) {
					params.contractId = contractIdElements[i].value;
					break;
				}
			}
		}
		
		//For Handling multiple clicks
		if(!submitRequest()){
			return;
		}   
		cursor_wait();
		wcService.invoke(ajaxShopCartService, params);
		this.baseItemAddedToCart=true;

		if(document.getElementById("headerShopCartLink")&&document.getElementById("headerShopCartLink").style.display != "none")
		{
			$("#headerShopCart").focus();
		}
		else
		{
			$("#headerShopCart1").focus();
		}
	},
	
	/**
	* ConfigureDynamicKit This function is used to call the configurator page for a dynamic kit.
	* @param {String} catEntryIdentifier A catalog entry ID of the item to add to the cart.
	* @param {int} quantity A quantity of the item to add to the cart.
	* @param {Object} customParams - Any additional parameters that needs to be passed to the configurator page.
	*
	**/
	ConfigureDynamicKit : function(catEntryIdentifier, quantity, customParams)
	{
		var params = {storeId: this.storeId,
catalogId: this.catalogId,
langId: this.langId,
catEntryId: catEntryIdentifier,
quantity: quantity};
		
		if(!isPositiveInteger(quantity)){
			MessageHelper.displayErrorMessage(MessageHelper.messages['QUANTITY_INPUT_ERROR']);
			return;
		}

		var contractIdElements = document.getElementsByName('contractSelectForm_contractId');
		if (contractIdElements != null && contractIdElements != "undefined") {
			for (i=0; i<contractIdElements.length; i++) {
				if (contractIdElements[i].checked) {
					params.contractId = contractIdElements[i].value;
					break;
				}
			}
		}
		
		//Pass any other customParams set by other add on features
		if(customParams != null && customParams != 'undefined'){
			for(i in customParams){
				params[i] = customParams[i];
			}
		}

		//For Handling multiple clicks
		if(!submitRequest()){
			return;
		}   
		cursor_wait();
		
		var configureURL = "ConfigureView";
		var i =0;
		for(param in params){
			configureURL += ((i++ == 0)? "?" : "&") + param + "=" + params[param];
		}
		document.location.href = getAbsoluteURL() + appendWcCommonRequestParameters(configureURL);
	},
	
	/**
	* ReplaceItemAjaxHelper This function is used to replace an item in the cart. This will be called from the {@link this.ReplaceItemAjax} method.
	*
	* @param {String} catalogEntryId The catalog entry of the item to replace to the cart.
	* @param {int} qty The quantity of the item to add.
	* @param {String} removeOrderItemId The order item ID of the catalog entry to remove from the cart.
	* @param {String} addressId The address ID of the order item.
	* @param {String} shipModeId The shipModeId of the order item.
	*
	**/
	ReplaceItemAjaxHelper : function(catalogEntryId,qty,removeOrderItemId,addressId,shipModeId){
		
		var params = {
            storeId: this.storeId,
            catalogId: this.catalogId,
            langId: this.langId,
            orderItemId: removeOrderItemId,
            orderId: (this.orderId != null && this.orderId != 'undefined' && this.orderId !== '') ?this.orderId:"."
        };
		if(CheckoutHelperJS.shoppingCartPage){	
			params.calculationUsage = "-1,-2,-5,-6,-7";
		}else{
			params.calculationUsage = "-1,-2,-3,-4,-5,-6,-7";
		}

		var params2 = {
            storeId: this.storeId,
            catalogId: this.catalogId,
            langId: this.langId,
            catEntryId: catalogEntryId,
            quantity: qty,
            orderId: (this.orderId != null && this.orderId != 'undefined' && this.orderId !== '')?this.orderId:"."
        };
		if(CheckoutHelperJS.shoppingCartPage){	
			params2.calculationUsage = "-1,-2,-5,-6,-7";
		}else{
			params2.calculationUsage = "-1,-2,-3,-4,-5,-6,-7";
		}

		var params3 = {
            storeId: this.storeId,
            catalogId: this.catalogId,
            langId: this.langId,
            orderId: (this.orderId != null && this.orderId != 'undefined' && this.orderId !== '')?this.orderId:"."
        };
		if(CheckoutHelperJS.shoppingCartPage){	
			params3.calculationUsage = "-1,-2,-5,-6,-7";
		}else{
			params3.calculationUsage = "-1,-2,-3,-4,-5,-6,-7";
		}
		params3.allocate="***";
		params3.backorder="***";
		params3.remerge="***";
		params3.check="*n";
		
		var shipInfoUpdateNeeded = false;
		if(addressId != null && addressId !== "" && shipModeId != null && shipModeId !== ""){
			params3.addressId = addressId;
			params3.shipModeId = shipModeId;
			shipInfoUpdateNeeded = true;
		}

		//Delcare service for deleting item...
		wcService.declare({
			id: "AjaxReplaceItem",
			actionId: "AjaxReplaceItem",
			url: "AjaxRESTOrderItemDelete",
			formId: ""

			,successHandler: function(serviceResponse) {
				//Now add the new item to cart..
				if(!shipInfoUpdateNeeded){
					//We dont plan to update addressId and shipMOdeId..so call AjaxAddOrderItem..
					wcService.invoke("AjaxAddOrderItem", params2);
				}
				else{
					//We need to update the adderessId and shipModeId..so call our temp service to add..
					wcService.invoke("AjaxAddOrderItemTemp", params2);
				}
			}

			,failureHandler: function(serviceResponse) {
				if (serviceResponse.errorMessage) {
							 MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
					  } else {
							 if (serviceResponse.errorMessageKey) {
									MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
							 }
					  }
					  cursor_clear();
			}

		});

		//Delcare service for adding item..
		wcService.declare({
			id: "AjaxAddOrderItemTemp",
			actionId: "AjaxAddOrderItemTemp",
			url: "AjaxRESTOrderItemAdd",
			formId: ""

			,successHandler: function(serviceResponse) {
				//Now item is added.. call update to set addressId and shipModeId...
				wcService.invoke("OrderItemAddressShipMethodUpdate", params3);
			}

			,failureHandler: function(serviceResponse) {
				MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
			}
		});

		//For Handling multiple clicks
		if(!submitRequest()){
			return;
		}   
		cursor_wait();
		wcService.invoke("AjaxReplaceItem",params);
	},
		
	/**
	* AddBundle2WishList This function is used to add a bundle to the wish list and it can be called by the product/bundle/package details pages.
	*
	* @param {form} form The form which contains all the inputs for the bundle.
	*
	**/	
	AddBundle2WishList : function(form){
		if (!isAuthenticated) { 
			setWarningMessageCookie('WISHLIST_GUEST_ADDITEM');
		}
		var productCount = form["numberOfProduct"].value; 
		for(var i = 1; i <= productCount; i++){
			var catEntryId = form["catEntryId_" + i].value;
			if(this.selectedProducts[catEntryId]){
				catEntryId = this.getCatalogEntryIdforProduct(this.selectedProducts[catEntryId]);
				if(catEntryId != null)
				form["catEntryId_" + i].value = catEntryId;
				else{
					MessageHelper.displayErrorMessage(MessageHelper.messages['ERR_RESOLVING_SKU']);
					return;
				}
			}
		}
		form.action="InterestItemAdd";
		form.page.value="customerlinkwishlist";

		if(this.userType=='G'){
			form.URL.value='InterestItemDisplay';
		}else {
			form.URL.value='AjaxLogonForm';
		}
			
		//For Handling multiple clicks
		if(!submitRequest()){
			return;
		}
		
		processAndSubmitForm(form);
	},
	
	/**
	* AddBundle2WishListAjax This fuction is used to add a bundle to the wish list using the ajax flow and it is called by the product/bundle/package details pages.
	*
	* @param {form} form The form which contains all the inputs for the bundle.
	*
	**/
	AddBundle2WishListAjax : function(form){
		if (!isAuthenticated) { 
			setWarningMessageCookie('WISHLIST_GUEST_ADDITEM');
		}
		var params = [];

		params.storeId		= this.storeId;
		params.catalogId	= this.catalogId;
		params.langId		= this.langId;
		params.updateable	= 0;
		params.orderId		= ".";
			
		var catEntryArray = [];
		catEntryArray = form.catEntryIDS.value.toString().split(",");
		
		for(var i = 0; i < catEntryArray.length; i++){
			var qty = document.getElementById("quantity_" + catEntryArray[i]).value;
			var catEntryId = catEntryArray[i];
			if(this.selectedProducts[catEntryArray[i]])
				catEntryId = this.getCatalogEntryIdforProduct(this.selectedProducts[catEntryArray[i]]);
			if(qty==0 || qty == null) qty = 1;
			if(qty!=null && qty !== '' && catEntryId!=null){
				this.updateParamObject(params,"catEntryId",catEntryId,false,-1);
				this.updateParamObject(params,"quantity",qty,false,-1);
			}
			else{
				MessageHelper.displayErrorMessage(MessageHelper.messages['ERR_RESOLVING_SKU']);
				return;
			}
		}
		//For Handling multiple clicks
		if(!submitRequest()){
			return;
		}   		
		cursor_wait();		
		wcService.invoke("AjaxInterestItemAdd", params);

	},
	
	/**
	* Add2WishListAjaxByID. This function is used to add a catalog entry to the wish list using ajax by passing in a catalog entry ID.
	*
	* @param {int} catalogEntryId The catalog entry ID of the catalog entry.
	*
	**/
	Add2WishListAjaxByID:function(catalogEntryId)
	{
		if(catalogEntryId!=null){
			if (!isAuthenticated) { 
				setWarningMessageCookie('WISHLIST_GUEST_ADDITEM');
			}
			var params = {
                storeId: this.storeId,
                catalogId: this.catalogId,
                langId: this.langId,
                catEntryId: catalogEntryId,
                updateable: 0,
                URL: "SuccessfulAJAXRequest"
            };
			if($("#controllerURLWishlist").length)
                $("#WishlistDisplay_Widget").refreshWidget("updateUrl", $("#controllerURLWishlist").val());

			//For Handling multiple clicks
			if(!submitRequest()){
				return;
			}   
			cursor_wait();
			wcService.invoke("AjaxInterestItemAdd", params);
		}
		else MessageHelper.displayErrorMessage(MessageHelper.messages['ERR_RESOLVING_SKU']);
	},
	
	/**
	* Add2WishListAjax This function is used to add an item to the wishlist using ajax by passing in the id of an HTML element containing a JSON object representing a catalog entry.
	*				   This fuction is called by product/bundle/package detail pages.
	* 
	* @param {HTMLDivElement} entitledItemId A DIV containing a JSON object which holds information about a catalog entry. You can reference CachedProductOnlyDisplay.jsp to see how that div is constructed.
	*
	**/
	Add2WishListAjax:function(entitledItemId)
	{
		if (!isAuthenticated) { 
			setWarningMessageCookie('WISHLIST_GUEST_ADDITEM');
		}
		var entitledItemJSON;

		if ($("#" + entitledItemId).length) {
			//the json object for entitled items are already in the HTML. 
			 entitledItemJSON = eval('('+ $("#" + entitledItemId).html() +')');
		}else{
			//if $("#" + entitledItemId).length is 0, that means there's no <div> in the HTML that contains the JSON object. 
			//in this case, it must have been set in catalogentryThumbnailDisplay.js when the quick info
			entitledItemJSON = this.getEntitledItemJsonObject(); 
		}
		this.setEntitledItems(entitledItemJSON);
		
		
		
		var catalogEntryId = this.getCatalogEntryId();
		
		this.Add2WishListAjaxByID(catalogEntryId);
		
	},
	
	/**
	* AddItem2WishListAjax. This function is used to add an item to the wishlist using AJAX by passing in its catentryId. 
	* 						This function can be called by item detail page.
	*
	* @param {String} itemId The catalog entry ID of the catalog entry to add to the wish list.
	*
	**/
	AddItem2WishListAjax:function(itemId)
	{
		if (!isAuthenticated) { 
			setWarningMessageCookie('WISHLIST_GUEST_ADDITEM');
		}
		var params = {
            storeId: this.storeId,
            catalogId: this.catalogId,
            langId: this.langId,
            catEntryId: itemId,
            updateable: 0,
            URL: "SuccessfulAJAXRequest"
        };
		if ($("#controllerURLWishlist").length)
            $("#WishlistDisplay_Widget").refreshWidget("updateUrl", $("#controllerURLWishlist").val());

		//For Handling multiple clicks
		if(!submitRequest()){
			return;
		}   		
		cursor_wait();
		wcService.invoke("AjaxInterestItemAdd", params);
	},

	/**
	* Add2WishList This function is used to add a catalog entry to the wish list using the non ajax flow by passing in the ID of an HTML element containing a JSON which represents a catalog entry 
	*			   This fuction is called by the product/bundle/package detail pages.
	*
	* @param {String} entitledItemId A DIV containing a JSON object which holds information about a catalog entry. You can reference CachedProductOnlyDisplay.jsp to see how that div is constructed.
	* @param {form} form form to submit the request.
	*
	**/
	Add2WishList:function(entitledItemId,form)
	{
		if (!isAuthenticated) { 
			setWarningMessageCookie('WISHLIST_GUEST_ADDITEM');
		}
		var entitledItemJSON;

		if ($("#" + entitledItemId).length) {
			//the json object for entitled items are already in the HTML. 
			 entitledItemJSON = eval('('+ $("#" + entitledItemId).html() +')');
		}else{
			//if $("#" + entitledItemId).length is 0, that means there's no <div> in the HTML that contains the JSON object. 
			//in this case, it must have been set in catalogentryThumbnailDisplay.js when the quick info
			entitledItemJSON = this.getEntitledItemJsonObject(); 
		}
		this.setEntitledItems(entitledItemJSON);
		var catalogEntryId = this.getCatalogEntryId();
		this.Add2WishListByID(catalogEntryId,form);
	},


	/**
	* Add2WishListByID Add a catalog entry to the wish list using the non-AJAX flow. This fuction is called by the product/bundle/package detail pages.
	*
	* @param {String} catalogEntryId The catalog entry ID of the catalog entry to be added.
	* @param {form} form  form to submit the request.
	*
	**/
	Add2WishListByID:function(catalogEntryId,form)
	{
		if (!isAuthenticated) { 
			setWarningMessageCookie('WISHLIST_GUEST_ADDITEM');
		}
		if(catalogEntryId!=null){
			form.productId.value = catalogEntryId;
			form.catEntryId.value = catalogEntryId;
			form.action="InterestItemAdd";
			form.page.value="customerlinkwishlist";

			if(this.userType=='G'){
				form.URL.value='InterestItemDisplay';
			}else {
				form.URL.value='AjaxLogonForm';
			}

			form.quantity.value = "1";

			//For Handling multiple clicks
			if(!submitRequest()){
				return;
			}
			
			processAndSubmitForm(form);
		}
		else MessageHelper.displayErrorMessage(MessageHelper.messages['ERR_RESOLVING_SKU']);
	},
	
	
	/** 
	* AddItem2WishList Add a SKU to the wish list using the non-AJAX flow. This function is called by the item detail page.
	*
	* @param {form} form The form to submit the request.
	*
	**/
	AddItem2WishList:function(form)
	{
		if (!isAuthenticated) { 
			setWarningMessageCookie('WISHLIST_GUEST_ADDITEM');
		}
		form.action="InterestItemAdd";
		form.quantity.value = "1";
		form.page.value="customerlinkwishlist";

		if(this.userType=='G'){
			form.URL.value='InterestItemDisplay';
		}else {
			form.URL.value='AjaxLogonForm';
		}

		//For Handling multiple clicks
		if(!submitRequest()){
			return;
		}
			
		processAndSubmitForm(form);
	},
	
	/**
	* initializeMerchandisingAssociation Since the merchandising associations are only displayed one at a time with a scrolling widget this method
	*									 will initialize that widget with a specified starting index represented by thumbnailIndex so that the correct 
	*									 merchandising association is displayed first.
	*									 This function is called on MerchandisingAssociationsDisplay.jsp.s
	* 
	* @param {String} thumbnailIndex The index of the association that needs to be displayed.
	*
	**/
	initializeMerchandisingAssociation:function(thumbnailIndex){
	
	var associationDisplay = document.getElementById("marchandisingAssociationDisplay");
	var totalPriceMsg = $("#totalPriceMsg").val();
	var baseCatEntryJSON = eval('('+ $("#baseCatEntryDetails").html() +')');
	this.baseCatalogEntryDetails = baseCatEntryJSON;
	var basePrice=this.baseCatalogEntryDetails[0].baseCatEntry_Price;
	this.totalAssociationCount= this.baseCatalogEntryDetails[0].totalAssociations;
	var identifierJSON = "associatedCatEntries_"+thumbnailIndex;
	var associationEntryJSON = eval('('+ $("#" + identifierJSON).html() +')');
	this.merchandisingAssociationItems = associationEntryJSON;
	var totalPrice = parseFloat(basePrice)+ parseFloat(this.merchandisingAssociationItems[0].catEntry_Price);
	var dragType = "";
		
	if(this.merchandisingAssociationItems[0].catEntry_Type =='ProductBean'){
		dragType = "product";
	}else if (this.merchandisingAssociationItems[0].catEntry_Type =='ItemBean'){
		dragType = "item";
	}else if (this.merchandisingAssociationItems[0].catEntry_Type =='PackageBean'){
		dragType = "package";
	}else if (this.merchandisingAssociationItems[0].catEntry_Type =='BundleBean'){
		dragType = "bundle";
	}
//Creates the inner HTML of the associated item determined by the thumbnailIndex which needs to be displayed in the page.
var widgetHTML = "";
if ($("#addToCartLink").length){
var url = "AjaxOrderItemDisplayView?storeId="+this.storeId+"&catalogId="+this.catalogId+"&langId="+this.langId;
						widgetHTML = widgetHTML
						+"<form name='OrderItemAddForm_"+this.merchandisingAssociationItems[0].catEntry_Identifier+"' action='RESTOrderItemAdd' method='post' id='OrderItemAddForm_"+this.merchandisingAssociationItems[0].catEntry_Identifier+"'>\n"
						+"<input type='hidden' name='storeId' value='"+this.storeId+"' id='OrderItemAddForm_storeId_"+this.merchandisingAssociationItems[0].catEntry_Identifier+"'/>\n"
						+"<input type='hidden' name='orderId' value='.' id='OrderItemAddForm_orderId_"+this.merchandisingAssociationItems[0].catEntry_Identifier+"'/>\n"
						+"<input type='hidden' name='catalogId' value='"+this.catalogId+"' id='OrderItemAddForm_orderId_"+this.merchandisingAssociationItems[0].catEntry_Identifier+"'/>\n"
						+"<input type='hidden' name='URL' value='"+ url + "' id='OrderItemAddForm_url_"+this.merchandisingAssociationItems[0].catEntry_Identifier+"'/>\n"
						+"<input type='hidden' name='errorViewName' value='InvalidInputErrorView' id='OrderItemAddForm_errorViewName_"+this.merchandisingAssociationItems[0].catEntry_Identifier+"'/>\n"
						+"<input type='hidden' name='catEntryId' value='"+this.merchandisingAssociationItems[0].catEntry_Identifier+"' id='OrderItemAddForm_catEntryId_"+this.merchandisingAssociationItems[0].catEntry_Identifier+"'/>\n"
						+"<input type='hidden' name='productId' value='"+this.merchandisingAssociationItems[0].catEntry_Identifier+"' id='OrderItemAddForm_productId_"+this.merchandisingAssociationItems[0].catEntry_Identifier+"'/>\n"
						+"<input type='hidden' value='1' name='quantity' id='OrderItemAddForm_quantity_"+this.merchandisingAssociationItems[0].catEntry_Identifier+"'/>\n"
						+"<input type='hidden' value='' name='page' id='OrderItemAddForm_page_"+this.merchandisingAssociationItems[0].catEntry_Identifier+"'/>\n"
						+"<input type='hidden' value='-1,-2,-3,-4,-5,-6,-7' name='calculationUsage' id='OrderItemAddForm_calcUsage_"+this.merchandisingAssociationItems[0].catEntry_Identifier+"'/>\n"
						+"<input type='hidden' value='0' name='updateable' id='OrderItemAddForm_updateable_"+this.merchandisingAssociationItems[0].catEntry_Identifier+"'/>\n"
						+"<input type='hidden' value='' name='giftListId' id='OrderItemAddForm_giftListId_"+this.merchandisingAssociationItems[0].catEntry_Identifier+"'/>\n"
						+"</form>\n";
						}
widgetHTML = widgetHTML					
			+"<div class='scroller' id='WC_CategoryDisplayJS_div_1'>";
			if(this.totalAssociationCount > 1){
				if(this.associationThumbnailIndex < this.totalAssociationCount){
					widgetHTML = widgetHTML
					+"		<a href='Javascript:categoryDisplayJS.showNextAssociation()'  id='WC_ProductAssociation_UpArrow_Link_1'>";
				}
				widgetHTML = widgetHTML
				+"		<img src='"+this.baseCatalogEntryDetails[0].storeImage_Path+"i_up_arrow.png' alt='"+this.displayNextAssociation+"'/></a>";
			}
			widgetHTML = widgetHTML +" <br />"
			+"<div id='baseContent_"+this.merchandisingAssociationItems[0].catEntry_Identifier+"'";
			if(this.merchandisingAssociationItems[0].showProductQuickView == 'true'){
				widgetHTML = widgetHTML
				+" onmouseover='showPopupButton("+this.merchandisingAssociationItems[0].catEntry_Identifier+");' onmouseout='hidePopupButton("+this.merchandisingAssociationItems[0].catEntry_Identifier+");'>";
			}else{
				widgetHTML = widgetHTML
				+" >";
			}
			widgetHTML = widgetHTML
			+"	<a href='"+this.merchandisingAssociationItems[0].catEntry_ProductLink+"'  id='img"+this.merchandisingAssociationItems[0].catEntry_Identifier+"' onfocus='showPopupButton("+this.merchandisingAssociationItems[0].catEntry_Identifier+");'>";
			widgetHTML = widgetHTML
			+"		<img src='"+this.merchandisingAssociationItems[0].catEntry_Thumbnail+"' alt='"+this.merchandisingAssociationItems[0].catEntry_ShortDescription+"' class='img' width='70' height='70'/>"
			+"	</a><br />";
			if(this.merchandisingAssociationItems[0].showProductQuickView == 'true'){
				widgetHTML = widgetHTML
				+" <div id='popupButton_"+this.merchandisingAssociationItems[0].catEntry_Identifier+"' class='main_quickinfo_button'>"
					+"<span class='secondary_button' >\n"
						+"<span class='button_container' >\n"
							+"<span class='button_bg' >\n"
								+"<span class='button_top'>\n"
									+"<span class='button_bottom'>\n"
										+"<a id='QuickInfoButton_"+this.merchandisingAssociationItems[0].catEntry_Identifier+"' href='#' onclick='javaScript:var actionListImageAcct = new popupActionProperties(); actionListImageAcct.showWishList="+this.merchandisingAssociationItems[0].associationProductBuyable+"; actionListImageAcct.showAddToCart="+this.merchandisingAssociationItems[0].associationProductBuyable+"; showPopup("+this.merchandisingAssociationItems[0].catEntry_Identifier+",event,null,null,actionListImageAcct);' onkeypress='javaScript:var actionListImageAcct = new popupActionProperties(); actionListImageAcct.showWishList="+this.merchandisingAssociationItems[0].associationProductBuyable+"; actionListImageAcct.showAddToCart="+this.merchandisingAssociationItems[0].associationProductBuyable+"; showPopup("+this.merchandisingAssociationItems[0].catEntry_Identifier+",event,null,null,actionListImageAcct);' onblur='hidePopupButton("+this.merchandisingAssociationItems[0].catEntry_Identifier+");' role='wairole:button' waistate:haspopup='true'>"+this.merchandisingAssociationItems[0].showProductQuickViewLable+"</a></span>\n"
								+"</span>\n"
							+"</span>\n"
						+"</span>\n"
					+"</span>\n"										
				+"</div>\n";
			}
			widgetHTML = widgetHTML
			+"</div>";	
		
			if(this.totalAssociationCount > 1){
				if(this.associationThumbnailIndex > 1 ){
					widgetHTML = widgetHTML
					+"		<a href='Javascript:categoryDisplayJS.showPreviousAssociation()'  id='WC_ProductAssociation_DownArrow_Link_1'>";
				}
				widgetHTML = widgetHTML
				+"		<img src='"+this.baseCatalogEntryDetails[0].storeImage_Path+"i_down_arrow.png' alt='"+this.displayPrevAssociation+"'/></a>";
			}
			
			var comboText = this.baseCatalogEntryDetails[0].associatedProductsName.replace(/%0/, this.baseCatalogEntryDetails[0].baseCatEntry_Name);
			comboText = comboText.replace(/%1/, this.merchandisingAssociationItems[0].catEntry_Name);
			
			widgetHTML = widgetHTML
			+"</div>"
			+"<div class='combo_text' id='WC_CategoryDisplayJS_div_2'>\n"
			+"	<h1 id='maHeader' class='status_msg'>"+ comboText +"</h1>\n"
			+"	<span id='maPrice' class='grey'>"+totalPriceMsg+Utils.formatCurrency(totalPrice.toFixed(2), {currency: this.baseCatalogEntryDetails[0].currency})+"</span>\n"+"</div>\n";
			widgetHTML = widgetHTML
			+"<input type='hidden' id='compareImgPath_"+this.merchandisingAssociationItems[0].catEntry_Identifier+"' value='"+this.merchandisingAssociationItems[0].catEntry_Thumbnail_compare+"'/>"
			+"<input type='hidden' id='compareProductDetailsPath_"+this.merchandisingAssociationItems[0].catEntry_Identifier+"' value='"+this.merchandisingAssociationItems[0].catEntry_ProductLink+"'/>"
			+"<input type='hidden' id='compareImgDescription_"+this.merchandisingAssociationItems[0].catEntry_Identifier+"' value='"+this.merchandisingAssociationItems[0].catEntry_ShortDescription+"'/>";
			associationDisplay.innerHTML=null;
			associationDisplay.innerHTML=widgetHTML;
            WCWidgetParser.parse(associationDisplay);
            WCWidgetParser.parseRefreshArea(associationDisplay);
},


	/**
	* showNextAssociation Displays the next association in the association array. No action is performed if it is already at the last item.
	*				      This function is used with the merchandising association widget on the MerchandisingAssociationDisplay.jsp to display the next
	*					  association available.
	**/
	showNextAssociation : function(){
		
		if(this.associationThumbnailIndex < this.totalAssociationCount){
			this.associationThumbnailIndex = this.associationThumbnailIndex+1;
			this.initializeMerchandisingAssociation(this.associationThumbnailIndex);
		}
	},

	/**
	* showPreviousAssociation Displays the previous association in the association array. No action is performed if it is already the first item.
	*				      This function is used with the merchandising association widget on the MerchandisingAssociationDisplay.jsp to display the previous
	*					  association available.
	**/
	showPreviousAssociation : function(){
		
	if(this.associationThumbnailIndex > 1 ){
			this.associationThumbnailIndex = this.associationThumbnailIndex-1;
			this.initializeMerchandisingAssociation(this.associationThumbnailIndex);
		}
	},

	/**
	* AddAssociation2ShopCartAjax Adds the associated product to the shopping cart.
	*
	* @param {String} baseProductId The catalog entry ID of the parent product.
	* @param {int} baseProductQuantity The quantity of the parent product to add.
	*
	**/
	AddAssociation2ShopCartAjax:function(baseProductId,baseProductQuantity){
	
		if (browseOnly){
			MessageHelper.displayErrorMessage(Utils.getLocalizationMessage('ADD2CART_BROWSE_ONLY_ERROR')); 
			return;
		}
		var identifierJSON = "associatedCatEntries_"+this.associationThumbnailIndex;
		//Get the associated item from the JSON object.
		var associationEntryJSON = eval('('+ $("#" + identifierJSON).html() +')');
		this.merchandisingAssociationItems = associationEntryJSON;
		this.baseItemAddedToCart = false;
		//Add the parent product to the cart.
		if(this.merchandisingAssociationItems[0].catEntry_Type=='ProductBean'){
			this.Add2ShopCartAjax(baseProductId,baseProductQuantity);
			if(this.baseItemAddedToCart){
				//Show the pop-up to select the attributes of the associated product.
				showPopup(this.merchandisingAssociationItems[0].catEntry_Identifier,function(e){return e;},'marchandisingAssociationDisplay');
			}
		}else if (["ItemBean", "PackageBean", "BundleBean"].indexOf(this.merchandisingAssociationItems[0].catEntry_Type) > -1){
			//Get the associated item from the JSON object.
			var entitledItemJSON = eval('('+ $("#" + baseProductId).html() +')');
			this.setEntitledItems(entitledItemJSON);
			var catalogEntryId = this.getCatalogEntryId();
			var params = {
                storeId: this.storeId,
                catalogId: this.catalogId,
                langId: this.langId,
                orderId: "."
            };
				// Remove calculations for performance
				// params.calculationUsage = "-1,-2,-5,-6,-7";
				params.calculateOrder="0";
			if(catalogEntryId!=null){
				this.updateParamObject(params,"catEntryId",catalogEntryId,false,-1);
				this.updateParamObject(params,"quantity",baseProductQuantity,false,-1);
				if(this.merchandisingAssociationItems[0].catEntry_Type=='BundleBean'){
					var form = document.getElementById(this.merchandisingAssociationItems[0].catEntry_BundleFormId);
					var catEntryArray = [];
					// add the individual bundle items to the request.
					catEntryArray = form.catEntryIDS.value.toString().split(",");
					for(var i = 0; i < catEntryArray.length; i++){
						var qty = document.getElementById("quantity_" + catEntryArray[i]).value;
						var catEntryId = catEntryArray[i];
						if(this.getDefaultItem(catEntryArray[i]))
							catEntryId = this.getDefaultItem(catEntryArray[i]);
						if(qty==0 || qty == null) qty = 1;
						if(qty!=null && qty !== '' && catEntryId!=null){
							this.updateParamObject(params,"catEntryId",catEntryId,false,-1);
							this.updateParamObject(params,"quantity",qty,false,-1);
						}else{
							MessageHelper.displayErrorMessage(MessageHelper.messages['ERR_RESOLVING_SKU']);
							return;
						}
					}
				}else{
					this.updateParamObject(params,"catEntryId",this.merchandisingAssociationItems[0].catEntry_Identifier,false,-1);
					this.updateParamObject(params,"quantity",1,false,-1);
				}
			}else{
				MessageHelper.displayErrorMessage(MessageHelper.messages['ERR_RESOLVING_SKU']);
				return;
			}
			//For Handling multiple clicks
			if(!submitRequest()){
				return;
			}   		
			cursor_wait();				
			//Invoke service to add to the cart.
			wcService.invoke("AjaxAddOrderItem", params);
		}
	},

	/** 
	* AddAssociation2ShopCart Adds an associated product to the shopping cart. This function is called by other functions in the FastFinderDisplay.js such as Add2ShopCart().
	* 
	* @param {String} associatedItemId The catalog entry ID of the associated item.
	* @param {int} quantity The quantity of the associated item to add.
	*
	**/
	AddAssociation2ShopCart:function(associatedItemId,quantity){
	
	if (browseOnly){
		MessageHelper.displayErrorMessage(Utils.getLocalizationMessage('ADD2CART_BROWSE_ONLY_ERROR')); 
		return;
	}
	var form = this.merchandisingProductAssociationForm;
	this.merchandisingProductAssociationAddToCart = false;
	if(this.isParentBundleBean){
		// add the individual bundle items to the request.
		var catEntryArray = [];
		catEntryArray = form.catEntryIDS.value.toString().split(",");
		var bundleItemsCount = 1;
		for(var i = 0; i < catEntryArray.length; i++){
			var qty = document.getElementById("quantity_" + catEntryArray[i]).value;
			var catEntryId = catEntryArray[i];
			if(this.selectedProducts[catEntryArray[i]])
				catEntryId = this.getCatalogEntryIdforProduct(this.selectedProducts[catEntryArray[i]]);
			if(qty==0 || qty == null) qty = 1;
			if(qty!=null && qty !== '' && catEntryId!=null){
				var input1 = document.createElement("input");
				$(input1).attr("id", "OrderItemAddForm_catEntryId_"+catEntryId);
				$(input1).attr("type", "hidden");
				$(input1).attr("name", "catEntryId_"+bundleItemsCount);
				$(input1).attr("value", catEntryId);
				bundleItemsCount = bundleItemsCount + 1;
				form.appendChild(input1);
			}else{
				MessageHelper.displayErrorMessage(MessageHelper.messages['ERR_RESOLVING_SKU']);
				return;
			}
		}
		var input2 = document.createElement("input");
		$(input2).attr("id", "OrderItemAddForm_catEntryId_"+associatedItemId);
		$(input2).attr("type", "hidden");
		$(input2).attr("name", "catEntryId_"+bundleItemsCount);
		$(input2).attr("value", associatedItemId);
		form.appendChild(input2);
		var quantity1 = document.createElement("input");
		$(quantity1).attr("id", "OrderItemAddForm_quantity_"+associatedItemId);
		$(quantity1).attr("type", "hidden");
		$(quantity1).attr("name", "quantity_"+bundleItemsCount);
		$(quantity1).attr("value", quantity);
		form.appendChild(quantity1);
		form.URL.value = "AjaxOrderItemDisplayView";
		this.isParentBundleBean = false;
	}else{
		form.catEntryId_2.value = associatedItemId;
		form.productId_2.value = associatedItemId;
		form.quantity_2.value = quantity;
	}

	//For Handling multiple clicks
	if(!submitRequest()){
		return;
	}
	
	// submit the form to add the items to the shop cart.
	processAndSubmitForm(form);
	this.merchandisingProductAssociationForm = "";
	},

	/** 
	* Sets the orderID if it is not already set on the Current Order page. 
	* The order ID is used to determine which order to act upon such as in the case of replacing an order item in an order.
	* 
	* @param {String} orderId The orderID to use.
	*/
	setOrderId : function(orderId) {
		this.orderId = orderId;
	},

	/**
	 * Resolves the SKU and adds the item to a new requisition list.
	 *  
	 * @param {String} entitledItemId The catalog entry ID of the item to add to the requisition list.
	 * @param {String} quantityElemId The ID of the Quantity field.
	 * @param {String} currentPage The URL of the current page. When a customer clicks Cancel on the requisition list creation page, they are redirected to the current page.
	 */
	addToNewListFromProductDetail:function (entitledItemId,quantityElemId,currentPage) {
		MessageHelper.hideAndClearMessage();
		var entitledItemJSON;

		if ($("#" + entitledItemId).length) {
			//the json object for entitled items are already in the HTML. 
			 entitledItemJSON = eval('('+ $("#" + entitledItemId).html() +')');
		}else{
			//if $("#" + entitledItemId).length is 0, that means there's no <div> in the HTML that contains the JSON object. 
			//in this case, it must have been set in catalogentryThumbnailDisplay.js when the quick info
			entitledItemJSON = this.getEntitledItemJsonObject(); 
		}
		this.setEntitledItems(entitledItemJSON);
		var catalogEntryId = this.getCatalogEntryId();
		if(catalogEntryId!=null){
			this.addItemToNewListFromProductDetail(catalogEntryId, quantityElemId, currentPage);
		}
		else{
			MessageHelper.displayErrorMessage(MessageHelper.messages['ERR_RESOLVING_SKU_REQ_LIST']);
			//Close the quick info pop-up if it exists
			if($('#second_level_category_popup').length){
				hidePopup('second_level_category_popup');
			}
			return;
		}
	},
	
	/**
	 * Adds the item to a new requisition list.
	 *  
	 * @param {String} catalogEntryId The resolved catalog entry ID of the item to add to the requisition list.
	 * @param {String} quantityElemId The ID of the Quantity field.
	 * @param {String} currentPage The URL of the current page. When a customer clicks Cancel on the requisition list creation page, they are redirected to the current page.
	 */
	addItemToNewListFromProductDetail:function (catalogEntryId,quantityElemId,currentPage) {
		MessageHelper.hideAndClearMessage();
		if(catalogEntryId!=null){
			var quantity = $("#" + quantityElemId).val()
			if (quantity == null || quantity === "" || quantity<=0 || !RequisitionList.isNumber(quantity)) {
				MessageHelper.displayErrorMessage(MessageHelper.messages['QUANTITY_INPUT_ERROR']);
				//Close the quick info pop-up if it exists
				if($('#second_level_category_popup').length){
					hidePopup('second_level_category_popup');
				}
				return;
			}

			var URL = "AjaxLogonForm?page=createrequisitionlist";
			
			//using the form because the previousPage url can be very long
			var formObj = document.createElement("form");
			$(formObj).attr("method", "POST");
			
			var input = document.createElement("input");
			$(input).attr("type", "hidden");
			$(input).attr("value", currentPage);
			$(input).attr("name", "previousPage");
			formObj.appendChild(input);
			
			formObj.action = URL + "&catEntryId="+catalogEntryId +"&quantity="+quantity+ "&storeId=" + this.storeId +"&catalogId=" + this.catalogId + "&langId=" + this.langId;
			
			document.body.appendChild(formObj); // have to add this form to the body node before submitting.
			processAndSubmitForm(formObj);
		}
		else{
			MessageHelper.displayErrorMessage(MessageHelper.messages['ERR_RESOLVING_SKU_REQ_LIST']);
		}
	},
	
	/**
	 * Adds the bundle to a new requisition list.
	 *  
	 * @param {form} form The form that contains all of the inputs for the bundle.
	 * @param {String} currentPage The URL of the current page. When a customer clicks Cancel on the requisition list creation page, they are redirected to the current page.
	 */
	addBundleToNewListFromProductDetail:function (form,currentPage) {
		var productCount = form["numberOfProduct"].value;
		var URL = "AjaxLogonForm?page=createrequisitionlist";
		
		for(var i = 1; i <= productCount; i++){
			var catEntryId = form["catEntryId_" + i].value;
			if(this.selectedProducts[catEntryId]) {
				catEntryId = this.getCatalogEntryIdforProduct(this.selectedProducts[catEntryId]);
			}
			
			var qty = form["quantity_" + i].value;
			if(qty == null || qty === "" || qty<=0 || !RequisitionList.isNumber(qty)){ 
				MessageHelper.displayErrorMessage(MessageHelper.messages['QUANTITY_INPUT_ERROR']); 
				return;
			} else if(catEntryId!=null){
				URL = URL + "&catEntryId=" + catEntryId + "&quantity=" + qty;
			} else{
				MessageHelper.displayErrorMessage(MessageHelper.messages['ERR_RESOLVING_SKU_REQ_LIST']);
				return;
			}
		}
		
		var input = document.createElement("input");
		$(input).attr("type", "hidden");
		$(input).attr("value", currentPage);
		$(input).attr("name", "previousPage");
		form.appendChild(input);
		
		URL = URL +"&numberOfProduct="+form.numberOfProduct.value+ "&storeId=" + this.storeId +"&catalogId=" + this.catalogId + "&langId=" + this.langId; 
		form.action=URL;
		processAndSubmitForm(form);
	},
	
	/**
	* Sets the currentPageType variable. 
	* This variable determines the type of catalog pages that are being viewed, such as product or item pages.
	*
	* @param {Boolean} pageType Indicates the type of catalog page viewed by the customer.
	*
	**/
	setCurrentPageType:function(pageType){
		this.currentPageType = pageType;
	},
	
	/**
	* Sets the currentCatalogEntryId variable. 
	* This variable stores the catalogEntryId of the catalog item being viewed.
	*
	* @param {Boolean} catalogEntryId The ID of the new catalog item viewed by the customer.
	*
	**/
	setCurrentCatalogEntryId:function(catalogEntryId){
		this.currentCatalogEntryId = catalogEntryId;
	},
	
	/**
	 * Submits a category subscription request by invoking the AjaxCategorySubscribe service.
	 * 
	 * @param {String} formId The form Id.
	 */
	handleCategorySubscription:function(formId){
		var form = document.forms[formId];
		var params = {
			DM_ReqCmd: form.DM_ReqCmd.value,
			storeId: form.storeId.value,
			catalogId: form.catalogId.value,
			langId: form.langId.value,
			categoryId: form.categoryId.value
		};
		if(!submitRequest()){
			return;
		}
		cursor_wait();
		wcService.invoke("AjaxCategorySubscribe", params);
	}
}
		
		
	
//-----------------------------------------------------------------
// Licensed Materials - Property of IBM
//
// WebSphere Commerce
//
// (C) Copyright IBM Corp. 2008, 2015 All Rights Reserved.
//
// US Government Users Restricted Rights - Use, duplication or
// disclosure restricted by GSA ADP Schedule Contract with
// IBM Corp.
//-----------------------------------------------------------------

	/** 
	 * @fileOverview This file contains all the global variables and JavaScript functions needed by the compare product page and the compare zone. 
	 */

	/**
	 * @class The functions defined in the class are used for comparing products. 
	 *
	 * This compareProductJS class defines all the variables and functions for the page that uses the comparison functionality in the store.
	 * The compare zone in the right side bar is a place holder that accepts a maximum of 4 products to compare.
	 * The compare product display page compares various products' attributes side-by-side.
	 *
	 */
	compareProductJS={
		
		/**
		 * The langId is a string to store the current language identifier of the store.
		 */
		langId: "-1",

		/**
		 * The storeId is a string to store the current store identifier of the store.
		 */
		storeId: "",

		/**
		 * The catalogId is a string to store the current catalog identifier of the store.
		 */
		catalogId: "",
		
		/**
		* The compareReturnName is a string to store the current name of the category from where the compare link was clicked
		*/
		compareReturnName: "",
		
		/**
		* The returnUrl is a string to store the url of the category from where the compare link was clicked
		*/
		returnUrl: "",
		
		/**
		 * The prefix of the cookie key that is used to store item Ids. 
		 */
		cookieKeyPrefix: "CompareItems_",
		
		/**
		 * The delimiter used to separate item Ids in the cookie.
		 */
		cookieDelimiter: ";",
		
		/**
		 * The maximum number of items allowed in the compare zone. 
		 */
		maxNumberProductsAllowedToCompare: 4,

					
		/**
		 * Sets the common parameters used in all service calls like langId, storeId and catalogId.
		 * @param {String} langId The language Id.
		 * @param {String} storeId The store Id.
		 * @param {String} catalogId The catalog Id.
		 * @param {String} compareReturnName The return page name
		 * @param {String} returnUrl The url of the return page to go back
		 */
		setCommonParameters:function(langId,storeId,catalogId, compareReturnName, returnUrl){
			this.langId = langId;
			this.storeId = storeId;
			this.catalogId = catalogId;
			this.compareReturnName = compareReturnName;
			this.returnUrl = decodeURIComponent(returnUrl);
		},
		
		
		/**
		 * This function clears items in the compare zone.
		 */
		clear: function(){
			MessageHelper.hideAndClearMessage();
			var cookieKey = this.cookieKeyPrefix + this.storeId;
			setCookie(cookieKey, '', {path:'/', domain:cookieDomain});
			
			$.remove('#compareDropZoneImgDiv');
			if($("#compareDropZoneImg").length){
				$('#compareDropZoneImg').css('display', 'block');
			}
			
			if($("#compareProductPage").length){
				if($("#compareProductPage").val()){
					var url = "CompareProductsDisplay?storeId=" + this.storeId + "&catalogId=" + this.catalogId + "&langId=" + this.langId 
						+ "&compareReturnName=" + this.compareReturnName + "&returnUrl=" + encodeURIComponent(appendWcCommonRequestParameters(this.returnUrl));
					document.location.href=appendWcCommonRequestParameters(url);
				}
			}
			MessageHelper.displayStatusMessage(MessageHelper.messages["COMPARE_ITEMS_CLEAR"]);
		},
	
		/**
		 * Removes an item from the products compare page.
		 * @param {String} key The Id of the item to remove.
		 */
		remove: function(key){
			var cookieKey = this.cookieKeyPrefix + this.storeId;
			var cookieValue = getCookie(cookieKey);
			if(cookieValue != null){
				if($.trim(cookieValue) == ""){
					setCookie(cookieKey, null, {expires: -1});
				}else{
					var cookieArray = cookieValue.split(this.cookieDelimiter);
					var newCookieValue = "";
					for(index in cookieArray){
				if(cookieArray[index] != key){
					if(newCookieValue === ""){
						newCookieValue = cookieArray[index];
					}else{
						newCookieValue = newCookieValue + this.cookieDelimiter + cookieArray[index]
					}
				}
					}
					setCookie(cookieKey, newCookieValue, {path:'/', domain:cookieDomain});
				}
				this.compareProducts();
			}
		},
		
		
		/**
		 * Adds an item to the compare zone.
		 * @param {string} catEntryIdentifier The Id of the catalog entry to add.
		 */
		Add2CompareAjax:function(catEntryIdentifier , dragImagePath , url , dragImageDescription){
			MessageHelper.hideAndClearMessage();
			if($("#compareProductParentId_" + catEntryIdentifier).length && document.getElementById("compareProductParentId_"+catEntryIdentifier)!=undefined){
				catEntryIdentifier = document.getElementById("compareProductParentId_"+catEntryIdentifier).value;	
			}
			var cookieKey = this.cookieKeyPrefix + this.storeId;
			var cookieValue = getCookie(cookieKey);
			
			if(cookieValue != null){
				if(cookieValue.indexOf(catEntryIdentifier) !== -1 || catEntryIdentifier == null){
					MessageHelper.displayErrorMessage(MessageHelper.messages["COMPARE_ITEM_EXISTS"]);
					return;
				}
			}
			
			var currentNumberOfItemsInCompare = 0;
			if(cookieValue != null && cookieValue !== ""){
				currentNumberOfItemsInCompare = cookieValue.split(this.cookieDelimiter).length;
			}
			
			if (currentNumberOfItemsInCompare < parseInt(this.maxNumberProductsAllowedToCompare)) {
				var newCookieValue = "";
				if(cookieValue == null || cookieValue === ""){
					newCookieValue = catEntryIdentifier;
				}else{
					newCookieValue = cookieValue + this.cookieDelimiter + catEntryIdentifier;
				}
				setCookie(cookieKey, newCookieValue, {path:'/', domain:cookieDomain});					
				
				if (0==currentNumberOfItemsInCompare) {
					$('#compareDropZoneImg').css('display', 'none');
					/* Initialize DOM of compare zone */
					$("#compareZone").after("<div id='compareDropZoneImgDiv' style='width:100%'><table><tbody id='compareItemsTable'><tr id='compareRow'></tr></tbody></table></div>");	
				}

				if ($("#compareDropZoneImgDiv").length){
					/* Build the inner HTML to display the items in the compare zone. */
					var itemHTML = 	('<td id="compareCatentry'+catEntryIdentifier+'"><div id="compareCatentryContainer'+catEntryIdentifier+'">'+
									'<div id="compare_img_'+catEntryIdentifier+'" class="compare_img">'+
										'<a id="imgcatBrowseCompare_Item_'+catEntryIdentifier+'" href="'+url+'">'+
											'<img height="40" width="40" border="0" alt="'+dragImageDescription+'" title="'+dragImageDescription+'" src="'+dragImagePath+'"></img>\n'+
										"</a></div>"+
									'<div id="compare_info_'+catEntryIdentifier+'" class="compare_info">'+
										'<div id="compare_product_desc_'+catEntryIdentifier+'" class="compare_product_desc">'+
											dragImageDescription+
										"</div></div></div></td>").replace(/\"/g,"'").replace(/\r|\n|\r\n|\n\r/g, "");				
					
					$("#compareRow").after(itemHTML);
				}

				if($("#compareProductPage").length && document.getElementById("compareProductPage") != 'undefined'){
					if($("#compareProductPage").val()){
						this.compareProducts();
					}
				}
				MessageHelper.displayStatusMessage(MessageHelper.messages["COMPAREZONE_ADDED"]);
			} else {
				MessageHelper.displayErrorMessage(MessageHelper.messages["COMPATE_MAX_ITEMS"]);
			}
		},

		/**
		 * Re-directs the browser to the CompareProductsDisplay page to compare products side-by-side.
		 */
		compareProducts:function(){
			var url = "CompareProductsDisplay?storeId=" + this.storeId + "&catalogId=" + this.catalogId + "&langId=" + this.langId + "&compareReturnName=" + this.compareReturnName;
			
			var cookieKey = this.cookieKeyPrefix + this.storeId;
			var cookieValue = getCookie(cookieKey);
			if(Utils.notNullOrWhiteSpace(cookieValue)){
				var cookieArray = cookieValue.split(this.cookieDelimiter);
				for(index in cookieArray){
					url = url + "&catentryId=" + cookieArray[index];
				}
			}
			url = appendWcCommonRequestParameters(url) + "&returnUrl=" + encodeURIComponent(appendWcCommonRequestParameters(this.returnUrl));
			document.location.href = getAbsoluteURL() + url;
		},
		
		
		
		/**
		 * Initializes the compare zone as a drop target and loads the product images for all the products in the compare zone.
		 */
		init:function(){

			 wcTopic.subscribe("/dnd/drop", function(source, nodes, copy, target){
				if (source != target) {
					target.deleteSelectedNodes();
				}
				var productDisplayPath="";
				var imgPath="";
				var imgDescription="";
				var sourceId = source.parent.id;
					
				if(target.parent.id=='compareZone'){
					if(getCookie('coShoppingDisableDnd')!=undefined && getCookie('coShoppingDisableDnd') == 'true') {
						wcTopic.publish("/wc/collaboration/dndDisabled",[]);

						return;
					}
					
	  			    var indexOfIdentifier = sourceId.indexOf("_",0);
	                if ( indexOfIdentifier >= 0) {
				        /* remove the prefix including the "underscore". */
					   sourceId = sourceId.substring(indexOfIdentifier+1);
	                }
					if($("#compareImgPath_" + sourceId).length && document.getElementById("compareImgPath_"+sourceId)!=undefined){
						imgPath = document.getElementById("compareImgPath_"+sourceId).value;
					}
	                if($("#compareProductDetailsPath_" + sourceId).length && document.getElementById("compareProductDetailsPath_"+sourceId)!=undefined){
						productDisplayPath=document.getElementById("compareProductDetailsPath_"+sourceId).value;
					}
	                if($("#compareImgDescription_" + sourceId).length && document.getElementById("compareImgDescription_"+sourceId)!=undefined){
						imgDescription = document.getElementById("compareImgDescription_"+sourceId).value;	
	                }
					if($("#compareProductParentId_" + sourceId).length && document.getElementById("compareProductParentId_"+sourceId)!=undefined){
							sourceId = document.getElementById("compareProductParentId_"+sourceId).value;	
					}
	                compareProductJS.Add2CompareAjax(sourceId,imgPath,productDisplayPath,imgDescription);
				}
			});
			var cookieKey = this.cookieKeyPrefix + this.storeId;
			var cookieValue = getCookie(cookieKey);
		}
	}	
	
//-----------------------------------------------------------------
// Licensed Materials - Property of IBM
//
// WebSphere Commerce
//
// (C) Copyright IBM Corp. 2008, 2016 All Rights Reserved.
//
// US Government Users Restricted Rights - Use, duplication or
// disclosure restricted by GSA ADP Schedule Contract with
// IBM Corp.
//-----------------------------------------------------------------

/**
 * @fileOverview This file provides utility functions for the order check-out pages.
 */

/**
 * The functions defined in this class are used for managing order information update during check-out.
 *
 * @class This CheckoutHelperJS class defines all the variables and functions for the page(s) used in the check-out process to udpate order related information, such as address, shipping method, shipping instruction, etc.
 *
 */

CheckoutHelperJS = {

    /* Global variable declarations */

    /**
     * This variable stores the ID of the language that the store currently uses. Its default value is set to -1, which corresponds to United States English.
     * @private
     */
    langId: "-1",

    /**
     * This variable stores the ID of the current store. Its default value is empty.
     * @private
     */
    
    storeId: "",

    /**
     * This variable stores the ID of the catalog. Its default value is empty.
     * @private
     */
    catalogId: "",

    /**
     * This variable stores the ID of the order, in case the current shopping cart is not being used. Its default value is empty.
     */
    orderId: "",

    /**
     * This variable stores the shipment type, either 1 for single shipment or 2 for multiple shipment. Its default value is set to empty.
     * @private
     */
    shipmentTypeId: "",


    /**
     * This array stores the item IDs in an order. It is used to save the item IDs before an address is edited or created during the order check-out.
     * @private
     */
    orderItemIds: [],

    /**
     * This constant stores the amount of time in milliseconds that the <code>updateCartWait</code> function needs to wait before updating the shopping cart.
     * @private
     * @constant
     * @see CheckoutHelperJS.updateCartWait
     */
    updateWaitTimeOut: 1500,

    /**
     * This array stores the number of key press events after a shopper has modified the quantity of an item in the shopping cart.
     * @private
     * @see CheckoutHelperJS.updateCartWait
     */
    keyPressCount: {},

    /**
     * This variable stores the true/false value that indicates if the 'SinglePageCheckout' feature is enabled/disabled.
     * When it is true, both shipping and billing information are captured in a single page. If it is false, checkout will
     * be a two step process where shipping is captured in first step and billing in second step.
     * It is set to true by default.
     *
     * @private
     */
    singlePageCheckout: true,

    /**
     * This array stores the address ID before it is updated by the user during the order check-out.
     * @private
     */
    selectedAddressesArray: {},

    /**
     * This array stores the values that indicate if the payment method input in a payment area has been changed by the user.
     *
     * @private
     */
    dataDirty: {},

    /**
     * This variable stores a value that indicates if the value of a shipping information related input field or the quantity of an item has been changed by the user.
     * Its default value is set to false.
     *
     * @private
     */
    fieldDirtyFlag: false,

    /**
     * This constant stores the String value representing a date that the service understands to reset a requested shipping date.
     * @private
     * @constant
     */
    resetRequestedShipDateValue: "1970-01-01T00:00:00.000Z",

    /**
     * This variable stores the value that indicates if the current page is the Shopping Cart page. It is used to determine what page to redirect to after a service call has been successfully performed.
     *
     * @private
     */
    shoppingCartPage: false,

    /**
     * This variable stores the value that indicates if the current page is the pending order details page. It is used to determine what page to redirect to after a service call has been successfully performed.
     *
     * @private
     */
    pendingOrderDetailsPage: false,

    /**
     * This variable stores the value that indicates if the requested shipping date has recently been updated. It is used to determine if certain area of the page needs to be refreshed.
     */
    RequestShippingDateAction: false,

    /**
     * Indicates whether the ShippingChargeType flexflow is enabled.
     */
    shipChargeEnabled: false,

    /**
     * The order ID.
     */
    tempOrderId: "",
    /**
     * The type of the current user.
     */
    tempUserType: "",
    /**
     * The list of emails spearated by space. Order confirmation will be sent to these emails.
     */
    tempEmailAddresses: "",
    /**
     * Indicates whether it is a Quote that is being checked out.
     */
    tempIsQuote: false,

    /**
     * The current order total.
     */
    tempOrderTotal: "0",

    /**
     * The payment instructions allocated in the order.
     */
    tempPaymentInstructions: {},
    lastAddressLinkIdToFocus: "",
    lastFocusId: "",
    setLastFocus: function (id) {
        this.lastFocusId = id;
    },
    getLastFocus: function () {
        return this.lastFocusId;
    },
    tabPressed: function (event) {
        if (event.keyCode == 9) {
            tabPressed = true;
        }
    },
    setLastAddressLinkIdToFocus: function (lastLinkId) {
        this.lastAddressLinkIdToFocus = lastLinkId;
    },
    getLastAddressLinkIdToFocus: function () {
        return this.lastAddressLinkIdToFocus;
    },

    /**
     * Indicates whether the order is prepared already or not.
     */
    orderPrepared: "false",

    /**
     * Sets the orderPrepared variable to indicate whether the order has been through the OrderPrepare command or not. An order must be prepared before it can be submitted.
     *
     * @param {Boolean} inPrepareIndicator Whether or not the order has been prepared.
     */
    setOrderPrepared: function (inPrepareIndicator) {
        this.orderPrepared = inPrepareIndicator;
    },

    /**
     * Returns whether or not the order is prepared.
     */
    isOrderPrepared: function () {
        return this.orderPrepared;
    },

    /**
     * Save some variables needed for re-calling checkoutOrder method after a service call.
     *
     * @param {Integer} orderId The order ID.
     * @param {String} userType The type of the current user.
     * @param {String} addressListForMailNotification The list of emails spearated by space. Order confirmation will be sent to these emails.
     * @param {boolean} isQuote Optional parameter which indicates whether it is a Quote that is being checked out. If this parameter is not passed then it defaults to false.
     */
    saveCheckoutOrderParameters: function (orderId, userType, addressListForMailNotification, isQuote) {
        this.tempOrderId = orderId;
        this.tempUserType = userType;
        this.tempEmailAddresses = addressListForMailNotification;
        this.tempIsQuote = isQuote;
    },

    /**
     * Sets some internal variables needed for verifying order totals.
     *
     * @param {Object} orderTotal The current order total.
     * @param {Object} paymentInstructions The currently allocated payment instructions for the order.
     */
    setOrderPayments: function (orderTotal, paymentInstructions) {
        this.tempOrderTotal = orderTotal + 0;
        this.tempPaymentInstructions = paymentInstructions;
    },

    /**
     * Returns whether or not the order total amount has been fully allocated with payment instructions.
     */
    isOrderPaymentFullyAllocated: function () {
        var allocatedAmount = 0;
        if (this.tempPaymentInstructions.paymentInstruction != null && this.tempPaymentInstructions.paymentInstruction.length >= 1) {
            for (var i = 0; i < this.tempPaymentInstructions.paymentInstruction.length; i++) {
                allocatedAmount = allocatedAmount + parseFloat(this.tempPaymentInstructions.paymentInstruction[i].piAmount);
            }
        }

        if (allocatedAmount == this.tempOrderTotal) {
            return true;
        } else {
            var roundedAllocatedAmount = allocatedAmount.toFixed(2);
            var roundedTempOrderTotal = this.tempOrderTotal.toFixed(2);
            if (roundedAllocatedAmount == roundedTempOrderTotal) {
                return true;
            } else {
                if (allocatedAmount < this.tempOrderTotal) {
                    MessageHelper.displayErrorMessage(MessageHelper.messages["EDPPaymentMethods_CANNOT_RECONCILE_PAYMENT_AMT"]);
                    return false;
                } else if (allocatedAmount > this.tempOrderTotal) {
                    MessageHelper.displayErrorMessage(MessageHelper.messages["EDPPaymentMethods_PAYMENT_AMOUNT_LARGER_THAN_ORDER_AMOUNT"]);
                    return false;
                } else {
                    MessageHelper.displayErrorMessage(MessageHelper.messages["EDPPaymentMethods_PAYMENT_AMOUNT_PROBLEM"]);
                    return false;
                }
            }
        }
    },

    /**
     * Returns the value of the internal variable with that name.
     *
     * @param {Object} paramName The value of the internal parameter.
     */
    getSavedParameter: function (paramName) {
        return this[paramName];
    },

    /**
     * Sets the ShipChargeEnabled variable to indicate whether the ShippingChargeType feature is enabled.
     *
     * @param {Boolean} enabled This parameter is set to true if the ShippingChargeType feature is enabled.
     */
    setShipChargeEnabled: function (enabled) {
        this.shipChargeEnabled = enabled;
    },

    /**
     * This function updates the input associative array params with the input key-value pair.
     * If the toArray value is true, this function creates an associative array for duplicate entries; otherwise it overwrites the existing array.
     * The function is used for updating input parameters before passing them to a service call.
     *
     * @param {Array} params The associative array to update.
     * @param {String} key The key to search for in the array.
     * @param {String} value The new value to update with when the key has been found in the array.
     * @param {Boolean} toArray If the value is true, then the function creates a new array for duplicate entries. If the value is false, no new array will be created, the existing array will be overwritten.
     * @param {Integer} index The index in the array in which the value should be updated.
     *
     * @returns {Array} params The updated associative array.
     */
    updateParamObject: function (params, key, value, toArray, index) {
        if (params == null) {
            params = [];
        }

        if (params[key] != null && toArray) {
            if ($.isArrayLike(params[key])) {
                //3rd time onwards
                if (index != null && index != "") {
                    //overwrite the old value at specified index
                    params[key][index] = value;
                } else {
                    params[key].push(value);
                }
            } else {
                //2nd time
                var tmpValue = params[key];
                params[key] = [];
                params[key].push(tmpValue);
                params[key].push(value);
            }
        } else {
            //1st time
            if (index != null && index != "" && index != -1) {
                //overwrite the old value at specified index
                params[key + "_" + index] = value;
            } else if (index == -1) {
                var i = 1;
                while (params[key + "_" + i] != null) {
                    i++;
                }
                params[key + "_" + i] = value;
            } else {
                params[key] = value;
            }
        }
        return params;
    },


    /**
     * This function shows or hides the request shipping date input field depending on the state of the corresponding checkbox.
     * If the checkbox is unchecked, the <code>OrderItemAddressShipMethodUpdate</code> service will be called to update the shipping information.
     *
     * @param {String} checkBoxName The ID of the request shipping date checkbox.
     * @param {String} divName The name of the div element that contains the request shipping date input field.
     * @param {String} suffix The suffix that is appended after the divName. It is usually the order item ID.
     */
    checkRequestShippingDateBox: function (checkBoxName, divName, suffix) {
        var thisCheckBoxName;
        var thisDivName;

        if (suffix != null && suffix != "") {
            checkBoxName = checkBoxName + "_" + suffix;
            divName = divName + "_" + suffix;
        }

        var checkBox = $("#" + checkBoxName)[0];

        if (checkBox.checked) {
            $("#" + divName).css("visibility", "visible");
            $("#" + divName).css("display", "block");
        } else {
            // If the checkbox is unchecked, hide the input field
            $("#" + divName).css("visibility", "hidden");
            $("#" + divName).css("display", "none");
            if (this.shipmentTypeId == "1") {
                $("#requestedShippingDate").blur();
            } else if (this.shipmentTypeId == "2") {
                $("#MS_requestedShippingDate_" + suffix).blur();
            }
        }

        var addressId, shipModeId = "";
        if (this.shipmentTypeId == "1") {
            addressId = document.getElementById("singleShipmentAddress").value;
            shipModeId = document.getElementById("singleShipmentShippingMode").value;
        } else if (this.shipmentTypeId == "2") {
            addressId = document.getElementById("MS_ShipmentAddress_" + suffix).value;
            shipModeId = document.getElementById("MS_ShippingMode_" + suffix).value;
        } else {
            console.debug("shipmentTypeId is undefined. Single shipment has Id 1; multiple shipment has Id 2.");
        }

        // Delete the requestedShippingDate if the checkBox is unchecked
        if (!checkBox.checked) {
            var params = [];
            params["storeId"] = this.storeId;
            params["catalogId"] = this.catalogId;
            params["langId"] = this.langId;
            params.orderId = ".";

            this.updateParamObject(params, "addressId", addressId, false, -1);
            this.updateParamObject(params, "shipModeId", shipModeId, false, -1);

           if($("#requestedShippingDate") != null || $("#MS_requestedShippingDate_" + suffix) != null){
				if(this.shipmentTypeId == "1") {
					params["requestedShipDate"] = this.resetRequestedShipDateValue;
				} else {
					this.updateParamObject(params, "requestedShipDate", this.resetRequestedShipDateValue, false, -1);
				}
			}

            var orderItemId = null;
            var qty = -1;
            var totalItems = document.getElementById("totalNumberOfItems").value;
            for (var i = 0; i < totalItems; i++) {
                if (document.getElementById("qty_" + (i + 1)) != null) {
                    qty = document.getElementById("qty_" + (i + 1)).value;
                }
                orderItemId = document.getElementById("orderItem_" + (i + 1)).value;
                // we need atleast one orderItemId..this is the limitation of order service..
                if (qty != -1) {
                    if (this.shipmentTypeId == "1") {
                        // Single Shipment
                        this.updateParamObject(params, "orderItemId", orderItemId, false, -1);
                        break;
                    } else if (this.shipmentTypeId == "2") {
                        // Multiple Shipment
                        if (suffix != null && suffix != "" && orderItemId == suffix) {
                            this.updateParamObject(params, "orderItemId", orderItemId, false, -1);
                            break;
                        }
                    } else {
                        console.debug("shipmentTypeId is undefined. Single shipment has Id 1; multiple shipment has Id 2.");
                    }
                }
            }

            //For handling multiple clicks
            if (!submitRequest()) {
                return;
            }
            cursor_wait();
            CheckoutHelperJS.RequestShippingDateAction = true;
            wcService.invoke("OrderItemAddressShipMethodUpdate", params);
        }
    },


    /**
     * This function shows or hides the shipping instruction input field depending on the state of the corresponding checkbox.
     * If the checkbox is unchecked, the <code>OrderShippingInfoUpdate</code> service will be called to update the shipping information.
     * Note that order items that have the same ship-to address and shipping method will share the same shipping instruction.
     *
     * @param {String} checkBoxName The ID of the shipping instruction checkbox.
     * @param {String} divName The name of the div element that contains the shipping instruction input field.
     * @param {String} suffix The suffix that is appended after the divName. It is usually the order item ID.
     */
    checkShippingInstructionsBox: function (checkBoxName, divName, suffix) {
        //var divName = "shippingInstructionsDiv";
        var thisCheckBoxName;
        var thisDivName;

        if (suffix != null && suffix != "") {
            thisCheckBoxName = checkBoxName + "_" + suffix;
            thisDivName = divName + "_" + suffix;
        } else {
            thisCheckBoxName = checkBoxName;
            thisDivName = divName;
        }

        var thisCheckBox = $("#" + thisCheckBoxName)[0];

        if (thisCheckBox.checked) {
            $("#" + thisDivName).css("visibility", "visible");
            $("#" + thisDivName).css("display", "block");
        } else {
            // If the checkbox is unchecked, hide the input field
            $("#" + thisDivName).css("visibility", "hidden");
            $("#" + thisDivName).css("display", "none");
        }

        // Update other shipping instructions div with same addressId and shipModeId..
        var addressId, shipModeId = "";
        if (this.shipmentTypeId == "1") {
            addressId = document.getElementById("singleShipmentAddress").value;
            shipModeId = document.getElementById("singleShipmentShippingMode").value;
        } else if (this.shipmentTypeId == "2") {
            var orderItemId, tempAddressId, tempShipModeId = "";

            //get current div's shipModeId and addressId..
            addressId = document.getElementById("MS_ShipmentAddress_" + suffix).value;
            shipModeId = document.getElementById("MS_ShippingMode_" + suffix).value;

            var totalItems = document.getElementById("totalNumberOfItems").value;
            for (var i = 0; i < totalItems; i++) {
                if (document.getElementById("qty_" + (i + 1)) != null && document.getElementById("qty_" + (i + 1)).value != -1) {
                    orderItemId = document.getElementById("orderItem_" + (i + 1)).value;
                    tempAddressId = document.getElementById("MS_ShipmentAddress_" + orderItemId).value;
                    tempShipModeId = document.getElementById("MS_ShippingMode_" + orderItemId).value;
                    if (tempShipModeId == shipModeId && tempAddressId == addressId) {
                        var tempDivName = divName + "_" + orderItemId;
                        var tempCheckBoxName = checkBoxName + "_" + orderItemId;
                        if (thisCheckBox.checked) {
                            $(tempDivName).css("visibility", "visible");
                            $(tempDivName).css("display", "block");
                            $(tempCheckBoxName).attr("checked", "checked");
			    } 
                        else {
                            //User doesnt want to specify shipping instructions and requested ship date..hide this div..
                            $("#" + tempDivName).css("visibility", "hidden");
                            $("#" + tempDivName).css("display", "none");
                            $("#" + tempCheckBoxName).attr("checked", "");
                        }
                    }
                }
            }
        } else {
            console.debug("shipmentTypeId is undefined. Single shipment has Id 1; multiple shipment has Id 2.");
        }

        // Delete shippingInstructions if the checkBox is unchecked
        if (!thisCheckBox.checked) {
            var params = [];
            params["storeId"] = this.storeId;
            params["catalogId"] = this.catalogId;
            params["langId"] = this.langId;
            params.orderId = ".";

            var orderItemId = null;
            if (this.shipmentTypeId == "1") {
                if (document.getElementById("shipInstructions") != null) {
                    this.updateParamObject(params, "shipInstructions", "", false);
                    document.getElementById("shipInstructions").value = "";
                }
                orderItemId = document.getElementById("orderItem_1").value;
                this.updateParamObject(params, "addressId", addressId, false);
                this.updateParamObject(params, "orderItemId", orderItemId, false);

            } else if (this.shipmentTypeId == "2") {
                if (suffix != null && suffix != "") {
                    if (document.getElementById("MS_shipInstructions_" + suffix) != null) {
                        this.updateParamObject(params, "shipInstructions", "", false);
                        document.getElementById("MS_shipInstructions_" + suffix).value = "";
                    }
                    this.updateParamObject(params, "addressId", addressId, false, -1);
                    this.updateParamObject(params, "orderItemId", suffix, false);
                    this.setShippingInstuctionsForAllOtherItems(addressId, shipModeId, "");
                }
            } else {
                console.debug("shipmentTypeId is undefined. Single shipment has Id 1; multiple shipment has Id 2.");
            }

            //For handling multiple clicks
            if (!submitRequest()) {
                return;
            }
            cursor_wait();
            wcService.invoke("OrderShippingInfoUpdate", params);
        }
    },


    /**
     * This function sets the shipment type for the current page.
     *
     * @param {Integer} shipmentTypeId The shipment type ID, 1 for single shipment or 2 for multiple shipment.
     *
     * @see CheckoutHelperJS.getShipmentTypeId
     */
    initializeShipmentPage: function (shipmentTypeId) {
        this.shipmentTypeId = shipmentTypeId;
    },


    /**
     * This function sets the common parameters for the current page, i.e. language ID, store ID and catalog ID.
     *
     * @param {Integer} langId The ID of the language that the store currently uses.
     * @param {Integer} storeId The ID of the current store.
     * @param {Integer} catalogId The ID of the catalog.
     */
    setCommonParameters: function (langId, storeId, catalogId) {
        this.langId = langId;
        this.storeId = storeId;
        this.catalogId = catalogId;
    },


    /**
     * This function deletes an order item from the shopping cart.
     * If forWishlist is true, then the item is added to the wish list subsequently by calling the <code>AjaxDeleteOrderItemFromCart</code> service.
     *
     * @param {Integer} orderItemId The ID of the order item to delete.
     * @param {Boolean} forWishlist If the value is true, then the item is added to the wish list.
     */
    deleteFromCart: function (orderItemId, forWishlist) {
    	
        var params = [];
        params.storeId = this.storeId;
        params.catalogId = this.catalogId;
        params.langId = this.langId;
        params.orderId = (this.orderId != null && this.orderId != 'undefined' && this.orderId != "") ? this.orderId : ".";
        params.orderItemId = orderItemId;
        if (this.shoppingCartPage) {
            params.calculationUsage = "-1,-2,-5,-6,-7";
        } else {
            params.calculationUsage = "-1,-2,-3,-4,-5,-6,-7";
        }
        params.check = "*n";
        params.calculateOrder = "1";

        var x = document.getElementById("totalNumberOfItems").value;
        var y = x;
        //Now remove free items from this total number of items count..
        //x = total items and y = totalItems - totalFreeItems
        for (var i = 0; i < x; i++) {
            var qtyObj = document.getElementById("freeGift_qty_" + (i + 1));
            if (qtyObj != null || qtyObj != undefined) {
                qty = qtyObj.value;
                if (qty != null && qty != undefined && qty == -1) {
                    y = y - 1;
                }
            }

        }

        //For handling multiple clicks
        if (!submitRequest()) {
            return;
        }
        cursor_wait();
        if (y == 1) {
            wcService.invoke("AjaxDeleteOrderItem1", params);
        } else {
            if (forWishlist) {
                wcService.invoke("AjaxDeleteOrderItemFromCart", params);
            } else {
                if (this.shoppingCartPage || this.pendingOrderDetailsPage) {
                    wcService.invoke("AjaxDeleteOrderItem", params);
                } else {
                    wcService.invoke("AjaxDeleteOrderItemForShippingBillingPage", params);
                }
            }
        }
    },


    /**
     * This function is used to update the ship-to address ID of all items in the current order when the user chooses to add a new address during order check-out.
     * This function calls the <code>AjaxUpdateOrderItemsAddressId</code> service.
     *
     * @param {Integer} addressId The ID of the newly created address.
     */
    updateAddressIdOFItemsOnCreateEditAddress: function (addressId) {
        if (this.shipmentTypeId == "2" && this.orderItemIds.length == 0) {
            // If this is multiple shipment and none of the orderItems addressId is same as modified addressId, then no need make a service call.
            return;
        }
        var params = [];
        params.orderId = ".";
        params["storeId"] = this.storeId;
        params["catalogId"] = this.catalogId;
        params["langId"] = this.langId;
        params.calculationUsage = "-1,-2,-3,-4,-5,-6,-7";
        params.allocate = "***";
        params.backorder = "***";
        params.remerge = "***";
        params.check = "*n";
        params.calculateOrder = "1";
        if (this.shipmentTypeId == "1") {
            params.addressId = addressId;
        } else {
            var orderItemId = null;
            for (var i = 0; i < this.orderItemIds.length; i++) {
                orderItemId = this.orderItemIds[i];
                this.updateParamObject(params, "orderItemId", orderItemId, false, -1);
                this.updateParamObject(params, "addressId", addressId, false, -1);
            }
        }

        //For handling multiple clicks
        if (!submitRequest()) {
            return;
        }
        cursor_wait();
        wcService.invoke("AjaxUpdateOrderItemsAddressId", params);
    },


    /**
     * This function is used to save the current order items list when the user edits an existing address or creates a new address during order check-out.
     *
     * @param {Integer} orderItemId The order item ID.
     * @param {String} addressId The ID of the address.
     *
     * @private
     */
    saveOrderItemsList: function (orderItemId, addressId) {
        if (orderItemId == '-1') {
            //Creating or editing shipping address for single shipment, get all the orderItemIds in the order..

            var totalItems = document.getElementById("totalNumberOfItems").value;
            // if order item section is collapsed, we only have data for the first order item. And this is the case for single shipment so it
            // is ok just to update orderItem_1
            this.orderItemIds[0] = document.getElementById("orderItem_1").value;

        } else if (orderItemId == 0 && this.shipmentTypeId == "1") {
            // Editing or creating billing address.. If it's single shipment type, then we need to save all orderItem Id's.
            // If the shipping address is same as this billing address which is edited, then after editing this addressId will change, so we need to update the orderItemIds.

            if (document.getElementById("singleShipmentAddress")) {
                if (addressId == document.getElementById("singleShipmentAddress").value) {
                    var totalItems = document.getElementById("totalNumberOfItems").value;
                    for (var i = 0; i < totalItems; i++) {
                        this.orderItemIds[i] = document.getElementById("orderItem_" + (i + 1)).value;
                    }
                } else {
                    this.orderItemIds = [];
                }
            } else {
                this.orderItemIds = [];
            }
            return;
        } else {
            // OrderItemId is passed..so it's multiple shipment, get all the orderItemIds with the same address...
            // This section is for multiple shipment and create/edit both shipping/billing address...
            var totalItems = document.getElementById("totalNumberOfItems").value;
            var temp = null;
            var orderItemId = null;
            var j = 0;

            //saving orderItemIds (used by this.updateAddressIdOFItemsOnCreateEditAddress) for  the'edit address' link
            for (var i = 0; i < totalItems; i++) {
                orderItemId = document.getElementById("orderItem_" + (i + 1)).value;
                if (document.getElementById("MS_ShipmentAddress_" + orderItemId)) {
                    temp = document.getElementById("MS_ShipmentAddress_" + orderItemId).value;
                    //addressId is -1 if 'create address' is clicked. The following if will always return false in that case.
                    if (temp == addressId) {
                        //Add this to our list..
                        this.orderItemIds[j++] = orderItemId;
                    }
                }
            }
        }
    },


    /**
     * By convention, all items in an order that have the same shipping address and shipping mode share the same shipping instruction.
     * This function is used to update the shipping instruction of all items that have the same shipping address and shipping mode.
     *
     * @param {Integer} addressId The shipping address ID.
     * @param {Integer} shipModeId The shipping mode ID.
     * @param {String} shipInstructions The shipping instruction.
     */
    setShippingInstuctionsForAllOtherItems: function (addressId, shipModeId, shipInstructions) {

        var orderItemId, addressId1, shipModeId1 = "";
        var totalItems = document.getElementById("totalNumberOfItems").value;
        for (var i = 0; i < totalItems; i++) {
            if (document.getElementById("qty_" + (i + 1)) != null && document.getElementById("qty_" + (i + 1)).value != -1) {
                orderItemId = document.getElementById("orderItem_" + (i + 1)).value;
                addressId1 = document.getElementById("MS_ShipmentAddress_" + orderItemId).value;
                shipModeId1 = document.getElementById("MS_ShippingMode_" + orderItemId).value;
                if (shipModeId1 == shipModeId && addressId1 == addressId) {
                    document.getElementById("MS_shipInstructions_" + orderItemId).value = shipInstructions;
                }
            }
        }
    },


    /**
     * When a user toggles the 'ship as complete' checkbox, the same will be updated at the server side by invoking the <code>OrderShippingInfoUpdate</code> service.
     *
     * @param {DOM Element} checkBox The 'ship as complete' checkbox object.
     */
    shipAsComplete: function (checkBox) {
        var params = [];
        params.orderId = ".";
        params["storeId"] = this.storeId;
        params["catalogId"] = this.catalogId;
        params["langId"] = this.langId;
        params.calculationUsage = "-1,-2,-3,-4,-5,-6,-7";
        params.calculateOrder = "1";
        if (checkBox.checked) {
            this.updateParamObject(params, "ShipAsComplete", "true", true);
        } else {
            this.updateParamObject(params, "ShipAsComplete", "false", true);
        }
        orderItemId = document.getElementById("orderItem_1").value;
        this.updateParamObject(params, "orderItemId", orderItemId, false);

        //For handling multiple clicks
        if (!submitRequest()) {
            return;
        }
        cursor_wait();
        wcService.invoke("OrderShippingInfoUpdate", params);
    },


    /**
     * When there is an invalid address ID in an order, this function updates all items to use the valid address ID by invoking the <code>AjaxSetAddressIdOfOrderItems</code> service.
     *
     * @param {Integer} addressId A valid address ID.
     */
    updateAddressIdForOrderItem: function (addressId) {
        if (addressId == null || addressId.length == 0) {
            return true;
        }

        var params = [];
        params["storeId"] = this.storeId;
        params["catalogId"] = this.catalogId;
        params["langId"] = this.langId;
        params.orderId = ".";
        params.calculationUsage = "-1,-2,-3,-4,-5,-6,-7";
        params.allocate = "***";
        params.backorder = "***";
        params.remerge = "***";
        params.check = "*n";
        params.calculateOrder = "1";

        this.updateParamObject(params, "addressId", addressId, false);
        wcService.invoke("AjaxSetAddressIdOfOrderItems", params);
    },


    /**
     * When there is an invalid shipping mode ID in an order, this function updates all items to use the valid shipping mode ID by invoking the <code>AjaxSetShipModeIdForOrder</code> service.
     *
     * @param {Integer} shipModeId A valid shipping mode ID.
     */
    updateShipModeIdForOrder: function (shipModeId) {
        var params = [];
        params["storeId"] = this.storeId;
        params["catalogId"] = this.catalogId;
        params["langId"] = this.langId;
        params["shipModeId"] = shipModeId;
        params.calculationUsage = "-1,-2,-3,-4,-5,-6,-7";
        params.allocate = "***";
        params.backorder = "***";
        params.remerge = "***";
        params.check = "*n";
        params.calculateOrder = "1";
        wcService.invoke("AjaxSetShipModeIdForOrder", params);
    },

    /**
     * When there is an inconsistent requested ship date in an order when multiple shipment is disabled,
     * this function updates all items to use the the same date by invoking the <code>AjaxSetRequestedShipDateForOrder</code> service.
     *
     * @param {String} date The String representation of the requested ship date
     */
    updateRequestedShipDateForOrder: function (date) {
        params = [];
        params["storeId"] = this.storeId;
        params["catalogId"] = this.catalogId;
        params["langId"] = this.langId;
        params.orderId = ".";
        params.calculationUsage = "-1,-2,-3,-4,-5,-6,-7";
        params.allocate = "***";
        params.backorder = "***";
        params.remerge = "***";
        params.check = "*n";
        params.calculateOrder = "1";

        if (date != "") {
            this.updateParamObject(params, "requestedShipDate", date, false);
        } else {
            this.updateParamObject(params, "requestedShipDate", this.resetRequestedShipDateValue, false);
        }

        wcService.invoke("AjaxSetRequestedShipDateForOrder", params);
    },



    /**
     * This function is used to apply a promotion code to the order.
     *
     * @param {String} formName	The name of the promotion code entry form.
     * @param {String} returnView	The name of the view that the server should redirect the browser to after a promotion code is applied.
     */
    applyPromotionCode: function (formName, orderId) {
        var form = document.forms[formName];
       
        if (trim(form.promoCode.value) == "") {
            MessageHelper.formErrorHandleClient(form.promoCode.id, MessageHelper.messages["PROMOTION_CODE_EMPTY"]);
            return;
        }

		service = wcService.getServiceById('AjaxPromotionCodeManage');

		var params = [];
		params["taskType"] = "A";
		params["promoCode"] = trim(form.promoCode.value);
		params["storeId"] = WCParamJS.storeId;
		params["catalogId"] = WCParamJS.catalogId;
		params["langId"] = WCParamJS.langId;
		params["orderId"] = orderId;

		//For handling multiple clicks
		if (!submitRequest()) {
			return;
		}
		cursor_wait();
		wcService.invoke('AjaxPromotionCodeManage', params);
      
    },


    /**
     * This function is used to remove a promotion code from the order.
     *
     * @param {String} promoCode	The promotion code to remove.
     */
    removePromotionCode: function (promoCode, orderId) {
	
		var params = [];
		params["taskType"] = "R";
		params["promoCode"] = promoCode;
		params["storeId"] = WCParamJS.storeId;
		params["catalogId"] = WCParamJS.catalogId;
		params["langId"] = WCParamJS.langId;
		params["orderId"] = orderId;
                       
	   //For handling multiple clicks
		if (!submitRequest()) {
			return;
		}
		cursor_wait();
		wcService.invoke('AjaxPromotionCodeDelete',params);
        
    },


    /**
     * If a customer has a coupon in his/her coupon wallet that has not been applied to an order then this function can be used to apply that coupon to the current order.
     *
     * @param {String} formName The name of the form that performs the action to apply the coupon, and holds the parameters to pass to the service.
     * @param {String} returnView The view to return to after the request has been processed.
     * @param {Integer} couponId The unique ID of the coupon. This is set into the form to be sent to the service.
     */
    applyCoupon: function (formName, returnView, couponId) {
        var form = document.forms[formName];
        form.setAttribute('action', 'CouponsAddRemove');
        form.couponId.value = couponId;
        form.taskType.value = "A";

        //For handling multiple clicks
        if (!submitRequest()) {
            return;
        }

        service = wcService.getServiceById('AjaxCouponsAdd');
        service.setFormId(formName);
        cursor_wait();
        wcService.invoke('AjaxCouponsAdd');
    },


    /**
     * If a customer has a coupon in his/her coupon wallet that has been applied to an order then this function can be used to remove that coupon from the current order.
     *
     * @param {String} formName The name of the form that performs the action to remove the coupon from the order, and holds the parameters to pass to the service.
     * @param {String} returnView The view to return to after the request has been processed.
     * @param {Integer} couponId The unique ID of the coupon. This is set into the form to be sent to the service.
     */
    removeCouponFromOrder: function (formName, returnView, couponId) {
        var form = document.forms[formName];
        form.setAttribute('action', 'CouponsAddRemove');
        form.couponId.value = couponId;
        form.taskType.value = "R";

        //For handling multiple clicks
        if (!submitRequest()) {
            return;
        }

        service = wcService.getServiceById('AjaxCouponsRemove');
        service.setFormId(formName);
        cursor_wait();
        wcService.invoke('AjaxCouponsRemove');
    },


    /**
     * Sets the SinglePageCheckout variable to indicate if the 'SinglePageCheckout' feature is enabled or disabled.
     *
     * @param {Boolean} singlePageCheckout. A true/false value that indicates if the 'SinglePageCheckout' feature is enabled.
     *
     * @see CheckoutHelperJS.isSinglePageCheckout
     */
    setSinglePageCheckout: function (singlePageCheckout) {
        this.singlePageCheckout = singlePageCheckout;
    },


    /**
     * Returns the singlePageCheckout variable that indicates if the 'SinglePageCheckout' feature is enabled/disabled.
     *
     * @returns {Boolean} singlePageCheckout A true/false value that indicates if the 'SinglePageCheckout' feature is
     * enabled/disabled.
     *
     * @see CheckoutHelperJS.setSinglePageCheckout
     */
    isSinglePageCheckout: function () {
        return this.singlePageCheckout;
    },


    /**
     * This function is used to submit the order by invoking the <code>AjaxSubmitOrder</code> service.
     *
     * @param {Integer} orderId The order ID.
     * @param {String} userType The type of the current user.
     * @param {String} addressListForMailNotification The list of emails separated by space. Order confirmation will be sent to these emails.
     * @param {boolean} isQuote Optional parameter which indicates whether it is a Quote that is being checked out. If this parameter is not passed then it defaults to false.
     */
    checkoutOrder: function (orderId, userType, addressListForMailNotification, isQuote) {
        if (isQuote == undefined || isQuote == null) {
            isQuote = false;
        }

        if (!this.isOrderPaymentFullyAllocated()) {
            return;
        }

        if (this.isOrderPrepared() == "false") {
            this.saveCheckoutOrderParameters(orderId, userType, addressListForMailNotification, isQuote);
            wcService.invoke("AjaxPrepareOrderForSubmit");
            return;
        }

        params = [];
        params["orderId"] = orderId;
        params["notifyMerchant"] = 1;
        params["notifyShopper"] = 1;
        params["notifyOrderSubmitted"] = 1;
        params["storeId"] = this.storeId;
        params["catalogId"] = this.catalogId;
        params["langId"] = this.langId;
        	
	var authToken = $("#PaymentsAndBill_authToken").val();
        params["authToken"] = authToken;
        var purchaseOrderForm = document.forms["purchaseOrderNumberInfo"];
        if (purchaseOrderForm) {
            var purchaseOrderNumber = purchaseOrderForm.purchase_order_number.value;
            if (purchaseOrderForm.purchaseOrderNumberRequired.value == 'true' && purchaseOrderForm.purchase_order_number.value == "") {
                MessageHelper.formErrorHandleClient(purchaseOrderForm.purchase_order_number, MessageHelper.messages["ERROR_PONumberEmpty"]);
                return;
		} 
            else if (!MessageHelper.isValidUTF8length(purchaseOrderForm.purchase_order_number.value, 128)) {
                MessageHelper.formErrorHandleClient(purchaseOrderForm.purchase_order_number, MessageHelper.messages["ERROR_PONumberTooLong"]);
                return;
            }
        }
        params["purchaseorder_id"] = purchaseOrderNumber;
        if (userType == 'G') {
            //addressListForMailNotification contains list of emailId's spearated by space.. remove leading or trailing spaces..
            addressListForMailNotification = trim(addressListForMailNotification);

            //Get the space separated email list in an array...
            var emailList = [];
            emailList = addressListForMailNotification.split(" ");

            //Now from this array, remove repeated email Id's.. keep only unique email Id's
            var uniqueList = [];
            for (var j = 0; j < emailList.length; j++) {
                uniqueList[emailList[j]] = emailList[j];
            }

            //Get the total length of unique email id's list..
            var totalLength = 0;
            for (i in uniqueList) {
                totalLength = totalLength + 1;
            }

            //Convert the unique List array into comma separated values...
            var temp = "";
            var k = 0;
            for (i in uniqueList) {
                k = k + 1;
                temp = temp + uniqueList[i];
                if (k < totalLength) {
                    //If not last value, add , before next value..
                    temp = temp + ",";
                }
            }
            //For guest user send the email list..
            params["notify_EMailSender_recipient"] = temp;

            //setup sms phone for service
            var smsOrderNotificationCheckbox = document.getElementById("sendMeSMSNotification");
            if (smsOrderNotificationCheckbox != null && smsOrderNotificationCheckbox != "undefined") {
                if (smsOrderNotificationCheckbox.checked) {
                    var mobileCountryCode = document.getElementById("mobileCountryCode");
                    var mobilePhone1 = document.getElementById("mobilePhone1");
                    if (mobileCountryCode != null && mobileCountryCode != "undefined" && mobilePhone1 != null && mobilePhone1 != "undefined") {
                        params["SMS"] = mobileCountryCode.value + mobilePhone1.value;
                    }
                }
            }
        }


        //For handling multiple clicks
        if (!submitRequest()) {
            return;
        }
        cursor_wait();

        if (!isQuote) {
            wcService.invoke("AjaxSubmitOrder", params);
        } else {
            params["URL"] = "";
            this.setOrderId(orderId);
            wcService.invoke("AjaxSubmitQuote", params);
        }
    },


    /**
     * Validates the scheduled start date and sets the cookies that are used to retrieve the start date and interval of a scheduled order.
     */
    prepareOrderSchedule: function () {
        if (document.getElementById("scheduleOrderInputSection") != null) {
            var scheduleOrderStartDateObj = $("#ScheduleOrderStartDate")[0];
            if (!this.validateDate(scheduleOrderStartDateObj, 'ScheduleOrderStartDate')) {
                return;
            }

            var interval = $("#ScheduleOrderFrequency").val();

            var key1 = "WC_ScheduleOrder_" + document.getElementById("orderIdToSchedule").value + "_strStartDate";
            var key2 = "WC_ScheduleOrder_" + document.getElementById("orderIdToSchedule").value + "_interval";

            if ((interval == "undefined") && (scheduleOrderStartDateObj.value == null)) {
                // if the order interval is '' and the specified start date is empty, remove the cookies
               	setCookie(key1, null, {expires: -1});
               	setCookie(key2, null, {expires: -1});
            } else {
                var t = $(scheduleOrderStartDateObj).datepicker("getDate");
                var now = new Date();

                t.setHours(now.getHours(), now.getMinutes(), now.getSeconds(), now.getMilliseconds());

                // set start date in zulu time
                t = t.toISOString();
                setCookie(key1, t, {
                    path: "/",
                    domain: cookieDomain
                });
                setCookie(key2, interval, {
                    path: "/",
                    domain: cookieDomain
                });
            }
        }
    },


    /**
     * Schedules an order.
     *
     * @param {Integer} orderId The order ID of the scheduled order.
     * @param {String} isRecurring The flag to identify a recurring order.
     * @param {String} userType The type of the user.
     */
    scheduleOrder: function (orderId, isRecurring, userType) {
        if (!this.isOrderPaymentFullyAllocated()) {
            return;
        }
        if (userType === "G" && isRecurring) {
            MessageHelper.displayErrorMessage(MessageHelper.messages["ERROR_GUEST_USER_SUBMIT_RECURRING_ORDER"]);
            return;
        }
        var params = [];
        params["storeId"] = this.storeId;
        params["catalogId"] = this.catalogId;
        params["langId"] = this.langId;
        params["orderId"] = orderId;
        
	var authToken = $("#PaymentsAndBill_authToken").val();
        params["authToken"] = authToken;
        if (isRecurring != undefined && isRecurring == true) {
            params["startDate"] = getCookie("WC_ScheduleOrder_" + orderId + "_strStartDate");
            if (getCookie("WC_ScheduleOrder_" + orderId + "_interval") == '1') {
                params["fulfillmentInterval"] = '1';
                params["fulfillmentIntervalUOM"] = 'DAY';
                params["timePeriod"] = '1';
                params["timePeriodUOM"] = 'DAY';
            } else if (getCookie("WC_ScheduleOrder_" + orderId + "_interval") == '2') {
                params["fulfillmentInterval"] = '1';
                params["fulfillmentIntervalUOM"] = 'DAY';
            } else if (getCookie("WC_ScheduleOrder_" + orderId + "_interval") == '3') {
                params["fulfillmentInterval"] = '1';
                params["fulfillmentIntervalUOM"] = 'WEE';
            } else if (getCookie("WC_ScheduleOrder_" + orderId + "_interval") == '4') {
                params["fulfillmentInterval"] = '2';
                params["fulfillmentIntervalUOM"] = 'WEE';
            } else if (getCookie("WC_ScheduleOrder_" + orderId + "_interval") == '5') {
                params["fulfillmentInterval"] = '3';
                params["fulfillmentIntervalUOM"] = 'WEE';
            } else if (getCookie("WC_ScheduleOrder_" + orderId + "_interval") == '6') {
                params["fulfillmentInterval"] = '4';
                params["fulfillmentIntervalUOM"] = 'WEE';
            }
		}
         else {
            params["strStartDate"] = getCookie("WC_ScheduleOrder_" + orderId + "_strStartDate");
            params["interval"] = getCookie("WC_ScheduleOrder_" + orderId + "_interval");
        }


        var purchaseOrderForm = document.forms["purchaseOrderNumberInfo"];
        if (purchaseOrderForm) {
            var purchaseOrderNumber = purchaseOrderForm.purchase_order_number.value;
            if (purchaseOrderForm.purchaseOrderNumberRequired.value == 'true' && purchaseOrderForm.purchase_order_number.value == "") {
                MessageHelper.formErrorHandleClient(purchaseOrderForm.purchase_order_number, MessageHelper.messages["ERROR_PONumberEmpty"]);
                return;
            } else if (!MessageHelper.isValidUTF8length(purchaseOrderForm.purchase_order_number.value, 128)) {
                MessageHelper.formErrorHandleClient(purchaseOrderForm.purchase_order_number, MessageHelper.messages["ERROR_PONumberTooLong"]);
                return;
            }
            params["purchaseorder_id"] = purchaseOrderNumber;
        }

        //For handling multiple clicks
        if (!submitRequest()) {
            return;
        }
        cursor_wait();
        if (isRecurring != undefined && isRecurring == true) {
            wcService.invoke("SubmitRecurringOrder", params);
        } else {
            wcService.invoke("ScheduleOrder", params);
        }
    },


    /**
     * Checks if a date occurred in the past.
     *
     * @param {Object} dateObj The date object to be validated.
     * @param {String} elementId The ID of the element that an error message would be attached to.
     */
    validateDate: function (dateObj, elementId) {
        var now = new Date();
        if ($(dateObj).datepicker("getDate") != null && ($(dateObj).datepicker("getDate") - now < 0)) {
            //if the date is the current date, then it is valid
            if (now.toDateString() === $(dateObj).datepicker("getDate").toDateString()) {
                return true;
            }

            if ((elementId != null) && (document.getElementById(elementId) != null)) {
                MessageHelper.formErrorHandleClient(document.getElementById(elementId).id, MessageHelper.messages["PAST_DATE_ERROR"]);
            } else {
                MessageHelper.displayErrorMessage(MessageHelper.messages["PAST_DATE_ERROR"]);
            }
            return false;
        } else {
            return true;
        }
    },

    /**
     * Creates a new address during order check-out.
     *
     * @param {Integer} orderItemId The order item ID for a multiple shipment scenario, or 0 to indicate a shipping address needs to be created, or 1 to indicate a billing address needs to be created.
     * @param {String} addressType The type of the address to be created.
     */
    createAddress: function (orderItemId, addressType) {
        this.saveOrderItemsList(orderItemId, "-1");

        //For handling multiple clicks
        if (!submitRequest()) {
            return;
        }
        var checkForOpera = true; //require a check of whether the browser is opera or not
        cursor_wait(checkForOpera);
        wcRenderContext.updateRenderContext('editShippingAddressContext', {
            'shippingAddress': '-1',
            'addressType': addressType
        });
        //Hide the mainContents (contains shipping/billing details, shop cart details, promotion details, orderDetails)
        this.showHideDivs('editAddressContents', 'mainContents');
    },


    /**
     * This function is used to show an area and hide an area on the current page.
     *
     * @param {String} showArea The ID of the area to show.
     * @param {String} hideArea The ID of the area to hide.
     *
     * @private
     */
    showHideDivs: function (showArea, hideArea) {
        document.getElementById(hideArea).style.display = "none";
        document.getElementById(showArea).style.display = "block";
    },


    /**
     * Restores the previous address details when a user cancels editing an existing address or cancels creating a new address.
     *
     * @see CheckoutHelperJS.cancelEditAddress
     */
    restorePreviousAddressDetails: function () {

        //For Ajax flow when the previous shipping address is not available in the array
        //Save the addresses present on server side only.. on change of address the server will be updated in ajax checkout..so can use
        //the address from server side only..
        if (this.shipmentTypeId == "2") {
            for (var i = 0; i < this.orderItemIds.length; i++) {
                //Get the orderItemId
                var orderItemId = this.orderItemIds[i];
                var element = document.getElementById("MS_ShipmentAddress_" + orderItemId);

                if (element != null && element.value == -1) {
                    //IF createAddress is selected in this box, then restore it to previously selected value..
                    element.value = document.getElementById("addressId_" + orderItemId).value;
                }
            }
        } else if (this.shipmentTypeId == "1") {
            var element = document.getElementById("singleShipmentAddress");
            if (element != null && document.getElementById("addressId_all")) {
                element.value = document.getElementById("addressId_all").value;
            }
        }

        //Restore the original billing address(es) that was updated on the server
        for (var i = 1; i < 4; i++) {
            //Find the payment forms that are present on the page
            if (document.getElementById("PaymentForm" + i) != null) {
                var paymentForm = document.getElementById("PaymentForm" + i);
                //Restore the selected billing address if it "create address" was selected
                if (paymentForm.billing_address_id.value == -1) {
                    paymentForm.billing_address_id.value = document.getElementById("selectedAddressId_" + i).value;
                }
                if (wcRenderContext.getRenderContextProperties("billingAddressDropDownBoxContext")["billingAddress" + i] == -1) {
                	wcRenderContext.getRenderContextProperties("billingAddressDropDownBoxContext")["billingAddress" + i] = paymentForm.billing_address_id.value;
                }
            }
        }
    },


    /**
     * This function is used when a user edits an existing shipping address during check-out.
     *
     * @param {String} addressSelectBoxName The ID of the address drop-down object.
     * @param {Integer} orderItemId The item ID. It is required in the a multiple shipment scenario.
     * @param {String} profileshipping The name of the quick checkout profile shipping address.
     * @param {String} profilebilling The name of the quick checkout profile billing address.
     */
    editAddress: function (addressSelectBoxName, orderItemId, profileshipping, profilebilling) {
        var addressBox = document.getElementById(addressSelectBoxName);

        //We need to save order Items having this addressId..bcs if user edits this address then the id of this address changes..
        //so all order items needs to be updated with new id.
        this.saveOrderItemsList(orderItemId, addressBox.value);

        // the quick checkout address nick name is hardcoded here..it should be same as that used in quick checkout profile page..
        if (addressBox.options[addressBox.selectedIndex].text == profileshipping || addressBox.options[addressBox.selectedIndex].text == profilebilling) {
            if (addressSelectBoxName != null) {
                MessageHelper.formErrorHandleClient(addressSelectBoxName, MessageHelper.messages["ERROR_QUICKCHECKOUT_ADDRESS_CHANGE"]);
            } else {
                MessageHelper.displayErrorMessage(MessageHelper.messages["ERROR_QUICKCHECKOUT_ADDRESS_CHANGE"]);
            }
            return;
        }

        //For handling multiple clicks
        if (!submitRequest()) {
            return;
        }
        //Update the display area context..
        cursor_wait();
        wcRenderContext.updateRenderContext('editShippingAddressContext', {
            'shippingAddress': addressBox.value,
            'addressType': 'Shipping'
        });

        //Hide the mainContents (contains shipping/billing details, shop cart details, promotion details, orderDetails)
        this.showHideDivs('editAddressContents', 'mainContents');
    },


    /**
     * This function is used when a user edits an existing billing address during check-out.
     *
     * @param {Integer} orderItemId The item ID.
     * @param {Integer} paymentArea The payment area number that this billing address belongs to.
     * @param {String} profileshipping The name of the quick checkout profile shipping address.
     * @param {String} profilebilling The name of the quick checkout profile billing address.
     */
    editBillingAddress: function (orderItemId, paymentArea, profileshipping, profilebilling) {
        var form = document.forms["PaymentForm" + paymentArea];
        var addressBox = form.billing_address_id;

        //We need to save order Items having this addressId..bcs if user edits this address then the id of this address changes..
        //so all order items needs to be updated with new id..
        this.saveOrderItemsList(orderItemId, addressBox.value);

        // the quick checkout address nick name is hardcoded here..it should be same as that used in quick checkout profile page..
        if (addressBox.options[addressBox.selectedIndex].text == profileshipping || addressBox.options[addressBox.selectedIndex].text == profilebilling) {
            if (addressBox != null) {
                MessageHelper.formErrorHandleClient(addressBox, MessageHelper.messages["ERROR_QUICKCHECKOUT_ADDRESS_CHANGE"]);
            } else {
                MessageHelper.displayErrorMessage(MessageHelper.messages["ERROR_QUICKCHECKOUT_ADDRESS_CHANGE"]);
            }
            return;
        }
        var billingAddressId = addressBox.value;
        var shippingAddressId = (document.getElementById("singleShipmentAddress")) ? document.getElementById("singleShipmentAddress").value : "noAddress";
        var addressType = (billingAddressId == shippingAddressId) ? "ShippingAndBilling" : "Billing";
        //For handling multiple clicks
        if (!submitRequest()) {
            return;
        }
        //Update the display area context..
        cursor_wait();
        wcRenderContext.updateRenderContext('editShippingAddressContext', {
            'shippingAddress': addressBox.value,
            'addressType': addressType
        });

        //Hide the mainContents (contains shipping/billing details, shop cart details, promotion details, orderDetails)
        this.showHideDivs('editAddressContents', 'mainContents');
    },


    /**
     * When a user cancels editing an address, this function is called to hide the address entry form and show the original main content of the page, then calls restorePreviousAddressDetails to restore the previous address.
     *
     * @see CheckoutHelperJS.restorePreviousAddressDetails
     */
    cancelEditAddress: function () {
        this.showHideDivs('mainContents', 'editAddressContents');
        this.restorePreviousAddressDetails();
        if (this.getLastAddressLinkIdToFocus() != null && this.getLastAddressLinkIdToFocus() != 'undefined' && this.getLastAddressLinkIdToFocus() != '') {
            document.getElementById(this.getLastAddressLinkIdToFocus()).focus();
            this.setLastAddressLinkIdToFocus('');
        }

    },


    /**
     * This function gets the shipment type Id for the order. Shipment type Id 1 is for single shipment, 2 for multiple shipment.
     *
     * @see CheckoutHelperJS.initializeShipmentPage
     */
    getShipmentTypeId: function () {
        return this.shipmentTypeId;
    },


    /**
     * Sets the dataDiry flag to indicate if payment information in the specified payment form area has been changed by the user.
     * This method should be used for payment methods involving credit card.
     * @param {Integer} paymentAreaNumber The unique payment area number.
     * @param {Boolean} flag A true/false value to indicate if the payment method input has been changed.
     *
     * @see CheckoutHelperJS.isPaymentDataDirty
     */
    paymentDataDirty: function (paymentAreaNumber, flag) {
        this.dataDirty[paymentAreaNumber] = flag;
        console.debug("Information in payment area " + paymentAreaNumber + " has been modified.");
    },

    /**
     * Returns the dataDiry flag that indicates if payment information in the specified payment form area has been changed by the user.
     *
     * @param {Integer} paymentAreaNumber The unique payment area number.
     *
     * @see CheckoutHelperJS.paymentDataDirty
     */
    isPaymentDataDirty: function (paymentAreaNumber) {
        return this.dataDirty[paymentAreaNumber];
    },


    /**
     * Sets fieldDirtyFlag to indicates if the value of a shipping information related input field or the quantity of an item has been changed by the user.
     *
     * @param {Boolean} value A true/false value that indicates if the value of a shipping information related input field or the quantity of an item has been changed by the user.
     *
     * @see CheckoutHelperJS.getFieldDirtyFlag
     */
    setFieldDirtyFlag: function (value) {
        this.fieldDirtyFlag = value;
    },


    /**
     * Returns fieldDirtyFlag that indicates if the value of a shipping information related input field or the quantity of an item has been changed by the user.
     *
     * @returns {Boolean} fieldDirtyFlag A true/false value that indicates if the value of a shipping information related input field or the quantity of an item has been changed by the user.
     *
     * @see CheckoutHelperJS.setFieldDirtyFlag
     */
    getFieldDirtyFlag: function () {
        return this.fieldDirtyFlag;
    },


    /**
     * Verifies if the dirty flag is set to true, such as when a customer changes shipping information. If the dirty
     * flag is set to true, a message displays prompting the customer to update their current order before they continue
     * to checkout. This function is used in a non-AJAX checkout flow.
     *
     * @return {Boolean} Return true if the dirty flag is set to true.
     */
    checkForDirtyFlag: function () {
        if (this.getFieldDirtyFlag()) {
            if (document.getElementById("ShoppingCart_NonAjaxUpdate") != null) {
                MessageHelper.formErrorHandleClient(document.getElementById("ShoppingCart_NonAjaxUpdate"), MessageHelper.messages["ERROR_UPDATE_FIRST_SHOPPING_CART"]);
                return true;
            } else if (document.getElementById("MultipleShipment_NonAjaxShipInfoUpdate") != null) {
                MessageHelper.formErrorHandleClient(document.getElementById("MultipleShipment_NonAjaxShipInfoUpdate"), MessageHelper.messages["ERROR_UPDATE_FIRST"]);
                return true;
            } else if (document.getElementById("SingleShipment_NonAjaxShipInfoUpdate") != null) {
                MessageHelper.formErrorHandleClient(document.getElementById("SingleShipment_NonAjaxShipInfoUpdate"), MessageHelper.messages["ERROR_UPDATE_FIRST"]);
                return true;
            } else {
                MessageHelper.displayErrorMessage(MessageHelper.messages["ERROR_UPDATE_FIRST"]);
                return true;
            }
        }
        return false;
    },


    /**
     * This function is used to show or hide the SMS phone number field section for guest shoppers in the
     * order summary page.
     * @param {DOM Element Id} checkboxElementId The id of the checkbox for getting SMS order notifications.
     * @param {DOM Element Id} smsElementId The id of the element that contains the SMS phone number field.
     */
    showHideCheckoutSMS: function (checkboxElementId, smsElementId) {
        var smsOrderNotificationCheckbox = document.getElementById(checkboxElementId);
        if (smsOrderNotificationCheckbox != null && smsOrderNotificationCheckbox != "undefined") {
            if (smsOrderNotificationCheckbox.checked) {
                showElementById(smsElementId);
            } else {
                hideElementById(smsElementId);
            }
        }

    },

    /**
     * This function return an array of countries from a global variable called countries.
     * If that variable does not already exist then it will be created and populated from a JSON of country objects which should
     * have been loaded into a div on the page prior to calling this function.
     *
     * @returns {Array} countries An array of countries.
     **/
    getCountryArray: function () {
        //If the countries array does not already exist then create it.
        if (document["countries"] == null) {
            countries = new Array();
            var theDiv = document.getElementById("countryListSelectionHelper");

            if (typeof theDiv == 'undefined') return null;
            var divJSON = eval('(' + theDiv.innerHTML + ')');
            var countriesObject = divJSON.countries;

            for (var i = 0; i < countriesObject.length; i++) {
                var countryObject = countriesObject[i];
                countries[countryObject.code] = new Object();
                countries[countryObject.code].name = countryObject.displayName;
                countries[countryObject.code].countryCallingCode = countryObject.callingCode;

                if (countryObject.states.length > 0) {
                    countries[countryObject.code].states = new Object();
                    for (var j = 0; j < countryObject.states.length; j++) {
                        var state = countryObject.states[j];
                        countries[countryObject.code].states[state.code] = state.displayName;
                    }
                }
            }
        }

        return countries;
    },

    /**
     *  This function populates the country code to mobile phone based on the selected country.
     *  @param {string} countryDropDownId The id of the mobile country drop down list
     *  @param {string} countryCallingCodeId The id of the mobile country calling code text box.
     */
    loadCountryCode: function (countryDropDownId, countryCallingCodeId) {
        this.getCountryArray();
        var countryCode = document.getElementById(countryDropDownId).value;
        document.getElementById(countryCallingCodeId).value = countries[countryCode].countryCallingCode;
    },


    /**
     * Invokes the OrderShippingInfoUpdate service to expedite shipping for the selected order item.
     *
     * @param {DOM Element} checkBox The Expedite Shipping check-box object.
     * @param {String} inputOrderItemId The ID of the order item for which you want to expedite shipping.
     */
    expediteShipping: function (checkBox, inputOrderItemId) {

        var params = [];
        params["storeId"] = this.storeId;
        params["catalogId"] = this.catalogId;
        params["langId"] = this.langId;

        if (checkBox.checked) {
            this.updateParamObject(params, "isExpedited", "true", true);
        } else {
            this.updateParamObject(params, "isExpedited", "false", true);
        }
        if (inputOrderItemId != null) {
            this.updateParamObject(params, "orderItemId", inputOrderItemId, false);
        }

        //For handling multiple clicks
        if (!submitRequest()) {
            return;
        }
        cursor_wait();
        wcService.invoke("OrderShippingInfoUpdate", params);
    },


    /************************************************************
     * The following methods are used on the Shopping Cart page
     ************************************************************/

    /**
     * This function updates the total on the shopping cart page when the quantity of an item has been changed.
     * It updates the total by calling <code>updateCart</code> after <code>updateWaitTimeOut</code> milliseconds have passed.
     *
     * @param {DOM Element} quantityBox The quantity input text field.
     * @param {Integer} orderItemId The ID of the order item to update.
     * @param {Object} event A keyboard event object.
     *
     * @see CheckoutHelperJS.updateCart
     */
    updateCartWait: function (quantityBox, orderItemId, event) {
        //Arrows are escaped for keyboard accesibility of table
        if (event.keyCode == KeyCodes.TAB ||
            event.keyCode == KeyCodes.DOWN_ARROW ||
            event.keyCode == KeyCodes.UP_ARROW ||
            event.keyCode == KeyCodes.LEFT_ARROW ||
            event.keyCode == KeyCodes.RIGHT_ARROW
        ) return;

        //Key pressed.. update the flag
        if (this.keyPressCount[orderItemId] == null && isNaN(this.keyPressCount[orderItemId])) {
            this.keyPressCount[orderItemId] = 0;
        }
        this.keyPressCount[orderItemId] = parseInt(this.keyPressCount[orderItemId]) + 1;
        setTimeout($.proxy(this, "updateCart", quantityBox, orderItemId, this.keyPressCount[orderItemId]), this.updateWaitTimeOut);
    },


    /**
     * This function updates the total on the shopping cart page when the quantity of an item has been changed.
     * It updates the shopping cart by calling the <code>AjaxUpdateOrderItem</code> service.
     *
     * @param {DOM Element} quantityBox The quantity input text field.
     * @param {Integer} orderItemId The ID of the order item to update.
     * @param {Integer} keyPressCountValue The count of keyPress events. If there are more keyPress events after this event was fired, then this function just returns without doing anything.
     */
    updateCart: function (quantityBox, orderItemId, keyPressCountValue) {
        if (keyPressCountValue < this.keyPressCount[orderItemId]) {
            //User has pressed one more key..that key press call will update the server..no work for me..
            return;
        }

        var quantity = (quantityBox.value);
        if (!isNonNegativeInteger(quantity)) {
            TealeafWCJS.createExplicitChangeEvent(quantityBox.id);
            MessageHelper.formErrorHandleClient(quantityBox, MessageHelper.messages["QUANTITY_INPUT_ERROR"]);
        } else {
            //Its a positive valid number > 0...Update the qty at server side..
            if (!isChrome()) {
                TealeafWCJS.createExplicitChangeEvent(quantityBox.id);
            }
            var params = [];
            params.orderId = ".";
            params["storeId"] = this.storeId;
            params["catalogId"] = this.catalogId;
            params["langId"] = this.langId;
            if (this.shoppingCartPage) {
                params.calculationUsage = "-1,-2,-5,-6,-7";
                params.inventoryValidation = "true";
            } else {
                params.calculationUsage = "-1,-2,-3,-4,-5,-6,-7";
            }
            params.calculateOrder = "1";
            this.updateParamObject(params, "orderItemId", orderItemId, false, -1);
            this.updateParamObject(params, "quantity", quantity, false, -1);

            //For handling multiple clicks
            if (!submitRequest()) {
                return;
            }
            cursor_wait();

            if (quantity == 0) {
                var x = document.getElementById("totalNumberOfItems").value;
                var y = x;
                //Now remove free items from this total number of items count..
                //x = total items and y = totalItems - totalFreeItems
                for (var i = 0; i < x; i++) {
                    var qtyObj = document.getElementById("freeGift_qty_" + (i + 1));
                    if (qtyObj != null || qtyObj != undefined) {
                        qty = qtyObj.value;
                        if (qty != null && qty != undefined && qty == -1) {
                            y = y - 1;
                        }
                    }

                }

                if (y == 1) {
                    wcService.invoke("AjaxUpdateOrderItem1", params);
                } else {
                    wcService.invoke("AjaxUpdateOrderItem", params);
                }
            } else {
                wcService.invoke("AjaxUpdateOrderItem", params);
            }
        }
    },


    /**
     * Validates the quantity of all items on the 'Shopping Cart' page.
     * @param {DOM Element} form The form object that contains the table of order items.
     */
    updateShoppingCart: function (form) {

        MessageHelper.hideAndClearMessage();
        var totalItems = document.getElementById("totalNumberOfItems").value;
        if (totalItems != null) {
            for (var i = 0; i < totalItems; i++) {
                var quantity = null;
                if (form != undefined) {
                    quantity = form["quantity_" + (i + 1)];
                } else if (document.getElementById("qty_" + (i + 1)) != null) {
                    quantity = document.getElementById("qty_" + (i + 1));
                }
                //Update qty for all items
                if (quantity != null || quantity != undefined) {
                    var v = quantity.value;
                    if (!isNonNegativeInteger(v)) {
                        MessageHelper.formErrorHandleClient(quantity.id, MessageHelper.messages["QUANTITY_INPUT_ERROR"]);
                        return;
                    }
                }

            }
            return true;
        } else {
            console.debug("error: element 'totalNumberOfItems' was expected but undefined.");
            return;
        }
    },

    /**
     * If the shopper has selected to perform a recurring order in the shopping cart page, this function is used to
     * validate that all conditions for creating a recurring order are met:
     * - make sure it is a registered shopper
     * - make sure that the order does not have order items that are non-recurring (i.e disallowRecurringOrder flag set to 1)
     *
     * @param {String} userType The user type of the current user, either G (guest shopper) or R (registered shopper).
     */
    canCheckoutContinue: function (userType) {
		if ( (document.getElementById("recurringOrder") && document.getElementById("recurringOrder").checked) && ((document.getElementById("shipTypeOnline") && document.getElementById("shipTypeOnline").checked) || document.getElementById("shipTypeOnline") == null)) {
			if (document.getElementById("nonRecurringOrderItems") && document.getElementById("nonRecurringOrderItems").value != "") {
                MessageHelper.displayErrorMessage(MessageHelper.messages["RECURRINGORDER_ERROR"]);
                return false;
            } else if (userType != undefined && userType === "G") {
                MessageHelper.displayErrorMessage(MessageHelper.messages["ERROR_GUEST_USER_SUBMIT_RECURRING_ORDER"]);
                return false;
            }
        }
        return true;
    },

    /**
     * Updates the shopping cart in a 'quick check-out' scenario by invoking the <code>QuickCheckOutOrderCopy</code> service.
     *
     * @param {Integer} quickOrderId The ID of the quick check-out order.
     */
    updateCartWithQuickCheckoutProfile: function (quickOrderId) {
		var postRefreshHandlerParameters = [];
		var initialURL = "AjaxRESTOrderCopy";
		var urlRequestParams = [];
		urlRequestParams["storeId"] = this.storeId;
		urlRequestParams["catalogId"] = this.catalogId;
		urlRequestParams["langId"] = this.langId;
		urlRequestParams.toOrderId = ".";
		urlRequestParams["shippingAddressFromOrderProfile"] = "1";
		urlRequestParams["shippingModeFromOrderProfile"] = "1";
		urlRequestParams["URL"] = "dummy";
		urlRequestParams["payInfoFrom"] = quickOrderId;

		postRefreshHandlerParameters.push({"URL":"AjaxRESTOrderPrepare", "requestParams":{"orderId":"."}}); 
		postRefreshHandlerParameters.push({"URL":"OrderShippingBillingView","requestType":"GET", "requestParams":{"quickCheckoutProfileForPayment":"true"}}); 
		var service = getCustomServiceForURLChaining(initialURL,postRefreshHandlerParameters,null);

		//For handling multiple clicks
		if(!submitRequest()){
			return;
		}
		cursor_wait();

		wcService.invoke(service.getParam("id"), urlRequestParams);
    },


    /************************************************************
     * End Shopping Cart page specific functions
     ************************************************************/



    /**************************************************************
     * The following methods are used on the Single Shipment page
     **************************************************************/

    /**
     * Helper function used for adding a new shipping address in a single shipment scenario.
     *
     * @param {String} addressType The type of the selected address.
     */
    addNewShippingAddress: function (addressType) {
        this.displayAddressDetails(-1, addressType);
    },


    /**
     * This function is used to update the address of all order items in a single shipment checkout-out scenario.
     *
     * @param {DOM Element} addressSelectBox The select drop-down object that contains all available addresses.
     */
    updateAddressForAllItems: function (addressSelectBox) {
        //Save it in local array..
        if (addressSelectBox.value != -1) {
            this.selectedAddressesArray[addressSelectBox.name] = addressSelectBox.value;
        }

        var addressId = addressSelectBox.value;
        if (addressId == -1) {
            return;
        }
        params = [];
        params["storeId"] = this.storeId;
        params["catalogId"] = this.catalogId;
        params["langId"] = this.langId;
        params.orderId = ".";
        params.calculationUsage = "-1,-2,-3,-4,-5,-6,-7";
        params.allocate = "***";
        params.backorder = "***";
        params.remerge = "***";
        params.check = "*n";
        params.calculateOrder = "1";

        var addressId = document.getElementById("singleShipmentAddress").value;
        this.updateParamObject(params, "addressId", addressId, false);
        if (typeof updateGiftRegistrantAddressForItemsExt != "undefined" && typeof updateGiftRegistrantAddressForItemsExt != null) {
            params = updateGiftRegistrantAddressForItemsExt(params, addressId);
        }

        var enabledShipInstructions = false;
        var shipInstructions;

        //Check if Shipping Instructions is enabled
        if (document.getElementById("shipInstructions") != null) {
            shipInstructions = document.getElementById("shipInstructions").value;

            reWhiteSpace = new RegExp(/^\s+$/);
            if (reWhiteSpace.test(shipInstructions)) {
                shipInstructions = "";
            }
            enabledShipInstructions = true;
        }

        //For handling multiple clicks
        if (!submitRequest()) {
            return;
        }
        cursor_wait();

        //If Shipping Instructions is enabled & there are some shipping instructions entered
        //Update both the shipping address and shipping instructions
        //Else only update shipping address
        if (!enabledShipInstructions || shipInstructions == undefined || shipInstructions == "") {
            wcService.invoke("OrderItemAddressShipMethodUpdate", params);
        } else {
            wcService.invoke("OrderItemAddressShipInstructionsUpdate", params);
        }
    },


    /**
     * This function is used to update the shipping mode of all order items in a single shipment checkout-out scenario.
     *
     * @param {DOM Element} addressSelectBox The select drop-down object that contains all available shipping modes.
     */
    updateShipModeForAllItems: function (shipmentSelectBox) {

        var shipModeId = shipmentSelectBox.value;
        if (shipModeId == -1) {
            return;
        }
        params = [];
        params["storeId"] = this.storeId;
        params["catalogId"] = this.catalogId;
        params["langId"] = this.langId;
        params.orderId = ".";
        params.calculationUsage = "-1,-2,-3,-4,-5,-6,-7";
        params.allocate = "***";
        params.backorder = "***";
        params.remerge = "***";
        params.check = "*n";
        params.calculateOrder = "1";

        this.updateParamObject(params, "shipModeId", shipModeId, false);

        //For handling multiple clicks
        if (!submitRequest()) {
            return;
        }
        cursor_wait();
        wcService.invoke("OrderItemAddressShipMethodUpdate", params);
    },


    /**
     * This function updates the shipping instruction for items in the order. It is used in a single shipment check-out scenario.
     * It calls the <code>OrderShippingInfoUpdate</code> service.
     */
    updateShippingInstructionsForAllItems: function () {

        params = [];
        params["storeId"] = this.storeId;
        params["catalogId"] = this.catalogId;
        params["langId"] = this.langId;
        params.orderId = ".";

        var orderItemId = null;
        var shipInstructions = document.getElementById("shipInstructions").value;

        reWhiteSpace = new RegExp(/^\s+$/);
        if (reWhiteSpace.test(shipInstructions)) {
            shipInstructions = "";
        }

        //Validate the length of the shipping instructions
        if (!MessageHelper.isValidUTF8length(shipInstructions, 4000)) {
            MessageHelper.formErrorHandleClient(document.getElementById("shipInstructions").id, MessageHelper.messages["ERROR_ShippingInstructions_TooLong"]);
            return;
        }

        orderItemId = document.getElementById("orderItem_1").value;
        this.updateParamObject(params, "orderItemId", orderItemId, false);
        this.updateParamObject(params, "shipInstructions", shipInstructions, false);

        //For handling multiple clicks
        if (!submitRequest()) {
            return;
        }
        cursor_wait();
        wcService.invoke("OrderShippingInfoUpdate", params);
    },

    /**
     * Updates the shipping charge type and account number for items in the order. This method calls the
     * <code>OrderShippingInfoUpdate</code> service and is used in both single and multiple shipment checkout scenarios.
     *
     * @param {Integer} curOrderId The order ID of the current order.
     * @param {Integer} shipModeId The ID of the shipping mode to which shipping charge applies.
     * @param {String} shipChargeType Shipping charge type selected for the shipmode.
     * @param {Integer} shipAcctNum The account number that is used when the selected shipping charge type is Charge by Carrier.
     */
    updateShippingChargeForShipModeAjax: function (curOrderId, shipModeId, shipChargeType, shipAcctNum) {

        params = [];
        params["storeId"] = this.storeId;
        params["catalogId"] = this.catalogId;
        params["langId"] = this.langId;
        params.orderId = curOrderId;
        params.URL = "";
        params["shipModeId"] = shipModeId;
        params["shipChargTypeId"] = shipChargeType;

        // ship account number is optional field for shipping charge, if it is not specified, pass in empty
        if (shipAcctNum != null && shipAcctNum != undefined) {
            params["shipCarrAccntNum"] = shipAcctNum;
        } else {
            params["shipCarrAccntNum"] = "";
        }

        //For handling multiple clicks
        if (!submitRequest()) {
            return;
        }
        cursor_wait();
        wcService.invoke("AjaxOrderShipChargeUpdate", params);
    },


    /**
     * Hides the account number field for the selected in shipping charge. If the charge by seller charge
     * type is selected, account field should not be shown.
     * @param {object} selectValue The HTML element of the shipping charge type selection
     * @param {object} acctFieldId The HTML element of the account number field
     */
    hideShipChargeAccountField: function (selectValue, acctFieldId) {

        if (document.getElementById(selectValue).value.indexOf("ByCarrier") > -1) {
            document.getElementById(acctFieldId).style.display = 'block';
        } else {
            document.getElementById(acctFieldId).style.display = 'none';
        }
    },

    /**
     * This function validates the specified requested shipping date then calls {@link CheckoutHelperJS.updateShippingDateForAllItems}
     * to update the date for all items in the current order in a single shipment scenario.
     *
     * @param {datepicker} jsDate The jQuery datepicker object containing the requested shipping date specified by the user.
     *
     * @see CheckoutHelperJS.updateRequestedShipDateForThisItem
     */

    updateRequestedShipDate: function (jsDate) {
        if (jsDate == null || jsDate.value == "")
            return;

        var t = "";
        if (jsDate.value != "") {
            t = this.formatRequestedShipDate(jsDate);
        } else {
            t = this.resetRequestedShipDateValue;
        }

        this.updateShippingDateForAllItems(t);
    },


    /**
     * This function updates the requested shipping date for all items in the order. It is called by {@link CheckoutHelperJS.updateRequestedShipDate}.
     * It calls the <code>OrderItemAddressShipMethodUpdate</code> service.
     *
     * @param {String} date The String representation of the date object, see {@link CheckoutHelperJS.updateRequestedShipDate}.
     */
    updateShippingDateForAllItems: function (date) {
        params = [];
        params["storeId"] = this.storeId;
        params["catalogId"] = this.catalogId;
        params["langId"] = this.langId;
        params.orderId = ".";
        params.calculationUsage = "-1,-2,-3,-4,-5,-6,-7";
        params.allocate = "***";
        params.backorder = "***";
        params.remerge = "***";
        params.check = "*n";
        params.calculateOrder = "1";

        this.updateParamObject(params, "requestedShipDate", date, false);

        //For handling multiple clicks
        if (!submitRequest()) {
            return;
        }
        cursor_wait();
        wcService.invoke("OrderItemAddressShipMethodUpdate", params);
    },


    /**
     * Displays the details of an address in a single shipment check-out scenario.
     *
     * @param {String} addressSelectBoxValue The value, i.e. address ID, of the input address select drop-down object.
     * @param {String} addressType The type of the selected address.
     */
    displayAddressDetails: function (addressSelectBoxValue, addressType) {
        //Display selected address details..
        if (addressSelectBoxValue != -1) {
            //For handling multiple clicks
            if (!submitRequest()) {
                return;
            }
            var checkForOpera = true; //require a check of whether the browser is opera or not
            cursor_wait(checkForOpera);
            wcRenderContext.updateRenderContext('shippingAddressContext', {
                'shippingAddress': addressSelectBoxValue
            });
        } else {
            this.createAddress(-1, addressType);
        }
    },


    /************************************************************
     * End Single Shipment page specific functions
     ************************************************************/


    /****************************************************************
     * The following methods are used on the Multiple Shipment page
     ****************************************************************/

    /**
     * This function is used to move all order items into a single shipment when a shopper changes the order from multiple shipment check-out to single shipment.
     * The shipping information of the first item in the order will be used for all items after this update.
     * It calls the <code>OrderItemAddressShipMethodUpdate1</code> service to update the order.
     */
    moveAllItemsToSingleShipment: function () {
        //Get the first orderItem id..
        var orderItemId = document.getElementById("orderItem_1").value;
        //Now get the addressId and shipModeId of this orderItemId...
        var addressId = document.getElementById("MS_ShipmentAddress_" + orderItemId).value;
        //Update the shipModeId and addressId of all the items present in currentOrder...

        params = [];
        params["storeId"] = this.storeId;
        params["catalogId"] = this.catalogId;
        params["langId"] = this.langId;
        params.orderId = ".";
        params.calculationUsage = "-1,-2,-3,-4,-5,-6,-7";
        params.calculateOrder = "1";

	  // FIX LATER TODO	
        var requestedShipDate = $("#MS_requestedShippingDate_" + orderItemId);
        if (requestedShipDate == undefined) {
            requestedShipDate = document.getElementById("MS_requestedShippingDate_" + orderItemId);
            if (requestedShipDate != null && requestedShipDate != 'undefined') {
                if (requestedShipDate.value != "") {
                    params.requestedShipDate = requestedShipDate.value;
                } else {
                    params.requestedShipDate = this.resetRequestedShipDateValue;
                }
            }
        }

        var requestedShipDateCheckbox = document.getElementById("MS_requestShippingDateCheckbox_" + orderItemId);
        if (requestedShipDateCheckbox != null && requestedShipDateCheckbox != 'undefined') {
            if (requestedShipDateCheckbox.checked) {
                if (requestedShipDate.value != "") {
                    params.requestedShipDate = this.formatRequestedShipDate(requestedShipDate);
                } else {
                    params.requestedShipDate = this.resetRequestedShipDateValue;
                }
            } else {
                params.requestedShipDate = this.resetRequestedShipDateValue;
            }
        }

        //addressId -3 is reserved for gift registry "Registrant" address.
        if (addressId == -3) {
            var totalItems = document.getElementById("totalNumberOfItems").value;
            for (var i = 2; i <= totalItems; i++) {
                if (document.getElementById("orderItem_" + i) != null && document.getElementById("orderItem_" + i) != 'undefined') {
                    var giftOrderItemId = document.getElementById("orderItem_" + i).value;
                    var validAddressId = document.getElementById("MS_ShipmentAddress_" + giftOrderItemId).value;
                    if (validAddressId != -3) {
                        this.updateParamObject(params, "addressId", validAddressId, false);
                        break;
                    }
                } else {
                    break;
                }
            }
        } else {
            this.updateParamObject(params, "addressId", addressId, false);
        }
        //For handling multiple clicks
        if (!submitRequest()) {
            return;
        }
        cursor_wait();
        wcService.invoke("OrderItemAddressShipMethodUpdate1", params);
    },


    /**
     * Helper function for adding an address on the multiple shipment 'Shipping & Billing' page.
     * @param (Integer) orderItemId The ID of the order item.
     */
    addNewShippingAddressForMS: function (orderItemId) {
        this.updateAddressIdForThisItem(-1, orderItemId);

        this.orderItemIds = []; //Reset this.orderItemIds. So that previous edit/create address doesn't have effect on the new create/edit address
        //now save the orderItemId, so we can update that orderItem with the newly created addressId

        //now save the orderItemId, so we can update that orderItem with the newly created addressId
        this.orderItemIds.push(orderItemId);
    },


    /**
     * Updates the address ID for an order item in a multiple shipment check-out scenario.
     * It is used when a different address is selected from the drop down.
     * It calls the <code>OrderItemAddressShipMethodUpdate</code> service to update.
     *
     * @param {String} addressBoxValue The value, i.e. address ID, of the input select drop-down object that contains all available addresses.
     * @param {Integer} orderItemId The order item ID.
     */
    updateAddressIdForThisItem: function (addressBoxValue, orderItemId) {
        //Save it in local array..
        if (addressBoxValue != -1) {
            var addressBox = document.getElementById("MS_ShipmentAddress_" + orderItemId);
            this.selectedAddressesArray[addressBox.name] = addressBoxValue;
        }
        if (addressBoxValue == -1) return;

        params = [];
        params["storeId"] = this.storeId;
        params["catalogId"] = this.catalogId;
        params["langId"] = this.langId;
        params.orderId = ".";
        params.calculationUsage = "-1,-2,-3,-4,-5,-6,-7";
        params.allocate = "***";
        params.backorder = "***";
        params.remerge = "***";
        params.check = "*n";
        params.calculateOrder = "1";
        var addressId = addressBoxValue;
        this.updateParamObject(params, "shipToRegistrant", "0", false, -1)
        this.updateParamObject(params, "addressId", addressId, false, -1);
        this.updateParamObject(params, "orderItemId", orderItemId, false, -1);
        if (typeof updateGiftRegistrantAddressForThisItemExt != "undefined" && typeof updateGiftRegistrantAddressForThisItemExt != null) {
            params = updateGiftRegistrantAddressForThisItemExt(params, addressId);
        }
        //For handling multiple clicks
        if (!submitRequest()) {
            return;
        }
        cursor_wait();
        wcService.invoke("OrderItemAddressShipMethodUpdate", params);
    },


    /**
     * Updates the shipping mode for an item in the order. It is used in a multiple shipment scenario.
     * It calls the <code>OrderItemAddressShipMethodUpdate</code> service.
     *
     * @param {DOM Element} shipModeBox The select drop-down object that contains all available shipping modes.
     * @param {Integer} orderItemId The ID of the order item to update.
     */
    updateShipModeForThisItem: function (shipModeBox, orderItemId) {
        var shipModeId = shipModeBox.value;
        if (shipModeId == -1) {
            return;
        }
        params = [];
        params["storeId"] = this.storeId;
        params["catalogId"] = this.catalogId;
        params["langId"] = this.langId;
        params.orderId = ".";
        this.updateParamObject(params, "orderItemId", orderItemId, false, -1);
        this.updateParamObject(params, "shipModeId", shipModeId, false, -1);
        params.calculationUsage = "-1,-2,-3,-4,-5,-6,-7";
        params.calculateOrder = "1";
        params.allocate = "***";
        params.backorder = "***";
        params.remerge = "***";
        params.check = "*n";

        //For handling multiple clicks
        if (!submitRequest()) {
            return;
        }
        cursor_wait();
        wcService.invoke("OrderItemAddressShipMethodUpdate", params);
    },


    /**
     * Updates the shipping instruction for an item. It is used in a multiple shipment scenario.
     * It calls the <code>OrderShippingInfoUpdate</code> service.
     *
     * @param {DOM Element} textArea The input text area for shipping instruction.
     * @param {Integer} orderItemId The ID of the order item to update.
     */
    updateShippingInstructionsForThisItem: function (textArea, orderItemId) {
        var addressId = document.getElementById("MS_ShipmentAddress_" + orderItemId).value;
        var shipModeId = document.getElementById("MS_ShippingMode_" + orderItemId).value;
        var shipInstructions = textArea.value;

        reWhiteSpace = new RegExp(/^\s+$/);
        if (reWhiteSpace.test(shipInstructions)) {
            shipInstructions = "";
        }

        //Validate the length of the shipping instructions
        if (!MessageHelper.isValidUTF8length(shipInstructions, 4000)) {
            MessageHelper.formErrorHandleClient(textArea.id, MessageHelper.messages["ERROR_ShippingInstructions_TooLong"]);
            return;
        }

        this.setShippingInstuctionsForAllOtherItems(addressId, shipModeId, shipInstructions);

        params = [];
        params["storeId"] = this.storeId;
        params["catalogId"] = this.catalogId;
        params["langId"] = this.langId;
        params.orderId = ".";
        params.calculationUsage = "-1,-2,-3,-4,-5,-6,-7";
        params.calculateOrder = "1";

        this.updateParamObject(params, "addressId", addressId, false, -1);
        this.updateParamObject(params, "shipModeId", shipModeId, false, -1);
        this.updateParamObject(params, "shipInstructions", shipInstructions, false, -1);
        this.updateParamObject(params, "orderItemId", orderItemId, false, -1);

        //For handling multiple clicks
        if (!submitRequest()) {
            return;
        }
        cursor_wait();
        wcService.invoke("OrderShippingInfoUpdate", params);
    },


    /**
     * This function updates the requested shipping date for the current item in a multiple shipment check-out scenario.
     * It invokes the <code>OrderItemAddressShipMethodUpdate</code> service.
     *
     * @param {datepicker} jsDate The jQuery datepicker object containing the requested shipping date specified by the user.
     * @param {Integer} orderItemId The ID of the order item to update.
     */
    updateRequestedShipDateForThisItem: function (jsDate, orderItemId) {
        if (jsDate == null || jsDate.value == "")
            return;

        var t = "";
        if (jsDate.value != "") {
            t = this.formatRequestedShipDate(jsDate);
        } else if (jsDate.value == "") {
            t = this.resetRequestedShipDateValue;
        }

        var addressId = document.getElementById("MS_ShipmentAddress_" + orderItemId).value;
        var shipModeId = document.getElementById("MS_ShippingMode_" + orderItemId).value;

        params = [];
        params["storeId"] = this.storeId;
        params["catalogId"] = this.catalogId;
        params["langId"] = this.langId;
        params.orderId = ".";
        this.updateParamObject(params, "orderItemId", orderItemId, false, -1);
        this.updateParamObject(params, "requestedShipDate", t, false, -1);
        params.calculationUsage = "-1,-2,-3,-4,-5,-6,-7";
        params.allocate = "***";
        params.backorder = "***";
        params.remerge = "***";
        params.check = "*n";
        params.calculateOrder = "1";

        //For handling multiple clicks
        if (!submitRequest()) {
            return;
        }
        cursor_wait();
        CheckoutHelperJS.RequestShippingDateAction = true;
        wcService.invoke("OrderItemAddressShipMethodUpdate", params);
    },

    /**
     * This function formats the requested shipping date from the jQuery datepicker object into a GMT date string.
     *
     * @param {datepicker object} jsDate The jQuery datepicker object containing the requested shipping date specified by the user.
     * @return {string} String representation of the requested ship date in GMT.
     */
    formatRequestedShipDate: function (jsDate) {
        var date = $(jsDate).datepicker("getDate");
        //Set the time to 12pm to handle cases where daylight savings cause a date shift
        date.setHours(12);
        return date.toISOString();
    },


    /**
     * This function is used to bring up the address entry form when a user wants to create a new address for an item in a multiple shipment scenario.
     *
     * @param {Integer} orderItemId The ID of the order item to update.
     * @param {String} addressType The type of address to create.
     *
     * @private
     */
    createAddressForMS: function (orderItemId, addressType) {
        //For handling multiple clicks
        if (!submitRequest()) {
            return;
        }

        cursor_wait();
        wcRenderContext.updateRenderContext('editShippingAddressContext', {
            'shippingAddress': '-1',
            'addressType': addressType
        });
        //Hide the mainContents (contains shipping/billing details, shop cart details, promotion details, orderDetails)
        this.showHideDivs('editAddressContents', 'mainContents');
    },


    /**
     * Helper function for adding a new address in a multiple shipment scenario.
     *
     * @param (Integer) orderItemId The ID of the item.
     * @param (String) addressType The type of the selected address.
     */
    displayAddressDetailsForMSHelper: function (orderItemId, addressType) {
        this.displayAddressDetailsForMS(-1, orderItemId, addressType);
    },


    /**
     * Displays the details of an address in a multiple shipment check-out scenario.
     *
     * @param {String} addressSelectBoxValue The value, i.e. address ID, of the input address select drop-down object.
     * @param {Integer} orderItemId The order item ID.
     * @param {String} addressType The type of the selected address.
     */
    displayAddressDetailsForMS: function (addressSelectBoxValue, orderItemId, addressType) {
        if (addressSelectBoxValue == -1) {
            this.createAddressForMS(orderItemId, addressType);
        }
    },


    /**
     * This function is used to show or hide the edit address link in multiple and single shipment page.
     * @param {DOM Element} addressSelectBox The select drop-down object that contains all available addresses.
     * @param {String} orderItemId The id of the orderItem for which the edit address link is displayed/hidden.
     */

    showHideEditAddressLink: function (addressSelectBox, orderItemId) {
        if (addressSelectBox.value == '-3') {
            if ($("#editAddressLink_" + orderItemId).length) {
                $("#editAddressLink_" + orderItemId).css("display", "none");
            }
            return;
        }
        var orgAddressList = document.getElementById("shippingOrganizationAddressList");
        if (orgAddressList) {
            var orgAddressArray = [];
            orgAddressArray = orgAddressList.value.toString().split(",");
            for (var i = 0; i < orgAddressArray.length; i++) {
                if ($("#editAddressLink_" + orderItemId).length) {

                    if (addressSelectBox.value == orgAddressArray[i]) {
                        $("#editAddressLink_" + orderItemId).css("display", "none");
                        break;
                    } else {
                        $("#editAddressLink_" + orderItemId).css("display", "block");
                    }
                }
            }
        } else {
            if ($("#editAddressLink_" + orderItemId).length) {
                $("#editAddressLink_" + orderItemId).css("display", "block");
            }
        }
    },

    /**
     * This function is used to show or hide the edit billing address link in multiple and single shipment page.
     * @param {DOM Element} addressSelectBox The select drop-down object that contains all available addresses.
     * @param {String} paymentAreaNumber The area number of the payment section.
     */

    showHideEditBillingAddressLink: function (addressSelectBox, paymentAreaNumber) {

        // If the value is "Please Select Billing Method first", then don't display the edit link on load.
        if (addressSelectBox.value == '-2') {
            $("#editBillingAddressLink_" + paymentAreaNumber).css("display", "none");
            return;
        }

        // Gets the address Ids of all the organization addresses
        var orgAddressList = document.getElementById("shippingOrganizationAddressList");

        //if there exists organization addresses
        if (orgAddressList) {
            var orgAddressArray = [];
            orgAddressArray = orgAddressList.value.toString().split(",");

            //loops through all the organization address Ids
            for (var i = 0; i < orgAddressArray.length; i++) {

                //checks to see if the edit link divs exists
                if ($("#editBillingAddressLink_" + paymentAreaNumber).length) {

                    //compares the selected value address Id in the drop down to the organization address id
                    if (addressSelectBox.value == orgAddressArray[i]) {

                        //hides the link if a match is found and then exits the loop (exit is for the case where there might be a different org address id)
                        $("#editBillingAddressLink_" + paymentAreaNumber).css("display", "none");
                        break;
                    } else {
                        //displays it in all other cases
                        $("#editBillingAddressLink_" + paymentAreaNumber).css("display", "block");
                    }
                }
            }

        } else {

            // if no organization addresses exists, show the valid edit divs.
            if ($("#editBillingAddressLink_" + paymentAreaNumber).length) {
                $("#editBillingAddressLink_" + paymentAreaNumber).css("display", "block");
            }
        }
    },

    /**
     * Sets the order ID when it is not called form the current order.
     * The order ID is used to determine which order to act upon such as in the case of deleting an order item from an order.
     * @param {String} orderId The orderID to use.
     */
    setOrderId: function (orderId) {
        this.orderId = orderId;
    },

    /**
     * Returns the orderId.
     */
    getOrderId: function () {
        return this.orderId;
    },

    /************************************************************
     * End Multiple Shipment page specific functions
     ************************************************************/

    _toggleOrderItemDetails: function (div) {
        if (div.css("display") == "none") {
        	div.css("display", "block");
            $("#orderExpandAreaBottom").css("display", "none");
            $("#OrderItemDetailsPlus").css("display", "none");
            $("#OrderItemDetailsShowPrompt").css("display", "none");
            $("#OrderItemDetailsMinus").css("display", "inline");
            $("#OrderItemDetailsHidePrompt").css("display", "inline");
            $("#OrderItemDetails_plusImage_link").css("display", "none");
            $("#OrderItemDetails_minusImage_link").css("display", "");
        } else {
        	div.css("display", "none");
            $("#orderExpandAreaBottom").css("display", "block");
            $("#OrderItemDetailsPlus").css("display", "inline");
            $("#OrderItemDetailsShowPrompt").css("display", "inline");
            $("#OrderItemDetailsMinus").css("display", "none");
            $("#OrderItemDetailsHidePrompt").css("display", "none");
            $("#OrderItemDetails_plusImage_link").css("display", "");
            $("#OrderItemDetails_minusImage_link").css("display", "none");
        }
    },
    toggleOrderItemDetailsShipping: function (orderItemDetailsDiv, contextId, initializeJS) {
        var div = $("#" + orderItemDetailsDiv);
        if (div.css("display") == "none") {
            if (!div.hasClass('orderRetrieved')) {
                cursor_wait();
                wcRenderContext.updateRenderContext(contextId, {
                    'beginIndex': 0,
                    'storeId': this.storeId,
                    'catalogId': this.catalogId,
                    'langId': this.langId,
                    'initializeJS': initializeJS
                });
                div.addClass('orderRetrieved');
            }
        }
        this._toggleOrderItemDetails(div);
    },

    toggleOrderItemDetailsSummary: function (orderItemDetailsDiv, contextId, beginIndex, pageSize, exOrderId, exQuoteId, fromOrderDetails, analytics) {
        var div = $("#" + orderItemDetailsDiv);
        if (div.css("display") == "none") {
            if (!div.hasClass('orderRetrieved')) {
                cursor_wait();
                wcRenderContext.updateRenderContext(contextId, {
                    'beginIndex': '',
                    'pageSize': pageSize,
                    'externalOrderId': exOrderId,
                    'externalQuoteId': exQuoteId,
                    'isFromOrderDetailsPage': 'false',
                    'analytics': analytics
                });
                div.addClass('orderRetrieved');
            }
        }
        this._toggleOrderItemDetails(div);
    }
}
//-----------------------------------------------------------------
// Licensed Materials - Property of IBM
//
// WebSphere Commerce
//
// (C) Copyright IBM Corp. 2008, 2017 All Rights Reserved.
//
// US Government Users Restricted Rights - Use, duplication or
// disclosure restricted by GSA ADP Schedule Contract with
// IBM Corp.
//-----------------------------------------------------------------

/**
* @fileOverview This JavaScript file contains functions used by the payment section of the checkout pages.
*/

//declare the namespace if it does not already exist
if (CheckoutPayments == null || typeof(CheckoutPayments) != "object") {
	var CheckoutPayments = new Object();
}

CheckoutPayments = {
	/** used to hold error messages for any error encountered */
	errorMessages: {},

	/** indicates the number of payment methods a shopper has selected to use from the shipping and billing page, default to 1 */
	numberOfPaymentMethods: 1,

	/** language ID to be used, default to -1 (English) */
	langId: "-1",

	/** store ID to be used */
	storeId: "",

	/** catalog ID to be used */
	catalogId: "",

	/** indicates if the shipping information on the checkout page has been changed */
	dirtyFlag: false,

	/** locale code to be passed to jQuery functions */
	jQlocale: "",

	/** This constant is the standard number of payment methods supported during order check out. */
	maxNumberOfPaymentMethodsSupported: 3,

	/** Stores all payment objects on the shipping & billing page. */
	paymentObjects: new Array(),

	/** Stores the payment instructions that should be deleted from the order. */
	paymentsToDelete: new Array(),

	/** Stores the payment instructions that should be added to the order. */
	paymentsToAdd: new Array(),

	/** Stores the payment instructions that should be updated in the order. */
	paymentsToUpdate: new Array(),

	/** Keeps track of the previous number of payment methods selected by the user. */
	prevNumberOfPaymentMethods: 1,

	/** The Purchase Order Number entered */
	purchaseOrderNumber: "",

	/** This flag indicates whether billing address dropdown box should be refreshed on change of the payment method.*/
	paymentSpecificAddress: false,

	/** This flag indicates whether quick checkout is enabled*/
	quickCheckoutProfileForPaymentFlag: false,

	/** Keep track of which payment method selection was changed */
	currentPaymentMethodChanged: 1,

	/**
	* Sets the jQlocale variable to be used by jQuery functions
	* @param {String} locale Locale to be set
	*/
	setLocale: function (locale) {
		this.jQlocale = locale;
	},

	/**
	* Sets the quickCheckoutProfileForPaymentFlag variable to be used to display masked credit card info.
	* @param {String} flag to be set true or false
	*/
	setQuickCheckoutProfileForPaymentFlag: function (flag) {
		this.quickCheckoutProfileForPaymentFlag = flag;
	},

	/**
	* This function is used to initialize the error messages object with all the required error messages.
	* @param {String} key The key used to access this error message.
	* @param {String} msg The error message in the correct language.
	*/
	setErrorMessage:function(key, msg) {
		this.errorMessages[key] = msg;
	},

	/**
	* Sets common parameters used by this JavaScript object
	* @param {String} langId language ID to use
	* @param {String} storeId store ID to use
	* @param {String} catalog Catalog ID to use
	*/
	setCommonParameters:function(langId,storeId,catalogId){
		this.langId = langId;
		this.storeId = storeId;
		this.catalogId = catalogId;
	},

	/**
	* This function checks to see how many payments are selected and decides if the number of payment indicator
	* should be shown or not.
	* Initially, the indicator is hidden because there's only 1 payment.
	* If there are more payments methods, the indicator is turned on.
	* @param {String} numPayments number of payments to set
	*/
	setNumPaymentIndicator:function(numPayments) {
		var payment2 = document.getElementById('paymentSection2');

		if (payment2.style.display=='block') {
			//if paymentSection2 is shown, that means there are more than one payment methods. Show all indicators
			for (i=1; i<numPayments; i++){
				var div = document.getElementById('paymentHeading'+i);
				div.style.display="block";
			}
		}else {
			//there's only 1 payment method. Hide the indicators
			document.getElementById('paymentHeading1').style.display="none";
		}
	},

	/**
	* This function displays (unhides) the number of payment methods specified. The pre-requisite is
	* that the payment sections	are named as the prefix that is passed in.
	* Look for the HTML elements named as the prefix passed	in and the number of payment methods required.
	* The rest are disabled.
	* @param {String} totalPaymentMethods The total number of payment methods blocks.
	* @param {String} numberOfPaymentMethodsField The number of payment method block to show.
	* @param {String} divNamePrefix The name of the root HTML element that contains each payment method block.
	*/
	setNumberOfPaymentMethods:function(totalPaymentMethods,numberOfPaymentMethodsField,divNamePrefix) {
		this.numberOfPaymentMethods = numberOfPaymentMethodsField.value;
		for (i=1; i<=totalPaymentMethods; i++) {
			var divNode = document.getElementById(divNamePrefix+i);
			if (divNode != undefined) {
				if (i<=numberOfPaymentMethodsField.value) {
					divNode.style.display = "block";
				} else {
					divNode.style.display = "none";
				}
			}
		}
		var orderTotal = document.getElementById("OrderTotalAmount").value;
		this.updateAmountFields(orderTotal);
		this.setNumPaymentIndicator(numberOfPaymentMethodsField.value);
	},

	/**
	* Clears all payment data for a specified form
	* @param {String} paymentFormName Name of the payment form to be cleared
	*/
	clearPaymentFormData:function(paymentFormName) {
		if (this.getValue(paymentFormName,"cc_brand") !== " ") {
			paymentFormName["cc_brand"].value = " ";
		}
		if (this.getValue(paymentFormName,"cc_cvc") !== " ") {
			paymentFormName["cc_cvc"].value = " ";
		}
		if (this.getValue(paymentFormName,"account") !== " ") {
			paymentFormName["account"].value = " ";
		}
		if (this.getValue(paymentFormName,"payment_token") !== " ") {
			paymentFormName["payment_token"].value = " ";
		}
		if (this.getValue(paymentFormName,"expire_month") !== " ") {
			paymentFormName["expire_month"].value = " ";
		}
		if (this.getValue(paymentFormName,"expire_year") !== " ") {
			paymentFormName["expire_year"].value = " ";
		}
		if (this.getValue(paymentFormName,"check_routing_number") !== " ") {
			paymentFormName["check_routing_number"].value = " ";
		}
		if (this.getValue(paymentFormName,"checkingAccountNumber") !== " ") {
			paymentFormName["checkingAccountNumber"].value = " ";
		}
		if (this.getValue(paymentFormName,"checkRoutingNumber") !== " ") {
			paymentFormName["checkRoutingNumber"].value = " ";
		}
		if (this.getValue(paymentFormName,"numberOfInstallments") !== " ") {
			paymentFormName["numberOfInstallments"].value = " ";
		}
	},

	/**
	* This function sets the context to the selected payment method so that the controller loads
	* the desired struts action.
	* Sets the specific payment block context to the selected payment method. The controller has
	* the mapping of what struts action to load for each payment method.
	* @param {String} paymentMethodSelectBox The identifier of the selected payment method.
	* @param {String} paymentAreaNumber The payment block that this payment method applies to.
	*/
	loadPaymentSnippet:function(paymentMethodSelectBox, paymentAreaNumber){
		// before updating context, clear previous form data
		var formObj = document.forms['PaymentForm'+paymentAreaNumber];
		this.clearPaymentFormData(formObj);

		var selectBoxValueArray = paymentMethodSelectBox.value.split("_");
		var paymentMethodName = selectBoxValueArray[0];
		var paymentTCId = '';
		if(selectBoxValueArray[1] != null){
			paymentTCId = selectBoxValueArray[1];
		}

		if(this.paymentSpecificAddress){
			wcRenderContext.getRenderContextProperties("billingAddressDropDownBoxContext")["payment"+paymentAreaNumber] = paymentMethodName;
			wcRenderContext.getRenderContextProperties("billingAddressDropDownBoxContext")["paymentTCId" + paymentAreaNumber] = paymentTCId;
			wcRenderContext.updateRenderContext("billingAddressDropDownBoxContext");
		}
		MessageHelper.hideAndClearMessage();
		var currentTotal = 0;
		for(var i = 1; i < paymentAreaNumber; i++){
			var formName = document.forms["PaymentForm"+i];
			if (formName.piAmount != null && formName.piAmount.value != "" && !isNaN(formName.piAmount.value)){
				currentTotal = (currentTotal) * (1) + (formName.piAmount.value) * (1);
			}
		}

		var contextPropertyName = "payment" + paymentAreaNumber;
		var buyerOrgDN = formObj.buyerOrgDN.value;
		var orderId = formObj.orderId.value;
		var piAmount = formObj.piAmount.value;
		var params = {};
		params[contextPropertyName] = paymentMethodName;
		params["paymentTCId" + paymentAreaNumber] = paymentTCId;
		params["currentPaymentArea"] = paymentAreaNumber;
		params["payMethodId"] = paymentMethodName;
		params["currentTotal"] = currentTotal;
		params["paymentTCId"] = paymentTCId;
		params["buyerOrgDN"] = buyerOrgDN;
		params["orderId"] = orderId;
		params["piAmount"] = piAmount;
		wcRenderContext.updateRenderContext("paymentContext", params);

		var currentForm = document.forms["PaymentForm"+paymentAreaNumber];
		if (paymentMethodName == "PayInStore") {
			//need to hide the billing address id
			var billingDiv = document.getElementById("billingAddressSelectBoxArea_"+paymentAreaNumber);
			billingDiv.style.display = "none";
			if (currentForm["billing_address_id"]) {
				currentForm.billing_address_id.value = "";
			}
		} else {
			var billingDiv = document.getElementById("billingAddressSelectBoxArea_"+paymentAreaNumber);
			billingDiv.style.display = "block";
			if (currentForm["billing_address_id"] == "") {
				currentForm.billing_address_id.value = "-1";
			}
		}
	},

	/**
	* Loads the payment snippet
	* @param {String} paymentMethodSelectBox The identifier of the selected payment method.
	* @param {String} paymentNumber The payment block that this payment method applies to.
	*
	*/
	loadPaymentSnippetLocally:function(paymentMethodSelectBox, paymentNumber){
		var selectBoxValueArray = paymentMethodSelectBox.value.split("_");
		var selectedPayMethod = selectBoxValueArray[0];
		var selectedDivContents ="";

		// save the current display amount and hidden amount of this payment form
		var thisPaymentAmount = "";
		var thisPaymentDisplayAmount = "";
		var thisForm = document.forms["PaymentForm"+paymentNumber];
		if (thisForm.piAmount != null && thisForm.piAmount.value != "" && !isNaN(thisForm.piAmount.value)){
			thisPaymentAmount = thisForm.piAmount.value;
		}
		if (thisForm.piAmount_display != null && thisForm.piAmount_display.value != "" && !isNaN(thisForm.piAmount_display.value)){
			thisPaymentDisplayAmount = thisForm.piAmount_display.value;
		}

		if(selectBoxValueArray[1] != null){
			var paymentTCId = selectBoxValueArray[1];
			selectedDivContents = $("#PIInfo_Div_"+selectedPayMethod+"_"+paymentNumber + "_" + paymentTCId).html();
		}else{
			selectedDivContents = $("#PIInfo_Div_"+selectedPayMethod+"_"+paymentNumber).html();
		}

		var divNode = document.getElementById("paymentFormDiv"+paymentNumber);
		divNode.html(selectedDivContents);

		// retrieve previously saved display amount and hidden amount of this payment form
		if (thisPaymentAmount != "") {
			thisForm.piAmount.value = thisPaymentAmount;
		}
		if (thisPaymentDisplayAmount != "") {
			thisForm.piAmount_display.value = thisPaymentDisplayAmount;
		}

		//Now set the amount field in the selected payment option with the remaining amount..
		var orderTotal = document.getElementById("OrderTotalAmount").value;
		this.updateAmountFields(orderTotal);
	},

	/**
	* This function processes the current shopping cart. The sequence of operations are:
	* 1. If its a non-ajax checkout, see if shopper has changed anything in current page. If so, alert shopper
	* to update these changes before starting checkout process.
	* 2. Check if its a singlePageCheckout or Traditional Checkout.
	* 2A. If Traditional Checkout, then call OrderPrepare Service and then display the BillingPage, by calling
	* showBillingPage() method
	* 2B. If SinglePageCheckout, then delete existing payment methods, add the new payment methods, call
	* OrderPrepare service and finally call showSummaryPage() method to display the OrderSummaryPage.
	* @param {String} ipFormName Name of the payment form containing payment data
	* @param {Boolean} skipOrderPrepare Indicates if Order Prepare process should be skipped. It defaults to false, if no value is passed.
	*/
	processCheckout:function(piFormName, skipOrderPrepare) {
		if (CheckoutHelperJS.isSinglePageCheckout() && !this.validatePaymentTotals(piFormName)) {
			return;
		}

		if (skipOrderPrepare == undefined || skipOrderPrepare == null){
			skipOrderPrepare = false;
		}

		if(CheckoutHelperJS.checkForDirtyFlag()){
			return;
		}

		if (CheckoutHelperJS.getShipmentTypeId() == "1") {
			if (document.getElementById("requestShippingDateCheckbox") != null) {

				// Validate input and create error message tooltip when there's error
				var jsDate = $("#requestedShippingDate");
				if(!jsDate.ValidationTextbox("validationAndErrorHandler")) {
					jsDate.focus();
					return;
				}
			}

		} else {
			var totalItemsDiv = document.getElementById("totalNumberOfItems");
			if (totalItemsDiv != null) {
				for (var i = 0; i < totalItemsDiv.value; i++) {
	
					var orderItemIdDiv = document.getElementById("orderItem_"+(i+1));
					if (orderItemIdDiv != null) {
						// Order items are being shown, so check shipping date
						var orderItemId = orderItemIdDiv.value;
					
						var requestShippingDateCheckbox = $("#MS_requestShippingDateCheckbox_" + orderItemId)[0];
		
						if (requestShippingDateCheckbox != null){
		
							var jsDate = $("#MS_requestedShippingDate_" + orderItemId);
							if(!jsDate.ValidationTextbox("validationAndErrorHandler")) {
								jsDate.focus();
								return;
							}
						}
					}
				}
			}
		}

		//Validate schedule orders or recurring orders section before allowing checkout. Only one of these
		//two features may be enable at a time.
		//1. schedule order fields are mandatory if either field is selected otherwise is a normal order
		//2. recurring order fields are always mandatory
		if(document.getElementById("scheduleOrderInputSection") != null){
			var scheduleOrderFrequencyObj = document.getElementById("ScheduleOrderFrequency");
			var scheduleOrderStartDateObj = $("#ScheduleOrderStartDate");
			var isRecurringOrderMandatory = document.getElementById("makeRecurringOrderMandatory");
			if((scheduleOrderFrequencyObj.value == "undefined" && scheduleOrderStartDateObj.val() != null) ||
						(isRecurringOrderMandatory && isRecurringOrderMandatory.value == "true" && scheduleOrderFrequencyObj.value == "undefined")){
				MessageHelper.formErrorHandleClient(scheduleOrderFrequencyObj.id, MessageHelper.messages["SCHEDULE_ORDER_MISSING_FREQUENCY"]);
				return;
			}
			if(scheduleOrderFrequencyObj.value != "undefined" && scheduleOrderStartDateObj.val() == null){
				MessageHelper.formErrorHandleClient(scheduleOrderStartDateObj[0].id, MessageHelper.messages["SCHEDULE_ORDER_MISSING_START_DATE"]);
				return;
			}
			if(!CheckoutHelperJS.validateDate(scheduleOrderStartDateObj, 'ScheduleOrderStartDate')){
				return;
			}
		}

		// The following code snippet is used to drop the paymentTermConditionId (if there is one) in the constructed payMethodId value before adding the payment instructions
		var numberOfPaymentMethodsRef = document.getElementById("numberOfPaymentMethods");
		if(numberOfPaymentMethodsRef){
			var paymentMethodsCount = numberOfPaymentMethodsRef.value;
			for(var i=1; i<=paymentMethodsCount; i++){
				var currentPaymentForm = document.forms[piFormName + i];
				//we don't need this block for "PayInStore" flow
				if (currentPaymentForm['payMethodId'].type == "select-one") {
					for(var j=0; j<currentPaymentForm['payMethodId'].options.length; j++){
						var payMethodId = currentPaymentForm['payMethodId'].options[j].value.split('_')[0];
						currentPaymentForm['payMethodId'].options[j].value = payMethodId;
					}
				}
			}
		}
		if(!skipOrderPrepare && !CheckoutHelperJS.isSinglePageCheckout()){
			//Call service to PrepareOrder and then show the billingPage....
			var params = [];
			params["storeId"] = this.storeId;
			params["catalogId"] = this.catalogId;
			params["langId"] = this.langId;
			params.orderId		= ".";
			if(!submitRequest()){
				return;
			}
			cursor_wait();
			wcService.invoke('AjaxPrepareOrderBeforePaymentCapture',params);
			return;
		}
		else{
			//SinglePageCheckout feature enabled.. So billing information is captured on the same page.. Delete existing
			//billing info, Validate and add these new billing info...
			if(skipOrderPrepare){
				this.processPIAndCheckout(piFormName,skipOrderPrepare);
			} else {
				var params = [];
				params["storeId"] = this.storeId;
				params["catalogId"] = this.catalogId;
				params["langId"] = this.langId;
				if(!submitRequest()){
					return;
				}
				cursor_wait();
				wcService.invoke('AjaxPrepareOrderBeforeSubmit', params);
			}
		}
	},

	/**
	* This function examines all payment instructions to find out which one(s) needs to be deleted, added or updated, then calls the corresponding AJAX service to process them.
	* Once all payment instructions are processed successfully, the current shopping cart is submitted.
	* @param {String} ipFormName Name of the payment form containing payment data
	* @param {Boolean} skipOrderPrepare Indicates if Order Prepare process should be skipped. It defaults to false, if no value is passed.
	*/
	processPIAndCheckout:function(piFormName, skipOrderPrepare) {
		if (skipOrderPrepare == undefined || skipOrderPrepare == null){
			skipOrderPrepare = false;
		} else if (skipOrderPrepare == 'true' || skipOrderPrepare == 'false'){
			//If skipOrderPrepare is passed in as a string instead of boolean from a service response
			//Cast the value back to a boolean before further processing
			skipOrderPrepare = (skipOrderPrepare === 'true');
		}

		if (this.checkValidPaymentInstructions(piFormName)){
			var formName = document.forms[piFormName + '1'];
			if(this.getValue(formName,"valueFromProfileOrder") == "Y") {
				this.setQuickCheckoutProfileForPaymentFlag("true");

				// Only the first payment method could be from the quick checkout profile. If it is, then re-add the payment instruction (PI).
				// This fixes the problem where a standard PI has already been registered with the order and the user now chooses quick checkout profile to check out without further modifying the payment.
				this.updatePaymentObject(1, "account");
			}

			var maxNumberOfPaymentMethodsSupported = parseInt(this.maxNumberOfPaymentMethodsSupported);

			for(var i=1; i<=maxNumberOfPaymentMethodsSupported; i++){
				var paymentObj = this.retrievePaymentObject(i);
				if(paymentObj != null){
					if((paymentObj['action'] == 'delete' || paymentObj['action'] == 're-add') && paymentObj['piId'] != ""){
						this.setPaymentsToDelete(i);
					}
					if(paymentObj['action'] == 'add' || paymentObj['action'] == 're-add'){
						this.setPaymentsToAdd(i);
					}
					if(paymentObj['action'] == 'update' && paymentObj['piId'] != ""){
						this.setPaymentsToUpdate(i);
					}
				}
			}
			if(this.getPaymentsToDelete().length > 0){
				this.deletePaymentInstructions();
			}else if(this.getPaymentsToAdd().length > 0){
				this.addPaymentInstructions();
			}else if(this.getPaymentsToUpdate().length > 0){
				this.updatePaymentInstructions();
			}else{
				CheckoutPayments.setCommonParameters(SBServicesDeclarationJS.langId,SBServicesDeclarationJS.storeId,SBServicesDeclarationJS.catalogId);
				CheckoutPayments.showSummaryPage();
				cursor_clear();
			}
			CheckoutHelperJS.setFieldDirtyFlag(false);
		}
	},

	/**
	* Determines the URL of the order summary page and invokes the page
	*/
	showSummaryPage:function(){
		if(document.getElementById("scheduleOrderInputSection") != null){
			CheckoutHelperJS.prepareOrderSchedule();
		}

		var po_id = encodeURIComponent(this.purchaseOrderNumber);
		var url = '';
		if(CheckoutHelperJS.getShipmentTypeId() == "1"){
			url = "SingleShipmentOrderSummaryView?langId="+this.langId+"&storeId="+this.storeId+"&catalogId="+this.catalogId+"&purchaseorder_id="+po_id+"&quickCheckoutProfileForPayment="+this.quickCheckoutProfileForPaymentFlag;
			document.location.href = appendWcCommonRequestParameters(url);
		}
		else {
			url = "MultipleShipmentOrderSummaryView?langId="+this.langId+"&storeId="+this.storeId+"&catalogId="+this.catalogId+"&purchaseorder_id="+po_id+"&quickCheckoutProfileForPayment="+this.quickCheckoutProfileForPaymentFlag;
			document.location.href = appendWcCommonRequestParameters(url);
		}
	},

	showBillingPage:function(){
		document.location.href = appendWcCommonRequestParameters("OrderBillingView?langId="+this.langId+"&storeId="+this.storeId+"&catalogId="+this.catalogId+"&forceShipmentType="+CheckoutHelperJS.getShipmentTypeId());
	},

	/**
	* Populates payment data
	* @param {String} formName Name of the payment form to be populated
	* @param {Object} params Object containing payment data
	* @retrun {Object} params Object holding payment data
	*/
	populateProtocolData:function(formName,params){
		params = this.updateParamObject(params,"storeId",this.getValue(formName,"storeId"),true);
		params = this.updateParamObject(params,"payment_token",this.getValue(formName,"payment_token"),true);
		params = this.updateParamObject(params,"catalogId",this.getValue(formName,"catalogId"),true);
		params = this.updateParamObject(params,"langId",this.getValue(formName,"langId"),true);
		params = this.updateParamObject(params,"valueFromProfileOrder",this.getValue(formName,"valueFromProfileOrder"),true);
		params = this.updateParamObject(params,"valueFromPaymentTC",this.getValue(formName,"valueFromPaymentTC"),true);
		params = this.updateParamObject(params,"paymentTCId",this.getValue(formName,"paymentTCId"),true);
		params = this.updateParamObject(params,"payMethodId",this.getValue(formName,"payMethodId"),true);
		params = this.updateParamObject(params,"piAmount",this.getValue(formName,"piAmount"),true);
		params = this.updateParamObject(params,"billing_address_id",this.getValue(formName,"billing_address_id"),true);
		params = this.updateParamObject(params,"cc_brand",this.getValue(formName,"cc_brand"),true);
		params = this.updateParamObject(params,"cc_cvc",this.getValue(formName,"cc_cvc"),true);

		params = this.updateParamObject(params,"account",this.getValue(formName,"account"),true);
		params = this.updateParamObject(params,"expire_month",this.getValue(formName,"expire_month"),true);
		params = this.updateParamObject(params,"expire_year",this.getValue(formName,"expire_year"),true);

		params = this.updateParamObject(params,"check_routing_number",this.getValue(formName,"check_routing_number"),true);
		params = this.updateParamObject(params,"checkingAccountNumber",this.getValue(formName,"checkingAccountNumber"),true);
		params = this.updateParamObject(params,"checkRoutingNumber",this.getValue(formName,"checkRoutingNumber"),true);
		params = this.updateParamObject(params,"requesttype","ajax",true);
		if(formName.authToken){
			params = this.updateParamObject(params,"authToken",this.getValue(formName,"authToken"),true);
		}
		return params;

	},

	/**
	* Populates payment data based on a specified array of fields.
	* @param {DOM Object} formName The payment form that contains input data.
	* @param {Array} params The array object that contains payment data.
	* @param {Array} arrayFields The array object containing the specified input fields that this function should populate data for.
	* @retrun {Array} params Array holding payment data.
	*/
	populateProtocolDataForGivenFields:function(formName,params,arrayFields){
		for(var i=0; i<arrayFields.length; i++){
			var field = arrayFields[i];
			params = this.updateParamObject(params,field,this.getValue(formName,field),true);
		}
		params = this.updateParamObject(params,"requesttype","ajax",true);
		return params;
	},

	/**
	* Gets the text value of a particular 'selectBox' from the form
	* @param {String} formName Name of the payment form
	* @param {String} fieldName Name of the filed to get value from
	* @return {String} the selected text of the field
	*/
	getSelected: function(formName,fieldName)
	{
		if (formName[fieldName] != null){
			var selObj = formName[fieldName];

			var selIndex = selObj.selectedIndex;
			  //in case index/selected option not found, return blank
			return (selIndex !== -1 ) ? selObj.options[selIndex].text : "";
		}
		else{
			return "";
		}
	},

	/**
	* Gets the value of a particular field in the form
	* @param {String} formName Name of the payment form
	* @param {String} fieldName Name of the filed to get value from
	* @return {String} value of the field
	*/
	getValue:function(formName,fieldName){
		if (formName[fieldName] != null)
			return formName[fieldName].value;
		else return " ";
	},

	/**
	* This function trims the spaces from the passed in word.
	* Delete all pre and trailing spaces around the word.
	* @param {String} inword The word to trim.
	* @return {String} Word with leading and trailing spaces trimmed
	*/
	trim:function(inword)
	{
	   word = inword.toString();
	   var i=0;
	   var j=word.length-1;
	   while(word.charAt(i) == " ") i++;
	   while(word.charAt(j) == " ") j=j-1;
	   if (i > j) {
			return word.substring(i,i);
		} else {
			return word.substring(i,j+1);
		}
	},

	/**
	* This function verifies that all the characters in the word are numbers.
	* This function is used to verify if a word is made up of all numbers.
	* @param {String} word The prefix used for the payment blocks.
	* @return {Boolean} False if word is not a number. True if word is a number.
	*/
	isNumber:function(word)
	{
		var numbers="0123456789";
		var word=this.trim(word);
		for (var i=0; i < word.length; i++)
		{
			if (numbers.indexOf(word.charAt(i)) == -1)
			return false;
		}
		return true;
	},

	/**
	* Make sure all changes to the hidden piAmount are synchronized with the piAmount_display
	* and formatted to the current locale
	* This function will check whether the hidden piAmount field has been updated by other
	* services or calculations etc, if so, format the value and copy it over to the
	* piAmount_display field
	* @param {String} paymentAreaNumber The payment area number to check the amount for.
	*/
	formatAmountDisplayForLocale:function(paymentAreaNumber) {
		//Take the hidden payment amount and format it to the current locale
		var paymentAmount = document.getElementById("piAmount_"+paymentAreaNumber);
		var paymentAmount_display = document.getElementById("piAmount_"+paymentAreaNumber+"_display");

		if(this.jQlocale == 'ar_EG')
		{
			var formattedPaymentAmountValue = Utils.formatNumber(paymentAmount.value, {
				maximumFractionDigits: 2,
				minimumFractionDigits: 2
			});
		}
		else
		{
			if (this.jQlocale.indexOf('zh') === 0 || this.jQlocale.indexOf('ja') === 0 || this.jQlocale.indexOf('ko') === 0) {
				// Add trailing 0 only if necessary.  Only useful for double-byte languages
				var formattedPaymentAmountValue = Utils.formatNumber(paymentAmount.value, {
 					locale: this.jQlocale,
 					maximumFractionDigits: 1
 				});
			}
			else {
				// Always add 2 trailing 0.  Only useful for single-byte languages
				var formattedPaymentAmountValue = Utils.formatNumber(paymentAmount.value, {
 					locale: this.jQlocale,
 					minimumFractionDigits: 2,
 					maximumFractionDigits: 2
 				});
			}
		}

		//If the displayed payment amount is different from the hidden payment amount
		//Synchronize the display payment amount according to the hidden payment amount
		if(paymentAmount_display.value != formattedPaymentAmountValue || this.jQlocale == 'ar_EG'){
			paymentAmount_display.value = formattedPaymentAmountValue;
		}
	},

	/**
	* This function verifies that the amount is valid.
	* This function will check that the amount field is not	empty, and is not negative and that
	* is numeric.
	* @param {String} formNamePrefix The prefix used for the payment blocks.
	* @param {String} paymentAreaNumber The payment area number to check the amount for.
	* @return {Boolean} False if amount is not valid. True if amount is valid.
	*/
	validateAmount:function(formNamePrefix, paymentAreaNumber) {
		//verify the field amount entered is a number
		var formName = document.forms[formNamePrefix+paymentAreaNumber];

		//Take the displayed payment amount, parse it back to a number
		// First trim leading and trailing spaces
		formName.piAmount_display.value = formName.piAmount_display.value.replace(/^\s+|\s+$/g,"");
		formName.piAmount_display.value = formName.piAmount_display.value.replace(/\xa0/g,'');
		var valueToParse = formName.piAmount_display.value;

		if(this.jQlocale == 'ar_EG')
		{
			valueToParse = valueToParse.replace(',','');
			var parsedAmountValue = Utils.formatNumber(valueToParse, {maximumFractionDigits: 2, minimumFractionDigits: 2});
		}
		else
		{
			var parsedAmountValue = Utils.parseNumber(valueToParse);
		}

		//If the displayed payment amount and the hidden payment amount are different
		//Synchronize the 2 fields according to the displayed payment amount
		if(parsedAmountValue != formName.piAmount.value){
			formName.piAmount.value = parsedAmountValue;
		}

		if (formName.piAmount != null && formName.piAmount.value == "") {
			MessageHelper.formErrorHandleClient(formName.piAmount_display,this.errorMessages["EDPPaymentMethods_NO_AMOUNT"]);
			return false;
		} else if (formName.piAmount != null && parseFloat(formName.piAmount.value) < 0){
			MessageHelper.formErrorHandleClient(formName.piAmount_display,this.errorMessages["EDPPaymentMethods_AMOUNT_LT_ZERO"]);
			return false;
		} else if (formName.piAmount != null && isNaN(formName.piAmount.value)) {
			MessageHelper.formErrorHandleClient(formName.piAmount_display,this.errorMessages["EDPPaymentMethods_AMOUNT_NAN"]);
			return false;
		}


		//amount total is correct. Save it in the context so that we can retrieve it when user changes payment method
		var params = {};
		params["paymentAreaAmount"+paymentAreaNumber] = parsedAmountValue;
		wcRenderContext.updateRenderContext("paymentContext", params);

		return true;

	},

	/**
	* This function submits the current shopping cart once all the payment instructions are added successfully.
	* This function will add all the payment instructions first with AJAX calls and then calls the order
	* processing service.
	* @param {String} formNamePrefix The prefix used for the payment blocks.
	* @retrun {Boolean} True if sum of payment amounts is equal to the order total. False if sum of payment amounts does not equal order total.
	*/
	validatePaymentTotals:function(formNamePrefix) {
		//verify that all payment amounts sum up to the order total
		var runningTotal = parseFloat(0.0);
		var orderTotal = document.getElementById("OrderTotalAmount").value;
		for (var i=1; i<=this.numberOfPaymentMethods; i++) {
			var formName = document.forms[formNamePrefix+i];

			if (this.validateAmount(formNamePrefix, i)) {
				runningTotal = runningTotal + parseFloat(formName.piAmount.value);
				var temp = runningTotal.toFixed(2);
				runningTotal = parseFloat(temp);
			} else {
				return false;
			}
		}
		if (runningTotal == orderTotal) {
			return true;
		} else {
			var element = (document.getElementsByName("piAmount_display"))[0]; // get the Amount field of the first payment method
			if (runningTotal < orderTotal) {
				MessageHelper.formErrorHandleClient(element, this.errorMessages["EDPPaymentMethods_CANNOT_RECONCILE_PAYMENT_AMT"]);
				return false;
			} else if (runningTotal > orderTotal) {
				MessageHelper.formErrorHandleClient(element, this.errorMessages["EDPPaymentMethods_PAYMENT_AMOUNT_LARGER_THAN_ORDER_AMOUNT"]);
				return false;
			} else {
				MessageHelper.formErrorHandleClient(element, this.errorMessages["EDPPaymentMethods_PAYMENT_AMOUNT_PROBLEM"]);
				return false;
			}
		}
	},

	/**
	* This function validates the billing address details to make sure that they are not empty.
	* @param {String} formNamePrefix The prefix used for the payment blocks.
	* @return {Boolean} True if all fields are validated without error. False if an error has encountered.
	*/
	isBillingAddressValid:function(formNamePrefix) {
		for (var i=1; i<=this.numberOfPaymentMethods; i++) {
			var formName = document.forms[formNamePrefix+i];
			var billing_address_isValid = formName.billing_address_isValid;
			if (billing_address_isValid) {
				if (billing_address_isValid.value == "false") {
					return false;
				}
			}
		}
		return true;
	},

	/**
	* This function validates all mandatory fields in the payment section are not empty.
	* This function makes sure all fields are valid before calling order services.
	* @param {String} formNamePrefix The prefix used for the payment blocks.
	* @return {Boolean} True if all fields are validated without error. False if an error has encountered.
	*/
	checkValidPaymentInstructions:function(formNamePrefix) {
		for (var i=1; i<=this.numberOfPaymentMethods; i++) {
			var formName = document.forms[formNamePrefix+i];
			var mandatoryFields = " ";
			if(formName["mandatoryFields_"+i] != null){
				mandatoryFields = formName["mandatoryFields_"+i].value;
			}
			var purchaseOrderForm = document.forms["purchaseOrderNumberInfo"];
			if (purchaseOrderForm) {
				this.purchaseOrderNumber = purchaseOrderForm.purchase_order_number.value;
				if(purchaseOrderForm.purchaseOrderNumberRequired.value == 'true' && purchaseOrderForm.purchase_order_number.value == ""){
					MessageHelper.formErrorHandleClient(purchaseOrderForm.purchase_order_number,this.errorMessages["ERROR_PONumberEmpty"]);
					return false;
				}
				else if(!MessageHelper.isValidUTF8length(purchaseOrderForm.purchase_order_number.value, 128)){
					MessageHelper.formErrorHandleClient(purchaseOrderForm.purchase_order_number,this.errorMessages["ERROR_PONumberTooLong"]);
					return false;
				}
			}
			if (formName.payMethodId.type == "select-one") {
				if (formName.payMethodId.options[formName.payMethodId.options.selectedIndex].value == "empty") {
					MessageHelper.formErrorHandleClient(formName.payMethodId,this.errorMessages["EDPPaymentMethods_NO_PAYMENT_SELECTED"]);
					return false;
				}
			}
			/* All the visa, masterCard and Amex  pages will have account1 field which will be filled by user and one more hidden field by name
			account...
			1. If its a quickcheckout profile and data is valid (!dirty) then copy the value of unmaskedAccount field into hidden account field
			2. If its not a quickcheckout or if data is dirty, then copy the value entered by user (account1 into hidden field account */
			//Its not a quick checkout..so just assign value of account1 to account..
			if(CheckoutHelperJS.isPaymentDataDirty(i)){
				if(document.getElementById("account_"+i) != null){
					document.getElementById("account_"+i).value = document.getElementById("account1_"+i).value;
				}
			}

			if (document.getElementById("expire_month_"+i) != null || document.getElementById("expire_year_"+i) != null) {
				var now = new Date(formName.curr_year.value,formName.curr_month.value - 1,formName.curr_date.value);
				var lastday = 1;
				var lastmonth = 1;

				if (document.getElementById("expire_month_"+i) != null) {
					lastmonth = new Number(document.getElementById("expire_month_"+i).value) + 1;
					if (lastmonth > 13) {
						lastmonth = 1;
					}
				}

				var expiry = 2000;
				if (document.getElementById("expire_year_"+i) != null) {
					expiry = new Date(document.getElementById("expire_year_"+i).value,lastmonth - 1,lastday);
				}
			}

			//Start validations...
			if (formName.piAmount != null && parseFloat(formName.piAmount.value) < 0){
				MessageHelper.formErrorHandleClient(formName.piAmount_display,this.errorMessages["EDPPaymentMethods_AMOUNT_LT_ZERO"]);
				return false;
			// account is checked for StandardAmex, StandardMasterCard, StandardVisa, StandardLOC and StandardCheck
			} else if (mandatoryFields.indexOf("account_"+i) != -1 && document.getElementById("account_"+i) != null && document.getElementById("account_"+i).value == "" ) {
				MessageHelper.displayErrorMessage(this.errorMessages["EDPPaymentMethods_NO_ACCOUNT_NUMBER"]);
				return false;
			// expiry date can be checked for credit cards StandardAmex, StandardMasterCard and StandardVisa
			} else if ((mandatoryFields.indexOf("expire_month_"+i) != -1 && mandatoryFields.indexOf("expire_year_"+i) != -1 && document.getElementById("expire_month_"+i) != null && document.getElementById("expire_year_"+i) != null)
					&& now >= expiry) {
				MessageHelper.displayErrorMessage(this.errorMessages["EDPPaymentMethods_INVALID_EXPIRY_DATE"]);
				return false;
			} else if (formName.piAmount != null && formName.piAmount.value == "") {
				MessageHelper.formErrorHandleClient(formName.piAmount_display,this.errorMessages["EDPPaymentMethods_NO_AMOUNT"]);
				return false;
			} else if (formName.piAmount != null && isNaN(formName.piAmount.value)) {
				MessageHelper.formErrorHandleClient(formName.piAmount_display,this.errorMessages["EDPPaymentMethods_AMOUNT_NAN"]);
				return false;
			} else if (mandatoryFields.indexOf("check_routing_number_"+i) != -1 && document.getElementById("check_routing_number_"+i) != null && document.getElementById("check_routing_number_"+i).value == "") {
				MessageHelper.displayErrorMessage(this.errorMessages["EDPPaymentMethods_NO_ROUTING_NUMBER"]);
				return false;
			}
			else if (mandatoryFields.indexOf("CheckAccount_"+i) != -1 && document.getElementById("CheckAccount_"+i) != null && document.getElementById("CheckAccount_"+i).value == "") {
				MessageHelper.displayErrorMessage(this.errorMessages["EDPPaymentMethods_NO_BANK_ACCOUNT_NO"]);
				return false;
			}
			else if (mandatoryFields.indexOf("billing_address_id") != -1 && formName.billing_address_id != null && (formName.billing_address_id.value == "" || formName.billing_address_id.value == "-1")) {
				MessageHelper.displayErrorMessage(this.errorMessages["EDPPaymentMethods_NO_BILLING_ADDRESS"]);
				return false;
			} else if (CheckoutHelperJS.isPaymentDataDirty(i) && mandatoryFields.indexOf("cc_cvc_"+i) != -1 && document.getElementById("cc_cvc_"+i) != null && this.trim(document.getElementById("cc_cvc_"+i).value)!= null && this.trim(document.getElementById("cc_cvc_"+i).value)!= ""){
				if (!this.isNumber(document.getElementById("cc_cvc_"+i).value)) {
					MessageHelper.displayErrorMessage(this.errorMessages["EDPPaymentMethods_CVV_NOT_NUMERIC"]);
					return false;
				}
			}
		}

		if (!this.isBillingAddressValid(formNamePrefix)) {
			MessageHelper.displayErrorMessage(this.errorMessages["EDPPaymentMethods_BILLING_ADDRESS_INVALID"]);
			return false;
		}

		if (!CheckoutHelperJS.isSinglePageCheckout() && !this.validatePaymentTotals(formNamePrefix)) {
			return false;
		}
		return true;
	},

	/**
	* Updates existingPiId element of the payment form passed in
	* @param {String} piFormName Form name of the payment form
	* @param {String} piId
	*/
	updateExistingPiId:function(piFormName,piId){
		if(piFormName != null){
			var formName = document.forms[piFormName+1];
			formName.existingPiId.value = piId;
		}
	},

	/**
	* This function updates the given params object with Key value pair.
	* If the toArray value is true, It creates an Array for duplicate entries. Else, It overwrites the old value.
	* It is useful while making a service call which excepts few paramters of type array
	* @param {Object} params array holding parameters
	* @param {String} key Key to store and retrieve the parameter
	* @param {String} value	Value of the parameter
	* @param {Boolean} toArray If true, creates an Array for duplicate entries. If false, does not creat an
	* Array for duplicate entries. It overwrites the old value.
	* @return	{Object} params A JavaScript Object having key - value pair.
	*/
	updateParamObject:function(params, key, value, toArray, index){
	   if(params == null){
		   params = [];
	   }

	   if(params[key] != null && toArray)
	   {
			if($.isArray(params[key]))
			{
				//3rd time onwards
				if(index != null && index != "")
				{
					//overwrite the old value at specified index
					 params[key][index] = value;
				}
				else
				{
					params[key].push(value);
				 }
			}
			else
			{
				 //2nd time
				 var tmpValue = params[key];
				 params[key] = [];
				 params[key].push(tmpValue);
				 params[key].push(value);
			}
	   }
	   else
	   {
			//1st time
		   if(index != null && index != "" && index != -1)
		   {
			  //overwrite the old value at specified index
			  params[key+"_"+index] = value;
		   }
		   else if(index == -1)
		   {
			  var i = 1;
			  while(params[key + "_" + i] != null)
			  {
				   i++;
			  }
			  params[key + "_" + i] = value;
		   }
		   else
		   {
			  params[key] = value;
			}
	   }
	   return params;
	 },

	/**
	* Save the selected address in billingAddressDropDownBoxContext,so that we can reselect this when the billing address
	* drop down box is refreshed. Billing address drop down box is refreshed on create New billing address action.
	* @param {String} actionType Type of action to be performed (e.g. edit)
	* @param {String} paymentArea The payment area number for this function to work on.
	*/
	saveBillingAddressDropDownBoxContextProperties:function(actionType,paymentArea){
		for(var i = 1; i < 4; i++){
			var form = document.forms["PaymentForm"+i];
			if(form) {
				if(form.billing_address_id != null){
					var selectedBillingAddress = form.billing_address_id.value;
					if (actionType == 'create' && paymentArea == i) {
						//creating a new address here. make selectedBillingAddress to -1 to indicated that the payment area needs to be refreshed later
						selectedBillingAddress = "-1";
					}
					wcRenderContext.getRenderContextProperties("billingAddressDropDownBoxContext")["billingAddress"+i] = selectedBillingAddress;
				}
			} else if(form == null && i > 1) {
				//do nothing it is fine
			} else {
				return;
			}
		}

		if(actionType == 'edit'){
			//If its edit, then set the billingAddress property to -1 for all the billing address select boxes, which has edited address selected.
			//so that the new addressId is selected...
			//Otherwise we would have saved old addressId and this old addressId doesnt exist anymore, since addressId changes on edit..
			var form = document.forms["PaymentForm"+paymentArea];
			if (form) {
				var selectedBillingAddress = form.billing_address_id.value;
				for(var i = 1; i < 4; i++){
					var form1 = document.forms["PaymentForm"+i];
					if (form1) {
						var selectedBillingAddress1 = form1.billing_address_id.value;
						if(selectedBillingAddress1 == selectedBillingAddress){
							wcRenderContext.getRenderContextProperties("billingAddressDropDownBoxContext")["billingAddress"+i] = "-1";
						}
					}
				}
			}
		}
	},

	/**
	* helper function to create a new billing address
	* @param {String} paymentAreaNumber The payment area number for this function to work on.
	* @param {String} addressType Value to pass to createAddress function. Address type of the address to be created.
	*/
	createBillingAddress:function(paymentAreaNumber,addressType){
		this.saveBillingAddressDropDownBoxContextProperties('create',paymentAreaNumber);
		CheckoutHelperJS.createAddress(-1,addressType);
	},

	/**
	* Displays detail information of the billing address
	* @param {String} addressSelectBox HTML dropdown box that contains billing address selection
	* @param {String} paymentAreaNumber The payment area number for this function to work on.
	* @param {String} addressType Value to pass to createAddress function. Address type of the address to be created.
	*/
	displayBillingAddressDetails:function(addressSelectBox,paymentAreaNumber,addressType){
		if(addressSelectBox.value != -1){
			document.getElementById("selectedAddressId_"+paymentAreaNumber).value = addressSelectBox.value;
		}

		//Also save the selected address in billingAddressDropDownBoxContext,so that we can reselect this when the billing address
		//drop down box is refreshed...Billing address drop down box is refreshed on create New billing address action...
		this.saveBillingAddressDropDownBoxContextProperties('create','-1');

		if(addressSelectBox.value != -1){
			//Display selected address details..
			var addressKey = "billingAddress" + paymentAreaNumber;
			wcRenderContext.updateRenderContext('billingAddressDropDownBoxContext', {addressKey:addressSelectBox.value, 'areaNumber':paymentAreaNumber});
		}

	},
	/**
	 * returns the current total of the order in a JSON object.
	 * @param {String} operation Identifies where this method is being called from, to determine the processing after.
	 * @param {String} ipFormName Name of the payment form containing payment data
	 * @param {Boolean} skipOrderPrepare Indicates if Order Prepare process should be skipped.
	 */
	getTotalInJSON: function (operation, piFormName, skipOrderPrepare) {
		var parameters = {};
		parameters.operation = operation;
		parameters.piFormName = piFormName;
		parameters.skipOrderPrepare = skipOrderPrepare;
		parameters.storeId = this.storeId;
		parameters.catalogId = this.catalogId;
		parameters.langId = this.langId;
		var url = appendWcCommonRequestParameters("orderTotalAsJSON");
		wcTopic.publish("ajaxRequestInitiated");
		$.ajax({
				url: url,
				method: "POST",
				dataType: "json",
				data: parameters,
				context: this,
				success: CheckoutPayments.updateAmountFieldsWithTotalInJSON,
				error: function(jqXHR, textStatus, error) {
					console.debug("error - inside CheckoutPayments.getTotalInJSON()");
					console.debug(error);
					wcTopic.publish("ajaxRequestCompleted");
				}
		});
	},

	/**
	 * This is helper function for updateAmountFields. It retrieves the total from a JSON object and passes it to updateAmountFields.
	 * @param {Object} The data returned from $.ajax, formatted according to the dataType parameter or the dataFilter callback function, if specified
	 * @param {String} A string describing the status of the $.ajax call
	 * @param {Object} The jqXHR (in jQuery 1.4.x, XMLHttpRequest) object from $.ajax
	 */
	updateAmountFieldsWithTotalInJSON:function(data, textStatus, jqXHR){
		if (data != null && data != undefined) {
			 CheckoutPayments.updateAmountFields(data.orderTotal, data.operation, data.piFormName,data.skipOrderPrepare );
		}
		wcTopic.publish("ajaxRequestCompleted");
	},

	/**
	* This functions calculates payment amount value of each payment area
	* @param {String} updatedTotal The grand total of the order
	* @param {String} operation Identifies where this method is being called from, to determine the processing after.
	* @param {String} ipFormName Name of the payment form containing payment data
	* @param {String} skipOrderPrepare Indicates if Order Prepare process should be skipped.
	*/
	updateAmountFields:function(updatedTotal, operation, piFormName, skipOrderPrepare){
		var totalPayments = 0;
		var formName;
		var currentTotal = 0.0;
		this.numberOfPaymentMethods = document.getElementById("numberOfPaymentMethods").value;
		if(document.getElementById("OrderTotalAmount") != null){
			document.getElementById("OrderTotalAmount").value = updatedTotal;
		}
		if(this.numberOfPaymentMethods == 1){
			formName = document.forms["PaymentForm1"];
			if (formName.piAmount != null && formName.piAmount.value != "" && !isNaN(formName.piAmount.value)){
				formName.piAmount.value = updatedTotal;
				formName.piAmount_display.value = updatedTotal;
				this.formatAmountDisplayForLocale("1");
				if(this.retrievePaymentObject(1) != null){
					this.updatePaymentObject(1, 'piAmount');
				}
			}
			if(operation != undefined && operation == 'OrderPrepare'){
				this.processPIAndCheckout(piFormName,skipOrderPrepare);
			} else if ((operation != undefined && operation == 'loadPaymentSnippet') || supportPaymentTypePromotions) {
				if (this.currentPaymentMethodChanged) {
					this.loadPaymentSnippet(document.getElementById("payMethodId_" + this.currentPaymentMethodChanged), this.currentPaymentMethodChanged);
					this.updatePaymentObject(this.currentPaymentMethodChanged, 'payMethodId');
				}
			}

			return;
		}

		for (var i=1; i<=this.numberOfPaymentMethods; i++) {
			formName = document.forms["PaymentForm"+i];
			if (formName.piAmount != null && formName.piAmount.value != "" && !isNaN(formName.piAmount.value)){
				currentTotal = (currentTotal) * (1) + (formName.piAmount.value) * (1);
			}
		}

		var difference = updatedTotal - currentTotal;
		difference = Math.round(difference*100)/100;

		if(difference > 0){
			//So difference is > 0.. order total is increased.. add this to last payment..
			var j = this.numberOfPaymentMethods;
			formName = document.forms["PaymentForm"+j];
			if (formName.piAmount != null && formName.piAmount.value != "" && !isNaN(formName.piAmount.value)){
				formName.piAmount.value = parseFloat(formName.piAmount.value) + parseFloat(difference);
				formName.piAmount_display.value = formName.piAmount.value;
				this.formatAmountDisplayForLocale(j);
				if(this.retrievePaymentObject(j) != null){
					this.updatePaymentObject(j, 'piAmount');
				}
			}
		}
		else{
			//The order total is decreased..remove it from last payment..if last payment goes negative, then set it to 0 and remove remaining from last but one...and so on..
			difference = difference * -1;
			for(var k = this.numberOfPaymentMethods; k > 0; k--){
				formName = document.forms["PaymentForm"+k];
				if (formName.piAmount != null && formName.piAmount.value != "" && !isNaN(formName.piAmount.value)){
					if(formName.piAmount.value > difference){
						var t = formName.piAmount.value - difference;
						formName.piAmount.value = Math.round(t*100)/100;
						formName.piAmount_display.value = formName.piAmount.value;
						this.formatAmountDisplayForLocale(k);
						if(this.retrievePaymentObject(k) != null){
							this.updatePaymentObject(k, 'piAmount');
						}
						difference = 0;
						break;
					}
					else{
						//Set this payment to 0 and decrease the difference...
						difference = difference - formName.piAmount.value;
						formName.piAmount.value = 0;
						if(this.retrievePaymentObject(k) != null){
							this.updatePaymentObject(k, 'piAmount');
						}
						this.formatAmountDisplayForLocale(k);
					}
				}
			}
		}
		if(operation != undefined && operation == 'OrderPrepare'){
			this.processPIAndCheckout(piFormName,skipOrderPrepare);
		} else if (operation != undefined && operation == 'loadPaymentSnippet') {
			if (this.currentPaymentMethodChanged ) {
				this.loadPaymentSnippet(document.getElementById("payMethodId_" + this.currentPaymentMethodChanged), this.currentPaymentMethodChanged);
				this.updatePaymentObject(this.currentPaymentMethodChanged, 'payMethodId');
			}
		}
	},


	/**
	 * Removes the credit card number and the security code from the given payment area.
	 * @param {Integer} paymentAreaNumber The payment area number.
	 * @param {Boolean} removeCardNumber A true or false value to indicate if the credit card number should be removed from the payment form.
	 * @param {Boolean} removeCVV A true or false value to indicate if the credit card security code should be removed from the payment form.
	 */
	removeCreditCardNumberAndCVV: function(paymentAreaNumber, removeCardNumber, removeCVV){
		if(!CheckoutHelperJS.isPaymentDataDirty(paymentAreaNumber)){
			if(removeCardNumber){
				if(document.forms["PaymentForm" + paymentAreaNumber].valueFromProfileOrder == null || document.forms["PaymentForm" + paymentAreaNumber].valueFromProfileOrder.value != 'Y'){
					if($("#account1_" + paymentAreaNumber).length){
						$("#account1_" + paymentAreaNumber).val("");
					}
				}
			}
			if(removeCVV){
				if($("#cc_cvc_" + paymentAreaNumber).length){
					$("#cc_cvc_" + paymentAreaNumber).val("");
				}
			}
		}
	},

	/**
	 * Initializes the payment area dirty flags when the order shipping & billing page is loaded.
	 */
	initializePaymentAreaDataDirtyFlags: function(){
		CheckoutHelperJS.dataDirty[1] = false;
		CheckoutHelperJS.dataDirty[2] = false;
		CheckoutHelperJS.dataDirty[3] = false;
	},

	/**
	 * Initializes the master payment objects array when the order shipping & billing page is loaded.
	 */
	initializeOverallPaymentObjects: function(){
		this.prevNumberOfPaymentMethods = document.getElementById('numberOfPaymentMethods').value;
		this.numberOfPaymentMethods = parseInt($("#numberOfPaymentMethods").val());
		var maxNumberOfPaymentMethodsSupported = parseInt(this.maxNumberOfPaymentMethodsSupported);

		for(var i=1; i<=maxNumberOfPaymentMethodsSupported; i++){
			this.initializePaymentObject(i);
		}

		var piIds = document.forms["PaymentForm1"].existingPiId.value;
		var unboundpiIds = null;
		if (document.forms["PaymentForm1"].unboundPiId) {
			unboundpiIds = document.forms["PaymentForm1"].unboundPiId.value;
			if(unboundpiIds != null && unboundpiIds != ""){
				var unboundpiArray = unboundpiIds.split(",");
			}
		}
		if(piIds != null && piIds != ""){
			var piArray = piIds.split(",");
			for(var i=0; i<piArray.length; i++){
				var paymentObjIndex = i+1;
				this.retrievePaymentObject(paymentObjIndex)['piId'] = piArray[i];
				document.forms["PaymentForm" + (paymentObjIndex)].piId.value = piArray[i];
				if(paymentObjIndex > this.numberOfPaymentMethods){
					// If regular payment instructions had already been registered with the order, then user goes back to the shopping cart page and chooses quick checkout,
					// and since only the payment defined in quick checkout profile would be displayed on the shipping & billing page, then the rest of payments that have been registered with the order need to be deleted.
					this.retrievePaymentObject(paymentObjIndex)['action'] = 'delete';
				}
				if(supportPaymentTypePromotions && unboundpiIds != null && unboundpiIds != ""){
					for(var j=0; j<unboundpiArray.length; j++){
						if (this.retrievePaymentObject(paymentObjIndex)['piId'] == unboundpiArray[j]) {
							this.retrievePaymentObject(paymentObjIndex)['action'] = 're-add';
							break;
						}
						}
				}
			}
		}else{
			this.retrievePaymentObject(1)['action'] = 'add';
		}
		// does quick checkout profile or payInStore qualify for payment type promotion?
		if(supportPaymentTypePromotions && 
				(this.getValue(document.forms['PaymentForm1'],"valueFromProfileOrder") == "Y" || this.getValue(document.forms['PaymentForm1'],"payMethodId") == "PayInStore"
					)){
			if(requestSubmitted){
				// 'requestSubmitted' will be set to false upon whole page loaded, listen to value change of 'requestSubmitted'
				this['updatePaymentTypePromotionForProfileCheckoutHandler'] = wcTopic.subscribe("requestSubmittedChanged", function(isRequestSubmitted) {
					if (!isRequestSubmitted ) {
						CheckoutPayments['updatePaymentTypePromotionForProfileCheckoutHandler'].remove();
						CheckoutPayments.updateUnboundPaymentToOrder();
					}
				});
			} else {
				this.updateUnboundPaymentToOrder();
			}
		}
	},

	/**
	 * Initializes a payment object for the given payment area.
	 * @param {Integer} paymentAreaNum The payment area number.
	 */
	initializePaymentObject: function(paymentAreaNum){
		var paymentObj = new Array();
		paymentObj['piId'] = "";
		paymentObj['action'] = "";
		paymentObj['fields'] = new Array();
		paymentObj['options'] = "";
		this.storePaymentObject(paymentAreaNum, paymentObj);
	},

	/**
	 * Stores the given payment object and its payment area number into the master payment objects array.
	 * @param {Integer} paymentAreaNum The payment area number.
	 * @param {Object} payObj The payment object to store.
	 */
	storePaymentObject: function(paymentAreaNum, payObj){
		this.paymentObjects[paymentAreaNum] = payObj;
	},

	/**
	 * Retrieves payment object associated with the given payment area number from the master payment objects array.
	 * @param {Integer} paymentAreaNum The payment area number.
	 * @return {Object} paymentObject The payment object associated with the given area number.
	 */
	retrievePaymentObject: function(paymentAreaNum){
		return this.paymentObjects[paymentAreaNum];
	},

	/**
	 * Updates the properties in a payment object.
	 * @param {Integer} paymentAreaNum The payment area number.
	 * @param {String} field The field that was changed by a user on the page.
	 */
	updatePaymentObject: function(paymentAreaNum, field){
		var paymentObj = this.retrievePaymentObject(paymentAreaNum);

		if(paymentObj != null){
			console.debug(field + " was changed.");
			if(paymentObj['piId'] == ''){
				paymentObj['action'] = 'add';
				console.debug("The action property in the payment object associated with payment area " + paymentAreaNum + " was updated to 'add'.");
			}else{
				if(field == 'piAmount' && paymentObj['action'] != 'add' && paymentObj['action'] != 'delete' && paymentObj['action'] != 're-add'){
					paymentObj['action'] = 'update';
					console.debug("The action property in the payment object associated with payment area " + paymentAreaNum + " was updated to 'update'.");
				}else{
					// For changes in fields other than piAmount, the existing payment instruction needs to be deleted first, then a new payment instruction will be created.
					paymentObj['action'] = 're-add';
					console.debug("The action property in the payment object associated with payment area " + paymentAreaNum + " was updated to 're-add'.");
				}
			}

			if(field == 'piAmount'){
				var thisFieldExists = false;
				for(var i=0; i< paymentObj['fields'].length; i++){
					if(paymentObj['fields'][i] == field){
						thisFieldExists = true;
						break;
					}
				}
				if(!thisFieldExists){
					paymentObj['fields'].push(field);
				}
			}
		}else{
			console.debug("CheckoutPayemnts.updatePaymentObject -- payment object not found.");
		}
	},

	/**
	 * Stores the payment area number of the payment instruction that needs to be deleted.
	 * @param {Integer} paymentAreaNumber The payment area number of a payment instruction.
	 */
	setPaymentsToDelete: function(paymentAreaNumber){
		this.paymentsToDelete.push(paymentAreaNumber);
	},

	/**
	 * Retrieves the array containing the payment area numbers of all payment instructions that need to be deleted.
	 * @return {Array} paymentsToDelete The array that contains the payment area numbers.
	 */
	getPaymentsToDelete: function(){
		return this.paymentsToDelete;
	},

	/**
	 * Stores the payment area number of the payment instruction that needs to be added.
	 * @param {Integer} paymentAreaNumber The payment area number of a payment instruction.
	 */
	setPaymentsToAdd: function(paymentAreaNumber){
		this.paymentsToAdd.push(paymentAreaNumber);
	},

	/**
	 * Retrieves the array containing the payment area numbers of all payment instructions that need to be added.
	 * @return {Array} paymentsToDelete The array that contains the payment area numbers.
	 */
	getPaymentsToAdd: function(){
		return this.paymentsToAdd;
	},

	/**
	 * Stores the payment area number of the payment instruction that needs to be added.
	 * @param {Integer} paymentAreaNumber The payment area number of a payment instruction.
	 */
	setPaymentsToUpdate: function(paymentAreaNumber){
		this.paymentsToUpdate.push(paymentAreaNumber);
	},

	/**
	 * Retrieves the array containing the payment area numbers of all payment instructions that need to be added.
	 * @return {Array} paymentsToDelete The array that contains the payment area numbers.
	 */
	getPaymentsToUpdate: function(){
		return this.paymentsToUpdate;
	},


	/**
	 * Deletes payment instruction(s) from the current order.
	 */
	deletePaymentInstructions: function(){
		var params = [];
		params["piId"] = new Array();
		if (this.getPaymentsToDelete().length > 0) {
			var paymentAreaNumber = this.getPaymentsToDelete().pop();
			params["piId"].push(document.forms["PaymentForm" + paymentAreaNumber].piId.value);
			params["storeId"] = this.storeId;
			params["catalogId"] = this.catalogId;
			params["paymentAreaNumber"] = paymentAreaNumber;
			params["langId"] = this.langId;
			if(document.forms["PaymentForm1"].authToken != null){
				params["authToken"] = document.forms["PaymentForm1"].authToken.value;
			}
			params.orderId = ".";
		}
		if(!submitRequest()){
			return;
		}
		cursor_wait();
		wcService.invoke('AjaxDeletePaymentInstructionFromThisOrder',params);
	},

	/**
	 * Adds payment instruction(s) to the current order.
	 */
	addPaymentInstructions: function(){
		var params = [];
		if(this.getPaymentsToAdd().length > 0) {
			var paymentAreaNumber = this.getPaymentsToAdd().pop();
			var form = document.forms["PaymentForm" + paymentAreaNumber];
			params = this.populateProtocolData(form,params);
		}
		if(!submitRequest()){
			return;
		}
		cursor_wait();
		wcService.invoke('AjaxAddPaymentInstructionToThisOrder',params);
	},

	/**
	 * Updates payment instruction(s) in the current order.
	 */
	updatePaymentInstructions: function(){
		var params = [];
		if(this.getPaymentsToUpdate().length > 0){
			var paymentAreaNumber = this.getPaymentsToUpdate().pop();
			var form = document.forms["PaymentForm" + paymentAreaNumber];
			var paymentObj = this.retrievePaymentObject(paymentAreaNumber);
			paymentObj['fields'].push('storeId');
			paymentObj['fields'].push('catalogId');
			paymentObj['fields'].push('langId');
			paymentObj['fields'].push('piId');
			paymentObj['fields'].push('payMethodId');
			paymentObj['fields'].push('authToken');
			paymentObj['fields'].push('orderId');
			document.forms["PaymentForm" + paymentAreaNumber].paymentDataEditable.value = false;
			paymentObj['fields'].push('paymentDataEditable');

			params = this.populateProtocolDataForGivenFields(form,params,paymentObj['fields']);
		}
		if(!submitRequest()){
			return;
		}
		cursor_wait();
		wcService.invoke('AjaxUpdatePaymentInstructionInThisOrder',params);
	},

	/**
	 * Updates the payment objects on the page when the number of payment methods is changed by a user.
	 * @param {Object} numberOfPaymentMethodsField The select drop-down object on the page that contains the number of payment methods.
	 */
	reinitializePaymentObjects: function(numberOfPaymentMethodsField){
		//Payment type promotion: call the updateUnboundPaymentToOrder() function
		if(supportPaymentTypePromotions){
			this.updateUnboundPaymentToOrder();
		}

		var currentNumberOfPaymentMethods = parseInt(numberOfPaymentMethodsField.value);
		var prevNumberOfPaymentMethods = parseInt(this.prevNumberOfPaymentMethods);
		var maxNumberOfPaymentMethodsSupported = parseInt(this.maxNumberOfPaymentMethodsSupported);
		if(currentNumberOfPaymentMethods < prevNumberOfPaymentMethods){
			for(var i=currentNumberOfPaymentMethods+1; i<=maxNumberOfPaymentMethodsSupported; i++){
				var paymentObj = this.retrievePaymentObject(i);
				if(paymentObj['piId'] == ''){
					paymentObj['action'] = '';
				}else{
					paymentObj['action'] = 'delete';
					console.debug("The action in the payment object associated with payment area " + i + " was updated to 'delete'.");
				}
			}
		}else if(currentNumberOfPaymentMethods > prevNumberOfPaymentMethods){
			for(var i=prevNumberOfPaymentMethods+1; i<=maxNumberOfPaymentMethodsSupported; i++){
				var paymentObj = this.retrievePaymentObject(i);
				if (paymentObj['piId'] != '') {
					// payment object has a piId, so it exists in the database and is not really a new payment object
					if (i > currentNumberOfPaymentMethods && i <=maxNumberOfPaymentMethodsSupported) {
						// delete any payment objects that exist beyond the current number of payment methods
						paymentObj['action'] == 'delete';
						console.debug("The action in the payment object associated with payment area " + i + " was updated to 'delete'.");
					}
					else {
						// re-add any payment objects that exist within the current number of payment methods
						paymentObj['action'] == 're-add';
						console.debug("The action in the payment object associated with payment area " + i + " was updated to 're-add'.");
					}
				}
				else {
					// payment object does not have a piId, so it really is a new payment object
					this.initializePaymentObject(i);
					console.debug("A new payment object was initialized to be associated with payment area " + i + ".");
				}

			}
		}
		this.prevNumberOfPaymentMethods = currentNumberOfPaymentMethods;
	},

	/**
	 * Payment type promotion - START
	 */

	/**
	 * Sets the value of the piId parameter in PaymentForm1 to the passed value.
	 * @param {Integer} piId The piId to set in PaymentForm.
	 * @param {Integer} paymentArea The payment area number for the Payment form.
	 */
	setPaymentFormPiId: function(paymentArea,piId){
	   var formObj = document.forms['PaymentForm'+ paymentArea];
	   if (formObj){
		   //payInStore only have 1 form
		   formObj["piId"].value = piId;
	   }
	},

	/**
	 * Adds or removes an unbounded payment to/from the current order.
	 * An unbound payment is a dummy/temporary payment instruction added to
	 * an order without any of its protocol data information.
	 *
	 * The function is invoked when numberOfPaymentMethods or payment method is chosen/changed.
	 * The function works in following way:
	 * 1. the method try to delete all payment instructions and clear all payment objects first
	 * 2. upon the deletion of existing payment instructions, a new dummy payment instruction
	 * 	  will be added if <code>isSinglePaymentType</code> return <code>true</code>, the function
	 *	  <code>addNewUnboundPaymentInstruction</code> will be invoked. See also
	 *	  <code>AjaxDeleteUnboundPaymentInstructionFromThisOrder</code> for detail.
	 * 3. if <code>isSinglePaymentType</code> return <code>false</code>, leave the order without
	 *    any payment instruction.
	 * 4. upon adding or deleting of payment instruction. The service
	 *    <code>AjaxPrepareOrderForPaymentSubmit</code> will be invoked to determine if
	 *    the order qualify for payment type promotion.
	 */
	updateUnboundPaymentToOrder: function(paymentMethodChanged){
		this.currentPaymentMethodChanged = paymentMethodChanged;
		 var form1 = document.forms["PaymentForm1"];
		 var piIdForm1 = this.getValue(form1, "piId");
			 // If payment methods existed already, delete it.
		 if(piIdForm1 != null && piIdForm1 != ""){
			var params = [];
			params.storeId = this.storeId;
			params.catalogId = this.catalogId;
			params.langId = this.langId;
			params.orderId = ".";
			params.piId = "";
			if(!submitRequest()){
				 return;
			}
			cursor_wait();
			wcService.invoke('AjaxDeleteUnboundPaymentInstructionFromThisOrder', params);
		 } else if (this.isSinglePaymentType()) {
			this.addNewUnboundPaymentInstruction();
		 } else if (paymentMethodChanged ){
			this.loadPaymentSnippet(document.getElementById("payMethodId_" + paymentMethodChanged), paymentMethodChanged);
			this.updatePaymentObject(paymentMethodChanged, 'payMethodId');
		 }
	},

	/**
	 * Adds a new unbounded payment method to the order. An unbound payment is a
	 * dummy/temporary payment instruction added to an order without any of its
	 * protocol data information. Only add unbounded payment method when all
	 * selected payment types are same.
	 */
	addNewUnboundPaymentInstruction: function(){
	   var form = document.forms["PaymentForm1"];
	   var params = [];
	   params.storeId = this.storeId;
	   params.catalogId = this.catalogId;
	   params.langId = this.langId;
	   if(document.forms["PaymentForm1"].authToken != null){
			params["authToken"] = document.forms["PaymentForm1"].authToken.value;
	   }

	   params["payMethodId"] = this.getValue(form,"payMethodId",true);
	   params["unbound"] = true;

	   if(params["payMethodId"] != "empty" && params["payMethodId"] != ""){
		  if(!submitRequest()){
			return;
		  }
		  cursor_wait();
		  wcService.invoke('AjaxAddUnboundPaymentInstructionToThisOrder', params);
	   }

   },

   /**
	 * Check whether the all selected payment types are same or not
	 * @return {boolean} true if selected payment types are same, false otherwise
	 */
   isSinglePaymentType: function() {
		var form = document.forms["PaymentForm1"];
		var fistFormPayType = this.getValue(form,"payMethodId");
		var isSinglePaymentType = fistFormPayType != "empty" && fistFormPayType != "";
		for (var i = 2; isSinglePaymentType && i <= this.numberOfPaymentMethods; i++) {
			var currentPaymentForm = document.forms["PaymentForm" + i];
			var currntPayType = this.getValue(currentPaymentForm,"payMethodId")
			isSinglePaymentType = currntPayType == fistFormPayType;
		}
		return isSinglePaymentType;
   }
  /**
   * Payment type promotion - END
   */
}
//-----------------------------------------------------------------
// Licensed Materials - Property of IBM
//
// WebSphere Commerce
//
// (C) Copyright IBM Corp. 2009, 2016 All Rights Reserved.
//
// US Government Users Restricted Rights - Use, duplication or
// disclosure restricted by GSA ADP Schedule Contract with
// IBM Corp.
//-----------------------------------------------------------------

/**
 * @fileOverview This javascript provides the variables and methods used on the PromotionChoiceOfFreeGiftsPopup.jspf
 * to allow the user to select a free gift of their choice when this promotion applies to the order.
 * @version 1.5
 */

PromotionChoiceOfFreeGiftsJS={

	/* Global variable declarations */

	/**
	 * This variable is used to keep track of the enable or disable status of the Apply button in the pop-up.
	 * @private
	 */
	disableApplyButton:false,

	/** 
	 * This variable stores the ID of the language that the store currently uses. Its default value is set to -1, which corresponds to United States English.
	 * @private
	 */
	langId: "-1",
	
	/** 
	 * This variable stores the ID of the current store. Its default value is empty.
	 * @private
	 */
	storeId: "",
	
	/** 
	 * This variable stores the ID of the catalog. Its default value is empty.
	 * @private
	 */
	catalogId: "",

	/**
	 * Sets the common parameters for the current page. 
	 * For example, the language ID, store ID, and catalog ID.
	 *
	 * @param {Integer} langId The ID of the language that the store currently uses.
	 * @param {Integer} storeId The ID of the current store.
	 * @param {Integer} catalogId The ID of the catalog.
	 */
	setCommonParameters: function(langId,storeId,catalogId){
		this.langId = langId;
		this.storeId = storeId;
		this.catalogId = catalogId;
	},

  /**
   * This function is used to update the free gift choices for a promotion, made by the user, during order check-out.
   * The <code>AjaxUpdateRewardOption</code> service is invoked.
   *
   * @param {String} formName: The name of the reward choices form.
   * @param {Integer} maximumNumberOfItems: The maximum number of gift selections that the user can make.
   * @param {Integer} rewardOptionId: The ID of the RewardOption object used to add the reward choices data to.
   */
   updateRewardChoices:function(formName, maximumNumberOfItems, rewardOptionId, orderId){

		if(this.disableApplyButton){
			return false;
		}

		var params = [];
		var catEntryId = [];
		var quantity = [];
		var j = 0;

		params.storeId = this.storeId;
		params.orderId = orderId;
		params["rewardOptionId"] = rewardOptionId;
		if(CheckoutHelperJS.shoppingCartPage){
			params["calculationUsage"] = "-1,-2,-5,-6,-7";
		}else{
			params["calculationUsage"] = "-1,-2,-3,-4,-5,-6,-7";
		}
		//params["allocate"] = "***";
		//params["backorder"] = "***";

		//add the catalog entry ID and quantity of each gift item selection.
		for(var i = 0; i < maximumNumberOfItems; i++){
			if(!document.getElementById("no_gifts").checked){
				if(document.getElementById("SelectFreeGift_" + (i+1)).checked){
					catEntryId[j] = document.getElementById("CatalogEntryID_" + (i+1)).value;
					quantity[j] = document.getElementById("GiftItemQuantity_" + (i+1)).value;
					j++;
				}
			}
		}
		params["catEntryId"] = catEntryId;
		params["quantity"] = quantity;

		//For handling multiple clicks
		if(!submitRequest()){
			return;
		}
		cursor_wait();
		wcService.invoke("AjaxUpdateRewardOption", params);
		//hide the pop-up after the service has been invoked after some delay.
		setTimeout($.proxy(this,"hidePopup",'free_gifts_popup'),200);
        $('#free_gifts_popup').data("wc-WCDialog").close();
	},

	/**
	 * This function is used to display a message of the total number of gift
	 * item selections made by the shopper. It also displays an error message
	 * when the user selects more gift items than the maximum number of gift
	 * items that are allowed for the promotion.
	 *
	 * @param {Integer}
	 *            maximumNumberOfItems The maximum number of gift items that are
	 *            allowed as part of the promotion.
	 */
	checkNumberOfAllowedItems:function(maximumNumberOfItems){
		var i = 1;
		var numberOfSelectionsMade = 0;
		this.disableApplyButton = false;

		while(document.getElementById("SelectFreeGift_" + i)){
			if(document.getElementById("SelectFreeGift_" + i).checked){
				numberOfSelectionsMade++;
			}
			i++;
		}
		if(numberOfSelectionsMade > maximumNumberOfItems){
			//display an error message warning the shopper about exceeding the maximum number of gift item selections
			if(document.getElementById('message')!= null){
				document.getElementById('message').className = "error";
				document.getElementById('message').innerHTML = MessageHelper.messages["PROMOTION_FREE_GIFTS_POPUP_ERROR_EXCEED_GIFT_QUANTITY"];
			}
			this.disableApplyButton = true;
		} else if(numberOfSelectionsMade > 0){
			//display a message indicating the number of gift item selections made by the shopper
			if(numberOfSelectionsMade == 1){
				var selectionsMadeMsg = MessageHelper.messages["PROMOTION_FREE_GIFTS_POPUP_NUMBER_OF_SELECTIONS_ONE"];
			} else {
				var selectionsMadeMsg = MessageHelper.messages["PROMOTION_FREE_GIFTS_POPUP_NUMBER_OF_SELECTIONS"];
				selectionsMadeMsg = selectionsMadeMsg.replace(/%0/, numberOfSelectionsMade);
			}
			if(document.getElementById('message')!= null){
				document.getElementById('message').className = "status_message";
				document.getElementById('message').innerHTML = selectionsMadeMsg;
			}
		} else if(numberOfSelectionsMade == 0){
			//checking that the element exists because when the promotion is inactive,
			//this element does not exist in the jsp.
			if(document.getElementById('message')!= null){
				document.getElementById('message').innerHTML = "&nbsp;"
			}
			this.disableApplyButton = true;
		}
	},

	/**
	 * If the user has selected the option to not receive any free gifts as part
	 * of the promotion, then the gift item choices are cleared and disabled for
	 * selection.
	 */
	rewardChoicesEnabledStatus:function(){
		var i = 1;

		if(document.getElementById("no_gifts").checked){
			this.disableApplyButton = false;
			if(document.getElementById('message')!= null){
				document.getElementById('message').innerHTML = "&nbsp;";
			}
			while(document.getElementById("SelectFreeGift_" + i)){
				document.getElementById("SelectFreeGift_" + i).checked = false;
				document.getElementById("SelectFreeGift_" + i).disabled = true;
				i++;
			}
		} else {
			while(document.getElementById("SelectFreeGift_" + i)){
				document.getElementById("SelectFreeGift_" + i).disabled = false;
				i++;
			}
			this.checkNumberOfAllowedItems();
			this.checkFreeGiftsAvailability();
		}
	},

	/**
	 * This function is used to make the free gift choices pop-up visible to the user.
	 */
	showFreeGiftsDialog: function(){
		this.checkNumberOfAllowedItems();
        $('#free_gifts_popup').data("wc-WCDialog").open();

		this.checkFreeGiftsAvailability();
	},

	/**
	 * This function is used to disable any free gifts that are not available.
	 */
	checkFreeGiftsAvailability: function(){
		var i = 1;
		var numberOfAvailableGifts = 0;

		while(document.getElementById("OnlineAvailability_" + i)){
			if(document.getElementById("OnlineAvailability_" + i).value != "Available" && document.getElementById("OnlineAvailability_" + i).value != "Backorderable"){
				document.getElementById("SelectFreeGift_" + i).checked = false;
				document.getElementById("SelectFreeGift_" + i).disabled = true;
			} else {
				numberOfAvailableGifts++;
			}
			i++;
		}

		if(numberOfAvailableGifts == 0){
			this.disableApplyButton = true;
		}

	},

	/**
	 * Hide the pop-up identified by the passed id parameter.
	 *
	 * @param {String} id: The id of the pop-up to hide.
	 * @param {Object} event: The event object.
	 */
	hideFreeGiftsPopup:function(id,event){
		if(event!=null && event.type=="keypress" && event.keyCode!=KeyCodes.ESCAPE){
			return;
		} else {
			var popUp =  $("#" + id).data("wc-WCDialog");
			if(popUp){
                popUp.close();
			}
		}
	}

}//-----------------------------------------------------------------
// Licensed Materials - Property of IBM
//
// WebSphere Commerce
//
// (C) Copyright IBM Corp. 2009, 2013 All Rights Reserved.
//
// US Government Users Restricted Rights - Use, duplication or
// disclosure restricted by GSA ADP Schedule Contract with
// IBM Corp.
//-----------------------------------------------------------------

/** 
 * @fileOverview This file is used by PunchoutPaymentRedirect.jsp, MyAccountDisplay.jsp and OrderDetailDisplay.jsp.
 */

if(typeof(PunchoutJS) === "undefined" || !PunchoutJS || !PunchoutJS.topicNamespace){
	
	/** 
	 * @class The PunchoutJS class defines helper functions that are used to process punchout payments.
	 */
	PunchoutJS = {
		/**
		 * The Id of a section on the page that will be replaced by the punchout payment page. 
		 */
		divId:"",
		
		/**
		 * A boolean value that indicates if the punchout payment page should be opened in the same browser window as the current page.
		 * The default value is true.
		 */
		sameWindow:true,
		
		/**
		 * Displays a message pop-up on the checkout page to remind the user that the punchout payment needs to be paid while blocking the background page with a semi-transparent image.
		 */
		displayPopup:function(){
			if(!$("#punchout_popup_container").length){
				console.debug("PunchoutJS.displayPopup: element with Id punchout_popup_container was not found on the page.");
				return;
			}
			$("#punchout_popup_container").show();
			
			var pageMask = $("<div id='pageMask'/>").appendTo($("body"));
			$(pageMask).css({
				"position":"absolute",
				"z-index":949,
				"top":"0px",
				"left":"0px",
				"width":$("body").innerWidth() + "px",
				"height":$("body").innerHeight() + "px",
				"background":"#000",
				"opacity":"0.40"
			});
			setTimeout("$('#punchout_popup_close_icon').focus()", 1000);
		},
		
		/**
		 * This function renders the actual punchout payment section on the page after a successful service call invocation to AjaxPunchoutPay.
		 * @param {String} orderId The Id of the order that is being processed.
		 */
		handleResponse:function(orderId) {
			var divId = this.divId;
			var sameWindow = this.sameWindow;
			
			var div = document.getElementById(divId);
			var url = div.innerHTML.replace(/(^\s*)|(\s*$)/g, "");
			var lowerUrl = url.toLowerCase();
			if (lowerUrl.indexOf('<form') !== 0 && lowerUrl.indexOf('&lt;form') !== 0) {
				if (lowerUrl.indexOf('<a') !== 0 && lowerUrl.indexOf('&lt;a') !== 0) {
					div.innerHTML = '<a name="punchout_anchor" href="' + url + '" />';
				} else {
					div.innerHTML = url;
				}
				var a = div.childNodes[0];
				if (!sameWindow) {
					a.target = '_blank';
					window.open(a.href);
				} else {
					window.location = a.href;
				}
			} else {
				div.innerHTML = url;
				var form = div.childNodes[0];
				form.name = 'punchout_form';
				if (!sameWindow) {
					form.target = '_blank';
					form.submit();
				} else {
					form.submit();
				}
			}
		},
		
		/**
		 * Invokes the service AjaxPunchoutPay to handle the payment for the current order.
 		 * @param {String} storeId The Id of the store.
		 * @param {String} orderId The Id of the order that is being processed.
		 * @param {String} piId The payment instruction Id.
		 * @param {String} divId The Id of the div element that the punchout payment page should be displayed in.
		 * @param {boolean} sameWindow Whether the punchout payment page should be displayed in the same browser window. 
		 */
		pay:function(storeId, orderId, piId, divId, sameWindow) {
			this.divId = divId;
			this.sameWindow = sameWindow;
			params = [];
			params["storeId"] = storeId;
			params["orderId"] = orderId;
			params["piId"] = piId;
			var punchoutPaymentRedirectForm = document.forms["punchoutPaymentRedirectForm_AuthTokenInfo"];
			var authToken = punchoutPaymentRedirectForm.punchoutPaymentRedirect_authToken.value;
			params["authToken"] = authToken;
			if(!submitRequest()){
				return;
			}
			cursor_wait();
			wcService.invoke("AjaxPunchoutPay",params);
		},
		
		/**
		 * Handles key press event that occurs in the punchout payment message pop-up dialog.
		 * If the key press event is not tab and shift, then refresh the page.
		 * @param {Object} event An HTML event object. 
		 */
		handleKeyPress:function(event){
			if(event.keyCode !== KeyCodes.TAB && event.keyCode !== KeyCodes.SHIFT){
				location.reload();
			}
		},
		
		/**
		 * Put the cursor focus on the element with the given Id.
		 * @param {String} elementId The element Id.
		 */
		focusElement:function(elementId){
			if(!$("#" + elementId).length){
				console.debug("PunchoutJS.focusElement: element with Id " + elementId + " was not found on the page.");
			}
			$("#" + elementId).focus();
		}
	}
}//-----------------------------------------------------------------
// Licensed Materials - Property of IBM
//
// WebSphere Commerce
//
// (C) Copyright IBM Corp. 2008, 2016 All Rights Reserved.
//
// US Government Users Restricted Rights - Use, duplication or
// disclosure restricted by GSA ADP Schedule Contract with
// IBM Corp.
//-----------------------------------------------------------------

/**
 * @fileOverview This javascript handles different actions to perform after shopper selects to proceed with checkout.
 * In summary, user can have different logon status and user can select different shopping option (buy online or 
 * pick up at store). 
 * A user can have the following logon status:
 * 1. Shopper is a guest user
 * 2. Shopper has a commerce account but is not yet logged on (and would like to log on before user proceeds with
 *    shopping flow)
 * 3. Shopper is already logged on
 * In addition, user can select different shipping options:
 * 1. Shop online
 * 2. Pick up at store
 * Every logon status/shipping selection combination as mentioned above will be handled in this javascript
 */

ShipmodeSelectionExtJS = {	
	/** language id used by the store, default to -1 (English) */
	langId: "-1",
	/** store id of the store */
	storeId: "",
	/** catalog id of the store */
	catalogId: "",		
	/** indicates if BOPIS feauture is enabled or not */
	BOPISEnabled: false,
	/** Order item ID of an order item in the current order. This is needed for RESTOrderItemUpdate to call DoInventoryActionCmd to get fulfillment center ID **/
	orderItemId : "",
	
	/**
	* Indicates if "Pick up in store" shipping option is selected by shopper
	*/
	isPickUpInStore: function() {
		var shipType = this.getShipTypeValue();
		if (shipType == "pickUp") {
			return true;
		} else {
			return false;
		}
	},
	
	/**
	* Gets the shipType value from the document.BOPIS_FORM form.
	*/
	getShipTypeValue: function() {
		if (document.BOPIS_FORM != undefined){	
			for (var i=0; i < document.BOPIS_FORM.shipType.length; i++) {
			   if (document.BOPIS_FORM.shipType[i].checked) {
				  return document.BOPIS_FORM.shipType[i].value;
				  }
			   }
		}  
	},

	/**
	 * This function retrieves the shipment type value for the current order from the cookie.  If no shipment type value for the 
	 * current order is found in the cookie, empty string is returned.
	 *
	 * @param {String} orderId The order ID.
	 * 
	 * @returns {String} The shipment type value.
	 *
	 */
	getShipTypeValueFromCookieForOrder:function(orderId) {
		var shipTypeValueOrderId = getCookie("WC_shipTypeValueOrderId");
		if (shipTypeValueOrderId == orderId) {
			var shipTypeValue = getCookie("WC_shipTypeValue");
			return shipTypeValue;
		} else {
			return "";
		}
	},

	/**
	 * This function adds or updates the shipment type value for the current order to the cookie.
	 *
	 * @param {String} value The new pick up store ID. 
	 * @param {String} orderId The order ID.
	 *
	 */
	setShipTypeValueToCookieForOrder:function(value, orderId) {
		var newShipTypeValue = value;
		if (newShipTypeValue != null && newShipTypeValue != "undefined" && newShipTypeValue != "") {
			var shipTypeValueOrderId = getCookie("WC_shipTypeValueOrderId");
			if (shipTypeValueOrderId != orderId) {
				setCookie("WC_shipTypeValueOrderId", null, {expires: -1});
				setCookie("WC_shipTypeValueOrderId", orderId, {path: "/", domain: cookieDomain});
			}
			var currentShipTypeValue = this.getShipTypeValueFromCookieForOrder(orderId);
			if (newShipTypeValue != currentShipTypeValue) {
				setCookie("WC_shipTypeValue", null, {expires: -1});
				setCookie("WC_shipTypeValue", newShipTypeValue, {path: "/", domain: cookieDomain});
			}
		}
		//select the proper options that are saved in context
		if (newShipTypeValue == "pickUp") {
			if (document.getElementById("scheduling_options")) {
				document.getElementById("scheduling_options").style.display="none";
				setCookie("WC_recurringOrder_"+orderId, "false", {path: "/", domain: cookieDomain});
				if (document.getElementById("recurringOrder")) {
					document.getElementById("recurringOrder").checked = false;
				}
				this.hideShowNonRecurringOrderMsg(orderId);
			}
		} else if (newShipTypeValue == "shopOnline") {
			if (document.getElementById("scheduling_options")) {
				document.getElementById("scheduling_options").style.display="block";
				this.hideShowNonRecurringOrderMsg(orderId);
			}
		}
	},

	/**
	 * This function select the proper shipmode in the shopping cart page that is saved in the cookie.
	 *
	 * @param {String} orderId The order identifier of the current shopping cart. 
	 *
	 */
	displaySavedShipmentTypeForOrder:function(orderId) {
		var shipTypeValueOrderId = getCookie("WC_shipTypeValueOrderId");
		if (shipTypeValueOrderId != orderId) {
			setCookie("WC_shipTypeValueOrderId", null, {expires: -1});
			setCookie("WC_shipTypeValue", null, {expires: -1});
		} else {
			var currentShipTypeValue = this.getShipTypeValueFromCookieForOrder(orderId);
				
			//select the proper shipmode that is saved in context
			if (currentShipTypeValue == "pickUp") {
				if(document.getElementById("shipTypePickUp").disabled == false){
						document.getElementById("shipTypePickUp").checked = true;
						if (document.getElementById("scheduling_options")) {
							document.getElementById("scheduling_options").style.display="none";
							setCookie("WC_recurringOrder_"+orderId, "false", {path: "/", domain: cookieDomain});
							if (document.getElementById("recurringOrder")) {
								document.getElementById("recurringOrder").checked = false;
							}
						}
				}else{
						document.getElementById("shipTypeOnline").checked = true;
						if (document.getElementById("scheduling_options")) {
							document.getElementById("scheduling_options").style.display="block";
						}
						this.setShipTypeValueToCookieForOrder("shopOnline", orderId);
				}
			} else if (currentShipTypeValue == "shopOnline") {
				document.getElementById("shipTypeOnline").checked = true;
				if (document.getElementById("scheduling_options")) {
					document.getElementById("scheduling_options").style.display="block";
				}
			}
		}
		this.hideShowNonRecurringOrderMsg(orderId,true);
	},

	/**
	 * This function is used to show all the cues to the shopper when in the shopping cart page. It shows messages for the following:
	 * - guest shopper attempting to checkout a recurring order
	 * - it flags non recurring items when attempting to checkout as a recurring order
	 *
	 * @param {String} orderId 			The order identifier of the current shopping cart. 
	 * @param {String} fromPageLoad Tells if this function is called on a page load, which does not need the error message to show.
	 */
	hideShowNonRecurringOrderMsg:function(orderId,fromPageLoad) {
		if ( (document.getElementById("recurringOrder") && document.getElementById("recurringOrder").checked && document.getElementById("shipTypeOnline") && document.getElementById("shipTypeOnline").checked) ||
					(document.getElementById("recurringOrder") && document.getElementById("recurringOrder").checked && document.getElementById("shipTypeOnline") == null)) {
			setCookie("WC_recurringOrder_"+orderId, "true", {path: "/", domain: cookieDomain});
		} else {
			setCookie("WC_recurringOrder_"+orderId, "false", {path: "/", domain: cookieDomain});
		}
		
		if (document.getElementById("nonRecurringOrderItems") && document.getElementById("nonRecurringOrderItems").value != "") {
			if (document.getElementById("nonRecurringOrderItemsCount") && document.getElementById("numOrderItemsInOrder")) {
				var totalItems = document.getElementById("numOrderItemsInOrder").value;
				var totalNonRecurringItems = document.getElementById("nonRecurringOrderItemsCount").value;
				if (totalItems == totalNonRecurringItems) {
					if (document.getElementById("scheduling_options")) {
						document.getElementById("scheduling_options").style.display = "none";
						setCookie("WC_recurringOrder_"+orderId, "false", {path: "/", domain: cookieDomain});
						if (document.getElementById("recurringOrder")) {
							document.getElementById("recurringOrder").checked = false;
						}
						return;
					}// else if (document.getElementById("scheduling_options") && document.getElementById("shipTypeOnline") && document.getElementById("shipTypeOnline").checked) {
					//	document.getElementById("scheduling_options").style.display = "block";
					//}
				}
			}
			var orderItemIds = document.getElementById("nonRecurringOrderItems").value;
			var orderItemIdArray = orderItemIds.split(",");
			for(var i=0; i<orderItemIdArray.length; i++){
				if (document.getElementById("nonRecurringItem_"+orderItemIdArray[i])) {
					if ( (document.getElementById("recurringOrder") && document.getElementById("recurringOrder").checked && document.getElementById("shipTypeOnline") && document.getElementById("shipTypeOnline").checked) ||
								(document.getElementById("recurringOrder") && document.getElementById("recurringOrder").checked && document.getElementById("shipTypeOnline") == null)) {
						document.getElementById("nonRecurringItem_"+orderItemIdArray[i]).style.display = "block";
					} else {
						document.getElementById("nonRecurringItem_"+orderItemIdArray[i]).style.display = "none";
					}
				}
			}
			if ( (document.getElementById("recurringOrder") && document.getElementById("recurringOrder").checked && document.getElementById("shipTypeOnline") && document.getElementById("shipTypeOnline").checked && !fromPageLoad) ||
						(document.getElementById("recurringOrder") && document.getElementById("recurringOrder").checked && document.getElementById("shipTypeOnline") == null && !fromPageLoad)) {
				MessageHelper.displayErrorMessage(MessageHelper.messages["RECURRINGORDER_ERROR"]);
			}
		}
	},

	/** 
	* Constructs the next URL to call when user is already signed on 
	* 3 scenarios to handle:
	* 	1. Registered user selects to shop online -> goes to the shipping and billing page
	* 	2. Registered user selects to pick up in store - 2 variations:
	*		2a. User has not yet selected a physical store (WC_physicalStores cookie is empty) -> 
	*				Goes to store selection page
	*		2b. User has selected at least one store (WC_physicalStore cookie is not empty) ->
	*				Updates shipmode then goes to shipping and billing page
	* @param {String} billingShippingPageURLForOnline The URL to the billing and shipping page of the online checkout path
	* @param (String) physicalStoreSelectionURL The URL to the physical store selection page of the pick up in store checkout path
	*/
	registeredUserContinue: function(billingShippingPageURLForOnline, physicalStoreSelectionURL) {

		if(CheckoutHelperJS.getFieldDirtyFlag()){
			MessageHelper.displayErrorMessage(MessageHelper.messages["ERROR_UPDATE_FIRST_SHOPPING_CART"]);
			return;
		}
    	
		//For handling multiple clicks
		if(!submitRequest()){
			return;
		}	
		
		/*
		// deletePaymentInstructionsURL is never used anywhere in this function. Comment it out for now.
		var deletePaymentInstructionsURL = "";
		var paymentInstructionIds = document.getElementById("existingPaymentInstructionId").value;
		if(paymentInstructionIds != "") {
			var paymentInstructionsArray = paymentInstructionIds.split(",");
			deletePaymentInstructionsURL = "RESTOrderPIDelete?";
			for (var i=0; i<paymentInstructionsArray.length; i++) {
				if (i!=0) {
					deletePaymentInstructionsURL = deletePaymentInstructionsURL + "&";
				}
				deletePaymentInstructionsURL = deletePaymentInstructionsURL + "piId=" + paymentInstructionsArray[i];
			}
			deletePaymentInstructionsURL = deletePaymentInstructionsURL + "&URL=";
		} */
		
		if (this.isBOPISEnabled() && this.isPickUpInStore()) {
			document.location.href = appendWcCommonRequestParameters(physicalStoreSelectionURL);
		} else {
			//need to pass in orderItemId here for RESTOrderItemUpdate so it will call DoInventoryActionCmd to get fulfillment center ID
			var nextLink = 'RESTOrderItemUpdate?remerge=***&check=*n&allocate=***&backorder=***&calculationUsage=-1,-2,-3,-4,-5,-6,-7&calculateOrder=1&orderItemId='+this.orderItemId +'&errorViewName=AjaxOrderItemDisplayView'+'&orderId=.&URL=';
			//document.location.href = appendWcCommonRequestParameters(nextLink + billingShippingPageURLForOnline);
	
			var postRefreshHandlerParameters = [];
			var initialURL = "AjaxRESTOrderItemUpdate";
			var urlRequestParams = [];
			urlRequestParams["remerge"] = "***";
			urlRequestParams["check"] = "*n";
			urlRequestParams["allocate"] = "***";
			urlRequestParams["backorder"] = "***";
			urlRequestParams["calculationUsage"] = "-1,-2,-3,-4,-5,-6,-7";
			urlRequestParams["calculateOrder"] = "1";
			urlRequestParams["orderItemId"] = this.orderItemId;
			urlRequestParams["orderId"] = ".";
			urlRequestParams["storeId"] = this.storeId;
			postRefreshHandlerParameters.push({"URL":billingShippingPageURLForOnline,"requestType":"GET", "requestParams":{}}); 
			var service = getCustomServiceForURLChaining(initialURL,postRefreshHandlerParameters,null);
			service.invoke(urlRequestParams);
		}

	},

	/**
	* Constructs the next URL to call when user is not signed on and selected to continue checkout with 
	* guest user mode
	* 3 scenarios to handle:
	* 	1. Guest user selects to shop online -> goes to the shipping and billing page
	* 	2. Guest user selects to pick up in store - 2 variations:
	*		2a. User has not yet selected a physical store (WC_physicalStores cookie is empty) -> 
	*				Goes to store selection page
	*		2b. User has selected at least one store (WC_physicalStore cookie is not empty) ->
	*				Updates shipmode then goes to shipping and billing page
	* @param {String} billingShippingPageURLForOnline The URL to the billing and shipping page of the online checkout path
	* @param (String) physicalStoreSelectionURL The URL to the physical store selection page of the pick up in store checkout path
	*/
	guestShopperContinue: function(billingShippingPageURLForOnline, physicalStoreSelectionURL) {

		if(CheckoutHelperJS.getFieldDirtyFlag()){
			MessageHelper.displayErrorMessage(MessageHelper.messages["ERROR_UPDATE_FIRST_SHOPPING_CART"]);
			return;
		}
		
		//For handling multiple clicks
		if(!submitRequest()){
			return;
		}
		
		var postRefreshHandlerParameters = [];
		if (this.isBOPISEnabled() && this.isPickUpInStore()) {
			var paymentInstructionIds = $("#existingPaymentInstructionId").val();
			if (paymentInstructionIds != "") {	
				var paymentInstructionsArray = paymentInstructionIds.split(",");
				for (var i = 1; i < paymentInstructionsArray.length; i++) {
					// Chain subsequent PI Delete calls. REST API can delete only one piId at a time. Hence these requests needs to be chained.
					postRefreshHandlerParameters.push({"URL":"AjaxRESTOrderPIDelete", "requestParams":{"piId":paymentInstructionsArray[i]}});
				}
				postRefreshHandlerParameters.push({"URL":physicalStoreSelectionURL,"requestType":"GET"});

				// Initial request to PIDelete
				var params = [];
				params["piId"] = paymentInstructionsArray[0];
				var service = getCustomServiceForURLChaining("AjaxRESTOrderPIDelete",postRefreshHandlerParameters,null);
					service.invoke(params);
			} else {
				// No piId to delete. Just redirect to physicalStoreSelectionURL
				document.location.href = physicalStoreSelectionURL;
			}
		} else {
			//need to pass in orderItemId here for RESTOrderItemUpdate so it will call DoInventoryActionCmd to get fulfillment center ID
			var params = [];
			params["remerge"] = "***";
			params["check"] = "*n";
			params["allocate"] = "***";
			params["backorder"] = "***";
			params["calculationUsage"] = "-1,-2,-3,-4,-5,-6,-7";
			params["calculateOrder"] = "1";
			params["orderItemId"] = this.orderItemId;
			params["orderId"] = ".";
			params["storeId"] = this.storeId;

			var postRefreshHandlerParameters = [];
			postRefreshHandlerParameters.push({"URL":billingShippingPageURLForOnline, "requestType":"GET", "requestParams":{"guestChkout":"1"}});
			var service = getCustomServiceForURLChaining("AjaxRESTOrderItemUpdate",postRefreshHandlerParameters,null);
			service.invoke(params);
		}
	},

	/**
	* Constructs the next URL to call when user is not signed on and selected to sign in before checkout
	* 3 scenarios to handle:
	* 	1. User selects to shop online -> invokes logon URL
	* 	2. User selects to pick up in store - 2 variations:
	*		2a. User has not yet selected a physical store (WC_physicalStores cookie is empty) -> 
	*				After logon URL, go to the store selection page
	* 	2b. User has selected at least one store (WC_physicalStore cookie is not empty) ->
	*				Updates shipmode then invokes logon URL	
	* @param {String} logonURL URL to perform user logon 
	* @param {String} orderMoveURL URL to call order move after user has logged on
	* @param {String} billingShippingPageURLForOnline The URL to the billing and shipping page of the online checkout path
	* @param (String) physicalStoreSelectionURL The URL to the physical store selection page of the pick up in store checkout path
	*/
	guestShopperLogon: function(logonURL, billingShippingPageURLForOnline, physicalStoreSelectionURL) {
		if(CheckoutHelperJS.getFieldDirtyFlag()){
			MessageHelper.displayErrorMessage(MessageHelper.messages["ERROR_UPDATE_FIRST_SHOPPING_CART"]);
			return;
		}
		
		//var completeOrderMoveURL = orderMoveURL;
		var afterLogonURL = "";
		
		if (this.isBOPISEnabled() && this.isPickUpInStore()) {
			afterLogonURL = physicalStoreSelectionURL;
		} else {
			afterLogonURL = billingShippingPageURLForOnline;
		}
		
		// change URL of logon link
		// when mergeCart = true is passed to LogonURL command, logonCmd will merge the cart + does order calculate using MigrateUserEntriesCmdImpl.
		// So no need to explicitly call OrderItemMove and OrderCacluate commands again.
		// completeOrderMoveURL = completeOrderMoveURL + "&URL=RESTOrderCalculate%3FURL=" + afterLogonURL + "&calculationUsageId=-1&calculationUsageId=-2&calculationUsageId=-7";
		document.AjaxLogon.URL.value = afterLogonURL; // Got to next view directly. 
		document.location.href = logonURL;
	},
	 	
	/** 
	* Function to call when Quick Checkout button is pressed
	* 2 scenarios to handle:
	*   1. User selects to shop online -> proceed to call CheckoutHelperJS.updateCartWithCheckoutProfile
	*   2. User selects to pick up in store -> display error message to indicate quick checkout option is only
	*      available with online shopping option
	* @param {String} quickOrderId order id of this order
	*/
	updateCartWithQuickCheckoutProfile: function(quickOrderId) {
		if (this.isBOPISEnabled() && this.isPickUpInStore()) {
			MessageHelper.displayErrorMessage(MessageHelper.messages["message_QUICK_CHKOUT_ERR"]);
		} else {
			if(CheckoutHelperJS.getFieldDirtyFlag()){
				MessageHelper.displayErrorMessage(MessageHelper.messages["ERROR_UPDATE_FIRST_SHOPPING_CART"]);
				return;
			}
			CheckoutHelperJS.setCommonParameters(this.langId, this.storeId, this.catalogId);
			CheckoutHelperJS.updateCartWithQuickCheckoutProfile(quickOrderId);	
		}
	},
	
	/** 
	* Sets common parameters used by this javascript object
	* @param {String} langId language ID to use
	* @param {String} storeId store ID to use
	* @param {String} catalog Catalog ID to use
	*/
	setCommonParameters:function(langId,storeId,catalogId){
		this.langId = langId;
		this.storeId = storeId;
		this.catalogId = catalogId;
	},
	
	/** 
	* Sets orderItemId used by this javascript object
	* @param {String} orderItemId OrderItemId to use
	*/
	setOrderItemId:function(orderItemId){
		this.orderItemId = orderItemId;
	},
		
	/**
	* sets to tell if BOPIS feature is enabled
	* @param {boolean} flag Contains value of true or false
	*/
	setBOPISEnabled:function(flag){
		this.BOPISEnabled = flag;
	},
	
	/**
	* indicates if BOPIS feature is enabled
	*/
	isBOPISEnabled:function(){
		return this.BOPISEnabled;
	},
	
	/**
	* This function is called by the CheckoutStoreSelection.jsp "Next" button. It's job is to decide if it should go to
	* the next page. If there are no missing information it submits the call to the server to save the pick up location
	* for all the order items and then goes to the next page.
	* @param {Object} form The form that contains the order items and that need to be submitted 
	*/
	submitStoreSelectionForm:function(form) {
		var phyStoreId = PhysicalStoreCookieJSStore.getPickUpStoreIdFromCookie();

		if (phyStoreId != null && phyStoreId != "") {
			form["physicalStoreId"].value = phyStoreId;
			processAndSubmitForm(form);
		} else {
			if(document.getElementById("storeSelection_NextButton") != null){
				MessageHelper.formErrorHandleClient(document.getElementById("storeSelection_NextButton"), MessageHelper.messages["message_NO_STORE"]);
			}else{
				MessageHelper.displayErrorMessage(MessageHelper.messages["message_NO_STORE"]);
			}
		}
	},
	
	/**
	* This function is called by the CheckoutPayInStore.jsp "Next" button. It's job is to decide if it should go to
	* the next page. If the action is to use "PayInStore" then it directly goes to next page, otherwise it does 
	* validation on the address form and if there are no missing information it submits the call to the server to 
	* create the address and then goes to the next page.
	* 
	* @param {String} formName Name of the form that contains the address and need to be submitted 
	* @param {String} stateDivName Name of the div that has the "state" field
	* @param {String} hasValidAddresses boolean indicating if the user has at least one valid address for checkout purposes
	*/
	submitAddressForm:function(formName, stateDivName, hasValidAddresses) {
		var form = document.forms[formName];
		if (stateDivName != "") {
			AddressHelper.setStateDivName(stateDivName);
		}
		
		var payInStore = false;
		if ($("#payInStorePaymentOption").is(':checked')) {
			payInStore = true;
		}
		
		var postRefreshHandlerParameters = [];
		var urlRequestParams = [];


		/* Chain of URLs that can be invoked are:
		*  AjaxPersonChangeServiceAddressAdd - ($(form).attr("action") )
		*  AjaxRESTOrderPIDelete - (If more than one piId is present, then this action is repeated as many times as piIds present
		*  AjaxRESTOrderItemUpdate
		*  DOMOrderShippingBillingView
		*  In worst case scenario, chained URLs will be: (Assuming maximum 3 piIds are present)
		*	AjaxPersonChangeServiceAddressAdd,AjaxRESTOrderPIDelete,AjaxRESTOrderPIDelete,AjaxRESTOrderPIDelete,AjaxRESTOrderItemUpdate,DOMOrderShippingBillingView
		*  In best case scenario, chained URLs will be: (Assuming shopper has valid address and no piIDs)
		*   AjaxRESTOrderItemUpdate,DOMOrderShippingBillingView
		*/
		if (hasValidAddresses) {
			var initialURL = null;
			var formId = null;
		}
		else if (AddressHelper.validateAddressForm(form)) {
			var initialURL = $(form).attr("action");
			var formId = form.id;
		}

		var paymentInstructionIds = $("#existingPaymentInstructionId").val();
		if (paymentInstructionIds != "") {
			var paymentInstructionsArray = paymentInstructionIds.split(",");
			if(initialURL == null){
				var initialURL = "AjaxRESTOrderPIDelete";
				urlRequestParams["piId"] = paymentInstructionsArray[0];
			} else {
				postRefreshHandlerParameters.push({"URL":"AjaxRESTOrderPIDelete", "requestParams":{"piId":paymentInstructionsArray[0]}});
			}

			for (var i = 1; i < paymentInstructionsArray.length; i++) {
				// Chain subsequent PI Delete calls. REST API can delete only one piId at a time. Hence these requests needs to be chained.
				postRefreshHandlerParameters.push({"URL":"AjaxRESTOrderPIDelete", "requestParams":{"piId":paymentInstructionsArray[i]}});
			}
		}

		var orderItemUpdateParams = [];
		orderItemUpdateParams["remerge"] = "***";
		orderItemUpdateParams["check"] = "*n";
		orderItemUpdateParams["allocate"] = "***";
		orderItemUpdateParams["backorder"] = "***";
		orderItemUpdateParams["calculationUsage"] = "-1,-2,-3,-4,-5,-6,-7";
		orderItemUpdateParams["calculateOrder"] = "1";
		orderItemUpdateParams["orderItemId"] = this.orderItemId;
		orderItemUpdateParams["orderId"] = ".";
		orderItemUpdateParams["storeId"] = this.storeId;

		if(initialURL == null ){
			initialURL = "AjaxRESTOrderItemUpdate"; // Best case scenario defined above.
			urlRequestParams = orderItemUpdateParams;
		} else {
			postRefreshHandlerParameters.push({"URL":"AjaxRESTOrderItemUpdate", "requestParams":orderItemUpdateParams});
		}
		postRefreshHandlerParameters.push({"URL":"DOMOrderShippingBillingView","requestType":"GET", "requestParams":{"payInStore":payInStore}}); 
		var service = getCustomServiceForURLChaining(initialURL,postRefreshHandlerParameters,formId);
		service.invoke(urlRequestParams);
	}
}	//-----------------------------------------------------------------
// Licensed Materials - Property of IBM
//
// WebSphere Commerce
//
// (C) Copyright IBM Corp. 2008, 2016 All Rights Reserved.
//
// US Government Users Restricted Rights - Use, duplication or
// disclosure restricted by GSA ADP Schedule Contract with
// IBM Corp.
//-----------------------------------------------------------------

/**
 * @fileOverview This file contains declarations of refresh controllers used by WebSphere Commerce AJAX services for the shipping and billing pages.
 */

/**
 * @class This class stores the common parameters and functions for the controllers.
 */
SBControllersDeclarationJS = { 

	/** 
	 * This variable stores the true/false value that indicates if the 'SinglePageCheckout' feature is enabled/disabled.
	 * When it is true, both shipping and billing information are captured in a single page. If it is false, checkout will
	 * be a two step process where shipping is captured in first step and billing in second step.
	 * It is set to true by default.
	 * 
	 * @private
	 */
	singlePageCheckout: true,
	
	/**
		* This variable is used to indicate if ShippingChargeType flexflow option is enabled or not.
		*/
	shipChargeEnabled: false,

	 /**
	  * This function sets the URL parameter for a given refresh area.
	  *
	  * @param {String} refreshAreaId The ID of the refresh area of which the URL parameter will be set.
	  * @param {String} url The new URL parameter for the controller.
	  */
	setRefreshURL:function(refreshAreaId, url){
		$("#" + refreshAreaId).attr("refreshurl", url);
	},


	/**
	 * Sets the SinglePageCheckout variable to indicate if the 'SinglePageCheckout' feature is enabled or disabled.
	 * 
	 * @param {Boolean} singlePageCheckout. A true/false value that indicates if the 'SinglePageCheckout' feature is enabled.
	 *
	 * @see CheckoutHelperJS.isSinglePageCheckout
	 */
	setSinglePageCheckout:function(singlePageCheckout){
		this.singlePageCheckout = singlePageCheckout;
	},
	
	
	/**
	 * Returns the singlePageCheckout variable that indicates if the 'SinglePageCheckout' feature is enabled/disabled.
	 * 
	 * @returns {Boolean} singlePageCheckout A true/false value that indicates if the 'SinglePageCheckout' feature is
	 * enabled/disabled.
	 *
	 * @see CheckoutHelperJS.setSinglePageCheckout
	 */
	isSinglePageCheckout:function(){
		return this.singlePageCheckout;
	},
	
	/**
	 * Sets the shipChargeEnabled variable to indicate if the 'ShippingChargeType' feature is enabled.
	 * 
	 * @param {Boolean} enabled A true/false value that indicates if the 'ShippingChargeType' feature is enabled.
	 */
	setShipChargeEnabled:function(enabled){
		this.shipChargeEnabled = enabled;
	}
};


/**
 * Refresh controller declaration for the main page area on the 'Shipping & Billing' page.
 * @constructor
 */
function declareControllerForMainAndAddressDiv() {
	/* this a local context..no need to define URL for this */
	var myWidgetObj = $("#content_wrapper");
	wcRenderContext.addRefreshAreaId("contextForMainAndAddressDiv", "content_wrapper");
	var myRCProperties = wcRenderContext.getRenderContextProperties("contextForMainAndAddressDiv");
	
	myWidgetObj.refreshWidget({
		/**
		 * Calls {@link CheckoutHelperJS.showHideDivs} to display and hide the areas defined in renderContext.
		 */
		renderContextChangedHandler: function() {
			CheckoutHelperJS.showHideDivs(myRCProperties["showArea"],myRCProperties["hideArea"]);
		}
	});

};


/**
 * Refresh controller declaration for the order items area on the single shipment 'Shipping & Billing' page.
 * @constructor
 */
function declareTraditionalShipmentDetailsController() {
	var myWidgetObj = $("#WC_ShipmentDisplay_div_17");
	wcRenderContext.addRefreshAreaId("traditionalShipmentDetailsContext", "WC_ShipmentDisplay_div_17");
	var myRCProperties = wcRenderContext.getRenderContextProperties("traditionalShipmentDetailsContext");
	
	var events = $.extend({}, order_updated,
			{"OrderShippingInfoUpdate": "OrderShippingInfoUpdate"},
			{"AjaxDeleteOrderItemForShippingBillingPage": "AjaxDeleteOrderItemForShippingBillingPage"},
			{"AjaxDeleteOrderItemForShippingBillingPage": "AjaxDeleteOrderItemForShippingBillingPage"},
			{"AjaxPrepareOrderForShipChargeUpdate": "AjaxPrepareOrderForShipChargeUpdate"},
			{"OrderItemAddressShipInstructionsUpdate": "OrderItemAddressShipInstructionsUpdate"},
			{"OrderItemAddressShipInstructionsUpdate1": "OrderItemAddressShipInstructionsUpdate1"},
			{"AjaxAddUnboundPaymentInstructionToThisOrder": "AjaxAddUnboundPaymentInstructionToThisOrder"},
			{"AjaxDeleteUnboundPaymentInstructionFromThisOrder": "AjaxDeleteUnboundPaymentInstructionFromThisOrder"},
			{"OrderItemAddressShipMethodUpdate": "OrderItemAddressShipMethodUpdate"});
	
	/**
	 * Refreshes the item details area with the properties defined in renderContext if the actionId of the input message parameter is from an order update service or if it is 'OrderShippingInfoUpdate'.
	 */
	wcTopic.subscribe(events, function(returnData) {
		myWidgetObj.refreshWidget("refresh", myRCProperties);
		if(returnData.actionId != 'OrderItemAddressShipMethodUpdate') {
			submitRequest(); //Till shop cart is refreshed, do not allow any other requests..
			cursor_wait();
		}
		
	});
	
	myWidgetObj.refreshWidget({
		/**
		 * Refreshes the order item details area with the properties defined in renderContext.
		 */
		renderContextChangedHandler: function() {
			if(wcRenderContext.testForChangedRC("traditionalShipmentDetailsContext", ["beginIndex"])){
				myWidgetObj.refreshWidget("refresh", myRCProperties);
			}
		},
		
		/**
		 * Clears the progress bar after a successful refresh.
		 */
		postRefreshHandler: function() {
			resetRequest(); //Shop cart is refreshed, give the control to shopper...
			cursor_clear();

			if (myRCProperties["initializeJS"] == 'true') {
				$('input[id^="orderItem_"]').each(function(i, orderItem) {
					var initJS = 'addReqListsJS' + orderItem.value + ' = new AddToRequisitionListsJS(' + 
							myRCProperties["storeId"] + ',' + 
							myRCProperties["catalogId"] + ',' +
							myRCProperties["langId"] + ',' +
							'"' + orderItem.value + 'requisitionListContent",' + 
							'"' + orderItem.value + 'requisitionListSelect",' +
							'"' + orderItem.value + 'createNewListMenu",' + 
							'"' + orderItem.value + 'listTypeMenu",' + 
							'"' + orderItem.value + 'newListNameInput",' + 
							'"' + orderItem.value + 'listType",' + 
							'"' + orderItem.value + 'productAdded",' + 
							'"",' + 
							'"AddToRequisitionListsJS' + orderItem.value + '"' + 
							');' + 
							'addReqListsJS' + orderItem.value + '.setCatEntryId("' + $('#catalogId_' + (orderItem.id.substring(orderItem.id.indexOf('_') + 1))).val() + '");';
					eval(initJS);
				});
				$('div[id^="shoppingListScript_"]').each(function(i, node){
					$.globalEval(node.innerHTML);
				});
			}
		}
	});
};


/**
 * Refresh controller declaration for the shipping address area on the single shipment 'Shipping & Billing' page.
 * @constructor
 */
function declareShippingAddressSelectBoxAreaController() {
	var myWidgetObj = $("#shippingAddressSelectBoxArea");
	wcRenderContext.addRefreshAreaId("shippingAddressDropDownBoxContext", "shippingAddressSelectBoxArea");
	var myRCProperties = wcRenderContext.getRenderContextProperties("shippingAddressDropDownBoxContext");
	
	var events = $.extend({}, address_updated, 
			{"AjaxUpdateOrderItemsAddressId": "AjaxUpdateOrderItemsAddressId"},
			{"AddBillingAddressInCheckOut": "AddBillingAddressInCheckOut"});
	
	/**
	 * Refreshes the shipping address area with the properties defined in renderContext.
	 */
	wcTopic.subscribe(events, function(returnData) {
			if (returnData.actionId in address_updated){
				//This means, invokeService for Address Add/Edit has been called..so update our select box area
				wcRenderContext.updateRenderContext('contextForMainAndAddressDiv', {'showArea':'mainContents','hideArea':'editAddressContents'});
				selectedAddressId = returnData.data.addressId;
				myRCProperties.addressId=selectedAddressId;
				if (CheckoutHelperJS.orderItemIds.length != 0) {
					CheckoutHelperJS.updateAddressIdOFItemsOnCreateEditAddress(selectedAddressId[0]);
				}					
				cursor_clear();  
			} else if (returnData.actionId == "AjaxUpdateOrderItemsAddressId"){
				//This means, new shipping address is created / edited and all the items are updated with this new address id
				// and ajax prepare order is called.. we need to update our shipping address drop down...
				myWidgetObj.refreshWidget("refresh", myRCProperties);
				cursor_clear();
			} else if (returnData.actionId == "AddBillingAddressInCheckOut" && 
					returnData.data.addBillingAddressInCheckOutAddressType == 'ShippingAndBilling' &&
					document.getElementById("singleShipmentAddress")){
				myRCProperties.addressId = document.getElementById("singleShipmentAddress").value;
				myWidgetObj.refreshWidget("refresh", myRCProperties);
				cursor_clear();
			}
	});

	myWidgetObj.refreshWidget({
		/**
		 * Sets focus after shipping address is altered.
		 */
		postRefreshHandler: function() {
			if (CheckoutHelperJS.getLastAddressLinkIdToFocus() != null && CheckoutHelperJS.getLastAddressLinkIdToFocus() != 'undefined' && CheckoutHelperJS.getLastAddressLinkIdToFocus() != '') {
				document.getElementById(CheckoutHelperJS.getLastAddressLinkIdToFocus()).focus();
			}
			// Initialize shippingAddressDisplayArea refresh widget
			declareShippingAddressDisplayAreaController();
		}
	});

};


/**
 * Refresh controller declaration for the order totals summary area.
 * @constructor
 */
function declareCurrentOrderTotalsAreaController() {
	var myWidgetObj = $("#WC_ShipmentDisplay_div_18");
	wcRenderContext.addRefreshAreaId("currentOrder_Context", "WC_ShipmentDisplay_div_18");
	var myRCProperties = wcRenderContext.getRenderContextProperties("currentOrder_Context");
	
	/**
	 * Payment type promotion: add message.actionId == 'AjaxPrepareOrderForPaymentSubmit' to cause the order total
	 * to refresh when order prepare is called.
	 */
	var events = $.extend({}, order_updated, 
			{"AjaxDeleteOrderItemForShippingBillingPage": "AjaxDeleteOrderItemForShippingBillingPage"},
			{"OrderItemAddressShipMethodUpdate": "OrderItemAddressShipMethodUpdate"},
			{"AjaxPrepareOrderForShipChargeUpdate": "AjaxPrepareOrderForShipChargeUpdate"},
			{"OrderItemAddressShipInstructionsUpdate": "OrderItemAddressShipInstructionsUpdate"},
			{"OrderItemAddressShipInstructionsUpdate1": "OrderItemAddressShipInstructionsUpdate1"},
			{"AjaxUpdateOrderAfterAddressUpdate": "AjaxUpdateOrderAfterAddressUpdate"},
			{"AjaxAddShippingAndBillingAddressForPersonDuringCheckout": "AjaxAddShippingAndBillingAddressForPersonDuringCheckout"},
			{"AjaxPrepareOrderForPaymentSubmit": "AjaxPrepareOrderForPaymentSubmit"});
	
	/**
	 * Refreshes the area with the properties defined in renderContext if the actionId of the input message is from an order update service.
	 */
	wcTopic.subscribe(events, function(returnData) {
		myWidgetObj.refreshWidget("refresh", myRCProperties);
	});
	
	myWidgetObj.refreshWidget({
		/**
		 * Updates the display style of relevant sections on the page after a successful refresh.
		 */
		postRefreshHandler: function() {
			// Order level discount tooltip section - if the tooltip is defined, show the section after area is refreshed
			if($("#discountDetailsSection").length )  {
				$("#discountDetailsSection").css("display", "block");
			}
			
			// Promotion code tooltip section - if the tooltip is defined, show the section after area is refreshed
			if($("#appliedPromotionCodes").length ) {
				$("#appliedPromotionCodes").css("display", "block");
			}		
		}
	});
};

/**
 * Refresh controller declaration for the shipping charge area in a single shipment check-out scenario.
 * @constructor
 */
function declareSingleShipmentShipChargeController() {
	var myWidgetObj = $("#WC_SingleShipmentDisplay_ShipCharge_Area");
	wcRenderContext.addRefreshAreaId("singleShipmentShipChargeContext", "WC_SingleShipmentDisplay_ShipCharge_Area");
	var myRCProperties = wcRenderContext.getRenderContextProperties("singleShipmentShipChargeContext");
	
	/**
	 * Only refresh this area when shipping method is updated
	 */
	wcTopic.subscribe(["OrderItemAddressShipMethodUpdate"], function() {
		if (SBControllersDeclarationJS.shipChargeEnabled) {
			myWidgetObj.refreshWidget("refresh", myRCProperties);
		}
	});
	
	myWidgetObj.refreshWidget({
		/**
		 * Clears the progress bar after a successful refresh.
		 */
		postRefreshHandler: function() {
			cursor_clear();
		}
	});
};

/**
 * Refresh controller declaration for the billing address area.
 * @constructor
 */
function declareBillingAddressSelectBoxAreaController(widgetId) {
	if(typeof widgetId == "object" || typeof widgetId == "array") {
		widgetId = widgetId[0];
	}
	
	var myWidgetObj = $("#" + widgetId);
	wcRenderContext.addRefreshAreaId("billingAddressDropDownBoxContext", widgetId);
	var myRCProperties = wcRenderContext.getRenderContextProperties("billingAddressDropDownBoxContext");
	
	/**
	 * This function refreshes the billing address area with the properties defined in renderContext if the actionId of the input message parameter is AddBillingAddressInCheckOut or AjaxUpdateAddressForPerson.
	 */
	wcTopic.subscribe(["AddBillingAddressInCheckOut","UpdateBillingAddressInCheckout","AjaxUpdateAddressForPerson",
	                   "AjaxAddShippingAndBillingAddressForPersonDuringCheckout","AjaxUpdateShippingAndBillingAddressForPersonDuringCheckout"], function(returnData) {
		//If we are creating a new billing address or editing the existing address, then we should update our billing address drop down box area...
		//Make sure that even after we refresh the billing address drop down box, we pre-select the previously selected address for user...
		var objectId = myWidgetObj.attr("objectId");
		var addressId = myRCProperties["billingAddress"+objectId];
		if (myRCProperties["paymentTCId"+objectId] == "") {
			myWidgetObj.refreshWidget("updateUrl", myRCProperties["billingURL"+objectId]);
		} else {
			myWidgetObj.refreshWidget("updateUrl", myRCProperties["billingURL"+objectId]+"&paymentTCId="+myRCProperties["paymentTCId"+objectId]);
		}
		if(myRCProperties["billingAddress"+objectId] == -1){
			//Create address was selected from this billing drop down..so this drop down box should have new address selected by default...
			addressId = returnData.data.addressId;
			myWidgetObj.refreshWidget("refresh", {"paymentAreaNumber":objectId,"selectedAddressId":addressId,"paymentMethodSelected":myRCProperties["payment"+objectId]});
			myRCProperties["billingAddress"+objectId] = addressId;
			// Mark this address for update
			if(objectId <= CheckoutPayments.numberOfPaymentMethods){
				CheckoutPayments.updatePaymentObject(objectId, 'billing_address_id');
			}
		}
		else if(myRCProperties["billingAddress"+objectId] == 0){
			//Means user has not yet touched this select box..don't try to select anything...
			myWidgetObj.refreshWidget("refresh", {"paymentAreaNumber":objectId,"paymentMethodSelected":myRCProperties["payment"+objectId]});
		}
		else{
			// User changed the select box selection
			if (document.getElementById("singleShipmentAddress")) {
				// Applies to single shipment only
				shippingAddressId = document.getElementById("singleShipmentAddress").value;
				billingAddressId = document.getElementById("billing_address_id_" + objectId).value;
				if (shippingAddressId == billingAddressId && objectId <= CheckoutPayments.numberOfPaymentMethods) {
					//If shipping and billing addresses are the same and we are updating the address(updated address will have new id), 
					//widget refresh should be based on the new addressId, not the old one. 
					//However, we should ignore the case that adding address from shipping address section 
					if (returnData.data.originalServiceId != "AjaxAddAddressForPerson"){
						addressId = returnData.data.addressId;
					}
				}
			}
			myWidgetObj.refreshWidget("refresh", {"paymentAreaNumber":objectId,"selectedAddressId":addressId,"paymentMethodSelected":myRCProperties["payment"+objectId]});
			// Mark this address for update
			if(objectId <= CheckoutPayments.numberOfPaymentMethods){
				CheckoutPayments.updatePaymentObject(objectId, 'billing_address_id');
			}
		}
	});
	
	myWidgetObj.refreshWidget({
		/**
		 * Refreshes the Billing Address dropdown box with addresses corresponding to the newly selected payment method.
		 * 
		 * @param {Object} message The render context changed event message.
		 */
		renderContextChangedHandler: function() {
			var objectId = myWidgetObj.attr("objectId");
			if(wcRenderContext.testForChangedRC("billingAddressDropDownBoxContext",["payment"+objectId]) || wcRenderContext.testForChangedRC("billingAddressDropDownBoxContext",["paymentTCId"+objectId])){
				if (myRCProperties["paymentTCId"+objectId] == "") {
					myWidgetObj.refreshWidget("updateUrl", myRCProperties["billingURL"+objectId]);
				} else {
					myWidgetObj.refreshWidget("updateUrl", myRCProperties["billingURL"+objectId]+"&paymentTCId="+myRCProperties["paymentTCId"+objectId]);
				}
				var selectedAddressId = $("#billing_address_id_" + objectId).val();
				myWidgetObj.refreshWidget("refresh", {"paymentAreaNumber":objectId,"selectedAddressId":selectedAddressId,"paymentMethodSelected":myRCProperties["payment"+objectId]});
			}	
		},
	
		postRefreshHandler: function() {
			var objectId = myWidgetObj.attr("objectId");
			// After the section refreshes, shows or hides the edit and create links. 						
			CheckoutHelperJS.showHideEditBillingAddressLink((document.getElementsByName('billing_address_id'))[objectId-1], objectId);
			
			//Removes the Progress Bar if its still running.
			cursor_clear();
			var lastAddress = CheckoutHelperJS.getLastAddressLinkIdToFocus();
			if ((numAjaxRequests >= 0) && lastAddress != null && lastAddress != 'undefined' && lastAddress != '') {
				if (document.getElementById(lastAddress) != null){
					document.getElementById(lastAddress).focus();
				}else{
					var lastAddressArray = lastAddress.split("_");
					var lastAddressOrderId = (parseInt(lastAddressArray[lastAddressArray.length - 1]) + 1) + '';
					if (lastAddress.indexOf('WC_ShippingAddressSelectMultiple_link_2_') > -1){
						var lastAddressForFreeGift = 'WC_ShippingAddressSelectMultiple_link_2_' + lastAddressOrderId;
						if (document.getElementById(lastAddressForFreeGift) != null ){
							document.getElementById(lastAddressForFreeGift).focus();
						}
					}else{
						var lastAddressForFreeGift = 'WC_ShippingAddressSelectMultiple_link_3_' + lastAddressOrderId;
						if (document.getElementById(lastAddressForFreeGift) != null ){
							document.getElementById(lastAddressForFreeGift).focus();
						}
					}
				}			
			}
			declareBillingAddressDisplayAreaController("billingAddressDisplayArea_" + objectId);
		}
	});
	
};

/**
 * Refresh controller declaration for the billing address display area.
 * @constructor
 */
function declareBillingAddressDisplayAreaController(widgetId) {
	if(typeof widgetId == "object" || typeof widgetId == "array") {
		widgetId = widgetId[0];
	}
	var myWidgetObj = $("#" + widgetId);
	
	wcRenderContext.addRefreshAreaId("billingAddressDropDownBoxContext", widgetId);
	var myRCProperties = wcRenderContext.getRenderContextProperties("billingAddressDropDownBoxContext");

	myWidgetObj.refreshWidget({
		renderContextChangedHandler: function() {
			var areaNumber = myRCProperties["areaNumber"];	
			var objectId = widgetId;
			if (wcRenderContext.testForChangedRC("billingAddressDropDownBoxContext", ["billingAddress"+areaNumber]) && objectId.charAt(objectId.length-1) == areaNumber) {
				var addressId = myRCProperties["billingAddress"+areaNumber];
				myWidgetObj.refreshWidget("refresh", {"addressId": addressId});
			}
		},
	
		postRefreshHandler: function() {
			var areaNumber = myRCProperties["areaNumber"];
			CheckoutHelperJS.showHideEditBillingAddressLink((document.getElementsByName('billing_address_id'))[areaNumber-1],areaNumber);
			//clears the progress bar set from billingdropdowndisplay.jsp
			cursor_clear();
		}
	});

};

/**
 * Refresh controller declaration for the order total area.
 * @constructor
 */
function declareOrderTotalController() {
	var myWidgetObj = $("#orderTotalAmountArea");
	wcRenderContext.addRefreshAreaId("paymentContext", "orderTotalAmountArea");
	var myRCProperties = wcRenderContext.getRenderContextProperties("paymentContext");
	
	var events = $.extend({}, order_updated,
			{"OrderItemAddressShipMethodUpdate": "OrderItemAddressShipMethodUpdate"},
			{"AjaxPrepareOrderForShipChargeUpdate": "AjaxPrepareOrderForShipChargeUpdate"},
			{"OrderItemAddressShipInstructionsUpdate": "OrderItemAddressShipInstructionsUpdate"},
			{"OrderItemAddressShipInstructionsUpdate1": "OrderItemAddressShipInstructionsUpdate1"},
			{"AjaxUpdateOrderAfterAddressUpdate": "AjaxUpdateOrderAfterAddressUpdate"},
			{"AjaxDeleteOrderItemForShippingBillingPage": "AjaxDeleteOrderItemForShippingBillingPage"},
			{"AjaxUpdateOrderItemsAddressId": "AjaxUpdateOrderItemsAddressId"});

	wcTopic.subscribe(events, function() {
		cursor_wait();
		//updating the total
		CheckoutPayments.getTotalInJSON();
	});
	
	// initialize widget
	myWidgetObj.refreshWidget({
		postRefreshHandler: function(widget) {
			cursor_clear();
		}
	});
};

/**
 * Refresh controller declaration for the payment area.
 * @constructor
 * There will be three controllers by default..
 * When paymentAreaController for paymentArea1 changes, the payment1 property of the context will be updated... So in that case for paymentAreaController for paymentArea1,
 * wcRenderContext.testForChangedRC(["payment1"])) will return true..and then we check for payment1 type ..if its VISA, then we load Visa.jsp.. similarly it works for other controllers
 */
function declarePaymentAreaController(divId) {
	if(typeof divId == "object") {
		divId = divId[0];
	}
	
	var myWidgetObj = $("#"+divId);
	wcRenderContext.addRefreshAreaId("paymentContext", divId);
	var myRCProperties = wcRenderContext.getRenderContextProperties("paymentContext");
	var paymentAreaNumber = divId[divId.length-1];

	myWidgetObj.refreshWidget({
		renderContextChangedHandler: function() {
				if (myRCProperties.currentPaymentArea == paymentAreaNumber) {
					if ((wcRenderContext.testForChangedRC("paymentContext", ["payment" + paymentAreaNumber])  || wcRenderContext.testForChangedRC("paymentContext", ["paymentTCId" + paymentAreaNumber])
						|| (wcRenderContext.testForChangedRC("paymentContext", ["piAmount"])) && supportPaymentTypePromotions )
					) {
						if (myRCProperties["payment" + paymentAreaNumber] == "empty") {
							viewName = "EmptySnippetView";
						} else {
							viewName = paymentSnippetsURLMap[myRCProperties["payment" + paymentAreaNumber]];
						}
						myWidgetObj.refreshWidget("updateUrl", viewName + paymentAreaUrlParam);
						
						if (supportPaymentTypePromotions) {									
							if (CheckoutPayments.numberOfPaymentMethods != 1) {
								myWidgetObj.refreshWidget("refresh", myRCProperties);
							} else if (CheckoutPayments.numberOfPaymentMethods == 1 && paymentAreaNumber < 2) {
								myWidgetObj.refreshWidget("refresh", myRCProperties);
							}
						} else {
							myWidgetObj.refreshWidget("refresh", myRCProperties);
						}
					}
				}
		},
		
		postRefreshHandler: function() {
			/**
				if supportPaymentTypePromotions is true, CheckoutPayments.loadPaymentSnippet should have been called to 
				reload the entire payment refresh area. This will also refresh the amount field. Hence, we don't need to
				call update amount field again	(which will trigger a call to CheckoutPayments.loadPaymentSnippet ).
			**/
			if (!supportPaymentTypePromotions) { 
				var orderTotal = $("#OrderTotalAmount").val();
				CheckoutPayments.updateAmountFields(orderTotal);
			}
			
			var widgetId = "paymentArea" + paymentAreaNumber;
			TealeafWCJS.rebind(widgetId);
			
			var addressKey = "billingAddress" + paymentAreaNumber;
			//reset the billing address id in the billing address context to be the default selected address after payment method refresh
			wcRenderContext.updateRenderContext('billingAddressDropDownBoxContext', {addressKey:(document.getElementsByName('billing_address_id'))[paymentAreaNumber-1].value, 'areaNumber':paymentAreaNumber});

			cursor_clear();
		}
	});
	
};

/**
 * Refresh controller declaration for shipping address display area.
 * @constructor
 */
function declareShippingAddressDisplayAreaController() {
	var myWidgetObj = $("#shippingAddressDisplayArea");
	
	wcRenderContext.addRefreshAreaId("shippingAddressContext", "shippingAddressDisplayArea");
	var myRCProperties = wcRenderContext.getRenderContextProperties("shippingAddressContext");

	myWidgetObj.refreshWidget({
		renderContextChangedHandler: function() {
			if (wcRenderContext.testForChangedRC("shippingAddressContext", ["shippingAddress"])) {
				var addressId = myRCProperties["shippingAddress"];
				myWidgetObj.refreshWidget("refresh", {"addressId": addressId});
			}
			cursor_clear();
		}
	});

};

/**
 * Refresh controller declaration for shipping address edit area.
 * @constructor
 */
function declareEditShippingAdddressAreaController() {
	var myWidgetObj = $("#editShippingAddressArea1");

	wcRenderContext.addRefreshAreaId("editShippingAddressContext", "editShippingAddressArea1");
	var myRCProperties = wcRenderContext.getRenderContextProperties("editShippingAddressContext");

	var events = $.extend({}, address_updated, {"UpdateBillingAddressInCheckout": "UpdateBillingAddressInCheckout"});
	
	wcTopic.subscribe(events, function(returnData) {
		if(shipmentTypeId == 2){
			//This means, invokeService for Address Add/Edit has been called..so update our select box area
			wcRenderContext.updateRenderContext('contextForMainAndAddressDiv', {'showArea':'mainContents','hideArea':'editAddressContents'});
			selectedAddressId = returnData.data.addressId;
			CheckoutHelperJS.updateAddressIdOFItemsOnCreateEditAddress(selectedAddressId[0]);
			cursor_clear();  
		}
	});
	
	myWidgetObj.refreshWidget({
		renderContextChangedHandler: function() {
			if (wcRenderContext.testForChangedRC("editShippingAddressContext", ["shippingAddress"])) {
				var addressId = myRCProperties["shippingAddress"];
				//reset the addressID..so that when user selects create address next time it works properly..
				myRCProperties["shippingAddress"] = 0;
				var addressType = myRCProperties["addressType"];
				myWidgetObj.refreshWidget("refresh", {"addressId": addressId,"addressType":addressType});
			}
		},
		postRefreshHandler: function() {
			cursor_clear();
			AddressHelper.loadStatesUI('shopcartAddressForm','','stateDiv','state', true);
			TealeafWCJS.rebind("centered_single_column_form");
		}
	});
};


function declareMultipleShipmentOrderDetailsRefreshArea() {
	var widgetName = "WC_MultipleShipmentDisplay_div_18";
	var contextName = "multipleShipmentDetailsContext";
	
	if (!wcRenderContext.checkIdDefined(contextName)) {
		wcRenderContext.declare(contextName, [], {shipmentDetailsArea: "update"});
	}
	var myRCProperties = wcRenderContext.getRenderContextProperties(contextName);
	var myWidgetObj = $("#"+widgetName);
	
	wcRenderContext.addRefreshAreaId(contextName, widgetName);
	
	var actionIds = $.extend({}, order_updated,{'AjaxUpdateOrderItemsAddressId':'AjaxUpdateOrderItemsAddressId','AjaxDeleteOrderItemForShippingBillingPage':'AjaxDeleteOrderItemForShippingBillingPage','OrderItemAddressShipMethodUpdate':'OrderItemAddressShipMethodUpdate',
	'AjaxPrepareOrderForShipChargeUpdate':'AjaxPrepareOrderForShipChargeUpdate',
	'OrderItemAddressShipInstructionsUpdate':'OrderItemAddressShipInstructionsUpdate',
	'OrderItemAddressShipInstructionsUpdate1':'OrderItemAddressShipInstructionsUpdate1',
	'AjaxAddUnboundPaymentInstructionToThisOrder':'AjaxAddUnboundPaymentInstructionToThisOrder',
	'AjaxDeleteUnboundPaymentInstructionFromThisOrder':'AjaxDeleteUnboundPaymentInstructionFromThisOrder',
	'AddBillingAddressInCheckOut':'AddBillingAddressInCheckOut'});  
	 
	wcTopic.subscribe(actionIds, function(data){
		if(!CheckoutHelperJS.RequestShippingDateAction && (data.actionId != 'AddBillingAddressInCheckOut' || data.addBillingAddressInCheckOutAddressType != 'Billing')){
			myWidgetObj.refreshWidget("refresh", myRCProperties);
			submitRequest(); //Till shop cart is refreshed, do not allow any other requests..
			cursor_wait();
		} else {
			CheckoutHelperJS.RequestShippingDateAction = false;
		}		
	});
	
	var renderContextChangedHandler = function() {
		if(wcRenderContext.testForChangedRC(contextName,["beginIndex"])){
			myWidgetObj.refreshWidget("refresh", myRCProperties);
		}
	};

	// post refresh handler
	var postRefreshHandler = function() {
		resetRequest(); //Shop cart is refreshed, give the control to shopper...
		cursor_clear();

		if (myRCProperties["initializeJS"] == 'true') {
			$('input[id^="orderItem_"]').each(function(i, orderItem) {
				$.globalEval($('#addToRequisitionListScript_' + orderItem.value).html());
				var addReqObj = 'addReqListsJS' + orderItem.value;
				$.globalEval('if(typeof '+ addReqObj + ' !== "undefined") {' + addReqObj + '.setCatEntryId("' + document.getElementById('catalogId_' + (orderItem.id.substring(orderItem.id.indexOf('_') + 1))).value + '");}');
			});
			$('div[id^="shoppingListScript_"]').each(function(i, node){
				$.globalEval($(node).html());
			});
		}
		if ((numAjaxRequests >= 0) && CheckoutHelperJS.getLastAddressLinkIdToFocus() != null && CheckoutHelperJS.getLastAddressLinkIdToFocus() != 'undefined' && CheckoutHelperJS.getLastAddressLinkIdToFocus() != '') {
			if (document.getElementById(CheckoutHelperJS.getLastAddressLinkIdToFocus()) != null){
				document.getElementById(CheckoutHelperJS.getLastAddressLinkIdToFocus()).focus();
			}else{
				var lastAddress = CheckoutHelperJS.getLastAddressLinkIdToFocus();
				var lastAddressArray = lastAddress.split("_");
				var lastAddressOrderId = (parseInt(lastAddressArray[lastAddressArray.length - 1]) + 1) + '';
				if (lastAddress.indexOf('WC_ShippingAddressSelectMultiple_link_2_') > -1){
					var lastAddressForFreeGift = 'WC_ShippingAddressSelectMultiple_link_2_' + lastAddressOrderId;
					if (document.getElementById(lastAddressForFreeGift) != null ){
						document.getElementById(lastAddressForFreeGift).focus();
					}
				}else{
					var lastAddressForFreeGift = 'WC_ShippingAddressSelectMultiple_link_3_' + lastAddressOrderId;
					if (document.getElementById(lastAddressForFreeGift) != null ){
						document.getElementById(lastAddressForFreeGift).focus();
					}
				}
			}						
		} else if (CheckoutHelperJS.getLastFocus() != '' && tabPressed) {
			tabPressed = false;			
			if (document.getElementById(CheckoutHelperJS.getLastFocus()) != null){
				document.getElementById(CheckoutHelperJS.getLastFocus()).focus();
			}else{
				var lastAddress = CheckoutHelperJS.getLastFocus();
				var lastAddressArray = lastAddress.split("_");
				var lastAddressOrderId = (parseInt(lastAddressArray[lastAddressArray.length - 1]) + 1) + '';
				if (lastAddress.indexOf('WC_ShippingAddressSelectMultiple_link_2_') > -1){
					var lastAddressForFreeGift = 'WC_ShippingAddressSelectMultiple_link_2_' + lastAddressOrderId;
					if (document.getElementById(lastAddressForFreeGift) != null ){
						document.getElementById(lastAddressForFreeGift).focus();
					}
				}else{
					var lastAddressForFreeGift = 'WC_ShippingAddressSelectMultiple_link_3_' + lastAddressOrderId;
					if (document.getElementById(lastAddressForFreeGift) != null ){
						document.getElementById(lastAddressForFreeGift).focus();
					}
				}
			}									
			CheckoutHelperJS.setLastFocus('');
		}	
	};

	// initialize widget
	myWidgetObj.refreshWidget({renderContextChangedHandler: renderContextChangedHandler, postRefreshHandler: postRefreshHandler});
};
		
function declareMultipleShipmentShipChargeRefreshArea() {

	var contextName = "multipleShipmentShipChargeContext";
	var widgetName = "WC_MultipleShipmentDisplay_ShipCharge_Area";
	var myWidgetObj = $("#"+widgetName);

	if (!wcRenderContext.checkIdDefined(contextName)) {
		wcRenderContext.declare(contextName, [],null);
	}
	var myRCProperties = wcRenderContext.getRenderContextProperties(contextName);
	wcRenderContext.addRefreshAreaId(contextName, widgetName);
	
	// model change
	wcTopic.subscribe(["OrderItemAddressShipMethodUpdate","AjaxDeleteOrderItemForShippingBillingPage"], function(data) {
		if (SBControllersDeclarationJS.shipChargeEnabled) {
			if (data.actionId=="OrderItemAddressShipMethodUpdate") {
				myWidgetObj.refreshWidget("refresh", myRCProperties);
			}
			if (data.actionId=="AjaxDeleteOrderItemForShippingBillingPage") {
				myWidgetObj.refreshWidget("refresh", myRCProperties);
			}
		}
	});
	
	var postRefreshHandler = function() {
		cursor_clear();
	};

	// initialize widget
	myWidgetObj.refreshWidget({postRefreshHandler: postRefreshHandler});
};

/**
 * Refresh controller declaration for shipping address edit area for DOMOrderShippingBillingDetails.jsp.
 * @constructor
 */
function declareDOMEditShippingAdddressAreaController() {
	var contextName = "editShippingAddressContext";
	var widgetName = "editShippingAddressArea1";
	
	var myWidgetObj = $("#" + widgetName);
	var myRCProperties = wcRenderContext.getRenderContextProperties(contextName);
	wcRenderContext.addRefreshAreaId(contextName, widgetName);
	
	wcTopic.subscribe(address_updated, function() {
		//This means, invokeService for Address Add/Edit has been called..so upadate our select box area
		wcRenderContext.updateRenderContext('contextForMainAndAddressDiv', {'showArea':'mainContents','hideArea':'editAddressContents'});
		cursor_clear();
	});
	
	myWidgetObj.refreshWidget({
		renderContextChangedHandler: function() {
			if (wcRenderContext.testForChangedRC(contextName, ["shippingAddress"])) {
				var addressId = myRCProperties["shippingAddress"];
				//reset the addressID..so that when user selects create address next time it works properly..
				myRCProperties["shippingAddress"] = 0;
				var addressType = myRCProperties["addressType"];
				myWidgetObj.refreshWidget("refresh", {"addressId": addressId,"addressType":addressType});
			}
		},
	
		postRefreshHandler: function() {
			cursor_clear();
		}
	});

};

//-----------------------------------------------------------------
// Licensed Materials - Property of IBM
//
// WebSphere Commerce
//
// (C) Copyright IBM Corp. 2008, 2016 All Rights Reserved.
//
// US Government Users Restricted Rights - Use, duplication or
// disclosure restricted by GSA ADP Schedule Contract with
// IBM Corp.
//-----------------------------------------------------------------

//
//

/** 
 * @fileOverview This file declares services that are used in the store check-out pages.
 */


/** 
 * This file declares services that are used in the store check-out pages.
 * 
 * @class This SBServicesDeclarationJS class defines all the variables and functions for the page(s) that use shipping and billing functionality in the store.
 *
 */
SBServicesDeclarationJS = {
	/** 
	 * This variable stores the ID of the language that the store is currently using.
	 *
	 * @private
	 */
	langId: "-1",
	
	/** 
	 * This variable stores the ID of the current store.
	 *
	 * @private
	 */
	storeId: "",
	
	/** 
	 * This variable stores the ID of the catalog that is used in the store.
	 *
	 * @private
	 */
	catalogId: "",

	/** 
	 * This variable stores the true/false value that indicates if the 'SinglePageCheckout' feature is enabled/disabled.
	 * When it is true, both shipping and billing information are captured in a single page. If it is false, checkout will
	 * be a two step process where shipping is captured in first step and billing in second step.
	 * It is set to true by default.
	 * 
	 * @private
	 */
	singlePageCheckout:true,
	
	/**
	 * This variable stores the value that indicates if an <code>OrderProcessServiceOrderPrepare</code> service call is required.
	 *
	 * @private
	 */
	orderPrepare: false,
	
	
	/**
 	 * Sets the common parameters for this instance.
 	 *
 	 * @param {int} langId The ID of the language used in the store.
 	 * @param {int} storeId The ID of the store.
 	 * @param {catalogId} catalogId The ID of the catalog used in the store.
	 */
	setCommonParameters:function(langId,storeId,catalogId){
			this.langId = langId;
			this.storeId = storeId;
			this.catalogId = catalogId;
	},
	

	/**
	 * Sets the SinglePageCheckout variable to indicate if the 'SinglePageCheckout' feature is enabled or disabled.
	 * 
	 * @param {Boolean} singlePageCheckout. A true/false value that indicates if the 'SinglePageCheckout' feature is enabled.
	 *
	 * @see CheckoutHelperJS.isSinglePageCheckout
	 */
	setSinglePageCheckout:function(singlePageCheckout){
		this.singlePageCheckout = singlePageCheckout;
	},
	
	
	/**
	 * Returns the singlePageCheckout variable that indicates if the 'SinglePageCheckout' feature is enabled/disabled.
	 * 
	 * @returns {Boolean} singlePageCheckout A true/false value that indicates if the 'SinglePageCheckout' feature is
	 * enabled/disabled.
	 *
	 * @see CheckoutHelperJS.setSinglePageCheckout
	 */
	isSinglePageCheckout:function(){
		return this.singlePageCheckout;
	}

}

/**
 * Declares an AJAX service that adds an item to the wish list and delete an item from the shopping cart.
 * @constructor 
 */
wcService.declare({
	id: "AjaxInterestItemAddAndDeleteFromCart",
	actionId: "AjaxInterestItemAddAndDeleteFromCart",
	url: "AjaxInterestItemAdd",
	formId: ""

	/**
	 * Hides the progress bar and deletes the order item from the shopping cart.
	 *
	 * @param (object) serviceResponse The service response object, which is the JSON object returned by the service invocation.
	 */
	,successHandler: function(serviceResponse) {
		cursor_clear();
		CheckoutHelperJS.deleteFromCart(serviceResponse.orderItemId);
	}
	
	/**
	 * Displays the error message returned with the service response and hides the progress bar.
	 *
	 * @param (object) serviceResponse The service response object, which is the JSON object returned by the service invocation.
	 */
	,failureHandler: function(serviceResponse) {
		if (serviceResponse.errorMessage) {
			MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
		} else {
			if (serviceResponse.errorMessageKey) {
				MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
			}
		}
		cursor_clear();
	}

}),


/**
 * Declares an AJAX service that updates the shipping address and shipping method for items in the order.
 * @constructor 
 */
wcService.declare({
	id: "OrderItemAddressShipMethodUpdate",
	actionId: "OrderItemAddressShipMethodUpdate",
	url: "AjaxRESTOrderShipInfoUpdate",
	formId: ""
	
	/**
	 * hides all the messages and the progress bar
	 * @param (object) serviceResponse The service response object, which is the
	 * JSON object returned by the service invocation
	 */
	,successHandler: function(serviceResponse) {
		MessageHelper.hideAndClearMessage();
		cursor_clear();
	}
	
	/**
	 * Displays the error message returned with the service response and hides the progress bar.
	 *
	 * @param (object) serviceResponse The service response object, which is the JSON object returned by the service invocation.
	 */
	,failureHandler: function(serviceResponse) {
		if (serviceResponse.errorMessage) {
			MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
		} else {
			if (serviceResponse.errorMessageKey) {
				MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
			}
		}
		cursor_clear();
	}

}),

/**
 * Declares an AJAX service that updates the shipping charge type for items in the order.
 * @constructor 
 */
wcService.declare({
	id: "AjaxOrderShipChargeUpdate",
	actionId: "AjaxOrderShipChargeUpdate",
	url: "AjaxShipInfoUpdate",
	formId: ""
	
	/**
	 * hides all the messages and the progress bar
	 * @param (object) serviceResponse The service response object, which is the
	 * JSON object returned by the service invocation
	 */
	,successHandler: function(serviceResponse) {
		/*
		MessageHelper.hideAndClearMessage();
		cursor_clear();
		*/
		var params = [];
		params.orderId = ".";
		params["storeId"] = CheckoutHelperJS.storeId;
		params["catalogId"] = CheckoutHelperJS.catalogId;
		params["langId"] = CheckoutHelperJS.langId;
		wcService.invoke("AjaxPrepareOrderForShipChargeUpdate", params);
	}
	
	/**
	 * Displays the error message returned with the service response and hides the progress bar.
	 *
	 * @param (object) serviceResponse The service response object, which is the JSON object returned by the service invocation.
	 */
	,failureHandler: function(serviceResponse) {
		if (serviceResponse.errorMessage) {
			MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
		} else {
			if (serviceResponse.errorMessageKey) {
				MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
			}
		}
		cursor_clear();
	}

}),

/**
 *This service calculates charges, performs inventory actions, and locks the
 *price of the order to indicate that the order can be submitted.
 *A message is displayed after the service call.
 * @constructor
 */
wcService.declare({
	id: "AjaxPrepareOrderForShipChargeUpdate",
	actionId: "AjaxPrepareOrderForShipChargeUpdate",
	url: getAbsoluteURL() + "AjaxRESTOrderPrepare",
	formId: ""
    /**
   * hides all the messages and the progress bar
   * @param (object) serviceResponse The service response object, which is the
   * JSON object returned by the service invocation
   */
	,successHandler: function(serviceResponse) {
		MessageHelper.hideAndClearMessage();
			cursor_clear();
	}

    /**
   * hides all the messages and the progress bar
   * @param (object) serviceResponse The service response object, which is the
   * JSON object returned by the service invocation
   */
	,failureHandler: function(serviceResponse) {

		if (serviceResponse.errorMessage) {
			MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
		} 
		else {
			 if (serviceResponse.errorMessageKey) {
				MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
			 }
		}
		cursor_clear();
	}

}),


/**
 * Declares an AJAX service that updates the shipping address and shipping instruction for items in the order.
 * @constructor 
 */
wcService.declare({
	id: "OrderItemAddressShipInstructionsUpdate",
	actionId: "OrderItemAddressShipInstructionsUpdate",
	url: "AjaxRESTOrderShipInfoUpdate",
	formId: ""
	
	/**
	 * Invokes the <code>OrderItemAddressShipInstructionsUpdate1</code> service if shipping instructions were specified, otherwise hides all the messages and the progress bar
	 *
	 * @param (object) serviceResponse The service response object, which is the JSON object returned by the service invocation.
	 */
	,successHandler: function(serviceResponse) {
		var params = [];
		params.orderId = ".";
		params["storeId"] = CheckoutHelperJS.storeId;
		params["catalogId"] = CheckoutHelperJS.catalogId;
		params["langId"] = CheckoutHelperJS.langId;
		params.calculationUsage = "-1,-2,-3,-4,-5,-6,-7";
		params.calculateOrder = "1";
		
		//Check if Shipping Instructions is enabled		
		if(document.getElementById("shipInstructions") != null){
			var shipInstructions = document.getElementById("shipInstructions").value;
			var orderItemId = document.getElementById("orderItem_1").value;				
			
			params["shipInstructions"] = shipInstructions;
			params["orderItemId"] = orderItemId;
			
			wcService.invoke("OrderItemAddressShipInstructionsUpdate1", params);			
		} else {
			MessageHelper.hideAndClearMessage();
			cursor_clear();
		}		
	}
	
	/**
	 * Displays the error message returned with the service response and hides the progress bar.
	 *
	 * @param (object) serviceResponse The service response object, which is the JSON object returned by the service invocation.
	 */
	,failureHandler: function(serviceResponse) {
		if (serviceResponse.errorMessage) {
			MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
		} else {
			if (serviceResponse.errorMessageKey) {
				MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
			}
		}
		cursor_clear();
	}

}),


/**
 * Declares an AJAX service that updates the shipping instruction for items in the order.
 * @constructor 
 */
wcService.declare({
	id: "OrderItemAddressShipInstructionsUpdate1",
	actionId: "OrderItemAddressShipInstructionsUpdate1",
	url: "AjaxRESTOrderShipInfoUpdate",
	formId: ""
	
	/**
	 * hides all the messages and the progress bar
	 * @param (object) serviceResponse The service response object, which is the
	 * JSON object returned by the service invocation
	 */
	,successHandler: function(serviceResponse) {
		MessageHelper.hideAndClearMessage();
		cursor_clear();
	}
	
	/**
	 * Displays the error message returned with the service response and hides the progress bar.
	 *
	 * @param (object) serviceResponse The service response object, which is the JSON object returned by the service invocation.
	 */
	,failureHandler: function(serviceResponse) {
		if (serviceResponse.errorMessage) {
			MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
		} else {
			if (serviceResponse.errorMessageKey) {
				MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
			}
		}
		cursor_clear();
	}

}),

/**
 * Declares an AJAX service that updates the shipping method for items in the order. This service is used to move all order items to single addressId and shipModeId when a user clicks on the single shipment button.
 * @constructor 
 */
wcService.declare({
	id: "OrderItemAddressShipMethodUpdate1",
	actionId: "OrderItemAddressShipMethodUpdate1",
	url: "AjaxRESTOrderShipInfoUpdate",
	formId: ""
	
	/**
	 * Invokes the <code>OrderChangeServiceShipInfoUpdate</code> service, then redirects the browser to OrderShippingBillingView.
	 *
	 * @param (object) serviceResponse The service response object, which is the JSON object returned by the service invocation.
	 */
	,successHandler: function(serviceResponse) {
		//Store the ids
		var storeId = CheckoutHelperJS.storeId;
		var catalogId = CheckoutHelperJS.catalogId;
		var langId = CheckoutHelperJS.langId;
		var orderId = serviceResponse.orderId;		

		//Obtain the shipmode id for the first order item
		var orderItemId = document.getElementById("orderItem_1").value;	
		var commonShipModeId = document.getElementById("commonShipModeId").value;
		if(commonShipModeId !=null && commonShipModeId!='undefined'){
			var shipModeId = commonShipModeId;
		}else{
			var shipModeId = document.getElementById("MS_ShippingMode_"+orderItemId).value;
		}
		
		var postRefreshHandlerParameters = [];
		var initialURL = "AjaxRESTOrderShipInfoUpdate";
		var urlRequestParams = [];
		urlRequestParams["remerge"] = "***";
		urlRequestParams["check"] = "*n";
		urlRequestParams["allocate"] = "***";
		urlRequestParams["backorder"] = "***";
		urlRequestParams["storeId"] = storeId;
		urlRequestParams["catalogId"] = catalogId;
		urlRequestParams["langId"] = langId;
		urlRequestParams["orderId"] = orderId;
		urlRequestParams["shipModeId"] = shipModeId;
		urlRequestParams["calculationUsage"] = "-1,-2,-3,-4,-5,-6,-7";
		urlRequestParams["calculateOrder"] = "1";
		
		//do not want to pass an empty purchaseorder_id to OrderChangeServiceShipInfoUpdate because it'll cause an failure in OrderFacadeClient.java
		var purchaseorderRef = document.getElementById("purchase_order_number");
		if(purchaseorderRef){
			var purchaseorder_id = purchaseorderRef.value;
			if(purchaseorder_id !=null && purchaseorder_id !='undefined' && purchaseorder_id !=''){
				urlRequestParams["purchaseorder_id"] = purchaseorder_id;
			}
		}
		//checks to see if quick checkout is enabled to display the credit card masked info  by checking the valueFromProfileOrder parameter
		if (valueFromProfileOrderElement = document.getElementsByName("valueFromProfileOrder")[0]&&valueFromProfileOrderElement.value == 'Y') {
			urlRequestParams["quickCheckoutProfileForPayment"] = "true";
		}
		postRefreshHandlerParameters.push({"URL":"OrderShippingBillingView","requestType":"GET", "requestParams":{}}); 
		var service = getCustomServiceForURLChaining(initialURL,postRefreshHandlerParameters,null);
		service.invoke(urlRequestParams);
	}
	
	/**
	 * Displays the error message returned with the service response and hides the progress bar.
	 *
	 * @param (object) serviceResponse The service response object, which is the JSON object returned by the service invocation.
	 */
	,failureHandler: function(serviceResponse) {
		if(serviceResponse.errorMessageKey == '_ERR_INVALID_ADDR'){
			MessageHelper.displayErrorMessage(MessageHelper.messages["ERROR_SWITCH_SINGLE_SHIPMENT"]);
		} else {		 
			if (serviceResponse.errorMessage) {
				MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
			} else {
				if (serviceResponse.errorMessageKey) {
					MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
				}
			}
		}
		cursor_clear();
	}
}),

/**
 * Declares an AJAX service that updates the shipping address for items in the order.
 * @constructor
 */
wcService.declare({
	id: "AjaxUpdateOrderItemsAddressId",
	actionId: "AjaxUpdateOrderItemsAddressId",
	url: "AjaxRESTOrderShipInfoUpdate",
	formId: ""
	
	/**
	 * After service was successfully performed, hides all messages and the progress bar. 
	 * Otherwise, routes to shipping and billing page.
	 *
	 * @param (object) serviceResponse The service response object, which is the JSON object returned by the service invocation.
	 */
	,successHandler: function(serviceResponse) {
		MessageHelper.hideAndClearMessage();
		CheckoutHelperJS.orderItemIds = [];
		cursor_clear();
	}
	
	/**
	 * Displays the error message returned with the service response and hides the progress bar.
	 *
	 * @param (object) serviceResponse The service response object, which is the JSON object returned by the service invocation.
	 */
	,failureHandler: function(serviceResponse) {
		if (serviceResponse.errorMessage) {
			MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
		} else {
			if (serviceResponse.errorMessageKey) {
				MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
			}
		}
		cursor_clear();
	}
}),


/**
 * Declares an AJAX service that adds a billing address during order check-out.
 * @constructor
 */
wcService.declare({
	id: "AddBillingAddressInCheckOut",
	actionId: "AddBillingAddressInCheckOut",
	url: "AjaxPersonChangeServiceAddressAdd",
	formId: ""
	
	/**
	 * This function renders the area having the context ID contextForMainAndAddressDiv with the specified properties.
	 *
	 * @param (object) serviceResponse The service response object, which is the JSON object returned by the service invocation.
	 */
	,successHandler: function(serviceResponse) {
		cursor_clear();
		wcRenderContext.updateRenderContext('contextForMainAndAddressDiv', {'showArea':'mainContents','hideArea':'editAddressContents'});
		if (this.formId != '' && document.getElementById(this.formId)){
			serviceResponse.addBillingAddressInCheckOutAddressType = document.getElementById(this.formId).addressType.value;
		}
	}
	
	/**
	 * Displays the error message returned with the service response and hides the progress bar.
	 *
	 * @param (object) serviceResponse The service response object, which is the JSON object returned by the service invocation.
	 */
	,failureHandler: function(serviceResponse) {
		if (serviceResponse.errorMessage) {
			MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
		} else {
			if (serviceResponse.errorMessageKey) {
				MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
			}
		}
		cursor_clear();
	}
}),

/**
 * This service edits an billing address for the person during checkout. An error message is displayed
 * if the service failed.
 * @constructor
 */
wcService.declare({
	id: "UpdateBillingAddressInCheckout",
	actionId: "UpdateBillingAddressInCheckout",
	url: getAbsoluteURL() + "AjaxPersonChangeServiceAddressUpdate",
	formId: ""

/**
 * hides all the messages and the progress bar
 * @param (object) serviceResponse The service response object, which is the JSON object returned by the service invocation
 * 
 */
	,successHandler: function(serviceResponse) {
		cursor_clear();
		wcRenderContext.updateRenderContext('contextForMainAndAddressDiv', {'showArea':'mainContents','hideArea':'editAddressContents'});
	}
 /**
 * display an error message
 * @param (object) serviceResponse The service response object, which is the
 * JSON object returned by the service invocation
 */
	,failureHandler: function(serviceResponse) {

		if (serviceResponse.errorMessage) {
			MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
		}
		else {
			 if (serviceResponse.errorMessageKey) {
				MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
			 }
		}
		cursor_clear();
	}

}),

/**
 * Declares an AJAX service that updates shipping information for order items during check-out.
 * @constructor
 */
wcService.declare({
	id: "OrderShippingInfoUpdate",
	actionId: "OrderShippingInfoUpdate",
	url: "AjaxRESTOrderShipInfoUpdate",
	formId: ""
	
	/**
	 * Clears the progress bar.
	 *
	 * @param (object) serviceResponse The service response object, which is the JSON object returned by the service invocation.
	 */
	,successHandler: function(serviceResponse) {
		cursor_clear();
	}
	
	/**
	 * Displays the error message returned with the service response and hides the progress bar.
	 *
	 * @param (object) serviceResponse The service response object, which is the JSON object returned by the service invocation.
	 */
	,failureHandler: function(serviceResponse) {
		if (serviceResponse.errorMessage) {
			MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
		} else {
			if (serviceResponse.errorMessageKey) {
				MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
			}
		}
		cursor_clear();
	}
}),


/**
 * Declares an AJAX service that prepares order information before submitting the order.
 * @constructor
 */
wcService.declare({
	id: "AjaxPrepareOrderBeforeSubmit",
	actionId: "AjaxPrepareOrderBeforeSubmit",
	url: "AjaxRESTOrderPrepare",
	formId: ""
	
	/**
	 * Submits the order with the name of the payment form.
	 *
	 * @param (object) serviceResponse The service response object, which is the JSON object returned by the service invocation.
	 */
	,successHandler: function(serviceResponse) {
		cursor_clear();
		CheckoutPayments.getTotalInJSON("OrderPrepare", 'PaymentForm', false);
	}
	
	/**
	 * Displays the error message returned with the service response and hides the progress bar.
	 *
	 * @param (object) serviceResponse The service response object, which is the JSON object returned by the service invocation.
	 */
	,failureHandler: function(serviceResponse) {
		if (serviceResponse.errorMessage) {
			MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
		} else {
			if (serviceResponse.errorMessageKey) {
				MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
			}
		}
		cursor_clear();
	}

}),

/**
 * Declares an AJAX service that prepares order information before submitting the order.
 * @constructor
 */
wcService.declare({
	id: "AjaxPrepareOrderBeforePaymentCapture",
	actionId: "AjaxPrepareOrderBeforePaymentCapture",
	url: "AjaxRESTOrderPrepare",
	formId: ""
	
	/**
	 * Submits the order with the name of the payment form.
	 *
	 * @param (object) serviceResponse The service response object, which is the JSON object returned by the service invocation.
	 */
	,successHandler: function(serviceResponse) {
		CheckoutPayments.setCommonParameters(SBServicesDeclarationJS.langId,SBServicesDeclarationJS.storeId,SBServicesDeclarationJS.catalogId);
		CheckoutPayments.showBillingPage();
		cursor_clear();
	}

	
	/**
	 * Displays the error message returned with the service response and hides the progress bar.
	 *
	 * @param (object) serviceResponse The service response object, which is the JSON object returned by the service invocation.
	 */
	,failureHandler: function(serviceResponse) {
		if (serviceResponse.errorMessage) {
			MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
		} else {
			if (serviceResponse.errorMessageKey) {
				MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
			}
		}
		cursor_clear();
	}

}),

/**
 * Declares an AJAX service that sets the address ID for all items in the order.
 * @constructor
 */
wcService.declare({
	id: "AjaxSetAddressIdOfOrderItems",
	actionId: "AjaxSetAddressIdOfOrderItems",
	url: "AjaxRESTOrderShipInfoUpdate",
	formId: ""
	
	/**
	 * Redirects the browser to OrderShippingBillingView
	 * @param (object) serviceResponse The service response object, which is the JSON object returned by the service invocation.
	 */
	,successHandler: function(serviceResponse) {
		var url="OrderShippingBillingView?orderId="+(serviceResponse.orderId?serviceResponse.orderId:".")+"&langId="+serviceResponse.langId+"&storeId="+serviceResponse.storeId+"&catalogId="+serviceResponse.catalogId+"&showRegTag=T";
		document.location.href=appendWcCommonRequestParameters(url);
	}
	
	/**
	 * Displays the error message returned with the service response and hides the progress bar.
	 *
	 * @param (object) serviceResponse The service response object, which is the JSON object returned by the service invocation.
	 */
	,failureHandler: function(serviceResponse) {
		if (serviceResponse.errorMessage) {
			MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
		} else {
			if (serviceResponse.errorMessageKey) {
				MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
			}
		}
		document.getElementById("OrderShippingBillingErrorArea").style.display = "block";
		cursor_clear();
	}

}),


/**
 * Declares an AJAX service that sets the shipping mode ID for the order.
 * @constructor
 */
wcService.declare({
	id: "AjaxSetShipModeIdForOrder",
	actionId: "AjaxSetShipModeIdForOrder",
	url: "AjaxRESTOrderShipInfoUpdate",
	formId: ""
	
	/**
	 * Redirects the browser to OrderShippingBillingView.
	 *
	 * @param (object) serviceResponse The service response object, which is the JSON object returned by the service invocation.
	 */
	,successHandler: function(serviceResponse) {
		var url="OrderShippingBillingView?langId="+SBServicesDeclarationJS.langId+"&storeId="+SBServicesDeclarationJS.storeId+"&catalogId="+SBServicesDeclarationJS.catalogId;
		document.location.href=appendWcCommonRequestParameters(url);
	}
	
	/**
	 * Displays the error message returned with the service response and hides the progress bar.
	 * 
	 * @param (object) serviceResponse The service response object, which is the JSON object returned by the service invocation.
	 */
	,failureHandler: function(serviceResponse) {
		if (serviceResponse.errorMessage) {
			MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
		} else {
			if (serviceResponse.errorMessageKey) {
				MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
			}
		}
		document.getElementById("OrderShippingBillingErrorArea").style.display = "block";
		cursor_clear();
	}

}),

/**
 * Declares an AJAX service that sets the requested ship date for all items in the order.
 * @constructor
 */
wcService.declare({
	id: "AjaxSetRequestedShipDateForOrder",
	actionId: "AjaxSetRequestedShipDateForOrder",
	url: "AjaxRESTOrderShipInfoUpdate",
	formId: ""
	
	/**
	 * Redirects the browser to OrderShippingBillingView
	 * @param (object) serviceResponse The service response object, which is the JSON object returned by the service invocation.
	 */
	,successHandler: function(serviceResponse) {
		var url = "OrderShippingBillingView?orderId="+(serviceResponse.orderId?serviceResponse.orderId:".")+"&langId="+SBServicesDeclarationJS.langId+"&storeId="+SBServicesDeclarationJS.storeId+"&catalogId="+SBServicesDeclarationJS.catalogId+"&showRegTag=T";
		document.location.href=appendWcCommonRequestParameters(url);
	}
	
	/**
	 * Displays the error message returned with the service response and hides the progress bar.
	 *
	 * @param (object) serviceResponse The service response object, which is the JSON object returned by the service invocation.
	 */
	,failureHandler: function(serviceResponse) {
		if (serviceResponse.errorMessage) {
			MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
		} else {
			if (serviceResponse.errorMessageKey) {
				MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
			}
		}
		document.getElementById("OrderShippingBillingErrorArea").style.display = "block";
		cursor_clear();
	}

}),


/**
* This service adds a shipping and billing address during order check out. An error message is displayed if the service failed.
* @constructor
*/
wcService.declare({
	id: "AjaxAddShippingAndBillingAddressForPersonDuringCheckout",
	actionId: "AjaxAddShippingAndBillingAddressForPersonDuringCheckout",
	url: getAbsoluteURL() + "AjaxPersonChangeServiceAddressAdd",
	formId: ""

/**
* Hides all the messages and the progress bar
* @param (object) serviceResponse The service response object, which is the JSON object returned by the service invocation.
*/
	,successHandler: function(serviceResponse) {
		if (this.formId != ""){
			serviceResponse.originalServiceId = document.getElementById(this.formId).originalServiceId.value;
		}
		MessageHelper.hideAndClearMessage();
		cursor_clear();
	}

/**
* Displays an error message in case of failure.
* @param (object) serviceResponse The service response object, which is the JSON object returned by the service invocation.
*/
	,failureHandler: function(serviceResponse) {

		if (serviceResponse.errorMessage) {
			MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
		} 
		else {
			 if (serviceResponse.errorMessageKey) {
				MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
			 }
		}
		cursor_clear();
	}

}),
/**
* This service updates a shipping and billing address during order check out. An error message is displayed if the service failed.
* @constructor
*/
wcService.declare({
	id: "AjaxUpdateShippingAndBillingAddressForPersonDuringCheckout",
	actionId: "AjaxUpdateShippingAndBillingAddressForPersonDuringCheckout",
	url: getAbsoluteURL() + "AjaxPersonChangeServiceAddressUpdate",
	formId: ""

/**
* Hides all the messages and the progress bar
* @param (object) serviceResponse The service response object, which is the JSON object returned by the service invocation.
*/
	,successHandler: function(serviceResponse) {
		if (this.formId != ""){
			serviceResponse.originalServiceId = document.getElementById(this.formId).originalServiceId.value;
		}
		MessageHelper.hideAndClearMessage();
		cursor_clear();
	}

/**
* Displays an error message in case of failure.
* @param (object) serviceResponse The service response object, which is the JSON object returned by the service invocation.
*/
	,failureHandler: function(serviceResponse) {

		if (serviceResponse.errorMessage) {
			MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
		} 
		else {
			 if (serviceResponse.errorMessageKey) {
				MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
			 }
		}
		cursor_clear();
	}

}),
/**
* Declares an AJAX service that deletes payment instructions from the current order.
* @constructor
*/
wcService.declare({
	id: "AjaxDeletePaymentInstructionFromThisOrder",
	actionId: "AjaxDeletePaymentInstructionFromThisOrder",
	url: "AjaxRESTOrderPIDelete",
	formId: ""
	
	/**
	 * Removes piId from payment objects and payment forms on the page, clears the progress bar.
	 * Invokes the AjaxPrepareOrderBeforeProceedingToSummary service to prepare order information.
	 * @param (object) serviceResponse The service response object, which is the JSON object returned by the service invocation.
	 */
	,successHandler: function(serviceResponse) {
		var paymentObj = CheckoutPayments.retrievePaymentObject(serviceResponse["paymentAreaNumber"]);
		if (typeof(paymentObj) != "undefined") {
			paymentObj['piId'] = "";
		}
		cursor_clear();
		if (CheckoutPayments.getPaymentsToDelete().length < 1) {
			cursor_clear();
			if(CheckoutPayments.getPaymentsToAdd().length > 0){
				CheckoutPayments.addPaymentInstructions();
			}else if(CheckoutPayments.getPaymentsToUpdate().length > 0){
				CheckoutPayments.updatePaymentInstructions();
			}else{
				if(!submitRequest()){
					return;
				}   		
				cursor_wait();
				CheckoutPayments.setCommonParameters(SBServicesDeclarationJS.langId,SBServicesDeclarationJS.storeId,SBServicesDeclarationJS.catalogId);
				CheckoutPayments.showSummaryPage();
				cursor_clear();
			}
		} else {
			CheckoutPayments.deletePaymentInstructions();
		}
	}
	
	/**
	 * Resets the array object that contains existing payment objects to delete.
	 * Displays the error message returned with the service response and hides the progress bar.
	 * @param (object) serviceResponse The service response object, which is the JSON object returned by the service invocation.
	 */
	,failureHandler: function(serviceResponse) {
		CheckoutPayments.paymentsToDelete = new Array();
		if (serviceResponse.errorMessage) {
			MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
		} else {
			if (serviceResponse.errorMessageKey) {
				MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
			}
		}
		cursor_clear();
	}

}),


/**
* Declares an AJAX service that adds a payment instruction to the current order.
* @constructor
*/
wcService.declare({
	id: "AjaxAddPaymentInstructionToThisOrder",
	actionId: "AjaxAddPaymentInstructionToThisOrder",
	url: "AjaxRESTOrderPIAdd",
	formId: ""
	
	/**
	 * Resets the array object that contains payment objects to add. Verifies if there is any payment instruction that needs to be updated.
	 * If there is no payment instruction that needs to be updated, direct the browser to the order summary page.
	 * @param (object) serviceResponse The service response object, which is the JSON object returned by the service invocation.
	 */
	,successHandler: function(serviceResponse) {
		cursor_clear();
		if (CheckoutPayments.getPaymentsToAdd().length < 1) {
			if(CheckoutPayments.getPaymentsToUpdate().length > 0){
				CheckoutPayments.updatePaymentInstructions();
			}else{
				if(!submitRequest()){
					return;
				}   		
				cursor_wait();			
				CheckoutPayments.setCommonParameters(SBServicesDeclarationJS.langId,SBServicesDeclarationJS.storeId,SBServicesDeclarationJS.catalogId);
				CheckoutPayments.showSummaryPage();
				cursor_clear();
			}
		} else {
			CheckoutPayments.addPaymentInstructions();
		}
	}
	
	/**
	 * Resets the array object that contains existing payment objects to add.
	 * Displays the error message returned with the service response and hides the progress bar.
	 * @param (object) serviceResponse The service response object, which is the JSON object returned by the service invocation.
	 */
	,failureHandler: function(serviceResponse) {
		CheckoutPayments.paymentsToAdd = new Array();
		if (serviceResponse.errorMessage) {
			MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
		} else {
			if (serviceResponse.errorMessageKey) {
				MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
			}
		}
		cursor_clear();
		//Payment type promotion: If add payment object failed, then if the number of payment methods is 1, call the service to associate an unbounded payment method with the order.
		if(supportPaymentTypePromotions && CheckoutPayments.numberOfPaymentMethods == 1){
			CheckoutPayments.addNewUnboundPaymentInstruction();
        }
	}

}),

/**
* Declares an AJAX service that updates payment instructions in the current order.
* @constructor
*/
wcService.declare({
	id: "AjaxUpdatePaymentInstructionInThisOrder",
	actionId: "AjaxUpdatePaymentInstructionInThisOrder",
	url: "AjaxRESTOrderPIUpdate",
	formId: ""
	
	/**
	 * Clears the progress bar, verifies if there is any more payment instruction that needs to be updated.
	 * If there is no more payment instruction that needs to be updated, direct the browser to the order summary page.
	 * @param (object) serviceResponse The service response object, which is the JSON object returned by the service invocation.
	 */
	,successHandler: function(serviceResponse) {
		cursor_clear();
		if(CheckoutPayments.getPaymentsToUpdate().length < 1){
			if(!submitRequest()){
				return;
			}   		
			cursor_wait();
			
			CheckoutPayments.setCommonParameters(SBServicesDeclarationJS.langId,SBServicesDeclarationJS.storeId,SBServicesDeclarationJS.catalogId);
			CheckoutPayments.showSummaryPage();
			cursor_clear();
		}else{
			CheckoutPayments.updatePaymentInstructions();
		}
	}
	
	/**
	 * Resets the array object that contains existing payment objects to update.
	 * Displays the error message returned with the service response and hides the progress bar.
	 * @param (object) serviceResponse The service response object, which is the JSON object returned by the service invocation.
	 */
	,failureHandler: function(serviceResponse) {
		CheckoutPayments.paymentsToUpdate = new Array();
		if (serviceResponse.errorMessage) {
			MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
		} else {
			if (serviceResponse.errorMessageKey) {
				MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
			}
		}
		cursor_clear();
	}
}),	 

/**
 * Payment type promotion - START
 */
 
/**
* Declares an AJAX service that adds an unbounded payment instruction to the current order.
* @constructor
*/
wcService.declare({
	id: "AjaxAddUnboundPaymentInstructionToThisOrder",
	actionId: "AjaxAddUnboundPaymentInstructionToThisOrder",
	url: "AjaxRESTOrderPIAdd",
	formId: ""
	
	/**
	 * Sets the piId of payment object 1 to the returned piId from the service
	 * call and updates its action to re-add, so that its correctly handled by
	 * the client logic of associating actions to payment objects. Invokes the
	 * AjaxPrepareOrderForPaymentSubmit service to prepare order information.
	 * 
	 * @param (object)
	 *            serviceResponse The service response object, which is the JSON
	 *            object returned by the service invocation.
	 */
	 ,successHandler: function(serviceResponse) { 
		cursor_clear();
		
		CheckoutPayments.setPaymentFormPiId(1, serviceResponse.paymentInstruction[0].piId);		 
		CheckoutPayments.paymentObjects[1]['piId'] = serviceResponse.paymentInstruction[0].piId;
		CheckoutPayments.paymentObjects[1]['action'] = 're-add'; 
		 
		var params = [];
		params.orderId = serviceResponse.orderId;
		params["storeId"] = CheckoutHelperJS.storeId;
		params["catalogId"] = CheckoutHelperJS.catalogId;
		params["langId"] = CheckoutHelperJS.langId;
		cursor_wait();
		wcService.invoke("AjaxPrepareOrderForPaymentSubmit", params);		 
 	 }
	/**
	 * Displays the error message returned with the service response and hides the progress bar.
	 * @param (object) serviceResponse The service response object, which is the JSON object returned by the service invocation.
	 */
	,failureHandler: function(serviceResponse) {		
		if (serviceResponse.errorMessage) {
			MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
		} else {
			if (serviceResponse.errorMessageKey) {
				MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
			}
		}
		cursor_clear();
	}	
}),
 	 
/**
* Declares an AJAX service that deletes an unbounded payment instruction from the current order.
* @constructor
*/
wcService.declare({
	id: "AjaxDeleteUnboundPaymentInstructionFromThisOrder",
	actionId: "AjaxDeleteUnboundPaymentInstructionFromThisOrder",
	url: "AjaxRESTOrderPIDelete",
	formId: ""
	
	/**
	 * The piId of all payment objects is set to empty string, the
	 * action is set to 'add' or empty string depends on whether the 
	 * payment object is in the scope of <code>numberOfPaymentMethods</code>,
	 * so that they are correctly handled by the client logic of associating 
	 * actions to payment objects. Invokes addNewUnboundPaymentInstruction
	 * if isSinglePaymentType return true. Else, it
	 * calls the AjaxPrepareOrderForPaymentSubmit service to prepare order
	 * information.
	 * 
	 * @param (object)
	 *            serviceResponse The service response object, which is the JSON
	 *            object returned by the service invocation.
	 */
	,successHandler: function(serviceResponse) {
		cursor_clear();	
		for(var i = 1; i < CheckoutPayments.paymentObjects.length; i++){
			// In order for adding new dummy instruction to calculate payment type promotion, 
			// all payment instructions (dummy or non-dummy) were deleted at this point.
			//
			// We also need to clear the card number (the number are shown in: ******1111), 
			// since the corresponding non-dummy instruction for paymentObjects[i]['piId'] is deleted.
			if($("#account1_" + i).length ){
				CheckoutPayments.removeCreditCardNumberAndCVV(i, true, true);
				CheckoutHelperJS.paymentDataDirty(i, true);
			}
			CheckoutPayments.setPaymentFormPiId(i,'');
			CheckoutPayments.paymentObjects[i]['piId'] = '';
			if (i > CheckoutPayments.numberOfPaymentMethods){
				CheckoutPayments.paymentObjects[i]['action'] = ''; 
			} else {
				CheckoutPayments.paymentObjects[i]['action'] = 'add'; 
			}
		}
		if(CheckoutPayments.isSinglePaymentType()){
			//Add new unbound instruction if is single payment type
			CheckoutPayments.addNewUnboundPaymentInstruction();
		} else {
			 var params = [];
			 params.orderId = serviceResponse.orderId;
			 params["storeId"] = CheckoutHelperJS.storeId;
			 params["catalogId"] = CheckoutHelperJS.catalogId;
			 params["langId"] = CheckoutHelperJS.langId;
			 cursor_wait();
			 wcService.invoke("AjaxPrepareOrderForPaymentSubmit", params);	
		}	
	}		
	/**
	 * Displays the error message returned with the service response and hides the progress bar.
	 * @param (object) serviceResponse The service response object, which is the JSON object returned by the service invocation.
	 */
	,failureHandler: function(serviceResponse) {		
		if (serviceResponse.errorMessage) {
			MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
		} else {
			if (serviceResponse.errorMessageKey) {
				MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
			}
		}
		cursor_clear();
	}
}),

/**
* Declares an AJAX service that prepares order information before submitting the order.
* @constructor
*/
wcService.declare({
	id: "AjaxPrepareOrderForPaymentSubmit",
	actionId: "AjaxPrepareOrderForPaymentSubmit",
	url: "AjaxRESTOrderPrepare",
	formId: ""
	
	/**
	 * If required, sets payment objects 2 and above to null. Triggers the
	 * calculation of order total and payment amounts.
	 * 
	 * @param (object)
	 *            serviceResponse The service response object, which is the JSON
	 *            object returned by the service invocation.
	 */
	,successHandler: function(serviceResponse) {
		cursor_clear();
		
		/**
		 * We want to update the total and load the payment snippets
		 */
		CheckoutPayments.getTotalInJSON("loadPaymentSnippet", "PaymentForm", true);		
	}
	
	/**
	 * Displays the error message returned with the service response and hides the progress bar.
	 * @param (object) serviceResponse The service response object, which is the JSON object returned by the service invocation.
	 */
	,failureHandler: function(serviceResponse) {
		if (serviceResponse.errorMessage) {
			MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
		} else {
			if (serviceResponse.errorMessageKey) {
				MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
			}
		}
		cursor_clear();
	}
})
//-----------------------------------------------------------------
// Licensed Materials - Property of IBM
//
// WebSphere Commerce
//
// (C) Copyright IBM Corp. 2013, 2014 All Rights Reserved.
//
// US Government Users Restricted Rights - Use, duplication or
// disclosure restricted by GSA ADP Schedule Contract with
// IBM Corp.
//-----------------------------------------------------------------

if (flowEnabled.SideBySideIntegration) {

	CallCenterIntegrationJS = function() {
		this.lookUpMode = 'lookup';
		this.normalMode = 'normal';

		this.setUpCookies = function(cookieValue){
			var cookieName = "WCC_Mode_"+WCParamJS.storeId;
			// Add new cookie.
			if(cookieValue != undefined && cookieValue != null) {
				if(cookieValue.length > 0){
					setCookie("WCC_Mode_"+WCParamJS.storeId, escapeXml(cookieValue, true), {path:'/', domain:cookieDomain});
				} else {
					//Empty value passed for wccModeCookie. Delete it.
					removeCookie(cookieName);
				}
			}
		};
		
		this.updateWCParamJS = function(key, value){
			WCParamJS[key] = value;
		};
		
		this.consumeAddToCartEvent = function(params, customParams){
			var wccModeCookie = getCookie("WCC_Mode_"+WCParamJS.storeId);
			if(wccModeCookie == this.lookUpMode) {
				params.action = "Sending_Product";
				$.extend( params, customParams );
				params = JSON.stringify(params);
				console.debug(params);
				window.parent.postMessage(params, WCParamJS.wcc_integration_origin);
				return true;
			} else {
				return false;
			}
		};
		
		this.postActionMessage = function(params,actionName){
			var wccModeCookie = getCookie("WCC_Mode_"+WCParamJS.storeId);
			if(wccModeCookie == this.lookUpMode || wccModeCookie == this.normalMode) {
				params.action = actionName;
				params = JSON.stringify(params);
				window.parent.postMessage(params, WCParamJS.wcc_integration_origin);
				return true;
			} 
		};
		
		window.addEventListener("message", function(event) {
			if (event.origin != WCParamJS.wcc_integration_origin) {
				console.warn("Unexpected WCC Integration server - " + event.origin);
				return;
			}
			try {
				console.debug(event.data);
				var data = JSON.parse(event.data);
				if (data.action && data.action === "Requesting_Cart_Details") {
					var orderIdCookie = getCookie("WC_CartOrderId_"+WCParamJS.storeId);
					var params = {};
					params.storeId = WCParamJS.storeId;
					params.action = 'Sending_Cart';
					params.custId = WCParamJS.logonId;
					params.orderId = orderIdCookie;
					event.source.postMessage(JSON.stringify(params), event.origin);
				} else if (data.action && data.action === "ADD_TO_EXTERNAL_CART_SUCCESS") {
						cursor_clear();
				} else if(data.action && data.action === "TERMINATE_ON_BEHALF_SESSION"){
					if(typeof GlobalLoginShopOnBehalfJS != 'undefined' && GlobalLoginShopOnBehalfJS != undefined && GlobalLoginShopOnBehalfJS != null){
						GlobalLoginShopOnBehalfJS.restoreCSRSessionAndRedirect(data.redirectURL);
					}
				} else if(data.action && data.action === "SET_USER_IN_SESSION"){
					if(typeof registeredCustomersJS != 'undefined' && registeredCustomersJS != undefined && registeredCustomersJS != null){
						registeredCustomersJS.setUserInSession(data.userId, data.userName, data.redirectURL);
					}
				}
				
			} catch (e) {
				// Likely invalid message.  Ignore or handle other messages here.
				console.warn("Unexpected message: " + event.data); 
			}					
		});				
	};

	$(document).ready(function(){		
		callCenterIntegrationJS = new CallCenterIntegrationJS();
	});

}

//-----------------------------------------------------------------
// Licensed Materials - Property of IBM
//
// WebSphere Commerce
//
// (C) Copyright IBM Corp. 2011, 2016 All Rights Reserved.
//
// US Government Users Restricted Rights - Use, duplication or
// disclosure restricted by GSA ADP Schedule Contract with
// IBM Corp.
//-----------------------------------------------------------------

shoppingActionsJS = {

    /** The language ID currently in use **/
    langId: "-1",

    /** The store ID currently in use **/
    storeId: "",

    /** The catalog ID currently in use **/
    catalogId: "",

    /** Holds the current user type such as guest or registered user. Allowed values are 'G' for guest and 'R' for registered.**/
    userType: "",

    /** A boolean used in a variety of the add to cart methods to tell whether or not the base item was added to the cart. **/
    baseItemAddedToCart: false,

    /** An array of entitled items which is used in various methods throughout ShoppingActions.js **/
    entitledItems: [],

    /** a JSON object that holds attributes of an entitled item **/
    entitledItemJsonObject: null,

    /** A map of attribute name value pairs for the currently selected attribute values **/
    selectedAttributesList: {},

    /** A variable used to form the url dynamically for the more info link in the Quickinfo popup */
    moreInfoUrl: "",

    /**
     * A boolean used to to determine is it from a Qick info popup or not. 
     **/
    isPopup: false,

    /**
     * A boolean used to to determine whether or not to diplay the price range when the catEntry is selected. 
     **/
    displayPriceRange: true,

    /**
     * This array holds the json object retured from the service, holding the price information of the catEntry.
     **/
    itemPriceJsonOject: [],

    /** 
     * stores all name and value of all swatches 
     * this is a 2 dimension array and each record i contains the following information:
     * allSwatchesArray[i][0] - attribute name of the swatch
     * allSwatchesArray[i][1] - attribute value of the swatch
     * allSwatchesArray[i][2] - image1 of swatch (image to use for enabled state)
     * allSwatchesArray[i][3] - image2 of swatch (image to use for disabled state)
     * allSwatchesArray[i][4] - onclick action of the swatch when enabled
     **/
    allSwatchesArrayList: {},

    /**
     * Holds the ID of the image used for swatch
     **/
    skuImageId: "",

    /**
     * The prefix of the cookie key that is used to store item Ids. 
     */
    cookieKeyPrefix: "CompareItems_",

    /**
     * The delimiter used to separate item Ids in the cookie.
     */
    cookieDelimiter: ";",

    /**
     * The maximum number of items allowed in the compare zone. 
     */
    maxNumberProductsAllowedToCompare: 4,

    /**
     * The minimum number of items allowed in the compare zone. 
     */
    minNumberProductsAllowedToCompare: 2,

    /**
     * Id of the base catalog entry. 
     */
    baseCatalogEntryId: 0,

    /**
     * An map which holds the attributes of a set of products
     */
    selectedProducts: {},

    /**
     * An array to keep the quantity of the products in a list (bundle)
     */
    productList: {},

    /**
     * stores the currency symbol
     */
    currencySymbol: "",

    /**
     * stores the compare return page name
     */
    compareReturnName: "",
    /**
     * stores the search term
     */
    searchTerm: "",

    search01: "'",

    search02: '"',

    replaceStr01: /\\\'/g,

    replaceStr02: /\\\"/g,

    ampersandChar: /&/g,

    ampersandEntityName: "&amp;",

    /**
     * An array to keep the details of the newly added products.
     */
    productAddedList: {},

    setCompareReturnName: function (compareReturnName) {
        this.compareReturnName = compareReturnName;
    },

    setSearchTerm: function (searchTerm) {
        this.searchTerm = searchTerm;
    },

    setCommonParameters: function (langId, storeId, catalogId, userType, currencySymbol) {
        this.langId = langId;
        this.storeId = storeId;
        this.catalogId = catalogId;
        this.userType = userType;
        this.currencySymbol = currencySymbol;
    },

    setEntitledItems: function (entitledItemArray) {
        this.entitledItems = entitledItemArray;
    },

    getCatalogEntryId: function (entitledItemId) {
        var attributeArray = [];
        var selectedAttributes = this.selectedAttributesList[entitledItemId];
        for (attribute in selectedAttributes) {
            attributeArray.push(attribute + "_|_" + selectedAttributes[attribute]);
        }
        return this.resolveSKU(attributeArray);
    },

    /**
     * getCatalogEntryIdforProduct Returns the catalog entry ID for a catalog entry that has the same attribute values as a specified product's selected attributes as passed in via the selectedAttributes parameter.
     *
     * @param {String[]} selectedAttributes The array of selected attributes upon which to resolve the SKU.
     *
     * @return {String} catalog entry ID of the SKU.
     *
     **/
    getCatalogEntryIdforProduct: function (selectedAttributes) {
        var attributeArray = [];
        for (attribute in selectedAttributes) {
            attributeArray.push(attribute + "_|_" + selectedAttributes[attribute]);
        }
        return this.resolveSKU(attributeArray);
    },

    /**
     * retrieves the entitledItemJsonObject
     */
    getEntitledItemJsonObject: function () {
        return this.entitledItemJsonObject;
    },

    /**
     * resolveSKU Resolves a SKU using an array of defining attributes.
     *
     * @param {String[]} attributeArray An array of defining attributes upon which to resolve a SKU.
     *
     * @return {String} catentry_id The catalog entry ID of the SKU.
     *
     **/
    resolveSKU: function (attributeArray) {

        console.debug("Resolving SKU >> " + attributeArray + ">>" + this.entitledItems);
        var catentry_id = "";
        var attributeArrayCount = attributeArray.length;

        // if there is only one item, no need to check the attributes to resolve the sku
        if (this.entitledItems.length == 1) {
            return this.entitledItems[0].catentry_id;
        }
        for (x in this.entitledItems) {
            var catentry_id = this.entitledItems[x].catentry_id;
            var Attributes = this.entitledItems[x].Attributes;
            var attributeCount = 0;
            for (index in Attributes) {
                attributeCount++;
            }

            // Handle special case where a catalog entry has one sku with no attributes
            if (attributeArrayCount == 0 && attributeCount == 0) {
                return catentry_id;
            }
            if (attributeCount != 0 && attributeArrayCount >= attributeCount) {
                var matchedAttributeCount = 0;

                for (attributeName in attributeArray) {
                    var attributeValue = attributeArray[attributeName];
                    var attributeValue2 = attributeValue.replace(this.search02, this.search01);
                    if (attributeValue in Attributes || attributeValue2 in Attributes) {
                        matchedAttributeCount++;
                    }
                }

                if (attributeCount == matchedAttributeCount) {
                    console.debug("CatEntryId:" + catentry_id + " for Attribute: " + attributeArray);
                    this.disableBuyButtonforUnbuyable(x);
                    return catentry_id;
                }
            }
        }
        return null;
    },

    /**
     * setSelectedAttribute Sets the selected attribute value for a particular attribute not in reference to any catalog entry.
     *					   One place this function is used is on CachedProductOnlyDisplay.jsp where there is a drop down box of attributes.
     *					   When an attribute is selected from that drop down this method is called to update the selected value for that attribute.
     *
     * @param {String} selectedAttributeName The name of the attribute.
     * @param {String} selectedAttributeValue The value of the selected attribute.
     * @param {String} entitledItemId The element id where the json object of the sku is stored
     * @param {String} skuImageId This is optional. The element id of the product image - image element id is different in product page and category list view. Product page need not pass it because it is set separately
     * @param {String} imageField This is optional. The json field from which image should be picked. Pass value if a different size image need to be picked
     *
     **/
    setSelectedAttribute: function (selectedAttributeName, selectedAttributeValue, entitledItemId, skuImageId, imageField) {
        console.debug(selectedAttributeName + " : " + selectedAttributeValue);
        var selectedAttributes = this.selectedAttributesList[entitledItemId];
        if (selectedAttributes == null) {
            selectedAttributes = {};
        }
        selectedAttributeValue = selectedAttributeValue.replace(this.replaceStr01, this.search01);
        selectedAttributeValue = selectedAttributeValue.replace(this.replaceStr02, this.search02);
        selectedAttributeValue = selectedAttributeValue.replace(this.ampersandChar, this.ampersandEntityName);
        selectedAttributes[selectedAttributeName] = selectedAttributeValue;
        this.moreInfoUrl = this.moreInfoUrl + '&' + selectedAttributeName + '=' + selectedAttributeValue;
        this.selectedAttributesList[entitledItemId] = selectedAttributes;
        this.changeProdImage(entitledItemId, selectedAttributeName, selectedAttributeValue, skuImageId, imageField);
    },

    /**
     * setSelectedAttributeOfProduct Sets the selected attribute value for an attribute of a specified product.
     *								This function is used to set the assigned value of defining attributes to specific 
     *								products which will be stored in the selectedProducts map.
     *
     * @param {String} productId The catalog entry ID of the catalog entry to use.
     * @param {String} selectedAttributeName The name of the attribute.
     * @param {String} selectedAttributeValue The value of the selected attribute.
     * @param {boolean} true, if it is single SKU
     *
     **/
    setSelectedAttributeOfProduct: function (productId, selectedAttributeName, selectedAttributeValue, isSingleSKU) {

        var selectedAttributesForProduct = null;

        if (this.selectedProducts[productId]) {
            selectedAttributesForProduct = this.selectedProducts[productId];
        } else {
            selectedAttributesForProduct = {};
        }

        // add only if attribute has some name. value can be empty
        if (null != selectedAttributeName && '' != selectedAttributeName) {
            selectedAttributesForProduct[selectedAttributeName] = selectedAttributeValue;
        }
        this.selectedProducts[productId] = selectedAttributesForProduct;

        //the json object for entitled items are already in the HTML. 
        var entitledItemJSON = eval('(' + $("#entitledItem_" + productId).html() + ')');

        this.setEntitledItems(entitledItemJSON);

        var catalogEntryId = this.getCatalogEntryIdforProduct(selectedAttributesForProduct);

        if (catalogEntryId == null) {
            catalogEntryId = 0;
        } else {
            // pass true to display price range
            this.changePrice("entitledItem_" + productId, false, true, productId);

            //Update selected sku in merchandising association array
            if (typeof MerchandisingAssociationJS != 'undefined') {
                if (MerchandisingAssociationJS.baseItemParams != null) {
                    if (MerchandisingAssociationJS.baseItemParams.type == 'BundleBean') {
                        // Update items in the bundle
                        for (idx = 0; idx < MerchandisingAssociationJS.baseItemParams.components.length; idx++) {
                            if (productId == MerchandisingAssociationJS.baseItemParams.components[idx].productId) {
                                MerchandisingAssociationJS.baseItemParams.components[idx].id = catalogEntryId;
                            }
                        }
                    }
                }
            }
        }
        var productDetails = null;
        if (this.productList[productId]) {
            productDetails = this.productList[productId];
        } else {
            productDetails = {};
            this.productList[productId] = productDetails;
            productDetails.baseItemId = productId;
        }

        productDetails.id = catalogEntryId;
        if (productDetails.quantity) {
            wcTopic.publish("Quantity_Changed", JSON.stringify(productDetails));
        }

        if (!isSingleSKU) {
            // publish the attribute change event
            if (catalogEntryId != 0) {
                wcTopic.publish('DefiningAttributes_Resolved_' + productId, catalogEntryId, productId);
            } else {
                wcTopic.publish('DefiningAttributes_Changed_' + productId, catalogEntryId, productId);
            }
        }
    },

    /**
     * Add2ShopCartAjax This function is used to add a catalog entry to the shopping cart using an AJAX call. This will resolve the catentryId using entitledItemId and adds the item to the cart.
     *				This function will resolve the SKU based on the entitledItemId passed in and call {@link this.AddItem2ShopCartAjax}.
     * @param {String} entitledItemId A DIV containing a JSON object which holds information about a catalog entry. You can reference CachedProductOnlyDisplay.jsp to see how that div is constructed.
     * @param {int} quantity The quantity of the item to add to the cart.
     * @param {String} isPopup If the value is true, then this implies that the function was called from a quick info pop-up. 	
     * @param {Object} customParams - Any additional parameters that needs to be passed during service invocation.
     *
     **/
    Add2ShopCartAjax: function (entitledItemId, quantity, isPopup, customParams) {
        var dialog = $('#quick_cart_container').data("wc-WCDialog");
        if (dialog) {
            dialog.close();
        }
        if (browseOnly) {
            MessageHelper.displayErrorMessage(Utils.getLocalizationMessage('ERROR_ADD2CART_BROWSE_ONLY'));
            return;
        }
        var entitledItemJSON;

        if ($("#" + entitledItemId).length) {
            //the json object for entitled items are already in the HTML. 
            entitledItemJSON = eval('(' + $("#" + entitledItemId).html() + ')');
        } else {
            //if $("#" +entitledItemId).length is 0, that means there's no <div> in the HTML that contains the JSON object. 
            //in this case, it must have been set in catalogentryThumbnailDisplay.js when the quick info
            entitledItemJSON = this.getEntitledItemJsonObject();
        }

        this.setEntitledItems(entitledItemJSON);
        var catalogEntryId = this.getCatalogEntryId(entitledItemId);

        if (catalogEntryId != null) {
            var productId = entitledItemId.substring(entitledItemId.indexOf("_") + 1);
            this.AddItem2ShopCartAjax(catalogEntryId, quantity, customParams, productId);
            this.baseItemAddedToCart = true;
        } else if (isPopup == true) {
            $('#second_level_category_popup').css("zIndex", '1');
            MessageHelper.formErrorHandleClient('addToCartLinkAjax', Utils.getLocalizationMessage('ERR_RESOLVING_SKU'));
        } else {
            MessageHelper.displayErrorMessage(Utils.getLocalizationMessage('ERR_RESOLVING_SKU'));
            this.baseItemAddedToCart = false;
        }
    },

    AddItem2ShopCartAjax: function (catEntryIdentifier, quantity, customParams, productId) {
        if (browseOnly) {
            MessageHelper.displayErrorMessage(Utils.getLocalizationMessage('ERROR_ADD2CART_BROWSE_ONLY'));
            return;
        }
        var params = {storeId: this.storeId,
catalogId: this.catalogId,
langId: this.langId,
orderId: "."};
        // Remove calculations for performance
        // params.calculationUsage = "-1,-2,-5,-6,-7";
        params.inventoryValidation = "true";
        params.calculateOrder = "0";
        var ajaxShopCartService = "AddOrderItem";

        this.productAddedList = {};
        if (Array.isArray(catEntryIdentifier) && Array.isArray(quantity)) {
            for (var i = 0; i < catEntryIdentifier.length; i++) {
                if (!isPositiveInteger(quantity[i])) {
                    MessageHelper.displayErrorMessage(Utils.getLocalizationMessage('QUANTITY_INPUT_ERROR'));
                    return;
                }
                params["catEntryId_" + (i + 1)] = catEntryIdentifier[i];
                params["quantity_" + (i + 1)] = quantity[i];
            }
        } else {
            if (!isPositiveInteger(quantity)) {
                MessageHelper.displayErrorMessage(Utils.getLocalizationMessage('QUANTITY_INPUT_ERROR'));
                return;
            }
            params.catEntryId = catEntryIdentifier;
            params.quantity = quantity;

            var selectedAttrList = {};
            for (attr in this.selectedAttributesList['entitledItem_' + productId]) {
                selectedAttrList[attr] = this.selectedAttributesList['entitledItem_' + productId][attr];
            }

            if (productId == undefined) {
                this.saveAddedProductInfo(quantity, catEntryIdentifier, catEntryIdentifier, selectedAttrList);
            } else {
                this.saveAddedProductInfo(quantity, productId, catEntryIdentifier, selectedAttrList);
            }
        }

        //Pass any other customParams set by other add on features
        if (customParams != null && customParams != 'undefined') {
            for (i in customParams) {
                params[i] = customParams[i];
            }
            if (customParams['catalogEntryType'] == 'dynamicKit') {
                ajaxShopCartService = "AddPreConfigurationToCart";
            }
        }

        var contractIdElements = document.getElementsByName('contractSelectForm_contractId');
        if (contractIdElements != null && contractIdElements != "undefined") {
            for (i = 0; i < contractIdElements.length; i++) {
                if (contractIdElements[i].checked) {
                    params.contractId = contractIdElements[i].value;
                    break;
                }
            }
        }

        //For Handling multiple clicks
        if (!submitRequest()) {
            return;
        }
        cursor_wait();

        wcService.invoke(ajaxShopCartService, params);
        this.baseItemAddedToCart = true;

        if (document.getElementById("headerShopCartLink") && document.getElementById("headerShopCartLink").style.display != "none") {
            $("#headerShopCart").focus();
        } else {
            $("#headerShopCart1").focus();
        }
    },

    /**
     * AddBundle2ShopCartAjax This function is used to add a bundle to the shopping cart.
     **/
    AddBundle2ShopCartAjax: function () {
        if (browseOnly) {
            MessageHelper.displayErrorMessage(Utils.getLocalizationMessage('ERROR_ADD2CART_BROWSE_ONLY'));
            return;
        }
        var ajaxShopCartService = "AddOrderItem";
        var params = {
            storeId: this.storeId,
            catalogId: this.catalogId,
            langId: this.langId,
            orderId: ".",
            inventoryValidation: "true",
            calculateOrder: "0"
        };
        // Remove calculations for performance
        // params.calculationUsage = "-1,-2,-5,-6,-7";
        
        var idx = 1;
        this.productAddedList = {};

        for (productId in this.productList) {
            var productDetails = this.productList[productId];
            var quantity = Utils.parseNumber(productDetails.quantity);

            if (quantity == 0) {
                continue;
            }
            if (productDetails.id == 0) {
                MessageHelper.displayErrorMessage(Utils.getLocalizationMessage('ERR_RESOLVING_SKU'));
                return;
            }
            if (isNaN(quantity) || quantity < 0) {
                MessageHelper.displayErrorMessage(Utils.getLocalizationMessage('QUANTITY_INPUT_ERROR'));
                return;
            }

            params["catEntryId_" + idx] = productDetails.id;
            params["quantity_" + idx++] = quantity;
            this.baseItemAddedToCart = true;

            this.saveAddedProductInfo(quantity, productId, productDetails.id, this.selectedProducts[productId]);
        }

        //For Handling multiple clicks
        if (!submitRequest()) {
            return;
        }
        cursor_wait();
        wcService.invoke(ajaxShopCartService, params);

    },

    resetProductAddedList: function () {
        shoppingActionsJS.productAddedList = {};
    },
    /**
     * Save the product information of the newly added product(s) to be used for the mini cart product added popup
     *
     * @param {String} quantity The quantity of the product being purchased.
     * @param {String} productId The id of the product.
     * @param {String} skuId The id of the sku.
     * @param {String} attrList The list of selected attributes for the product, if any.
     **/
    saveAddedProductInfo: function (quantity, productId, skuId, attrList) {

        var productName = "";
        if ($("#ProductInfoName_" + productId).length) {
            productName = document.getElementById("ProductInfoName_" + productId).value;
        } else if ($("#ProductInfoName_" + skuId).length) {
            productName = document.getElementById("ProductInfoName_" + skuId).value;
        }

        var productThumbnail = "";
        if ($("#ProductInfoImage_" + productId).length) {
            productThumbnail = document.getElementById("ProductInfoImage_" + productId).value;
        } else if ($("#ProductInfoImage_" + skuId).length) {
            productThumbnail = document.getElementById("ProductInfoImage_" + skuId).value;
        }

        var productPrice = "";
        if ($("#ProductInfoPrice_" + productId).length) {
            productPrice = document.getElementById('ProductInfoPrice_' + productId).value;
        } else if ($("#ProductInfoPrice_" + skuId).length) {
            productPrice = document.getElementById('ProductInfoPrice_' + skuId).value;
        }

        var productAdded = [productName, productThumbnail, productPrice, quantity, attrList];
        if (productId != skuId) {
            this.productAddedList[skuId] = productAdded;
        } else {
            this.productAddedList[productId] = productAdded;
        }

        wcTopic.publish("ProductInfo_Added", this.productAddedList);
    },

    /* SwatchCode start */

    /**
     *setSKUImageId Sets the ID of the image to use for swatch.
     **/
    setSKUImageId: function (skuImageId) {
        this.skuImageId = skuImageId;
    },

    /**
     * getImageForSKU Returns the full image of the catalog entry with the selected attributes as specified in the {@link this.selectedAttributes} value.
     *					This method uses resolveImageForSKU to find the SKU image with the selected attributes values.
     *
     * @param {String} imageField, the field name from which the image should be picked
     * @return {String} path to the SKU image.
     * 
     *
     **/
    getImageForSKU: function (entitledItemId, imageField) {
        var attributeArray = [];
        var selectedAttributes = this.selectedAttributesList[entitledItemId];
        for (attribute in selectedAttributes) {
            attributeArray.push(attribute + "_|_" + selectedAttributes[attribute]);
        }
        return this.resolveImageForSKU(attributeArray, imageField);
    },

    /**
     * resolveImageForSKU Resolves image of a SKU using an array of defining attributes.
     *
     * @param {String[]} attributeArray An array of defining attributes upon which to resolve a SKU.
     * @param {String} imageField, the field name from which the image should be picked
     *
     * @return {String} imagePath The location of SKU image.
     *
     **/
    resolveImageForSKU: function (attributeArray, imageField) {

        console.debug("Resolving SKU >> " + attributeArray + ">>" + this.entitledItems);
        var imagePath = "";
        var attributeArrayCount = attributeArray.length;

        for (x in this.entitledItems) {
            if (null != imageField) {
                var imagePath = this.entitledItems[x][imageField];
            } else {
                var imagePath = this.entitledItems[x].ItemImage467;
            }

            var Attributes = this.entitledItems[x].Attributes;
            var attributeCount = 0;
            for (index in Attributes) {
                attributeCount++;
            }

            // Handle special case where a catalog entry has one sku with no attributes
            if (attributeArrayCount == 0 && attributeCount == 0) {
                return imagePath;
            }
            if (attributeCount != 0 && attributeArrayCount >= attributeCount) {
                var matchedAttributeCount = 0;

                for (attributeName in attributeArray) {
                    var attributeValue = attributeArray[attributeName];
                    if (attributeValue in Attributes) {
                        matchedAttributeCount++;
                    }
                }

                if (attributeCount == matchedAttributeCount) {
                    console.debug("ItemImage:" + imagePath + " for Attribute: " + attributeArray);
                    this.disableBuyButtonforUnbuyable(x);
                    var imageArray = [];
                    imageArray.push(imagePath);
                    imageArray.push(this.entitledItems[x].ItemThumbnailImage);
                    if (this.entitledItems[x].ItemAngleThumbnail != null && this.entitledItems[x].ItemAngleThumbnail != undefined) {
                        imageArray.push(this.entitledItems[x].ItemAngleThumbnail);
                        imageArray.push(this.entitledItems[x].ItemAngleFullImage);
                    }
                    return imageArray;
                }
            }
        }
        return null;
    },

    disableBuyButtonforUnbuyable: function (entitledItemIndex) {
        var buyableFlag = this.entitledItems[entitledItemIndex].buyable;
        //				disable the add to cart button
        var btn = document.getElementById("listViewAdd2Cart_" + this.entitledItems[entitledItemIndex].productId);
        if (buyableFlag != null && btn != null) {
            if (buyableFlag == 'false') {
                btn.className += " add2CartButtonDisabled";
            } else {
                btn.className = btn.className.replace(" add2CartButtonDisabled", "");
            }
        }
    },

    /**
     * changeViewImages Updates the angle views of the SKU.
     *
     * @param {String[]} itemAngleThumbnail An array of SKU view thumbnails.
     * @param {String[]} itemAngleFullImage An array of SKU view full images.
     **/
    changeViewImages: function (itemAngleThumbnail, itemAngleFullImage) {
        var imageCount = 0;
        for (x in itemAngleThumbnail) {
            var prodAngleCount = imageCount;
            imageCount++;
            $("#WC_CachedProductOnlyDisplay_images_1_" + imageCount).attr('src', itemAngleThumbnail[x]);
            if ($("#WC_CachedProductOnlyDisplay_links_1_" + imageCount).length) {
                $("#WC_CachedProductOnlyDisplay_links_1_" + imageCount).attr('href',
                    "JavaScript:changeThumbNail('productAngleLi" + prodAngleCount + "','" + itemAngleFullImage[x] + "');");
            }

            if ($("#productAngleLi" + prodAngleCount).length && $("#productAngleLi" + prodAngleCount).attr('className') === ('selected')) {
                changeThumbNail("productAngleLi" + prodAngleCount, itemAngleFullImage[x]);
            }
        }
    },


    /**
     * updates the product image from the PDP page to use the selected SKU image
     * @param String swatchAttrName the newly selection attribute name
     * @param String swatchAttrValue the newly selection attribute value
     * @param {String} imageField, the field name from which the image should be picked
     **/
    changeProdImage: function (entitledItemId, swatchAttrName, swatchAttrValue, skuImageId, imageField) {
        if ($("#" + entitledItemId).length) {
            //the json object for entitled items are already in the HTML. 
            entitledItemJSON = eval('(' + $("#" + entitledItemId).html() + ')');
        }

        this.setEntitledItems(entitledItemJSON);
        var productId = entitledItemId.substring(entitledItemId.indexOf("_") + 1);

        var skuImage = null;
        var imageArr = shoppingActionsJS.getImageForSKU(entitledItemId, imageField);
        if (imageArr != null) {
            skuImage = imageArr[0];
        }

        if (skuImageId != undefined) {
            this.setSKUImageId(skuImageId);
        }

        if (skuImage != null) {
            if ($("#" + this.skuImageId).length) {
                document.getElementById(this.skuImageId).src = skuImage;
                if ($("#ProductInfoImage_" + productId).length) {
                    document.getElementById("ProductInfoImage_" + productId).value = skuImage;
                }

                var itemAngleThumbnail = imageArr[2];
                var itemAngleFullImage = imageArr[3];
                if (itemAngleThumbnail != null && itemAngleThumbnail != undefined) {
                    shoppingActionsJS.changeViewImages(itemAngleThumbnail, itemAngleFullImage);
                }
            }
        } else {
            var imageFound = false;
            for (x in this.entitledItems) {
                var Attributes = this.entitledItems[x].Attributes;
                if (null != imageField) {
                    var itemImage = this.entitledItems[x][imageField];
                } else {
                    var itemImage = this.entitledItems[x].ItemImage467;
                }


                var itemAngleThumbnail = this.entitledItems[x].ItemAngleThumbnail;
                var itemAngleFullImage = this.entitledItems[x].ItemAngleFullImage;

                for (y in Attributes) {
                    var index = y.indexOf("_|_");
                    var entitledSwatchName = y.substring(0, index);
                    var entitledSwatchValue = y.substring(index + 3);

                    if (entitledSwatchName == swatchAttrName && entitledSwatchValue == swatchAttrValue) {
                        // set sku image only if the img element is present
                        if ($("#" + this.skuImageId).length) {
                            $("#" + this.skuImageId).attr('src', itemImage);
                            if (document.getElementById("ProductInfoImage_" + productId) != null) {
                                document.getElementById("ProductInfoImage_" + productId).value = itemImage;
                            }
                        }
                        if (itemAngleThumbnail != null && itemAngleThumbnail != undefined) {
                            shoppingActionsJS.changeViewImages(itemAngleThumbnail, itemAngleFullImage);
                        }
                        imageFound = true;
                        break;
                    }
                }

                if (imageFound) {
                    break;
                }
            }
        }
    },

    /**
     * Updates the swatches selections on list view.
     * Sets up the swatches array and sku images, then selects a default swatch value.
     **/
    updateSwatchListView: function () {
        var swatchArray = $("a[id^='swatch_array_']");
        for (var i = 0; i < swatchArray.length; i++) {
            var swatchArrayElement = swatchArray[i];
            eval($(swatchArrayElement).attr("href"));
        }

        var swatchSkuImage = $("a[id^='swatch_setSkuImage_']");
        for (var i = 0; i < swatchSkuImage.length; i++) {
            var swatchSkuImageElement = swatchSkuImage[i];
            eval($(swatchSkuImageElement).attr("href"));
        }

        var swatchDefault = $("a[id^='swatch_selectDefault_']");
        for (var i = 0; i < swatchDefault.length; i++) {
            var swatchDefaultElement = swatchDefault[i];
            eval($(swatchDefaultElement).attr("href"));
        }
    },

    /**
     * Handles the case when a swatch is selected. Set the border of the selected swatch.
     * @param {String} selectedAttributeName The name of the selected swatch attribute.
     * @param {String} selectedAttributeValue The value of the selected swatch attribute.
     * @param {String} entitledItemId The ID of the SKU
     * @param {String} doNotDisable The name of the swatch attribute that should never be disabled.
     * @param {String} imageField, the field name from which the image should be picked
     * @return boolean Whether the swatch is available for selection
     **/
    selectSwatch: function (selectedAttributeName, selectedAttributeValue, entitledItemId, doNotDisable, selectedAttributeDisplayValue, skuImageId, imageField) {
        if ($("#swatch_" + entitledItemId + "_" + selectedAttributeValue).hasClass("color_swatch_disabled")) {
            return;
        }
        var selectedAttributes = this.selectedAttributesList[entitledItemId];
        for (attribute in selectedAttributes) {
            if (attribute == selectedAttributeName) {
                // case when the selected swatch is already selected with a value, if the value is different than
                // what's being selected, reset other swatches and deselect the previous value and update selection
                if (selectedAttributes[attribute] != selectedAttributeValue) {
                    // deselect previous value and update swatch selection
                    var swatchElement = document.getElementById("swatch_" + entitledItemId + "_" + selectedAttributes[attribute]);
                    swatchElement.className = "color_swatch";
                    swatchElement.src = swatchElement.src.replace("_disabled.png", "_enabled.png");

                    //change the title text of the swatch link
                    document.getElementById("swatch_link_" + entitledItemId + "_" + selectedAttributes[attribute]).title = swatchElement.alt;
                }
            }
            if (document.getElementById("swatch_link_" + entitledItemId + "_" + selectedAttributes[attribute]) != null) {
                document.getElementById("swatch_link_" + entitledItemId + "_" + selectedAttributes[attribute]).setAttribute("aria-checked", "false");
            }
        }
        this.makeSwatchSelection(selectedAttributeName, selectedAttributeValue, entitledItemId, doNotDisable, selectedAttributeDisplayValue, skuImageId, imageField);
    },

    /**
     * Make swatch selection - add to selectedAttribute, select image, and update other swatches and SKU image based on current selection.
     * @param {String} swatchAttrName The name of the selected swatch attribute.
     * @param {String} swatchAttrValue The value of the selected swatch attribute.
     * @param {String} entitledItemId The ID of the SKU.
     * @param {String} doNotDisable The name of the swatch attribute that should never be disabled.	
     * @param {String} skuImageId This is optional. The element id of the product image - image element id is different in product page and category list view. Product page need not pass it because it is set separately
     * @param {String} imageField This is optional. The json field from which image should be picked. Pass value if a different size image need to be picked
     **/
    makeSwatchSelection: function (swatchAttrName, swatchAttrValue, entitledItemId, doNotDisable, selectedAttributeDisplayValue, skuImageId, imageField) {
        // setSelectedAttribute internally calls changeProdImage method to change product image.
        this.setSelectedAttribute(swatchAttrName, swatchAttrValue, entitledItemId, skuImageId, imageField);
        document.getElementById("swatch_" + entitledItemId + "_" + swatchAttrValue).className = "color_swatch_selected";
        document.getElementById("swatch_link_" + entitledItemId + "_" + swatchAttrValue).setAttribute("aria-checked", "true");
        document.getElementById("swatch_selection_label_" + entitledItemId + "_" + swatchAttrName).className = "header color_swatch_label";
        if (document.getElementById("swatch_selection_" + entitledItemId + "_" + swatchAttrName).style.display == "none") {
            document.getElementById("swatch_selection_" + entitledItemId + "_" + swatchAttrName).style.display = "inline";
        }
        if (selectedAttributeDisplayValue != null) {
            document.getElementById("swatch_selection_" + entitledItemId + "_" + swatchAttrName).innerHTML = selectedAttributeDisplayValue;
        } else {
            document.getElementById("swatch_selection_" + entitledItemId + "_" + swatchAttrName).innerHTML = swatchAttrValue;
        }

        this.updateSwatchImages(swatchAttrName, entitledItemId, doNotDisable, imageField);
    },

    /**
     * Constructs record and add to this.allSwatchesArray.
     * @param {String} swatchName The name of the swatch attribute.
     * @param {String} swatchValue The value of the swatch attribute.	
     * @param {String} swatchImg1 The path to the swatch image.
     **/
    addToAllSwatchsArray: function (swatchName, swatchValue, swatchImg1, entitledItemId, swatchDisplayValue) {
        var swatchList = this.allSwatchesArrayList[entitledItemId];
        if (swatchList == null) {
            swatchList = [];;
        }
        if (!this.existInAllSwatchsArray(swatchName, swatchValue, swatchList)) {
            var swatchRecord = [];
            swatchRecord[0] = swatchName;
            swatchRecord[1] = swatchValue;
            swatchRecord[2] = swatchImg1;
            swatchRecord[4] = document.getElementById("swatch_link_" + entitledItemId + "_" + swatchValue).onclick;
            swatchRecord[5] = null;
            swatchRecord[6] = swatchDisplayValue;
            swatchList.push(swatchRecord);
            this.allSwatchesArrayList[entitledItemId] = swatchList;
        }
    },

    /**
     * Checks if a swatch is already exist in this.allSwatchesArray.
     * @param {String} swatchName The name of the swatch attribute.
     * @param {String} swatchValue The value of the swatch attribute.		
     * @return boolean Value indicating whether or not the specified swatch name and value exists in the allSwatchesArray.
     */
    existInAllSwatchsArray: function (swatchName, swatchValue, swatchList) {
        for (var i = 0; i < swatchList.length; i++) {
            var attrName = swatchList[i][0];
            var attrValue = swatchList[i][1];
            if (attrName == swatchName && attrValue == swatchValue) {
                return true;
            }
        }
        return false;
    },

    /**
     * Check the entitledItems array and pre-select the first entited SKU as the default swatch selection.
     * @param {String} entitledItemId The ID of the SKU.
     * @param {String} doNotDisable The name of the swatch attribute that should never be disabled.		
     **/
    makeDefaultSwatchSelection: function (entitledItemId, doNotDisable) {
        if (this.entitledItems.length == 0) {
            if ($("#" + entitledItemId).length) {
                entitledItemJSON = eval('(' + $("#" + entitledItemId).html() + ')');
            }
            this.setEntitledItems(entitledItemJSON);
        }

        // need to make selection for every single swatch
        for (x in this.entitledItems) {
            var Attributes = this.entitledItems[x].Attributes;
            for (y in Attributes) {
                var index = y.indexOf("_|_");
                var swatchName = y.substring(0, index);
                var swatchValue = y.substring(index + 3);
                this.makeSwatchSelection(swatchName, swatchValue, entitledItemId, doNotDisable, null, imageField);
            }
            break;
        }
    },

    /**
     * Update swatch images - this is called after selection of a swatch is made, and this function checks for
     * entitlement and disable swatches that are not available
     * @param selectedAttrName The attribute that is selected
     * @param {String} entitledItemId The ID of the SKU.
     * @param {String} doNotDisable The name of the swatch attribute that should never be disabled.	
     **/
    updateSwatchImages: function (selectedAttrName, entitledItemId, doNotDisable, imageField) {
        var swatchToUpdate = [];
        var selectedAttributes = this.selectedAttributesList[entitledItemId];
        var selectedAttrValue = selectedAttributes[selectedAttrName];
        var swatchList = this.allSwatchesArrayList[entitledItemId];

        // finds out which swatch needs to be updated, add to swatchToUpdate array
        for (var i = 0; i < swatchList.length; i++) {
            var attrName = swatchList[i][0];
            var attrValue = swatchList[i][1];
            var attrImg1 = swatchList[i][2];
            var attrImg2 = swatchList[i][3];
            var attrOnclick = swatchList[i][4];
            var attrDisplayValue = swatchList[i][6];

            if (attrName != doNotDisable && attrName != selectedAttrName) {
                var swatchRecord = [];
                swatchRecord[0] = attrName;
                swatchRecord[1] = attrValue;
                swatchRecord[2] = attrImg1;
                swatchRecord[4] = attrOnclick;
                swatchRecord[5] = false;
                swatchRecord[6] = attrDisplayValue;
                swatchToUpdate.push(swatchRecord);
            }
        }

        // finds out which swatch is entitled, if it is, image should be set to enabled
        // go through entitledItems array and find out swatches that are entitled 
        for (x in this.entitledItems) {
            var Attributes = this.entitledItems[x].Attributes;

            for (y in Attributes) {
                var index = y.indexOf("_|_");
                var entitledSwatchName = y.substring(0, index);
                var entitledSwatchValue = y.substring(index + 3);

                //the current entitled item has the selected attribute value
                if (entitledSwatchName == selectedAttrName && entitledSwatchValue == selectedAttrValue) {
                    //go through the other attributes that are available to the selected attribute
                    //exclude the one that is selected
                    for (z in Attributes) {
                        var index2 = z.indexOf("_|_");
                        var entitledSwatchName2 = z.substring(0, index2);
                        var entitledSwatchValue2 = z.substring(index2 + 3);

                        if (y != z) { //only check the attributes that are not the one selected
                            for (i in swatchToUpdate) {
                                var swatchToUpdateName = swatchToUpdate[i][0];
                                var swatchToUpdateValue = swatchToUpdate[i][1];

                                if (entitledSwatchName2 == swatchToUpdateName && entitledSwatchValue2 == swatchToUpdateValue) {
                                    swatchToUpdate[i][5] = true;
                                }
                            }
                        }
                    }
                }
            }
        }

        // Now go through swatchToUpdate array, and update swatch images
        var disabledAttributes = [];
        for (i in swatchToUpdate) {
            var swatchToUpdateName = swatchToUpdate[i][0];
            var swatchToUpdateValue = swatchToUpdate[i][1];
            var swatchToUpdateImg1 = swatchToUpdate[i][2];
            var swatchToUpdateImg2 = swatchToUpdate[i][3];
            var swatchToUpdateOnclick = swatchToUpdate[i][4];
            var swatchToUpdateEnabled = swatchToUpdate[i][5];

            if (swatchToUpdateEnabled) {
                if (document.getElementById("swatch_" + entitledItemId + "_" + swatchToUpdateValue).className != "color_swatch_selected") {
                    var swatchElement = document.getElementById("swatch_" + entitledItemId + "_" + swatchToUpdateValue);
                    swatchElement.className = "color_swatch";
                    swatchElement.src = swatchElement.src.replace("_disabled.png", "_enabled.png");

                    //change the title text of the swatch link
                    document.getElementById("swatch_link_" + entitledItemId + "_" + swatchToUpdateValue).title = swatchElement.alt;
                }
                document.getElementById("swatch_link_" + entitledItemId + "_" + swatchToUpdateValue).setAttribute("aria-disabled", "false");
                document.getElementById("swatch_link_" + entitledItemId + "_" + swatchToUpdateValue).onclick = swatchToUpdateOnclick;
            } else {
                if (swatchToUpdateName != doNotDisable) {
                    var swatchElement = document.getElementById("swatch_" + entitledItemId + "_" + swatchToUpdateValue);
                    var swatchLinkElement = document.getElementById("swatch_link_" + entitledItemId + "_" + swatchToUpdateValue);
                    swatchElement.className = "color_swatch_disabled";
                    swatchLinkElement.onclick = null;
                    swatchElement.src = swatchElement.src.replace("_enabled.png", "_disabled.png");

                    //change the title text of the swatch link

                    var titleText = Utils.getLocalizationMessage("INV_ATTR_UNAVAILABLE", [swatchElement.alt]);

                    document.getElementById("swatch_link_" + entitledItemId + "_" + swatchToUpdateValue).setAttribute("aria-disabled", "true");

                    //The previously selected attribute is now unavailable for the new selection
                    //Need to switch the selection to an available value
                    if (selectedAttributes[swatchToUpdateName] == swatchToUpdateValue) {
                        disabledAttributes.push(swatchToUpdate[i]);
                    }
                }
            }
        }

        //If there were any previously selected attributes that are now unavailable
        //Find another available value for that attribute and update other attributes according to the new selection
        for (i in disabledAttributes) {
            var disabledAttributeName = disabledAttributes[i][0];
            var disabledAttributeValue = disabledAttributes[i][1];

            for (i in swatchToUpdate) {
                var swatchToUpdateName = swatchToUpdate[i][0];
                var swatchToUpdateValue = swatchToUpdate[i][1];
                var swatchToUpdateDisplayValue = swatchToUpdate[i][6];
                var swatchToUpdateEnabled = swatchToUpdate[i][5];

                if (swatchToUpdateName == disabledAttributeName && swatchToUpdateValue != disabledAttributeValue && swatchToUpdateEnabled) {
                    this.makeSwatchSelection(swatchToUpdateName, swatchToUpdateValue, entitledItemId, doNotDisable, swatchToUpdateDisplayValue, imageField);
                    break;
                }
            }
        }
    },
    /* SwatchCode end */

    /**
     * This function is used to change the price displayed in the Product Display Page on change of  a attribute of the product using an AJAX call. 
     * This function will resolve the catentryId using entitledItemId and displays the price of the catentryId.
     *				
     * @param {Object} entitledItemId A DIV containing a JSON object which holds information about a catalog entry. You can reference CachedProductOnlyDisplay.jsp to see how that div is constructed.
     * @param {Boolean} isPopup If the value is true, then this implies that the function was called from a quick info pop-up.
     * @param {Boolean} displayPriceRange If the value is true, then display the price range. If it is false then donot display the price range.
     *
     **/
    changePrice: function (entitledItemId, isPopup, displayPriceRange, productId) {
        this.displayPriceRange = displayPriceRange;
        this.isPopup = isPopup;
        var entitledItemJSON;

        if ($("#" + entitledItemId).length && !this.isPopup) {
            //the json object for entitled items are already in the HTML. 
            entitledItemJSON = eval('(' + $("#" + entitledItemId).html() + ')');
        } else {
            //if $("#"+ entitledItemId).length is 0, that means there's no <div> in the HTML that contains the JSON object. 
            //in this case, it must have been set in catalogentryThumbnailDisplay.js when the quick info
            entitledItemJSON = this.getEntitledItemJsonObject();
        }
        var catalogEntryId = null;
        this.setEntitledItems(entitledItemJSON);

        if (this.selectedProducts[productId]) {
            var catalogEntryId = this.getCatalogEntryIdforProduct(this.selectedProducts[productId]);
        } else {
            var catalogEntryId = this.getCatalogEntryId(entitledItemId);
        }

        if (catalogEntryId != null) {
            //check if the json object is already present for the catEntry.
            if (this.itemPriceJsonOject[catalogEntryId] != null && this.itemPriceJsonOject[catalogEntryId] != 'undefined') {
                this.displayPrice(this.itemPriceJsonOject[catalogEntryId].catalogEntry, productId);
                console.debug("ShoppingActions.changePrice: using stored json object.");
            }
            //if json object is not present, call the service to get the details.
            else {
                var parameters = {
                    storeId: this.storeId,
                    langId: this.langId,
                    catalogId: this.catalogId,
                    catalogEntryId: catalogEntryId,
                    productId: productId
                };

                //Declare a service for retrieving catalog entry detailed information for an item...
                wcService.declare({
                    id: "getCatalogEntryDetailsSA",
                    actionId: "getCatalogEntryDetailsSA",
                    url: getAbsoluteURL() + appendWcCommonRequestParameters("GetCatalogEntryDetailsByIDView"),
                    formId: ""

                    ,
                    successHandler: function (serviceResponse, ioArgs) {
                        shoppingActionsJS.displayPriceServiceResponse(serviceResponse, ioArgs);
                    }

                    ,
                    failureHandler: function (serviceResponse, ioArgs) {
                        console.debug("ShoppingActions.changePrice: Unexpected error occurred during an xhrPost request.");
                    }

                });
                wcService.invoke("getCatalogEntryDetailsSA", parameters);
            }
        } else {
            console.debug("ShoppingActions.changePrice: all attributes are not selected.");
        }

    },

    /** 
     * Displays price of the catEntry selected with the JSON objrct returned from the server.
     * 
     * @param {object} serviceRepsonse The JSON response from the service.
     * @param {object} ioArgs The arguments from the service call.
     */
    displayPriceServiceResponse: function (serviceResponse, ioArgs) {
        var productId = ioArgs.productId;
        //stores the json object, so that the service is not called when same catEntry is selected.
        shoppingActionsJS.itemPriceJsonOject[serviceResponse.catalogEntry.catalogEntryIdentifier.uniqueID] = serviceResponse;

        shoppingActionsJS.displayPrice(serviceResponse.catalogEntry, productId);
    },

    /** 
     * Displays price of the attribute selected with the JSON oject.
     * 
     * @param {object} catEntry The JSON object with catalog entry details.
     */
    displayPrice: function (catEntry, productId) {

        var tempString;
        var popup = shoppingActionsJS.isPopup;

        if (popup == true) {
            $("#productPrice").html(catEntry.offerPrice);
            document.getElementById('productName').innerHTML = catEntry.description[0].name;
            document.getElementById('productSKUValue').innerHTML = catEntry.catalogEntryIdentifier.externalIdentifier.partNumber;
        }

        if (popup == false) {
            var innerHTML = "";
            var listPrice = Utils.parseNumber(catEntry.listPrice);
            var offerPrice = Utils.parseNumber(catEntry.offerPrice);

            this.setPriceInProductList(productId, offerPrice);

            if (!catEntry.listPriced || listPrice <= offerPrice) {
                innerHTML = "<span id='offerPrice_" + catEntry.catalogEntryIdentifier.uniqueID + "' class='price'>" + catEntry.offerPrice + "</span>";
            } else {
                innerHTML = "<span id='listPrice_" + catEntry.catalogEntryIdentifier.uniqueID + "' class='old_price'>" + catEntry.listPrice + "</span>" +
                    "<span id='offerPrice_" + catEntry.catalogEntryIdentifier.uniqueID + "' class='price'>" + catEntry.offerPrice + "</span>";
            }
            document.getElementById('price_display_' + productId).innerHTML = innerHTML + "<input type='hidden' id='ProductInfoPrice_" + catEntry.catalogEntryIdentifier.uniqueID + "' value='" + catEntry.offerPrice + "'/>";

            innerHTML = "";
            if (shoppingActionsJS.displayPriceRange == true) {
                for (var i in catEntry.priceRange) {
                    if (catEntry.priceRange[i].endingNumberOfUnits == catEntry.priceRange[i].startingNumberOfUnits) {
                        tempString = Utils.getLocalizationMessage('PQ_PRICE_X', {
                            0: catEntry.priceRange[i].startingNumberOfUnits
                        });
                        innerHTML = innerHTML + "<p>" + tempString;
                    } else if (catEntry.priceRange[i].endingNumberOfUnits != 'null') {
                        tempString = Utils.getLocalizationMessage('PQ_PRICE_X_TO_Y', {
                            0: catEntry.priceRange[i].startingNumberOfUnits,
                            1: catEntry.priceRange[i].endingNumberOfUnits
                        });
                        innerHTML = innerHTML + "<p>" + tempString;
                    } else {
                        tempString = Utils.getLocalizationMessage('PQ_PRICE_X_OR_MORE', {
                            0: catEntry.priceRange[i].startingNumberOfUnits
                        });
                        innerHTML = innerHTML + "<p>" + tempString;
                    }
                    innerHTML = innerHTML + " <span class='price'>" + catEntry.priceRange[i].localizedPrice + "</span></p>";
                }
            }
            // Append productId so that element is unique in bundle page, where there can be multiple components
            var quantityDiscount = document.getElementById("productLevelPriceRange_" + productId);
            var itemQuantityDiscount = document.getElementById("itemLevelPriceRange_" + productId);

            // if product level price exists and no section to update item level price
            if (null != quantityDiscount && null == itemQuantityDiscount) {
                quantityDiscount.style.display = ""; //display product level price range
            }
            // if item level price range is present
            else if ("" != innerHTML && null != itemQuantityDiscount) {
                innerHTML = Utils.getLocalizationMessage('PQ_PURCHASE') + innerHTML;
                itemQuantityDiscount.innerHTML = innerHTML;
                itemQuantityDiscount.style.display = "";
                // hide the product level price range
                if (null != quantityDiscount) {
                    quantityDiscount.style.display = "none";
                }
            }
            // if item level price range is not present
            else if ("" == innerHTML) {
                if (null != itemQuantityDiscount) {
                    itemQuantityDiscount.style.display = "none"; //hide item level price range
                }
                if (null != quantityDiscount) {
                    quantityDiscount.style.display = ""; //display product level price range
                }
            }

            /*
             * If the product name is a link, do not replace the link only replace the text in the link.
             * Otherwise, replace the whole text
             */
            var productNameLink = $('#product_name_' + productId + ' > a');
            if (productNameLink.length == 1) {
                $(productNameLink[0]).html(catEntry.description[0].name);
            } else if ($('#product_name_' + productId)) {
                $('#product_name_' + productId).html(catEntry.description[0].name);
            }

            if ($("#widget_product_info_viewer > div[id^='PageHeading_']").length) {
                $("#widget_product_info_viewer > div[id^='PageHeading_']").each(function (i, node) {
                    if (node.childNodes != null && node.childNodes.length == 3) {
                        node.childNodes[1].innerHTML = catEntry.description[0].name;
                    }
                });
            }
            if (document.getElementById("ProductInfoName_" + productId) != null) {
                document.getElementById("ProductInfoName_" + productId).value = catEntry.description[0].name;
            }
            if (document.getElementById('product_shortdescription_' + productId)) {
                document.getElementById('product_shortdescription_' + productId).innerHTML = catEntry.description[0].shortDescription;
            }
            if (document.getElementById('product_SKU_' + productId)) {
                document.getElementById('product_SKU_' + productId).innerHTML = Utils.getLocalizationMessage('SKU') + " " + catEntry.catalogEntryIdentifier.externalIdentifier.partNumber;
            }
        }
    },

    /**
     *This method will show the WC Dialog popup
     *@param{String} widgetId The ID of the WC Dialog which should be shown
     */
    showWCDialogPopup: function (widgetId) {
        var dialog = $("#" + widgetId).data("wc-WCDialog");
        if (dialog) {
            dialog.open();
            $("#" + widgetId).css("display", "block");
        } else {
            console.debug(widgetId + " does not exist");
        }
    },

    /**
     * To notify the change in attribute to other components that is subscribed to DefiningAttributes_Resolved_[productId] event.
     */
    notifyAttributeChange: function (catalogEntryID) {
        this.baseCatalogEntryId = catalogEntryID;
        var selectedAttributes = this.selectedAttributesList["entitledItem_" + catalogEntryID];
        wcTopic.publish('DefiningAttributes_Resolved_' + catalogEntryID, catalogEntryID, -1);
    },

    /**
     * To notify the change in quantity to other components that is subscribed to Quantity_Changed event.
     */
    notifyQuantityChange: function (quantity) {
        wcTopic.publish("Quantity_Changed", quantity);
    },

    /**
     * Initializes the compare check box for all the products added to compare.
     */
    initCompare: function (fromPage) {
        if (fromPage == 'compare' || fromPage == 'catalogEntryList') {
            this.checkForCompare();
        } else {
            var cookieKey = this.cookieKeyPrefix + this.storeId;
            var newCookieValue = "";
            setCookie(cookieKey, newCookieValue, {
                path: '/',
                domain: cookieDomain
            });
        }

    },

    /**
     * Change the compare box status to checked or unchecked
     * @param{String} cbox The ID of the compare check box of the given catentry identifier.
     * @param{String} catEntryIdentifier The catalog entry identifer to current product.
     */
    changeCompareBox: function (cbox, catEntryIdentifier) {
        box = document.getElementById(cbox);
        box.checked = !box.checked;
        this.addOrRemoveFromCompare(catEntryIdentifier, box.checked);
    },

    /**
     * Adds or removes the product from the compare depending on the compare box checked or unchecked.
     * @param{String} catEntryIdentifier The catalog entry identifer to current product.
     * @param{boolean} checked True if the checkbox is checked or False
     */
    addOrRemoveFromCompare: function (catEntryIdentifier, checked) {
        //box = eval(cbox);
        if (checked) {
            this.addToCompare(catEntryIdentifier);
        } else {
            this.removeFromCompare(catEntryIdentifier);
        }
    },

    /**
     * Adds the product to the compare cookie.
     * @param{String} catEntryIdentifier The catalog entry identifer to current product.
     */
    addToCompare: function (catEntryIdentifier) {

        var cookieKey = this.cookieKeyPrefix + this.storeId;
        var cookieValue = getCookie(cookieKey);

        if (cookieValue != null) {
            if (cookieValue.indexOf(catEntryIdentifier) != -1 || catEntryIdentifier == null) {
                MessageHelper.displayErrorMessage(Utils.getLocalizationMessage("COMPARE_ITEM_EXISTS"));
                return;
            }
        }

        var currentNumberOfItemsInCompare = 0;
        if (cookieValue != null && cookieValue !== "") {
            currentNumberOfItemsInCompare = cookieValue.split(this.cookieDelimiter).length;
        }

        if (currentNumberOfItemsInCompare < parseInt(this.maxNumberProductsAllowedToCompare)) {
            var newCookieValue = "";
            if (cookieValue == null || cookieValue === "") {
                newCookieValue = catEntryIdentifier;
            } else {
                newCookieValue = cookieValue + this.cookieDelimiter + catEntryIdentifier;
            }
            setCookie(cookieKey, newCookieValue, {
                path: '/',
                domain: cookieDomain
            });
            shoppingActionsJS.checkForCompare();
        } else {
            this.showWCDialogPopup('widget_product_comparison_popup');
            document.getElementById("comparebox_" + catEntryIdentifier).checked = false;
            console.debug("You can only compare up to 4 products");
        }
    },

    /**
     * Removes the product from the compare cookie.
     * @param{String} catEntryIdentifier The catalog entry identifer to current product.
     */
    removeFromCompare: function (catEntryIdentifier) {
        var cookieKey = this.cookieKeyPrefix + this.storeId;
        var cookieValue = getCookie(cookieKey);
        var currentNumberOfItemsInCompare = 0;
        if (cookieValue != null) {
            if (cookieValue.trim() == "") {
                setCookie(cookieKey, null, {
                    expires: -1
                });
            } else {
                var cookieArray = cookieValue.split(this.cookieDelimiter);
                var newCookieValue = "";
                for (index in cookieArray) {
                    if (cookieArray[index] != catEntryIdentifier) {
                        if (newCookieValue === "") {
                            newCookieValue = cookieArray[index];
                        } else {
                            newCookieValue = newCookieValue + this.cookieDelimiter + cookieArray[index];
                        }
                    }
                }
                setCookie(cookieKey, newCookieValue, {
                    path: '/',
                    domain: cookieDomain
                });
                currentNumberOfItemsInCompare = newCookieValue.split(this.cookieDelimiter).length;
            }
            shoppingActionsJS.checkForCompare();
        }
    },

    /**
     * Re-directs the browser to the CompareProductsDisplay page to compare products side-by-side.
     */
    compareProducts: function (categoryIds, manufacturer) {
        var url = appendWcCommonRequestParameters("CompareProductsDisplayView?storeId=" + this.storeId + "&catalogId=" + this.catalogId + "&langId=" + this.langId + "&compareReturnName=" + encodeURIComponent(this.compareReturnName) + "&searchTerm=" + this.searchTerm);
        if ('' != categoryIds.top_category) {
            url = url + "&top_category=" + categoryIds.top_category;
        }
        if ('' != categoryIds.parent_category_rn) {
            url = url + "&parent_category_rn=" + categoryIds.parent_category_rn;
        }
        if ('' != categoryIds.categoryId) {
            url = url + "&categoryId=" + categoryIds.categoryId;
        }
		if (manufacturer != undefined && '' != manufacturer) {
			url = url + "&manufacturer=" + manufacturer;
		}
		
        var cookieKey = this.cookieKeyPrefix + this.storeId;
        var cookieValue = getCookie(cookieKey);
        if (cookieValue != null && cookieValue.trim() != "") {
            url = url + "&catentryId=" + cookieValue;
        }
        var returnUrl = appendWcCommonRequestParameters(location.href);
        if (returnUrl.indexOf("?") === -1) {
            returnUrl = returnUrl + "?fromPage=compare";
        } else if (returnUrl.indexOf("fromPage=compare") === -1) {
            returnUrl = returnUrl + "&fromPage=compare";
        }
        url = url + "&returnUrl=" + encodeURIComponent(returnUrl);
        location.href = getAbsoluteURL() + url;
    },

    /**
     * Sets the quantity of a product in the list (bundle)
     * 
     * @param {String} catalogEntryType, type of catalogEntry (item/product/bundle/package)
     * @param {int} catalogEntryId The catalog entry identifer to current product.
     * @param {int} quantity The quantity of current product.
     * @param {float} price The price of current product.
     */
    setProductQuantity: function (catalogEntryType, catalogEntryId, quantity, price) {
        var productDetails = null;
        if (this.productList[catalogEntryId]) {
            productDetails = this.productList[catalogEntryId];
        } else {
            productDetails = {};
            this.productList[catalogEntryId] = productDetails;
            productDetails.baseItemId = catalogEntryId;
            if ("item" == catalogEntryType) {
                productDetails.id = catalogEntryId;
            } else {
                productDetails.id = 0;
            }
        }
        productDetails.quantity = quantity;
        wcTopic.publish("Quantity_Changed", JSON.stringify(productDetails));
        productDetails.price = Utils.parseNumber(price);
    },

    /**
     * Sets the quantity of a product in the list (bundle)
     * 
     * @param {int} catalogEntryId The catalog entry identifer to current product.
     * @param {int} quantity The quantity of current product.
     */
    quantityChanged: function (catalogEntryId, quantity) {
        if (this.productList[catalogEntryId]) {
            var productDetails = this.productList[catalogEntryId];
            productDetails.quantity = quantity.trim();
            wcTopic.publish("Quantity_Changed", JSON.stringify(productDetails));

            //Update quantity for catentries in the merchandising association array
            if (MerchandisingAssociationJS != null) {
                if (MerchandisingAssociationJS.baseItemParams != null) {
                    if (MerchandisingAssociationJS.baseItemParams.type == 'BundleBean') {
                        // Update items in the bundle
                        for (idx = 0; idx < MerchandisingAssociationJS.baseItemParams.components.length; idx++) {
                            if (catalogEntryId == MerchandisingAssociationJS.baseItemParams.components[idx].productId || catalogEntryId == MerchandisingAssociationJS.baseItemParams.components[idx].id) {
                                MerchandisingAssociationJS.baseItemParams.components[idx].quantity = productDetails.quantity;
                            }
                        }
                    }
                }
            }
        }
    },

    /**
     * Sets the price of a product in the list (bundle)
     * 
     * @param {int} catalogEntryId The catalog entry identifer to current product.
     * @param {int} price The price of current product.
     */
    setPriceInProductList: function (catalogEntryId, price) {
        var productDetails = this.productList[catalogEntryId];
        if (productDetails) {
            productDetails.price = price;
        }
    },

    /**
     * Select bundle item swatch
     * 
     * @param {int} catalogEntryId The catalog entry identifer to current product.
     * @param {String} swatchName
     * @param {String} swatchValue
     * @param {String} doNotDisable, the first swatch, that should not be disabled
     */
    selectBundleItemSwatch: function (catalogEntryId, swatchName, swatchValue, doNotDisable) {
        if ($("#swatch_" + catalogEntryId + "_" + swatchName + "_" + swatchValue).hasClass("color_swatch_disabled")) {
            return;
        }
        if ($("#entitledItem_" + catalogEntryId).length) {
            var entitledItemJSON;
            var currentSwatchkey = swatchName + "_" + swatchValue;
            //the json object for entitled items are already in the HTML. 
            entitledItemJSON = JSON.stringify($("#entitledItem_" + catalogEntryId).html());
            var validSwatchArr = [];
            for (idx in entitledItemJSON) {
                var validItem = false;
                var entitledItem = entitledItemJSON[idx];
                for (attribute in entitledItem.Attributes) {

                    if (currentSwatchkey == attribute) {
                        validItem = true;
                        break;
                    }
                }
                if (validItem) {
                    for (attribute in entitledItem.Attributes) {
                        var currentSwatch = attribute.substring(0, attribute.lastIndexOf("_|_"));
                        if (currentSwatch != doNotDisable && currentSwatch != swatchName) {
                            validSwatchArr.push(attribute);
                        }
                    }
                }
            }

            var swatchesDisabled = [];
            var selectedSwatches = [];
            for (idx in entitledItemJSON) {
                var entitledItem = entitledItemJSON[idx];
                for (attribute in entitledItem.Attributes) {
                    var currentSwatch = attribute.substring(0, attribute.lastIndexOf("_|_"));
                    if (currentSwatch != doNotDisable && currentSwatch != swatchName) {
                        var swatchId = "swatch_" + catalogEntryId + "_" + attribute;
                        var swatchLinkId = swatchId.replace("swatch_", "swatch_link_");
                        if (validSwatchArr.indexOf(attribute) > -1) {
                            if (!$("#" + swatchId).hasClass("color_swatch_selected")) {
                                document.getElementById(swatchId).className = "color_swatch";
                                document.getElementById(swatchId).src = document.getElementById(swatchId).src.replace("_disabled.png", "_enabled.png");

                                //change the title text of the swatch link
                                document.getElementById(swatchLinkId).title = document.getElementById(swatchId).alt;
                                document.getElementById(swatchLinkId).setAttribute("aria-disabled", "false");
                            }
                        } else if (swatchesDisabled.indexOf(attribute) === -1) {
                            swatchesDisabled.push(attribute);
                            if ($("#" + swatchId).hasClass("color_swatch_selected")) {
                                selectedSwatches.push(swatchId);
                            }
                            document.getElementById(swatchId).className = "color_swatch_disabled";
                            document.getElementById(swatchId).src = document.getElementById(swatchId).src.replace("_enabled.png", "_disabled.png");

                            //change the title text of the swatch link
			    
			    var altText = document.getElementById(swatchId).alt;
                            var titleText = Utils.getLocalizationMessage("INV_ATTR_UNAVAILABLE", [altText]);
                            

                           
                            $("#" + swatchLinkId).attr("aria-disabled", "true");
                        }
                    }
                    if (document.getElementById("swatch_link_" + catalogEntryId + "_" + attribute) != null) {
                        document.getElementById("swatch_link_" + catalogEntryId + "_" + attribute).setAttribute("aria-checked", "false");
                    }
                }
            }

            for (idx in selectedSwatches) {
                var selectedSwatch = selectedSwatches[idx];
                var idSelector = selectedSwatch.substring(0, selectedSwatch.lastIndexOf("_|_"));
                var swatchSelected = false;
                $("[id^='" + idSelector + "']").each(function (index, node, arr) {
                    if (!swatchSelected && $(node).hasClass("color_swatch")) {
                        var values = node.id.split("_");
                        shoppingActionsJS.selectBundleItemSwatch(values[1], values[2], values[3], doNotDisable);
                        shoppingActionsJS.setSelectedAttributeOfProduct(values[1], values[2], values[3], false);
                        swatchSelected = true;
                    }
                });
            }
        }

        if ($("#swatch_selection_" + catalogEntryId + "_" + swatchName).css("display") == ("none")) {
            $("#swatch_selection_" + catalogEntryId + "_" + swatchName).css("display", "inline");
        }
        $("#swatch_selection_" + catalogEntryId + "_" + swatchName).html(swatchValue);

        var swatchItem = "swatch_" + catalogEntryId + "_" + swatchName + "_";
        var swatchItemLink = "swatch_link_" + catalogEntryId + "_" + swatchName + "_";

        $("img[id^='" + swatchItem + "']").each(function (index, node, arr) {
            if ($(node).hasClass("color_swatch_disabled")) {
                $(node).removeClass("color_swatch")
            } else {
                $(node).addClass("color_swatch");
            }
            $(node).removeClass("color_swatch_selected");
        });

        $("#" + swatchItem + swatchValue).attr("className", "color_swatch_selected");
        document.getElementById(swatchItemLink + swatchValue).setAttribute("aria-checked", "true");

        this.setSelectedAttributeOfProduct(catalogEntryId, swatchName, swatchValue, false);
        // select image
        this.changeBundleItemImage(catalogEntryId, swatchName, swatchValue, "productThumbNailImage_" + catalogEntryId);

    },

    changeBundleItemImage: function (catalogEntryId, swatchAttrName, swatchAttrValue, skuImageId) {
        var entitledItemId = "entitledItem_" + catalogEntryId;
        if ($("#" + entitledItemId).length) {
            //the json object for entitled items are already in the HTML. 
            entitledItemJSON = eval('(' + $("#" + entitledItemId).html() + ')');
        }

        this.setEntitledItems(entitledItemJSON);

        var skuImage = null;
        var imageArr = shoppingActionsJS.getImageForBundleItem(catalogEntryId);
        if (imageArr != null) {
            skuImage = imageArr[1];
        }

        if (skuImageId != undefined) {
            this.setSKUImageId(skuImageId);
        }

        if (skuImage != null) {
            if ($("#" + this.skuImageId) != null) {
                document.getElementById(this.skuImageId).src = skuImage;
                if (document.getElementById("ProductInfoImage_" + catalogEntryId) != null) {
                    document.getElementById("ProductInfoImage_" + catalogEntryId).value = skuImage;
                }
            }
        } else {
            var imageFound = false;
            for (x in this.entitledItems) {
                var Attributes = this.entitledItems[x].Attributes;
                var itemImage = this.entitledItems[x].ItemThumbnailImage;

                for (y in Attributes) {
                    var index = y.indexOf("_|_");
                    var entitledSwatchName = y.substring(0, index);
                    var entitledSwatchValue = y.substring(index + 3);

                    if (entitledSwatchName == swatchAttrName && entitledSwatchValue == swatchAttrValue) {
                        document.getElementById(this.skuImageId).src = itemImage;
                        if (document.getElementById("ProductInfoImage_" + catalogEntryId) != null) {
                            document.getElementById("ProductInfoImage_" + catalogEntryId).value = itemImage;
                        }
                        imageFound = true;
                        break;
                    }
                }

                if (imageFound) {
                    break;
                }
            }
        }
    },

    getImageForBundleItem: function (entitledItemId) {
        var attributeArray = [];
        var selectedAttributes = this.selectedProducts[entitledItemId];
        for (attribute in selectedAttributes) {
            attributeArray.push(attribute + "_|_" + selectedAttributes[attribute]);
        }
        return this.resolveImageForSKU(attributeArray);
    },

    /**
     * Check if any product is already selected for compare in other pages and select them
     */
    checkForCompare: function () {
        var cookieValues = getCookie(shoppingActionsJS.cookieKeyPrefix + shoppingActionsJS.storeId);
        cookieValues = (cookieValues ? cookieValues.split(shoppingActionsJS.cookieDelimiter) : []);
        var labels = $(".compareCheckboxLabels > label");
        $(".compare_target").each(function (i, div) {
            var checkbox = $("input[type=\"checkbox\"]", div)[0];
            checkbox.checked = (cookieValues.indexOf(checkbox.value) !== -1);
            var state = (checkbox.checked ? (cookieValues.length > 1 ? 2 : 1) : 0);
            div.setAttribute("data-state", state.toString());
            var label = $("label[for=\"" + checkbox.id + "\"]", div)[0];
            $(label).html($(labels[state]).html());
        });
    },

    /**
     * replaceItemAjaxHelper This function is used to replace an item in the cart. This will be called from the {@link this.ReplaceItemAjax} method.
     *
     * @param {String} catalogEntryId The catalog entry of the item to replace to the cart.
     * @param {int} qty The quantity of the item to add.
     * @param {String} removeOrderItemId The order item ID of the catalog entry to remove from the cart.
     * @param {String} addressId The address ID of the order item.
     * @param {String} shipModeId The shipModeId of the order item.
     * @param {String} physicalStoreId The physicalStoreId of the order item.
     *
     **/
    replaceItemAjaxHelper: function (catalogEntryId, qty, removeOrderItemId, addressId, shipModeId, physicalStoreId) {

        var params = {
            storeId: WCParamJS.storeId,
            catalogId: WCParamJS.catalogId,
            langId: WCParamJS.langId,
            orderItemId: removeOrderItemId,
            orderId: "."
        };
        if (CheckoutHelperJS.shoppingCartPage) {
            params.calculationUsage = "-1,-2,-5,-6,-7";
        } else {
            params.calculationUsage = "-1,-2,-3,-4,-5,-6,-7";
        }

        var params2 = {
            storeId: WCParamJS.storeId,
            catalogId: WCParamJS.catalogId,
            langId: WCParamJS.langId,
            catEntryId: catalogEntryId,
            quantity: qty,
            orderId: ".",
	    calculateOrder: "1"
        };
        if (CheckoutHelperJS.shoppingCartPage) {
            params2.calculationUsage = "-1,-2,-5,-6,-7";
        } else {
            params2.calculationUsage = "-1,-2,-3,-4,-5,-6,-7";
        }

        var params3 = {
            storeId: WCParamJS.storeId,
            catalogId: WCParamJS.catalogId,
            langId: WCParamJS.langId,
            orderId: "."
        };
        if (CheckoutHelperJS.shoppingCartPage) {
            params3.calculationUsage = "-1,-2,-5,-6,-7";
        } else {
            params3.calculationUsage = "-1,-2,-3,-4,-5,-6,-7";
        }

        var shipInfoUpdateNeeded = false;
        var orderItemReqd = true;
        if (addressId != null && addressId !== "") {
            params3.addressId = addressId;
        }
        if (shipModeId != null && shipModeId !== "") {
            params3.shipModeId = shipModeId;
        }
        if (physicalStoreId != null && physicalStoreId !== "") {
            params3.physicalStoreId = physicalStoreId;
            orderItemReqd = false;
        }
        if (params3.shipModeId != null && (params3.addressId != null || params3.physicalStoreId != null)) {
            shipInfoUpdateNeeded = true;
        }

        if (orderItemReqd) {
            params3.allocate = "***";
            params3.backorder = "***";
            params3.remerge = "***";
            params3.check = "*n";
        }

        //Delcare service for deleting item...
        wcService.declare({
            id: "AjaxReplaceItem",
            actionId: "AjaxReplaceItem",
            url: "AjaxRESTOrderItemDelete",
            formId: ""

            ,
            successHandler: function (serviceResponse) {
                //Now add the new item to cart..
                if (!shipInfoUpdateNeeded) {
                    //We dont plan to update addressId and shipMOdeId..so call AjaxAddOrderItem..
                    wcService.invoke("AjaxAddOrderItem", params2);
                } else {
                    //We need to update the adderessId and shipModeId..so call our temp service to add..
                    wcService.invoke("AjaxAddOrderItemTemp", params2);
                }
            }

            ,
            failureHandler: function (serviceResponse) {
                if (serviceResponse.errorMessage) {
                    MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
                } else {
                    if (serviceResponse.errorMessageKey) {
                        MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
                    }
                }
                cursor_clear();
            }

        });

        //Delcare service for adding item..
        wcService.declare({
            id: "AjaxAddOrderItemTemp",
            actionId: "AjaxAddOrderItemTemp",
            url: "AjaxRESTOrderItemAdd",
            formId: ""

            ,
            successHandler: function (serviceResponse) {
                // setting the newly created orderItemId
                params3.orderItemId = (serviceResponse.orderItem != null && serviceResponse.orderItem[0].orderItemId != null) ? serviceResponse.orderItem[0].orderItemId : serviceResponse.orderItemId;

                MessageHelper.displayStatusMessage(MessageHelper.messages["SHOPCART_ADDED"]);

                //Now item is added.. call update to set addressId and shipModeId...
                wcService.invoke("OrderItemAddressShipMethodUpdate", params3);
            }

            ,
            failureHandler: function (serviceResponse) {
                MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
            }
        });

        //For Handling multiple clicks
        if (!submitRequest()) {
            return;
        }
        cursor_wait();
        wcService.invoke("AjaxReplaceItem", params);
    },

    /**
     * customizeDynamicKit This function is used to call the configurator page for a dynamic kit.
     * @param {String} catEntryIdentifier A catalog entry ID of the item to add to the cart.
     * @param {int} quantity A quantity of the item to add to the cart.
     * @param {Object} customParams - Any additional parameters that needs to be passed to the configurator page.
     *
     **/
    customizeDynamicKit: function (catEntryIdentifier, quantity, customParams) {
        var params = {
            storeId: this.storeId,
            catalogId: this.catalogId,
            langId: this.langId,
            catEntryId: catEntryIdentifier,
            quantity: quantity
        };

        if (!isPositiveInteger(quantity)) {
            MessageHelper.displayErrorMessage(Utils.getLocalizationMessage('QUANTITY_INPUT_ERROR'));
            return;
        }

        var contractIdElements = document.getElementsByName('contractSelectForm_contractId');
        if (contractIdElements != null && contractIdElements != "undefined") {
            for (i = 0; i < contractIdElements.length; i++) {
                if (contractIdElements[i].checked) {
                    params.contractId = contractIdElements[i].value;
                    break;
                }
            }
        }

        //Pass any other customParams set by other add on features
        if (customParams != null && customParams != 'undefined') {
            for (i in customParams) {
                params[i] = customParams[i];
            }
        }

        //For Handling multiple clicks
        if (!submitRequest()) {
            return;
        }
        cursor_wait();

        var configureURL = "ConfigureView";
        var i = 0;
        for (param in params) {
            configureURL += ((i++ == 0) ? "?" : "&") + param + "=" + params[param];
        }
        document.location.href = getAbsoluteURL() + appendWcCommonRequestParameters(configureURL);
    }

}

wcTopic.subscribe("ProductInfo_Reset", shoppingActionsJS.resetProductAddedList);

$(document).ready(function () {
    var ie_version = Utils.get_IE_version();
    if (ie_version < 9) {
        $(document).on("click", ".compare_target > input[type=\"checkbox\"]:click", function (event) {
            this.blur();
            this.focus();
        });
    }
});
//-----------------------------------------------------------------
// Licensed Materials - Property of IBM
//
// WebSphere Commerce
//
// (C) Copyright IBM Corp. 2008, 2016 All Rights Reserved.
//
// US Government Users Restricted Rights - Use, duplication or
// disclosure restricted by GSA ADP Schedule Contract with
// IBM Corp.
//-----------------------------------------------------------------

/**
 * @fileOverview This class contains declarations of AJAX services used by the Madisons store pages.
 */

/**
 * @class This class stores common parameters needed to make the service call.
 */
shoppingActionsServicesDeclarationJS = {
	langId: "-1", /* language of the  store */
	storeId: "", /*numeric unique identifier of the store */
	catalogId: "", /*catalog of the store that is currently in use */

	/**
	 * Sets common parameters used by the services
	 * @param (int) langId The language of the store.
	 * @param (int) storeId The store currently in use.
	 * @param (int) catalogId The catalog of the store currently in use.
	 */
	setCommonParameters:function(langId,storeId,catalogId){
			this.langId = langId;
			this.storeId = storeId;
			this.catalogId = catalogId;
	},

	registerMarketingEvent : function(params) {
		cursor_wait();
		wcService.invoke("AjaxMarketingTriggerInvoke",params);
	}

}

	/**
	 * Add an item to a shopping cart in Ajax mode. A message is displayed after
	 * the service call.
	 * @constructor
	 */
	wcService.declare({
		id: "AddOrderItem",
		actionId: "AddOrderItem",
		url: getAbsoluteURL() + "AjaxRESTOrderItemAdd",
		formId: ""

     /**
     * display a success message
     * @param (object) serviceResponse The service response object, which is the
     * JSON object returned by the service invocation
     */

		,successHandler: function(serviceResponse) {
			MessageHelper.hideAndClearMessage();
			// Do not show this message. When item is added, we open up mini cart to display the currently added item.
			// MessageHelper.displayStatusMessage(Utils.getLocalizationMessage("SHOPCART_ADDED"));
			cursor_clear();
			if(shoppingActionsJS){
				
				var attributes_container = $('div[id^="attrValue_"]');
				
				if (($(".definingAttributes")[0]) != null) {
					var attributes_container = $(".definingAttributes");	
				}
				else if (($(".product_sizes")[0]) != null) {
					var attributes_container = $(".product_sizes");
				}
				else if (($(".product_info")[0]) != null) {
					var attributes_container = $(".product_info");
				}
				
				var attributes = new Array();
				for (var i = 0; i < attributes_container.length; i++) {
					var attribute_selectors = attributes_container[i].querySelectorAll(".dijitSelect");
					for (var j = 0; j < attribute_selectors.length; j++) {
						attributes = attributes.concat(attribute_selectors[j]);
					}
				}
				
				var dijitSelect = new Array();
				for (var i = 0; i < attributes.length; i++) {
					dijitSelect[i] = dijit.registry.byNode(attributes[i]);
				}
				
				var singleSKU = true;
				for(var i=0; i<dijitSelect.length; i++){
					if (dijitSelect[i].options.length > 2)
					{
						singleSKU = false;
					}
				}
				
				if (!singleSKU)
				{
					shoppingActionsJS.selectedAttributes = new Object();
					wcTopic.publish('DefiningAttributes_Resolved_'+shoppingActionsJS.baseCatalogEntryId, shoppingActionsJS.baseCatalogEntryId, -1);
					for(var i=0; i<dijitSelect.length; i++){
						if(dijitSelect[i] != null){
							dijitSelect[i].value = "";
						}
					}
				}
				
			}
			if(typeof(ShipmodeSelectionExtJS)!= null && typeof(ShipmodeSelectionExtJS)!='undefined'){
				ShipmodeSelectionExtJS.setOrderItemId((serviceResponse.orderItem != null && serviceResponse.orderItem[0].orderItemId != null) ? serviceResponse.orderItem[0].orderItemId : serviceResponse.orderItemId);
			}
			wcTopic.publish('ProductAddedToCart');
		}
     /**
     * display an error message
     * @param (object) serviceResponse The service response object, which is the
     * JSON object returned by the service invocation
     */
		,failureHandler: function(serviceResponse) {

			if (serviceResponse.errorMessage) {
			 	if(serviceResponse.errorMessageKey == "_ERR_NO_ELIGIBLE_TRADING"){
			 		MessageHelper.displayErrorMessage(Utils.getLocalizationMessage("ERROR_CONTRACT_EXPIRED_GOTO_ORDER"));
 				} else if (serviceResponse.errorMessageKey == "_ERR_RETRIEVE_PRICE") {
					var tempString = Utils.getLocalizationMessage("GENERICERR_MAINTEXT", {0:Utils.getLocalizationMessage("GENERICERR_CONTACT_US")});
 					MessageHelper.displayErrorMessage(tempString);
 				} else {
 					MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
 				}
			} 
			else {
				 if (serviceResponse.errorMessageKey) {
					MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
				 }
			}
			
			if(serviceResponse.errorCode){
				wcTopic.publish("OrderError",serviceResponse);
			}

			cursor_clear();
		}

	}),
	
	/**
	 * Adds a pre-defined dynamic kit to a shopping cart in Ajax mode. A message is displayed after
	 * the service call.
	 * @constructor
	 */
	wcService.declare({
		id: "AddPreConfigurationToCart",
		actionId: "AddOrderItem",
		url: getAbsoluteURL() + "AjaxRESTOrderAddPreConfigurationToCart",
		formId: ""

     /**
     * display a success message
     * @param (object) serviceResponse The service response object, which is the
     * JSON object returned by the service invocation
     */

		,successHandler: function(serviceResponse) {
			MessageHelper.hideAndClearMessage();
			cursor_clear();
			if(shoppingActionsJS){
				
				var attributes = document.getElementsByName("attrValue");
			
				var singleSKU = true;
				
				for(var i=0; i<attributes.length; i++){
					if (attributes[i].options.length > 1)
					{
						singleSKU = false;
					}
				}
				
				if (!singleSKU)
				{
					shoppingActionsJS.selectedAttributes = new Object();
					for(var i=0; i<attributes.length; i++){
						if(attributes[i] != null){
							attributes[i].value = "";
							attributes[i].onchange();
						}
					}
				}
			}
			if(typeof(ShipmodeSelectionExtJS)!= null && typeof(ShipmodeSelectionExtJS)!='undefined'){
				ShipmodeSelectionExtJS.setOrderItemId(serviceResponse.orderItem[0].orderItemId);
			}
		}
     /**
     * display an error message
     * @param (object) serviceResponse The service response object, which is the
     * JSON object returned by the service invocation
     */
		,failureHandler: function(serviceResponse) {

			if (serviceResponse.errorMessage) {
			 	if(serviceResponse.errorMessageKey == "_ERR_NO_ELIGIBLE_TRADING"){
			 		MessageHelper.displayErrorMessage(Utils.getLocalizationMessage("ERROR_CONTRACT_EXPIRED_GOTO_ORDER"));
 				} else if (serviceResponse.errorMessageKey == "_ERR_RETRIEVE_PRICE") {
					var tempString = Utils.getLocalizationMessage("GENERICERR_MAINTEXT",{0:Utils.getLocalizationMessage("GENERICERR_CONTACT_US")});
 					MessageHelper.displayErrorMessage(tempString);
 				} else {
 					MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
 				}
			} 
			else {
				 if (serviceResponse.errorMessageKey) {
					MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
				 }
			}
			cursor_clear();
		}

	})
//-----------------------------------------------------------------
// Licensed Materials - Property of IBM
//
// WebSphere Commerce
//
// (C) Copyright IBM Corp. 2008, 2016 All Rights Reserved.
//
// US Government Users Restricted Rights - Use, duplication or
// disclosure restricted by GSA ADP Schedule Contract with
// IBM Corp.
//-----------------------------------------------------------------

/** 
 * @fileOverview This file provides the common render context variables and functions, 
 * and defines all the render contexts needed throughout the store.
 */

/** 
 * @class The CommonContextsJS class defines all the common variables and functions 
 * for the render contexts across all store pages.
 */
CommonContextsJS = {
	/**
	 * This variable stores the ID of the language that the store is currently using.
	 * @private
	 */
	langId: "-1",

	/**
	 * This variable stores the ID of the current store.
	 * @private
	 */	
	storeId: "",

	/**
	 * This variable stores the ID of the catalog that is used in the store.
	 * @private
	 */	
	catalogId: "",

	/** 
	 * Sets the common ids used in the store - language id, store id, and catalog id.
	 * 
	 * @param {string} langId The id of the store language.
	 * @param {string} storeId The id of the store.
	 * @param {string} langId The id of the catalog used in the store.
	 */
	setCommonParameters:function(langId,storeId,catalogId){
			this.langId = langId;
			this.storeId = storeId;
			this.catalogId = catalogId;
	},

	/** 
	 * Updates the specified context's property and assign it the desired value.
	 * 
	 * @param {string} contextId The id of the render context 
	 * @param {string} property The name of the context's property to update
	 * @param {string} value The value to update the specified property to
	 */
	setContextProperty:function(contextId,property,value){
        wcRenderContext.getRenderContextProperties(contextId)[property] = value;
	}

}

/**
 * Declares a new render context for Multiple Shipment Shipping & Billing display.
 */
wcRenderContext.declare("multipleShipmentDetailsContext", [], {shipmentDetailsArea: "update"}),

/**
 * Declares a new render context for Single Shipment Shipping Charge display.
 */
wcRenderContext.declare("singleShipmentShipChargeContext", [], null),

/**
 * Declares a new render context for Multiple Shipment Shipping Charge display.
 */
wcRenderContext.declare("multipleShipmentShipChargeContext", [], null),

/**
 * Declares a new render context for Single Shipment Shipping & Billing display.
 */
wcRenderContext.declare("traditionalShipmentDetailsContext", [], {shipmentDetailsArea: "update"}),

/**
 * Declares a new render context for the Current Order Totals display.
 */
wcRenderContext.declare("currentOrder_Context", [], null),

/**
 * Declares a new render context for creating/editing the shipping address
 * and initializes it with the shipping address id and address type to the default placeholder values.
 */
wcRenderContext.declare("editShippingAddressContext", [], {shippingAddress: "0",addressType: "ShippingAndBilling"}),

/**
 * Declares a new render context for dealing with states for the shipping addresses in all shipments
 * and initializes it with the shipping address id to the default placeholder values.
 */
wcRenderContext.declare("shippingAddressContext",[],{shippingAddress: "0"});

/**
 * Declares a new render context for the select Billing Address dropdowns,
 * and initializes each Billing Address dropdown with address id and billing url placeholders.
 * Even though BillingURL1, 2, 3 point to same BillingAddressDropDisplay.jsp we cannot use only one URL to submit 3 requests.
 * There are 3 billing dropdown boxes in the Checkout page and all needs to be refreshed on address add/change.
 * But using the same URL and submitting 3 requests separately to refresh 3 dropdown boxes doesn't work, 
 * and invariably one of the request doesn't come back with response. Solution is to use 3 different URLs as a workaround.
 * BillingURL1,2,3 are set to correct <c:url values in .JSP page using setContextPRoperty method..
 */
wcRenderContext.declare("billingAddressDropDownBoxContext", [], {billingAddress1: "0", billingAddress2: "0", billingAddress3: "0", billingURL1: "",billingURL2:"",billingURL3:"",areaNumber:'0',payment1: "", payment2: "", payment3: "", paymentTCId1: "", paymentTCId2: "", paymentTCId3: ""}),

/**
 * Declares a new render context for 3 payment areas
 * and initializes it with the payment method names, current area number, billing modes and current total price to the default placeholder values.
 * When the context changes the corresponding controller will be used and the paymentArea div will be populated with the required JSP file, based on the
 * selection made...ex: if Visa brand is selected in payment1, then paymentArea1 will get populated with contents of Visa.jsp
 */
wcRenderContext.declare("paymentContext", [], {payment1: "empty", payment2: "empty", payment3: "empty", currentAreaNumber: "1", billingMode1: "none", billingMode2: "none", billingMode3: "none",currentTotal:"0"}),

/**
 * Declares a new render context for showing/hiding the address form on the Checkout pages,
 * and initializes the show and hide area to a placeholder value.  
 */
wcRenderContext.declare("contextForMainAndAddressDiv", [], {showArea: "0",hideArea: "0"}),

/**
 * Declares a new render context for the select Shipping Address dropdown.
 */
wcRenderContext.declare("shippingAddressDropDownBoxContext", [], {}),

/**
 * Declares a new render context for the Category display with pagination.
 */
wcRenderContext.declare("CategoryDisplay_Context", [], {pageView:"", beginIndex:""}),

/**
 * Declares a new render context for the Sub-category display with pagination.
 */
wcRenderContext.declare("SubCategoryDisplay_Context", [], null),

/**
 * Declares a new render context for Shopping Cart with pagination,
 * and initializes it with the beginning index value. 
 */
wcRenderContext.declare("ShopCartPaginationDisplay_Context", [], {}),
/**
* Declares a new render context for Pending order details page with pagination,
* and initializes it with the beginning index value. 
*/
wcRenderContext.declare("PendingOrderPaginationDisplay_Context", [], {}),
/**
* Declares a new render context for the pending order details page with pagination,
* and initializes it with the beginning index value. 
*/
wcRenderContext.declare("PendingOrderDisplay_Context", [], {beginIndex: "0"}),

/**
 * Declares a new render context for Single Shipment Order Summmary/Confirmation with pagination,
 * and initializes it with the beginning index value. 
 */
wcRenderContext.declare("OrderItemPaginationDisplay_Context", [], {beginIndex: "0"}),

/**
 * Declares a new render context for the Order Status Details with pagination,
 * and initializes it with the beginning index value. 
 */
wcRenderContext.declare("OrderDetailPaginationDisplay_Context", [], {beginIndex: "0"}),

/**
 * Declares a new render context for Multiple Shipment Order Summary/Confirmation with pagination,
 * and initializes it with the beginning index value.
 */
wcRenderContext.declare("MSOrderItemPaginationDisplay_Context", [], {beginIndex: "0"}),

/**
 * Declares a new render context for the Coupon Wallet display.
 */
wcRenderContext.declare("CouponDisplay_Context", [], null),
/**
 * Declares a new render context for the Promotion Choice of free gifts pop-up display.
 */
wcRenderContext.declare("PromotionFreeGifts_Context", [], {}),

/**
 *  Declares a new render context for the saved orders list.
 */
wcRenderContext.declare("ListOrdersDisplay_Context", [], {startNumber: "0"}),

/**
 * Declares a new render context for the scheduled orders status display.
 */
wcRenderContext.declare("ScheduledOrdersStatusDisplay_Context", [], {beginIndex: "0", selectedTab: "Scheduled"}),

/**
 * Declares a new render context for the processed orders status display.
 */
wcRenderContext.declare("ProcessedOrdersStatusDisplay_Context", [], {beginIndex: "0", selectedTab: "PreviouslyProcessed"}),

/**
 * Declares a new render context for the waiting-for-approval orders status display.
 */
wcRenderContext.declare("WaitingForApprovalOrdersStatusDisplay_Context", [], {beginIndex: "0", selectedTab: "WaitingForApproval"}),

/**
 * Declares a new render context for the Browsing History Espot.
 */
wcRenderContext.declare("BrowsingHistoryContext", [], {status:"init"}),

/**
 * Declares a new render context for the Browsing History Display in My Account.
 */
wcRenderContext.declare("BrowsingHistoryDisplay_Context", [], {currentPage: "0", pageView: ""}),

/**
 * Declares a new render context for the subscription display area on category pages.
 */
wcRenderContext.declare("CategorySubscriptionContext", [], null),

/**
 * Declares a new render context for the recurring order display.
 */
wcRenderContext.declare("RecurringOrderDisplay_Context", [], {beginIndex: "0"}),

/**
 * Declares a new render context for the subscription display.
 */
wcRenderContext.declare("SubscriptionDisplay_Context", [], {beginIndex: "0"}),

/**
 * Declares a new render context for the recent recurring order display.
 */
wcRenderContext.declare("RecentRecurringOrderDisplay_Context", [], {beginIndex: "0",isMyAccountMainPage:"true"}),

/**
 * Declares a new render context for the recent subscription display.
 */
wcRenderContext.declare("RecentSubscriptionDisplay_Context", [], {beginIndex: "0",isMyAccountMainPage:"true"}),

/**
 * Declares a new render context for the recurring order child orders display.
 */
wcRenderContext.declare("RecurringOrderChildOrdersDisplay_Context", [], {beginIndex: "0",orderId: ""}),

/**
 * Declares a new render context for the subscription child orders display.
 */
wcRenderContext.declare("SubscriptionChildOrdersDisplay_Context", [], {beginIndex: "0",orderItemId: "",subscriptionName: ""}),

/**
 * Declares a new render context for the QuickInfo.
 */
wcRenderContext.declare("QuickInfoContext", ["quickInfoRefreshArea"], {}),

/**
 * Declares a new render context for the Discounts.
 */
wcRenderContext.declare("DiscountDetailsContext", [], null),

/**
 * Declares a new render context for the Discounts in quick info.
 */
wcRenderContext.declare("QuickInfoDiscountDetailsContext", [], {}),

/**
 * Declares a new render context for double content area espot.
 */
wcRenderContext.declare("DoubleContentAreaESpot_Context", [], {emsName: ""}),

/**
 * Declares a new render context for scrollable espot.
 */
wcRenderContext.declare("ScrollableESpot_Context", [], {emsName: ""}),

/**
 * Declares a new render context for top categories espot.
 */
wcRenderContext.declare("TopCategoriesESpot_Context", [], {emsName: ""}),

/**
 * Declares a new render context for featured products in category espot.
 */
wcRenderContext.declare("CategoryFeaturedProductsESpot_Context", [], {emsName: ""}),

/**
 * Declares a new render context for home hero espot.
 */
wcRenderContext.declare("HomeHeroESpot_Context", [], {emsName: ""}),

/**
 * Declares a new render context for home left espot.
 */
wcRenderContext.declare("HomeLeftESpot_Context", [], {emsName: ""}),

/**
 * Declares a new render context for home right top espot.
 */
wcRenderContext.declare("HomeRightTopESpot_Context", [], {emsName: ""}),

/**
 * Declares a new render context for home right bottom espot.
 */
wcRenderContext.declare("HomeRightBottomESpot_Context", [], {emsName: ""}),

/**
 * Declares a new render context for tall double espot.
 */
wcRenderContext.declare("TallDoubleContentAreaESpot_Context", [], {emsName: ""}),

/**
 * Declares a new render context for top category hero espot.
 */
wcRenderContext.declare("TopCategoryHeroESpot_Context", [], {emsName: ""}),

/**
 * Declares a new render context for top category tall double espot.
 */
wcRenderContext.declare("TopCategoryTallDoubleESpot_Context", [], {emsName: ""}),


wcRenderContext.declare("AttachmentPagination_Context", [], {beginIndex: "0"})
//-----------------------------------------------------------------
// Licensed Materials - Property of IBM
//
// WebSphere Commerce
//
// (C) Copyright IBM Corp. 2008, 2016 All Rights Reserved.
//
// US Government Users Restricted Rights - Use, duplication or
// disclosure restricted by GSA ADP Schedule Contract with
// IBM Corp.
//-----------------------------------------------------------------

/**
 * @fileOverview This file provides the common controller variables and functions,
 * and links these controllers to listen to the defined render contexts in CommonContextsDeclarations.js.
 */

/**
 * @class The CommonControllersDeclarationJS class defines all the common variables and functions
 * for the controllers of the defined render contexts across all store pages.
 */
CommonControllersDeclarationJS = {
	
	/**
        * This variable stores the ID of the language that the store is currently using.
        * @private
        */
       langId: "-1",

       /**
        * This variable stores the ID of the current store.
        * @private
        */
       storeId: "",

       /**
        * This variable stores the ID of the catalog that is used in the store.
        * @private
        */
       catalogId: "",

       /**
        * Sets the common ids used in the store - language id, store id, and catalog id.
        *
        * @param {string} langId The id of the store language.
        * @param {string} storeId The id of the store.
        * @param {string} langId The id of the catalog used in the store.
        */
       setCommonParameters:function(langId,storeId,catalogId){
              this.langId = langId;
              this.storeId = storeId;
              this.catalogId = catalogId;
       },

       /**
        * Sets the URL of the specified refresh area.
        *
        * @param {string} refreshAreaId The id of the target refresh area.
        * @param {string} url The link to specify for the refresh area.
        */
       setRefreshURL:function(refreshAreaId,url){
              $("#" + refreshAreaId).attr("refreshurl", url);
       },

        declareAccountCouponRefreshArea:function() {
            // ============================================
            // div: CouponDisplay_Widget refresh area
            // Declares a new refresh controller for Coupon Wallet display.
            var myWidgetObj = $("#CouponDisplay_Widget");

            // model change
            wcTopic.subscribe(["AjaxCouponsAddRemove","AjaxWalletItemProcessServiceDelete"], function() {
                myWidgetObj.refreshWidget("refresh");
            });

            // initialize widget
            myWidgetObj.refreshWidget();
        },

        declareShopCartDisplayRefreshArea: function() {
            // ============================================
            // div: ShopCartDisplay refresh area
            // Declares a new refresh controller for the Shopping Cart display.
            var myWidgetObj = $("#ShopCartDisplay");
            var myRCProperties = wcRenderContext.getRenderContextProperties("ShopCartPaginationDisplay_Context");
            
            /**
             * Refreshs the shopping cart area when an update to the order is made,
             * such as add/remove items or update quantity/promotions etc.
             * This function is called when a modelChanged event is detected.
             */
            wcTopic.subscribe(order_updated, function() {
                myWidgetObj.refreshWidget("refresh", myRCProperties);
                submitRequest(); //Till shop cart is refreshed, do not allow any other requests..
                cursor_wait();
            });
            
            /**
             * Displays the discounts and promotions area upon a successful refresh.
             *
             * @param {object} widget The registered refresh area
             */
            var postRefreshHandler = function () {
                resetRequest(); //Shop cart is refreshed, give the control to shopper...
                if (typeof(savedOrdersJS) != null && typeof(savedOrdersJS) != 'undefined') {
                    savedOrdersJS.isCurrentOrderPage(true);
                }
                // Order level discount tooltip section - if the tooltip is defined, show the section after area is refreshed
                $("#discountDetailsSection").css("display", "block");
                // Promotion code tooltip section - if the tooltip is defined, show the section after area is refreshed
                $("#appliedPromotionCodes").css("display", "block");
                
                // select the proper shipmode that is saved in the cookie
                var orderId = myRCProperties["orderId"];
                if ($("#currentOrderId").length) {
                    orderId = document.getElementById("currentOrderId").value;
                }
                ShipmodeSelectionExtJS.displaySavedShipmentTypeForOrder(orderId);
                if ($("#OrderFirstItemId").length) {
                    ShipmodeSelectionExtJS.orderItemId = document.getElementById("OrderFirstItemId").value;
                }
                
                // evaluate scripts in shopping list
				/* TODO - Fix globalEval issue later.
                $('div[id^="shoppingListScript_"]').each(function(i, e) {
                   $.globalEval($(e).html()); 
                });
                
                $('input[id^="orderItem_"]').each(function(i, e) {
                    if ($('addToRequisitionListScript_' + $(e).val()) != null) {
                        $.globalEval($('addToRequisitionListScript_' + $(e).val()).html());
                    }
                    if ($('addReqListsJS_' + $(e).val()) != null) {
                        $.globalEval('addReqListsJS' + $(e).val() + '.setCatEntryId("' + $('catalogId_' + $(e).attr("id").substring($(e).attr("id").indexOf('_')+1)).val() + '");');
                    }
                });*/
                
                cursor_clear();
		/* APPLEPAY BEGIN */
		if (typeof(showApplePayButtons) == "function") {
			showApplePayButtons();
		}
		/* APPLEPAY END */
		
            };
            
            // initialize widget
            myWidgetObj.refreshWidget({postRefreshHandler: postRefreshHandler});
        },
        
		declareShopCartPagingDisplayRefreshArea: function() {
            // ============================================
            // div: ShopCartPagingDisplay refresh area
            // Declares a new refresh controller for the Shopping Cart pagination display.
            var myWidgetObj = $("#ShopCartPagingDisplay");
			wcRenderContext.addRefreshAreaId("ShopCartPaginationDisplay_Context", "ShopCartPagingDisplay");
            var myRCProperties = wcRenderContext.getRenderContextProperties("ShopCartPaginationDisplay_Context");
		   /**
			* Displays the previous/next page of order items in the shopping cart.
			* This function is called when a render context changed event is detected.
			*
			* @param {string} message The render context changed event message
			* @param {object} widget The registered refresh area
			*/
			var renderContextChangedHandler = function() {
				if(wcRenderContext.testForChangedRC("ShopCartPaginationDisplay_Context", ["beginIndex"])){
                     myWidgetObj.refreshWidget("refresh", myRCProperties);
				}
            };
            
		   /**
			* Hide the progress bar upon a successful refresh.
			*
			* @param {object} widget The registered refresh area
			*/
            var postRefreshHandler = function () {
              cursor_clear();

              //select the proper shipmode that is saved in the cookie
              var orderId = myRCProperties["orderId"];
              if(document.getElementById("currentOrderId")) {
                orderId = document.getElementById("currentOrderId").value;
              }
              ShipmodeSelectionExtJS.displaySavedShipmentTypeForOrder(orderId);
              // evaluate scripts in shopping list
              $('div[id^="shoppingListScript_"]').each(function(i, e){
                 $.globalEval($(e).html());
              });
              $('input[id^="orderItem_"]').each(function(i,orderItem) {
                if($('addToRequisitionListScript_' + orderItem.value) != null){
                      $.globalEval($('addToRequisitionListScript_' + orderItem.value).innerHTML);
                }
                if($('addReqListsJS_' + orderItem.value).length != 0){
                  $.globalEval('addReqListsJS' + orderItem.value + '.setCatEntryId("' + $('catalogId_' + (orderItem.id.substring(orderItem.id.indexOf('_') + 1))).value + '");');
                }
              });
			};
            
            // initialize widget
            myWidgetObj.refreshWidget({renderContextChangedHandler: renderContextChangedHandler, postRefreshHandler: postRefreshHandler});
        },
		
		declarePromotionFreeGiftsDisplayRefreshArea: function() {
            // ============================================
            // div: PromotionFreeGiftsDisplay refresh area
            // Declares a new refresh controller for the Promotion Free Gifts display.
            var myWidgetObj = $("#PromotionFreeGiftsDisplay");
            wcRenderContext.addRefreshAreaId("PromotionFreeGifts_Context", "PromotionFreeGiftsDisplay");
            var myRCProperties = wcRenderContext.getRenderContextProperties("PromotionFreeGifts_Context");
            
            
			var renderContextChangedHandler = function() {
				myWidgetObj.refreshWidget("refresh", myRCProperties);
            };

            var postRefreshHandler = function () {
			    PromotionChoiceOfFreeGiftsJS.showFreeGiftsDialog();
			};
            
            // initialize widget
            myWidgetObj.refreshWidget({renderContextChangedHandler: renderContextChangedHandler, postRefreshHandler: postRefreshHandler});
        },
		
        declareRecentRecurringOrderDisplayRefreshArea: function() {
            // ============================================
            // div: RecentRecurringOrderDisplay refresh area
            // Declares a new refresh controller for Recent Recurring Orders in My Account landing page.
            var myWidgetObj = $("#RecentRecurringOrderDisplay");
            wcRenderContext.addRefreshAreaId("RecentRecurringOrderDisplay_Context", "RecentRecurringOrderDisplay");
            var myRCProperties = wcRenderContext.getRenderContextProperties("RecentRecurringOrderDisplay_Context");
            
            /**
             * Displays the previous/next page of recurring orders.
             * This function is called when a render context changed event is detected.
             */
            wcTopic.subscribe("AjaxCancelSubscription", function () {
                myWidgetObj.refreshWidget("refresh", myRCProperties);
            });
            
            /**
            * Hide the progress bar upon a successful refresh.
            */
            var postRefreshHandler = function() {
                cursor_clear();
            };
            
            // initialize widget
            myWidgetObj.refreshWidget({postRefreshHandler: postRefreshHandler});
        },
        
        declareRecentSubscriptionDisplayRefreshArea: function() {
            // ============================================
            // div: RecentSubscriptionDisplay refresh area
            // Declares a new refresh controller for recent Subscription display in My Account landing page.
            var myWidgetObj = $("#RecentSubscriptionDisplay");
            wcRenderContext.addRefreshAreaId("RecentSubscriptionDisplay_Context", "RecentSubscriptionDisplay");
            var myRCProperties = wcRenderContext.getRenderContextProperties("RecentSubscriptionDisplay_Context");
            
            /**
             * Displays the previous/next page of subscriptions.
             * This function is called when a render context changed event is detected.
             */
            wcTopic.subscribe("AjaxCancelSubscription", function () {
                myWidgetObj.refreshWidget("refresh", myRCProperties);
            });
             
            /**
            * Hide the progress bar upon a successful refresh.
            */
            var postRefreshHandler = function() {
                cursor_clear();
            };
            
            // initialize widget
            myWidgetObj.refreshWidget({postRefreshHandler: postRefreshHandler});
        },
        
        declareOrderItemPaginationDisplayRefreshArea: function(widgetId) {
            // ============================================
            // old controller: OrderItemPaginationDisplayController
            // div: OrderConfirmPagingDisplay refresh area
            // Declares a new refresh controller for Single Shipment Order Item display with pagination
            // on the Order Summary and Confirmation pages.
        	if(typeof widgetId == "object" || typeof widgetId == "array") {
        		widgetId = widgetId[0];
        	}
        	
            var myWidgetObj = $("#" + widgetId);
            wcRenderContext.addRefreshAreaId("OrderItemPaginationDisplay_Context", widgetId);
            var myRCProperties = wcRenderContext.getRenderContextProperties("OrderItemPaginationDisplay_Context");
            
            /**
             * Displays the previous/next page of order items for Single Shipment Order Summary/Confirmation display.
             * This function is called when a render context changed event is detected.
             */
            var renderContextChangedHandler = function() {
                if (wcRenderContext.testForChangedRC("OrderItemPaginationDisplay_Context", ["beginIndex"])){
                	myWidgetObj.refreshWidget("refresh", myRCProperties);
                }
            }
           
            /**
             * Hide the progress bar upon a successful refresh.
             */
            var postRefreshHandler = function() {
                cursor_clear();
                if (myRCProperties["analytics"] == 'true') {
                    wcTopic.publish("order_contents_ProductRec", $("#orderPartNumbers").val());
                }
            }          
            
            // initialize widget
            myWidgetObj.refreshWidget({renderContextChangedHandler: renderContextChangedHandler, postRefreshHandler: postRefreshHandler});
        },
        
        declareRecurOrderDisplayRefreshArea: function() {
            // ============================================
            // div: RecurringOrderDisplay refresh area
            // Declares a new refresh controller for Recurring Order display with pagination
            // in My Recurring Order page.
            var myWidgetObj = $("#RecurringOrderDisplay");
            wcRenderContext.addRefreshAreaId("RecurringOrderDisplay_Context", "RecurringOrderDisplay");
            var myRCProperties = wcRenderContext.getRenderContextProperties("RecurringOrderDisplay_Context");
            
            /**
             * Displays the previous/next page of recurring orders.
             * This function is called when a render context changed event is detected.
             */
             
            wcTopic.subscribe("AjaxCancelSubscription", function () {
                myWidgetObj.refreshWidget("refresh", myRCProperties);
            });
            
            
            var renderContextChangedHandler = function() {
                if(wcRenderContext.testForChangedRC("RecurringOrderDisplay_Context", ["beginIndex"])){
                    myWidgetObj.refreshWidget("refresh", myRCProperties);
                }
            }
           
            /**
             * Hide the progress bar upon a successful refresh.
             */
            var postRefreshHandler = function() {
                cursor_clear();
            }          
            
            // initialize widget
            myWidgetObj.refreshWidget({renderContextChangedHandler: renderContextChangedHandler, postRefreshHandler: postRefreshHandler});
        },

        declareRecurOrderChildOrdersRefreshArea: function() {
            // ============================================
            // div: RecurringOrderChildOrdersDisplay refresh area
            // Declares a new refresh controller for Recurring Order child orders display with pagination
            // in Recurring Order Details History page.
            var myWidgetObj = $("#RecurringOrderChildOrdersDisplay");
            var myRCProperties = wcRenderContext.getRenderContextProperties("RecurringOrderChildOrdersDisplay_Context");
            
            /**
             * Displays the previous/next page of recurring orders.
             * This function is called when a render context changed event is detected.
             */
            var renderContextChangedHandler = function() {
                if(wcRenderContext.testForChangedRC("RecurringOrderChildOrdersDisplay_Context", ["beginIndex"])){
                    myWidgetObj.refreshWidget("refresh", myRCProperties);
                }
            };
           
            /**
             * Hide the progress bar upon a successful refresh.
             */
            var postRefreshHandler = function() {
                cursor_clear();
            }          
            
            // initialize widget
            myWidgetObj.refreshWidget({renderContextChangedHandler: renderContextChangedHandler, postRefreshHandler: postRefreshHandler});
        },
        
        declareSubscriptionDisplayRefreshArea: function() {
            // ============================================
            // div: SubscriptionDisplay refresh area
            // Declares a new refresh controller for Subscription display with pagination
            // in My Subscription page.
            var myWidgetObj = $("#SubscriptionDisplay");
            wcRenderContext.addRefreshAreaId("SubscriptionDisplay_Context", "SubscriptionDisplay");
            var myRCProperties = wcRenderContext.getRenderContextProperties("SubscriptionDisplay_Context");
            
            /**
             * Displays the previous/next page of subscriptions.
             * This function is called when a render context changed event is detected.
             */
            wcTopic.subscribe("AjaxCancelSubscription", function () {
                myWidgetObj.refreshWidget("refresh", myRCProperties);
            });
            
            
            var renderContextChangedHandler = function() {
                if(wcRenderContext.testForChangedRC("SubscriptionDisplay_Context", ["beginIndex"])){
                    myWidgetObj.refreshWidget("refresh", myRCProperties);
                }
            }
           
            /**
             * Hide the progress bar upon a successful refresh.
             */
            var postRefreshHandler = function() {
                cursor_clear();
            }          
            
            // initialize widget
            myWidgetObj.refreshWidget({renderContextChangedHandler: renderContextChangedHandler, postRefreshHandler: postRefreshHandler});
        },
        
        declareSubscriptionChildOrdersRefreshArea: function() {
            // ============================================
            // div: SubscriptionChildOrdersDisplay refresh area
            // Declares a new refresh controller for Subscription child orders display with pagination
            // in Subscription Details History page.
            var myWidgetObj = $("#SubscriptionChildOrdersDisplay");
            var myRCProperties = wcRenderContext.getRenderContextProperties("SubscriptionChildOrdersDisplay_Context");
            
            /**
             * Displays the previous/next page of subscriptions.
             * This function is called when a render context changed event is detected.
             */
            var renderContextChangedHandler = function() {
                if(wcRenderContext.testForChangedRC("SubscriptionChildOrdersDisplay_Context", ["beginIndex"])){
                    myWidgetObj.refreshWidget("refresh", myRCProperties);
                }
            };
           
            /**
             * Hide the progress bar upon a successful refresh.
             */
            var postRefreshHandler = function() {
                cursor_clear();
            }          
            
            // initialize widget
            myWidgetObj.refreshWidget({renderContextChangedHandler: renderContextChangedHandler, postRefreshHandler: postRefreshHandler});
        },
    
        declareQuickInfoDetails: function() {
            var widgetObj = $("#quickInfoRefreshArea"),
                rcProperties = wcRenderContext.getRenderContextProperties("QuickInfoContext");
            
            widgetObj.refreshWidget({
                formId: "",
                /**
                 * Refreshs the wishlist drop down in the quick info popup.
                 */
                renderContextChangedHandler: function() {
                    widgetObj.refreshWidget("refresh", rcProperties);
                },
                
                /**
                 * Hide the progress bar upon a successful refresh.
                 */
                postRefreshHandler: function() {
                	if ($("#catEntryParamsForJS").length){
                        var catEntryParams = $.parseJSON($("#catEntryParamsForJS").val());
                    }
                	
                    if ($("#QuickInfostoreParams").length){
                        var storeParams = $("#QuickInfostoreParams").val();
                        var shoppingListNames = $("#QuickInfoshoppingListNames").val();

                        shoppingListJSQuickInfo = new ShoppingListJS($.parseJSON(storeParams), catEntryParams, $.parseJSON(shoppingListNames),"shoppingListJSQuickInfo");


                        if (!this.quickInfoEvenSubscribed){
                            this.quickInfoEvenSubscribed = true;
                            wcTopic.subscribe("DefiningAttributes_Resolved", function(catEntryId, productId) {
                                shoppingListJSQuickInfo.setItemId(catEntryId, productId);
                            });
                            wcTopic.subscribe("QuickInfo_attributesChanged", function(catEntryAttributes) {
                                shoppingListJSQuickInfo.setCatEntryAttributes(catEntryAttributes);
                            });
                            wcTopic.subscribe("Quantity_Changed", function(catEntryQuantityObject) {
                                shoppingListJSQuickInfo.setCatEntryQuantity(catEntryQuantityObject);
                            });
                            wcTopic.subscribe("ShoppingList_Changed", function(serviceResponse) {
                                shoppingListJSQuickInfo.updateShoppingListAndAddItem(serviceResponse);
                            });
                            wcTopic.subscribe("ShoppingListItem_Added", function() {
                                shoppingListJSQuickInfo.deleteItemFromCart();
                            });
                            $("#QuickInfoaddToShoppingListDropdown").on("mouseover", function(){
                                shoppingListJSQuickInfo.mouseOnArrow = true;
                            });
                            $("#QuickInfoShoppingList_0").on("mouseover", function(){
                                shoppingListJSQuickInfo.exceptionFlag = true; $("#QuickInfoShoppingListLink_0").focus();
                            });
                        }

                        var catEntryId = catEntryParams.id;
                        if(null != catEntryId && '' != catEntryId){
                            wcRenderContext.updateRenderContext('QuickInfoDiscountDetailsContext', {productId: catEntryParams.id});
                        }
                    }
                    if ($("#catEntryParamsForJS").length){
                        QuickInfoJS.catEntryParams = $.parseJSON($("#catEntryParamsForJS").val());
                    }
                    //the quick info dialog is hidden by default. We have to display it after the area is refreshed.
                    var quickInfoPopup = $("#quickInfoPopup").data("wc-WCDialog");
                    if (quickInfoPopup) {
                        closeAllDialogs(); //close other dialogs(quickinfo dialog, etc) before opening this.
                        // if itemId is present, then quickInfo popup is from change attribute link in shopping cart page, which will explicitly set the quantity
                        if(QuickInfoJS.itemId == ''){
                            QuickInfoJS.setCatEntryQuantity(1);
                            QuickInfoJS.selectDefaultSwatch();
                        } else {
                            QuickInfoJS.selectCurrentAttributes();
                        }
                        quickInfoPopup.open();
                        // disable dialog re-position for ios and android right after the dialog is opened, this is to avoid virtual keyboard conflict
                        //if (ios || android) {
                        // quickInfoPopup._relativePosition = new Object();
                        //}
                        if(typeof TealeafWCJS !== 'undefined'){
                            TealeafWCJS.rebind("quickInfoPopup");
                        }
                    }else {
                        console.debug("quickInfoPopup does not exist");
                    }
                    cursor_clear();
                }
            });
        },
        
        /**
         * Refresh controller for fetching discount details for quick info.
         */
        declareQuickInfoDiscountDetailsController: function() {
            var widgetObj = $("#quickInfoDiscountDetailsRefreshArea");
            wcRenderContext.addRefreshAreaId("QuickInfoDiscountDetailsContext", "quickInfoDiscountDetailsRefreshArea");
            var renderContextProperties = wcRenderContext.getRenderContextProperties("QuickInfoDiscountDetailsContext");
            
            widgetObj.refreshWidget({
                formId: "", 
                /**
                 * Refreshes the discount section.
                 */
                renderContextChangedHandler: function() {
                    widgetObj.refreshWidget("refresh", renderContextProperties);
                },
                /**
                 * Hide the progress bar upon a successful refresh.
                 */
                postRefreshHandler: function() {
                    cursor_clear();
                }
            });
            
        },
		
		declareMSOrderItemPagingDisplayRefreshArea:function(widgetName) {

			var contextName = "MSOrderItemPaginationDisplay_Context";
			if(typeof widgetName == "object") {
				widgetName = widgetName[0];
			}
			var myWidgetObj = $("#"+widgetName);

			if (!wcRenderContext.checkIdDefined(contextName)) {
				wcRenderContext.declare(contextName, [],null);
			}
			var myRCProperties = wcRenderContext.getRenderContextProperties(contextName);
			wcRenderContext.addRefreshAreaId(contextName, widgetName);
			
		   /** 
			* Displays the previous/next page of order items for Multiple Shipment Order Summary/Confirmation display.
			* This function is called when a render context changed event is detected. 
			* 
			*/
		   renderContextChangedHandler = function() {
			    if(wcRenderContext.testForChangedRC(contextName,["beginIndex"])){
					myWidgetObj.refreshWidget("refresh", myRCProperties);
				}
		   };

		   /** 
			* Hide the progress bar upon a successful refresh.
			* 
			* @param {object} widget The registered refresh area
			*/
		   postRefreshHandler = function() {
				  cursor_clear();
				  if (myRCProperties["analytics"] == 'true') {
					  wcTopic.publish("order_contents_ProductRec", $("#orderPartNumbers").value);
				  }
		   };

			// initialize widget
			myWidgetObj.refreshWidget({renderContextChangedHandler: renderContextChangedHandler, postRefreshHandler: postRefreshHandler});
		},

        /** 
         * Declares a new refresh controller for Single Shipment Order Item display with pagination
         * on the Order Summary pages when inegrating with Sterling. 
         */
        declareSSFSOrderItemPaginationDisplayController: function() {
            var myWidgetObj = $("#OrderConfirmPagingDisplay");
            wcRenderContext.addRefreshAreaId("OrderItemPaginationDisplay_Context", "OrderConfirmPagingDisplay");
            var myRCProperties = wcRenderContext.getRenderContextProperties("OrderItemPaginationDisplay_Context");

            // initialize widget
            myWidgetObj.refreshWidget({
                /** 
                 * Displays the previous/next page of order items for Single Shipment Order Summary/Confirmation display.
                 * This function is called when a render context changed event is detected.
                 */
                renderContextChangedHandler: function() {
                    if(wcRenderContext.testForChangedRC("OrderItemPaginationDisplay_Context", ["beginIndex"])){
                        myWidgetObj.refreshWidget("refresh", myRCProperties);
                    }
                },

                /** 
                 * Hide the progress bar upon a successful refresh.
                 */
                postRefreshHandler: function() {
                    var orderStr = document.getElementById("jsonOrderStr").innerHTML;
                    var beginIndex = myRCProperties['beginIndex'];
                    var pageSize = myRCProperties['pageSize'];
                    sterlingIntegrationJS.populateOrderLineInfoForSingleShipment(orderStr, beginIndex, pageSize);
                    cursor_clear();
                }
            });
        },

        /** 
         * Declares a new refresh controller for Multiple Shipment Order Item display with pagination
         * on the Order Summary when integrating with Sterling.
         */
        declareSSFSMSOrderItemPaginationDisplayController: function() {
            var myWidgetObj = $("#MSOrderDetailPagingDisplay");
            wcRenderContext.addRefreshAreaId("MSOrderItemPaginationDisplay_Context", "MSOrderDetailPagingDisplay");
            var myRCProperties = wcRenderContext.getRenderContextProperties("MSOrderItemPaginationDisplay_Context");

            // initialize widget
            myWidgetObj.refreshWidget({
                /** 
                 * Displays the previous/next page of order items for Multiple Shipment Order Summary/Confirmation display.
                 * This function is called when a render context changed event is detected. 
                 */
                renderContextChangedHandler: function() {
                    if(wcRenderContext.testForChangedRC("MSOrderItemPaginationDisplay_Context", ["beginIndex"])){
                        myWidgetObj.refreshWidget("refresh", myRCProperties);
                    }
                },

                /** 
                 * Hide the progress bar upon a successful refresh.
                 */
                postRefreshHandler: function() {
                    var orderStr = document.getElementById("jsonOrderStr").innerHTML;
                    var beginIndex = myRCProperties['beginIndex'];
                    var pageSize = myRCProperties['pageSize'];
                    sterlingIntegrationJS.populateOrderLineInfoForMultipleShipment(orderStr, beginIndex, pageSize);
                    cursor_clear();
                }
            });
        }
}

// convert in future - move from CommonControllersDeclaration.js: 
        // id: "ShopCartPaginationDisplayController",
        // id: "PendingOrderPaginationDisplayController",
        // id: "ListOrdersDisplay_Controller",
        // id: "PendingOrderDisplayController",
        // id: "BrowsingHistoryController",
        // id: "BrowsingHistoryDisplay_Controller",
        // id: "CategorySubscriptionController",
        // id: "RecentSubscriptionDisplayController",
        // id: "DiscountDetailsController",
        // id: "DoubleContentAreaESpot_Controller",
        // id: "ScrollableESpot_Controller",
        // id: "TopCategoriesESpot_Controller",
        // id: "CategoryFeaturedProductsESpot_Controller",
        // id: "HomeHeroESpot_Controller",
        // id: "HomeLeftESpot_Controller",
        // id: "HomeRightTopESpot_Controller",
        // id: "HomeRightBottomESpot_Controller",
        // id: "TallDoubleContentAreaESpot_Controller",
        // id: "TopCategoryHeroESpot_Controller",
        // id: "TopCategoryTallDoubleESpot_Controller",
        // id: "AttachmentPagination_Controller",

//-----------------------------------------------------------------
// Licensed Materials - Property of IBM
//
// WebSphere Commerce
//
// (C) Copyright IBM Corp. 2009, 2014 All Rights Reserved.
//
// US Government Users Restricted Rights - Use, duplication or
// disclosure restricted by GSA ADP Schedule Contract with
// IBM Corp.
//-----------------------------------------------------------------

/** 
 * @fileOverview This javascript file declares services used by Dynamic Kits. 
 * @version 1.0
 */

	/**
	 * Adds a pre-defined dynamic kit to a shopping cart in Ajax mode. A message is displayed after
	 * the service call.
	 * @constructor
	 */
	wcService.declare({
		id: "AjaxAddPreConfigurationToCart",
		actionId: "AjaxAddOrderItem",
		url: getAbsoluteURL() + "AjaxRESTOrderAddPreConfigurationToCart",
		formId: ""

     /**
     * display a success message
     * @param (object) serviceResponse The service response object, which is the
     * JSON object returned by the service invocation
     */

		,successHandler: function(serviceResponse) {
			MessageHelper.hideAndClearMessage();
			MessageHelper.displayStatusMessage(MessageHelper.messages["SHOPCART_ADDED"]);
			cursor_clear();
			if(categoryDisplayJS){
				
				var attributes = document.getElementsByName("attrValue");
			
				var singleSKU = true;
				
				for(var i=0; i<attributes.length; i++){
					if (attributes[i].options.length > 1)
					{
						singleSKU = false;
					}
				}
				
				if (!singleSKU)
				{
					categoryDisplayJS.selectedAttributes = [];
					for(var i=0; i<attributes.length; i++){
						if(attributes[i] != null){
							attributes[i].value = "";
						}
					}
				}
			}
			if(typeof(ShipmodeSelectionExtJS)!= null && typeof(ShipmodeSelectionExtJS)!='undefined'){
				ShipmodeSelectionExtJS.setOrderItemId(serviceResponse.orderItem[0].orderItemId);
			}
		}
     /**
     * display an error message
     * @param (object) serviceResponse The service response object, which is the
     * JSON object returned by the service invocation
     */
		,failureHandler: function(serviceResponse) {

			if (serviceResponse.errorMessage) {
			 	if(serviceResponse.errorMessageKey == "_ERR_NO_ELIGIBLE_TRADING"){
			 		MessageHelper.displayErrorMessage(MessageHelper.messages["ERROR_CONTRACT_EXPIRED_GOTO_ORDER"]);
 				} else if (serviceResponse.errorMessageKey == "_ERR_RETRIEVE_PRICE") {
 					MessageHelper.displayErrorMessage(MessageHelper.messages["ERROR_RETRIEVE_PRICE"]);
 				} else {
 					MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
 				}
			} 
			else {
				 if (serviceResponse.errorMessageKey) {
					MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
				 }
			}
			cursor_clear();
		}

	}),

   /**
   * Adds a pre-defined dynamic kit to a shopping cart in non-Ajax mode. Upon a successful request,
   * the shopping cart page is loaded. An error message is displayed otherwise.
   * @constructor
   */
	wcService.declare({
		id: "AjaxAddPreConfigurationToCart_shopCart",
		actionId: "AjaxAddOrderItem",
		url: getAbsoluteURL() + "AjaxRESTOrderAddPreConfigurationToCart",
		formId: ""

     /**
     * redirects to the shopping cart page
     * @param (object) serviceResponse The service response object, which is the
     * JSON object returned by the service invocation
     */
		,successHandler: function(serviceResponse) {
			//Now delete from cart..
			var url = appendWcCommonRequestParameters("AjaxOrderItemDisplayView?storeId=" + ServicesDeclarationJS.storeId + "&catalogId=" + ServicesDeclarationJS.catalogId + "&langId=" + ServicesDeclarationJS.langId);
			document.location.href = url;
		}
     /**
     * display an error message
     * @param (object) serviceResponse The service response object, which is the
     * JSON object returned by the service invocation
     */
		,failureHandler: function(serviceResponse) {

			if (serviceResponse.errorMessage) {
			 	if(serviceResponse.errorMessageKey == "_ERR_NO_ELIGIBLE_TRADING"){
			 		MessageHelper.displayErrorMessage(MessageHelper.messages["ERROR_CONTRACT_EXPIRED_GOTO_ORDER"]);
			 	} else if (serviceResponse.errorMessageKey == "_ERR_RETRIEVE_PRICE") {
 					MessageHelper.displayErrorMessage(MessageHelper.messages["ERROR_RETRIEVE_PRICE"]);
 				} else {				
 					MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
 				}
			} 
			else {
				 if (serviceResponse.errorMessageKey) {
					MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
				 }
			}
			cursor_clear();
		}

	})
	
//-----------------------------------------------------------------
// Licensed Materials - Property of IBM
//
// WebSphere Commerce
//
// (C) Copyright IBM Corp. 2013 All Rights Reserved.
//
// US Government Users Restricted Rights - Use, duplication or
// disclosure restricted by GSA ADP Schedule Contract with
// IBM Corp.
//-----------------------------------------------------------------

////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Geolocation.js contains the JavaScript functions to call HTML5 Geolocation API
// to return the current device location coordinates
//
////////////////////////////////////////////////////////////////////////////////////////////////////////////

var GeolocationJS = {

    /**
     * Get the current coordinates
     * @param position      geolocation position returned by the device
     */
    showPosition: function(position) {
        if (position !== undefined && position != null) {
            storeLocatorJSStore.refreshResultsFromNearest(position.coords.latitude,position.coords.longitude);
        }
    },
    
    /**
     * Handle the error returned from geolocation call
     * @param error     the error returned by the device
     */
    locationError: function(error) {
        var errorMsgKey;
        switch (error.code) {
            case error.PERMISSION_DENIED:
                errorMsgKey = "LBS_ERROR_PERMISSION_DENIED";
                break;
            case error.POSITION_UNAVAILABLE:
                errorMsgKey = "LBS_ERROR_NO_USER_CURRENT_LOC";
                break;
            case error.TIMEOUT:
                errorMsgKey = "LBS_ERROR_TIMEOUT";
                break;
            default:
                break;
        }
        storeLocatorJSStore.refreshResultsWithLocationError(errorMsgKey);
    },
    
    /**
     * Call the HTML5 geolocation API with callback function
     */
    launch: function() {
        if (navigator.geolocation) {
            navigator.geolocation.getCurrentPosition(GeolocationJS.showPosition,GeolocationJS.locationError,{timeout:10000,enableHighAccuracy:true}); 
        }
    }

};//-----------------------------------------------------------------
// Licensed Materials - Property of IBM
//
// WebSphere Commerce
//
// (C) Copyright IBM Corp. 2007, 2016 All Rights Reserved.
//
// US Government Users Restricted Rights - Use, duplication or
// disclosure restricted by GSA ADP Schedule Contract with
// IBM Corp.
//-----------------------------------------------------------------

/**
 *@fileOverview This javascript file defines all the javascript functions used to display
 *and handle the information messages, error messages.
 */

if (typeof (MessageHelper) == "undefined" || !MessageHelper || !MessageHelper.topicNamespace) {

    /**
     * @class The MessageHelper class contains variables and functions that are used
     * to initialize, display and handle informational and error message.
     */
    MessageHelper = {
        /**A variable that contains all the messages to be displayed*/
        messages: {},

        /**
         * internal variable to keep track of the current element id that has
         * an error tooltip assigned to it */
        identifier: "",

        /**
         * internal variable to keep track of the element id that needs to
         * give focus to on dialog dismissal */
        focusElement: "",

        /**
         * returns the current year
         * @return (int) the current year
         */
        getCurrentYear: function () {
            return new Date().getFullYear();
        },

        /**
         * returns the current month. January is 1, and December is 12.
         * @return (int) the current month
         */
        getCurrentMonth: function () {
            return new Date().getMonth() + 1;
        },

        /**
         * returns the current day of the current month, starting from 1.
         * @return (int) the current day
         */
        getCurrentDay: function () {
            return new Date().getDate();
        },

        /**
         *
         *summary: retrieves the value of the property from a render context
         *description: This function retrieves the value of the property whose name is propertName
         *from the given context.
         *
         * @param (wc.render.Content) content The context in which the properties
         * belong to.
         * @param (string) propertyName The property to be retrieved
         * @return (string) null if the context is null. undefined if the property is not found.
         * otherwise, the value of the property int he given context.
         */
        getRenderContextProperty: function ( /*wc.render.Context*/ context, /*String*/ propertyName) {

            console.debug("enter getRenderContextProperty with propertyName = " + propertyName);
            if (context == null) {
                console.debug("context is null. Return null...");
                return null;
            }

            var result = context.properties[propertyName]
            console.debug("the found property value is: " + result);

            return result;
        },

        /**
         * This function is used to initialize the messages object with all the 
         * required messages. It is used to setup a JS object with any key/value.
         * @param (string) key The key used to access this message.
         * @param (string) msg The message in the correct language.
         *
         */
        setMessage: function (key, msg) {
            this.messages[key] = msg;
        },
        /**
         * This function is used to initialize the element that needs to give focus to on dialog dismissal.
         * @param (string) element The element needs to give focus to.
         *
         */
        setFocusElement: function (element) {
            this.focusElement = element;
        },



        /**
         * Use fadeIn and fadeOut to display error and informative messages in the store.
         * @param (int) topOffset how far from the top the message display area will be displayed. 
         */
        showHideMessageArea: function (topOffset) {
            cursor_clear();
            if (topOffset == null || topOffset == undefined) {
                topOffset = 0;
            }
            var node = $("#MessageArea");

            if ($("#MessageArea_ACCE_Title") !== null) {
                $("#MessageArea_ACCE_Title").css("display", "block");
            }
            // fade in
            $(node).fadeIn(200);


        },

        /**
         * Use fadeOut to hide error and informative messages in the store.
         */
        hideMessageArea: function () {
            cursor_clear();
            var focusOnElement = "";
            if (this.focusElement !== "" && $("#" + this.focusElement) !== null) {
                focusOnElement = $("#" + this.focusElement);
            }
            var node = $("#MessageArea");

            if ($("#MessageArea_ACCE_Title") !== null) {
                $("#MessageArea_ACCE_Title").css("display", "none");
            }
            if (document.getElementById(focusOnElement) != null) {
                focusOnElement.focus();
            }
            $(node).fadeOut(500);
            $('#ErrorMessageText').html("");
            this.focusElement = "";
        },

        /**
         * This function is used to display the error messages to the user. 
         * @param (string) msg The error/information message to be displayed
         * @param (int) topOffset how far from the top the message display area will be displayed. 
         * @param (boolean) showType whether or not the message type should be appended to the actual message
         *
         * @return (element) a HTML element that contains the error message. 
         *
         */
        displayErrorMessage: function (msg, topOffset, showType) {
            if (topOffset == null || topOffset == undefined) {
                topOffset = 0;
            }

            if (showType == undefined || showType == null || showType == true) {
                //if showType is undefined, keep the FEP1 behaviour.  
                if (this.messages["ERROR_MESSAGE_TYPE"] != null && this.messages["ERROR_MESSAGE_TYPE"] != 'undefined') {
                    var MsgType = this.messages["ERROR_MESSAGE_TYPE"];
                    msg = MsgType + msg;
                }
            }

            this.setMessageAreaStyle('error_icon');
            $('#ErrorMessageText').html(msg);
            this.showHideMessageArea(topOffset);
            $('#clickableErrorMessageImg').focus();
            setTimeout(function () {
                if ($('#ErrorMessageText') !== null) {
                    $('#ErrorMessageText').focus();
                }
            }, 1000);
            if (typeof TealeafWCJS != "undefined") {
                TealeafWCJS.logClientValidationCustomEvent({
                    fieldId: "-1",
                    message: msg
                });
            }
        },


        /**
         * Sets the style for the message area on the page.
         * @param (String) styleId The style Id.
         */
        setMessageAreaStyle: function (styleId) {
            $("#success_icon").css("display", "none");
            $("#error_icon").css("display", "none");
            if ($("#" + styleId) != null) {
                $("#" + styleId).css("display", "inline");
            }
        },


        /**
         * This function is used to display the informative messages to the user.
         * @param (string) msg The status message to be displayed.
         * @param (int) topOffset how far from the top of the browser the message will be displayed. 
         * @return (element) a HTML element that contains the status message.
         */
        displayStatusMessage: function (msg, topOffset) {
            if (topOffset == null || topOffset == undefined) {
                topOffset = 0;
            }
            this.setMessageAreaStyle('success_icon');
            $('#ErrorMessageText').html(msg);
            this.showHideMessageArea(topOffset);
            $('#clickableErrorMessageImg').focus();
            setTimeout(function () {
                if ($('#ErrorMessageText') !== null) {
                    $('#ErrorMessageText').focus();
                }
            }, 1000);
        },

        /**
         * This function is used to hide and clear the message display area in
         * the page.
         */
        hideAndClearMessage: function () {
            $('#ErrorMessageText').html("");
            $('#MessageArea').css("display", "none");
        },

        /**
         * This function is used to re-adjust the coordinates of the message display area on the page. Its location is relative to the "page" element.
         * @param (int) topOffset how far from the top the message display area will be displayed. 
         */
        adjustCoordinates: function (topOffset) {
            if ($("#MessageArea").css("display") != "none") {
                var page = $("#page");
                var node = $("#MessageArea");
                if (page != null && node != null) {
                    var postion = $(page).position();;
                    var width = $(page).width();


                    if (topOffset == null || topOffset == undefined) {
                        topOffset = 0;
                    }

                    $(node).css({
                        "width": width + 20 + "px",
                        "left": postion.left - 10 + "px",
                        "top": (postion.top + topOffset) + "px"
                    });
                }
            }
        },

        /**
         * This function will show the an error message tooltip
         * around the input field with the problem.
         *
         * The function assumes the "serviceResponse" is the
         * JSON object from a WebSphere Commerce exception. The error
         * field is in the serviceResponse.errorMessageParam and the
         * error message is in the serviceResponse.errorMessage.
         *
         * @see MessageHelper.formErrorHandleClient
         * @param (object) serviceResponse The JSON object with the error data.
         * @param (string) formName The name of the form where the error field is.
         * 
         */
        formErrorHandle: function (serviceResponse, formName) {

            this.formErrorHandleClient(serviceResponse.errorMessageParam, serviceResponse.errorMessage);

        },


        /**
         * This function will show the an error message tooltip
         * around the input field with the problem.
         *
         * This function will check for the emptiness of the required
         * filed and displays the "errorMessage" related to that field as a tooltip.
         * The tooltip will be closed on focus lost.
         *
         * @param (string) id The identifier for the filed in the form.
         * @param (string) errorMessage The message that should be displayed to the user.
         */
        formErrorHandleClient: function (id, errorMessage) {
            if (id.id) {
                id = id.id;
            }
            var element = $("#"+id);
            if (errorMessage == null) {
                console.debug("formErrorHandleClient: The error message is null.");
                return;
            }
            if (element) {
                if (Utils.has_ios()) {
                    this.setMessageAreaStyle('error_icon');
                    $('#MessageArea').css("display", "block");
                    $('#ErrorMessageText').html(errorMessage);
                    window.setTimeout(function () {
                        window.scrollTo(0, 0);
                    }, 0);
                } else if (this.identifier != (id + "_tooltip")) {
                    element.focus();
                    this.identifier = id + "_tooltip";
                    var node = document.createElement('span');
                    var imgDirPath = getImageDirectoryPath();
                    if (Utils.get_IE_version() < 7) {
                        node.innerHTML = errorMessage + "<iframe id='errorMessageIFrame' scrolling='no' frameborder='0' src='" + imgDirPath + "images/empty.gif'></iframe>";
                    } else {
                        node.innerHTML = errorMessage;
                    }

                    
                    if (Utils.hasTouch()) {
                        var _this = this;
                        setTimeout(function () {
                        var _this = this;
                        var $toolTipConnector = '/wcsstore/AuroraStorefrontAssetStore/images/colors/color1/tooltipConnectorUp.png';
                        this.tooltip = $("<div class='WCTooltip'><div class='container' style='padding:5px;' ><div class='connector''></div>" + errorMessage + "</div></div>");
                        $("#" + id).after(this.tooltip);
                        this.tooltip.position({
                            my: "center top",
                            at: "center bottom",
                            of: $("#" + id)

                        });

                        $("#" + id).blur(function () {
                            if (_this.tooltip) {
                                _this.tooltip.hide();
                                _this.tooltip.remove();
                            }
                            MessageHelper.clearCurrentIdentifier();

                        });

                        }, 1000);
                    } else {
                        var _this = this;
                        var $toolTipConnector = '/wcsstore/AuroraStorefrontAssetStore/images/colors/color1/tooltipConnectorUp.png';
                        this.tooltip = $("<div class='WCTooltip'><div class='container' style='padding:5px;' ><div class='connector''></div>" + errorMessage + "</div></div>");
                        $("#" + id).after(this.tooltip);
                        this.tooltip.position({
                            my: "center top",
                            at: "center bottom",
                            of: $("#" + id)

                        });

                        $("#" + id).blur(function () {
                            if (_this.tooltip) {
                                _this.tooltip.hide();
                                _this.tooltip.remove();
                            }
                            MessageHelper.clearCurrentIdentifier();

                        });

                    }
                }
                if (typeof TealeafWCJS != "undefined") {
                    TealeafWCJS.logClientValidationCustomEvent({
                        fieldId: element.id,
                        message: errorMessage
                    });
                }
	}
            },

            /**
             * This function hides and destroys the current form error handler tooltip that is displayed
             * and clears the identifier that is currently tracked.
             */
            hideFormErrorHandle: function () {
                    if (this.tooltip != null) {
                        this.tooltip.destroyRecursive();
                        this.tooltip = null;
                        this.clearCurrentIdentifier();
                    }
                },

                /**
                 * This function clears the internal variable that has the element id
                 * with the error tooltip.
                 * 
                 */
                clearCurrentIdentifier: function () {

                    this.identifier = "";
                },

                /**
                 * This function is used to override any of the default functions
                 * associated with the events. Ex: Tooltip widget tracks onMouseOver event
                 * and display the tooltip. To remove this association,
                 * tooltip widgets onMouseOver function will be overridden by this empty
                 * function.
                 * 
                 * It is an empty implementation which does nothing.
                 *
                 * @param (string) event  The event which triggers this function. 
                 */
                emptyFunc: function (event) {

                },



                /**
                 * Checks whether a string contains a double byte character.
                 *
                 * @param (string) target the string to be checked
                 * @return (boolean) true if target contains a double byte char;
                 * false otherwise
                 */
                containsDoubleByte: function (target) {

                    var str = new String(target);
                    var oneByteMax = 0x007F;

                    for (var i = 0; i < str.length; i++) {
                        chr = str.charCodeAt(i);
                        if (chr > oneByteMax) {
                            return true;
                        }
                    }
                    return false;
                },

                /**
                 * This function validate email address. It does not allow double byte
                 * characters in the email address.
                 *
                 * @return (boolean) true if the email address is valid; false otherwise
                 *
                 * @param (string) strEmail the email address string to be validated
                 */
                isValidEmail: function (strEmail) {

                    if (this.containsDoubleByte(strEmail)) {
                        return false;
                    }

                    if (strEmail.length == 0) {
                        return true;
                    } else if (strEmail.length < 5) {
                        return false;
                    } else {
                        if (strEmail.indexOf(" ") > 0) {
                            return false;
                        } else {
                            if (strEmail.indexOf("@") < 1) {
                                return false;
                            } else {
                                if (strEmail.lastIndexOf(".") < (strEmail.indexOf("@") + 2)) {
                                    return false;
                                } else {
                                    if (strEmail.lastIndexOf(".") >= strEmail.length - 2) {
                                        return false;
                                    }
                                }
                            }
                        }
                    }
                    return true;
                },

                /**
                 * This function will check if the number of bytes of the string
                 * is within the maxlength specified.
                 *
                 * @param (string) UTF16String the UTF-16 string
                 * @param (int) maxlength the maximum number of bytes allowed in your input
                 *
                 * @return (boolean) false is this input string is larger than maxlength
                 */
                isValidUTF8length: function (UTF16String, maxlength) {
                    if (this.utf8StringByteLength(UTF16String) > maxlength) return false;
                    else return true;
                },

                /**
                 * This function will count the number of bytes represented in a UTF-8
                 * string.
                 *
                 * @param (string) UTF16String the UTF-16 string you want a byte count of
                 * @return (int) the integer number of bytes represented in a UTF-8 string
                 */
                utf8StringByteLength: function (UTF16String) {

                    if (UTF16String === null) return 0;

                    var str = String(UTF16String);
                    var oneByteMax = 0x007F;
                    var twoByteMax = 0x07FF;
                    var byteSize = str.length;

                    for (i = 0; i < str.length; i++) {
                        chr = str.charCodeAt(i);
                        if (chr > oneByteMax) byteSize = byteSize + 1;
                        if (chr > twoByteMax) byteSize = byteSize + 1;
                    }
                    return byteSize;
                },

                /**
                 * this function will check whether the text is a numeric or not.
                 * 
                 * @param allowDot is a boolean wich specifies whether to consider
                 * the '.' or not.
                 *
                 * @return (boolean) true if text is numeric
                 */
                IsNumeric: function (text, allowDot) {
                    if (allowDot) var ValidChars = "0123456789.";
                    else var ValidChars = "0123456789";

                    var IsNumber = true;
                    var Char;


                    for (i = 0; i < text.length && IsNumber == true; i++) {
                        Char = text.charAt(i);
                        if (ValidChars.indexOf(Char) == -1) {
                            IsNumber = false;
                        }
                    }
                    return IsNumber;
                },

                /**
                 *
                 *This function will check for a valid Phone Number
                 *
                 *@param (string) text The string to check
                 *
                 *@return (boolean) true if text is a phone number, ie if each character of
                 *input is one of 0123456789() -+ 
                 */
                IsValidPhone: function (text) {

                    var ValidChars = "0123456789()-+ ";

                    var IsValid = true;
                    var Char;

                    for (i = 0; i < text.length && IsValid == true; i++) {
                        Char = text.charAt(i);
                        if (ValidChars.indexOf(Char) == -1) {
                            IsValid = false;
                        }
                    }
                    return IsValid;
                },

                /**
                 *  To use confirmation popup, the ${StoreDirectory}/Common/ConfirmationPopup.jspf must be included
                 *  in the jsp page where the confirmation popup launches from.
                 *	This function launch confirmation popup
                 * 
                 * @param (string) topicName The name of the topic that calling widget subscribing to.
                 * @param (stirng) message The message to be displayed in the confirmation dialog.
                 */
                showConfirmationDialog: function (topicName, message) {
                    $("#confirmationPopupMessage").html(message);
                    var confirmationPopupWidget = $("#confirmationPopup").data("wc-WCDialog"),
                        // Also add a namespace to the click event so we 
                        // only remove our click handler instead of other click handlers
                        eventName = "click.MessageHelper";
                    // Do this only once. 
                    confirmationPopupWidget.primary_button.one(eventName, function (e) {
                        e.preventDefault();
                        confirmationPopupWidget.secondary_button.off(eventName);
                        wcTopic.publish(topicName, {
                            action: "YES"
                        });
                    });

                    confirmationPopupWidget.secondary_button.one(eventName, function (e) {
                        e.preventDefault();
                        confirmationPopupWidget.primary_button.off(eventName);
                        wcTopic.publish(topicName, {
                            action: "NO"
                        });
                    });
                    confirmationPopupWidget.open();

                }
        }
    }
//-----------------------------------------------------------------
// Licensed Materials - Property of IBM
//
// WebSphere Commerce
//
// (C) Copyright IBM Corp. 2009, 2016 All Rights Reserved.
//
// US Government Users Restricted Rights - Use, duplication or
// disclosure restricted by GSA ADP Schedule Contract with
// IBM Corp.
//-----------------------------------------------------------------

/**
* @fileOverview This javascript contains javascript functions used by the quick order function
*/

quickOrderJS={
	/** language ID to be used, default to -1 (English) */
	langId: "-1",
	
	/** store ID to be used */
	storeId: "",
	
	/** catalog ID to be used */
	catalogId: "",
	
	/** used to hold error messages when bad SKU is entered */
	skuErrorMessage: "", 
	
	/** used to hold error messages when bad quantity is entered */
	qtyErrorMessage: "",
	
	/** 
	 * This constant stores the number of items that are allowed to be submitted in a single quick order.
	 * @private
	 * @constant
	 */
	numberOfItemsSupportedPerQuickOrder: "12",

	/** 
	* Sets common parameters used by this javascript object
	* @param {String} langId language ID to use
	* @param {String} storeId store ID to use
	* @param {String} catalog Catalog ID to use
	* @param {String} skuErrorMessage Error message to use when bad SKU is entered 
	* @param {String} qtyErrorMessage Error message to use when bad quantity is entered 
	*/	
	setCommonParameters:function(langId,storeId,catalogId,skuErrorMessage,qtyErrorMessage){
			this.langId = langId;
			this.storeId = storeId;
			this.catalogId = catalogId;
			this.skuErrorMessage = skuErrorMessage;
			this.qtyErrorMessage = qtyErrorMessage;
	},
	
	/**
	* This function validates the SKU input values and their corresponding quantities on the quick order form before sending the request to the server to add the SKUs to the order.
	* An error message would be displayed if an input is invalid and the requested will be stopped.
	* @param {String} formName The name of the quick order form..
	*/
	addToOrderAjax:function(formName){
		if (browseOnly){
			MessageHelper.displayErrorMessage(storeNLS['ERROR_ADD2CART_BROWSE_ONLY']); 
			return;
		}
		var params = [];
		var form = document.forms[formName];
		params.storeId = form.storeId.value;
		params.catalogId = form.catalogId.value;
		params.langId = form.langId.value;
		// Remove calculations for performance
		// params.calculationUsage = "-1,-2,-3,-4,-5,-6,-7";
		params.calculateOrder="0";
		
		var orderItemsCount = 0;
		for(var i=1; i<=this.numberOfItemsSupportedPerQuickOrder; i++){
			var currentPartNumberInputFieldId = form["partNumber_" + i].id;
			var currentQuantityInputFieldId = form["quantity_" + i].id;
			var currentPartNumber = trim(form["partNumber_" + i].value);
			var currentQuantity = trim(form["quantity_" + i].value);
			if((currentPartNumber != null && currentPartNumber != "") || (currentQuantity != null && currentQuantity != "")){
				if(currentPartNumber == null || currentPartNumber == ""){
					MessageHelper.formErrorHandleClient(currentPartNumberInputFieldId, this.skuErrorMessage);
					return;
				}
				if(!isPositiveInteger(currentQuantity)){
					MessageHelper.formErrorHandleClient(currentQuantityInputFieldId, this.qtyErrorMessage);
					return;
				}
				orderItemsCount = orderItemsCount + 1;
				form["partNumber_" + i].value = currentPartNumber;
				form["quantity_" + i].value = currentQuantity;
				this.updateParamObject(params,"partNumber_"+orderItemsCount, form["partNumber_" + i].value);
				this.updateParamObject(params,"quantity_"+orderItemsCount, form["quantity_" + i].value);
			}
		}
		
		if(orderItemsCount > 0){
			//For Handling multiple clicks
			if(!submitRequest()){
				return;
			}
			cursor_wait();
			wcService.invoke("QuickOrderAddOrderItem", params);
		}
	},
	
	/**
	* This function updates the given params object with Key value pair.
	* It is useful while making a service call which excepts few paramters of type array
	* @param {Object} params Object containing data to be passed to commerce services
	* @param {String} key Key to store and retrieve the parameter 
	* @param {String} value	Value of the parameter
	* @return {Object} params A JavaScript Object having key - value pair.
	*/
	updateParamObject:function(params, key, value, index){
		if(params == null){
			params = [];
		}

		if(index != null && index !== "" && index !== -1){
			//overwrite the old value at specified index
			params[key+"_"+index] = value;
		}else if(index === -1){
			var i = 1;
			while(params[key + "_" + i] != null){
				i++;
			}
			params[key + "_" + i] = value;
		}else{
			params[key] = value;
		}
		return params;
	},
	
	/**
	* This function clears all the input fields of the form passed in by parameter
	* @param {String} formName The name of the form containing the input fields.	
	*/
	 clearForm:function(formName){
		var form = document.forms[formName];
		for(var i=0; i<form.elements.length; i++) {
			if (form.elements[i].type == "text") {
				form.elements[i].value = "";
			}
		}
	}

}

/**
* Add an item to a shopping cart in Ajax mode. A message is displayed after the service call.
* The URL "AjaxRESTOrderAddPreConfigurationToCart" is a superset of the URL
* "AjaxRESTOrderItemAdd", allowing dynamic kit partnumbers to be entered into the quick order form.
*/
wcService.declare({
		id: "QuickOrderAddOrderItem",
		actionId: "AjaxAddOrderItem",
		url: "AjaxRESTOrderAddPreConfigurationToCart",
		formId: ""
		
		/**
		* display a success message
		* @param (object) serviceResponse The service response object, which is the
		* JSON object returned by the service invocation
		*/
		,successHandler: function(serviceResponse) {
			MessageHelper.hideAndClearMessage();
			MessageHelper.displayStatusMessage(MessageHelper.messages["SHOPCART_ADDED"]);
			cursor_clear();
			quickOrderJS.clearForm("MQuickOrderForm");
		}
		
		/**
		* display an error message
		* @param (object) serviceResponse The service response object, which is the
		* JSON object returned by the service invocation
		*/
		,failureHandler: function(serviceResponse) {

			if (serviceResponse.errorMessage) {
			 	if(serviceResponse.errorMessageKey == "_ERR_NO_ELIGIBLE_TRADING"){
			 		MessageHelper.displayErrorMessage(MessageHelper.messages["ERROR_CONTRACT_EXPIRED_GOTO_ORDER"]);
			 	} else if (serviceResponse.errorMessageKey == "_ERR_RETRIEVE_PRICE") {
 					MessageHelper.displayErrorMessage(MessageHelper.messages["ERROR_RETRIEVE_PRICE"]);
 				} else {
 					MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
 				}
			} 
			else {
				 if (serviceResponse.errorMessageKey) {
					MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
				 }
			}
			cursor_clear();
		}

	})
//-----------------------------------------------------------------
// Licensed Materials - Property of IBM
//
// WebSphere Commerce
//
// (C) Copyright IBM Corp. 2011, 2013 All Rights Reserved.
//
// US Government Users Restricted Rights - Use, duplication or
// disclosure restricted by GSA ADP Schedule Contract with
// IBM Corp.
//-----------------------------------------------------------------

if(typeof(ResponsiveJS) == "undefined" || ResponsiveJS == null || !ResponsiveJS){

	ResponsiveJS = { 	
			
	
	
	init: function(){
		$("#footerCustomerService").on("click", $.proxy(ResponsiveJS._cSToggleAndShow, ResponsiveJS));
		$("#footerCorporateInfo").on("click", $.proxy(ResponsiveJS._cIToggleAndShow, ResponsiveJS));
		$("#footerExplore").on("click", $.proxy(ResponsiveJS._eToggleAndShow, ResponsiveJS));
		$("#footerFollowUs").on("click", $.proxy(ResponsiveJS._FUToggleAndShow, ResponsiveJS));
		
	},
		
	_cSToggleAndShow:function(evt){			
		this.toggle($("#cSTog"));
		this.show($("#expandCS"));
	},
	
	_cIToggleAndShow:function(evt){			
		this.toggle($("#cITog"));
		this.show($("#expandCI"));
	},
	
	_eToggleAndShow:function(evt){			
		this.toggle($("#eTog"));
		this.show($("#expandE"));
	},
	
	_FUToggleAndShow:function(evt){			
		this.toggle($("#fUTog"));
		this.show($("#expandFU"));
	},
	
	toggle:function(node){			 
		var srcElement = node;
		if(srcElement != null) {
		      if(srcElement.style.backgroundPosition== '-161px -1px') {
		        srcElement.style.backgroundPosition= '-181px -1px';
		        srcElement.style.width='12px';
		        srcElement.style.height='6px';
		        srcElement.style.left='6px';
		        srcElement.style.top='14px';
		      }
		      else {
		        srcElement.style.backgroundPosition= '-161px -1px';
		        srcElement.style.width='6px';
		        srcElement.style.height='12px';
		        srcElement.style.left='10px';
		        srcElement.style.top='10px';
		  }
		}
	},
	
	show:function(node){
		srcElement = node;
	    if(srcElement != null) {
	      if(srcElement.style.display == "block") {
	        close('searchDropdown');
	        srcElement.style.display= 'none';
	      }
	      else {	    	  
	    	$(".subDeptDropdown ").each(function(i,node){
	    		close(node.id);
		    });
		    close("departmentsDropdown");	
	        close('qLinkDropdown');	        
	        close('mobileSearchDropdown');
	        close('searchDropdown');
	        close('pageDropdown');	        
	        close('sortDropdown');
	        srcElement.style.display='block';
	      }	      
	    }
	}
	
		
 };
}
//-----------------------------------------------------------------
// Licensed Materials - Property of IBM
//
// WebSphere Commerce
//
// (C) Copyright IBM Corp. 2008, 2016 All Rights Reserved.
//
// US Government Users Restricted Rights - Use, duplication or
// disclosure restricted by GSA ADP Schedule Contract with
// IBM Corp.
//-----------------------------------------------------------------

/**
 * @fileOverview This class contains declarations of AJAX services used by the Madisons store pages.
 */

/**
 * @class This class stores common parameters needed to make the service call.
 */
ServicesDeclarationJS = {
	langId: "-1", /* language of the  store */
	storeId: "", /*numeric unique identifier of the store */
	catalogId: "", /*catalog of the store that is currently in use */

	/**
	 * Sets common parameters used by the services
	 * @param (int) langId The language of the store.
	 * @param (int) storeId The store currently in use.
	 * @param (int) catalogId The catalog of the store currently in use.
	 */
	setCommonParameters:function(langId,storeId,catalogId){
			this.langId = langId;
			this.storeId = storeId;
			this.catalogId = catalogId;
	}
}

function nullCartTotalCookie(orderId){
	setCookie("WC_CartTotal_"+orderId, null, {expires: -1, path:'/', domain:cookieDomain});

	var cookies = document.cookie.split(";");
	for (var i = 0; i < cookies.length; i++) {
		var index = cookies[i].indexOf("=");
		var name = cookies[i].substr(0,index);
		var value = cookies[i].substr(index+1)
		name = name.replace(/^\s+|\s+$/g,"");
		value = value.replace(/^\s+|\s+$/g,"");
		if (value == orderId) {
			setCookie(name, null, {expires: -1, path:'/', domain:cookieDomain});
			break;
		}
	}
}

	/**
	* Adds an item to to the wishlist and remove the same item from the shopping
	* cart.
	* @constructor
	 */
	wcService.declare({
		id: "AjaxInterestItemAddAndDeleteFromCart",
		actionId: "AjaxInterestItemAddAndDeleteFromCart",
		url: getAbsoluteURL() + "AjaxInterestItemAdd",
		formId: ""

	 /**
	 * display a success message
	 * @param (object) serviceResponse The service response object, which is the
	 * JSON object returned by the service invocation
	 */
		,successHandler: function(serviceResponse) {
			//Now delete from cart..
			MessageHelper.hideAndClearMessage();
			resetRequest();
			CheckoutHelperJS.deleteFromCart(serviceResponse.orderItemId,true);
			MessageHelper.displayStatusMessage(MessageHelper.messages["WISHLIST_ADDED"]);
		}

	 /**
	 * display an error message
	 * @param (object) serviceResponse The service response object, which is the
	 * JSON object returned by the service invocation
	 */
		,failureHandler: function(serviceResponse) {

			if (serviceResponse.errorMessage) {
				MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
			}
			else {
				 if (serviceResponse.errorMessageKey) {
					MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
				 }
			}
			cursor_clear();
		}

	}),

	/**
	 * Add an item to a shopping cart in Ajax mode. A message is displayed after
	 * the service call.
	 * @constructor
	 */
	wcService.declare({
		id: "AjaxAddOrderItem",
		actionId: "AjaxAddOrderItem",
		url: getAbsoluteURL() + "AjaxRESTOrderItemAdd",
		formId: ""

	 /**
	 * display a success message
	 * @param (object) serviceResponse The service response object, which is the
	 * JSON object returned by the service invocation
	 */

		,successHandler: function(serviceResponse) {
			MessageHelper.hideAndClearMessage();
			MessageHelper.displayStatusMessage(MessageHelper.messages["SHOPCART_ADDED"]);
			cursor_clear();
			if(categoryDisplayJS){

				var attributes = document.getElementsByName("attrValue");

				var singleSKU = true;

				for(var i=0; i<attributes.length; i++){
					if (attributes[i].options.length > 1)
					{
						singleSKU = false;
					}
				}

				if (!singleSKU)
				{
					categoryDisplayJS.selectedAttributes = [];
					for(var i=0; i<attributes.length; i++){
						if(attributes[i] != null){
							attributes[i].value = "";
						}
					}
				}
			}
			if(typeof(ShipmodeSelectionExtJS)!= null && typeof(ShipmodeSelectionExtJS)!='undefined'){
				ShipmodeSelectionExtJS.setOrderItemId((serviceResponse.orderItem != null && serviceResponse.orderItem[0].orderItemId != null) ? serviceResponse.orderItem[0].orderItemId : serviceResponse.orderItemId);
			}
		}
	 /**
	 * display an error message
	 * @param (object) serviceResponse The service response object, which is the
	 * JSON object returned by the service invocation
	 */
		,failureHandler: function(serviceResponse) {

			if (serviceResponse.errorMessage) {
				if(serviceResponse.errorMessageKey == "_ERR_NO_ELIGIBLE_TRADING"){
					MessageHelper.displayErrorMessage(MessageHelper.messages["ERROR_CONTRACT_EXPIRED_GOTO_ORDER"]);
				} else if (serviceResponse.errorMessageKey == "_ERR_RETRIEVE_PRICE") {
					MessageHelper.displayErrorMessage(MessageHelper.messages["ERROR_RETRIEVE_PRICE"]);
				} else {
					MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
				}
			}
			else {
				 if (serviceResponse.errorMessageKey) {
					MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
				 }
			}
			cursor_clear();
		}

	}),

   /**
   * Add an item to a shopping cart in non-Ajax mode. Upon a successful request,
   * the shopping cart page is loaded. An error message is displayed otherwise.
   * @constructor
   */
	wcService.declare({
		id: "AjaxAddOrderItem_shopCart",
		actionId: "AjaxAddOrderItem",
		url: getAbsoluteURL() + "AjaxOrderChangeServiceItemAdd",
		formId: ""

	 /**
	 * redirects to the shopping cart page
	 * @param (object) serviceResponse The service response object, which is the
	 * JSON object returned by the service invocation
	 */
		,successHandler: function(serviceResponse) {
			//Now delete from cart..
			document.location.href =  appendWcCommonRequestParameters("AjaxOrderItemDisplayView?storeId=" + ServicesDeclarationJS.storeId + "&catalogId=" + ServicesDeclarationJS.catalogId + "&langId=" + ServicesDeclarationJS.langId);
		}
	 /**
	 * display an error message
	 * @param (object) serviceResponse The service response object, which is the
	 * JSON object returned by the service invocation
	 */
		,failureHandler: function(serviceResponse) {

			if (serviceResponse.errorMessage) {
				if(serviceResponse.errorMessageKey == "_ERR_NO_ELIGIBLE_TRADING"){
					MessageHelper.displayErrorMessage(MessageHelper.messages["ERROR_CONTRACT_EXPIRED_GOTO_ORDER"]);
				} else if (serviceResponse.errorMessageKey == "_ERR_RETRIEVE_PRICE") {
					MessageHelper.displayErrorMessage(MessageHelper.messages["ERROR_RETRIEVE_PRICE"]);
				} else {
					MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
				}
			}
			else {
				 if (serviceResponse.errorMessageKey) {
					MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
				 }
			}
			cursor_clear();
		}

	}),

	/**
	 * Remove an item from shopping cart. A message is displayed after the service
	 * call.
	 * @constructor
	 */
	wcService.declare({
		id: "AjaxDeleteOrderItem",
		actionId: "AjaxDeleteOrderItem",
		url: getAbsoluteURL() + "AjaxRESTOrderItemDelete",
		formId: ""
	/**
	 * display a success message
	 * @param (object) serviceResponse The service response object, which is the
	 * JSON object returned by the service invocation
	 */
		,successHandler: function(serviceResponse) {
			MessageHelper.hideAndClearMessage();
			MessageHelper.displayStatusMessage(MessageHelper.messages["SHOPCART_REMOVEITEM"]);
		}
	 /**
	 * display an error message
	 * @param (object) serviceResponse The service response object, which is the
	 * JSON object returned by the service invocation
	 */
		,failureHandler: function(serviceResponse) {

			if (serviceResponse.errorMessage) {
				MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
			}
			else {
				 if (serviceResponse.errorMessageKey) {
					MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
				 }
			}
			if(serviceResponse.errorCode){
				wcTopic.publish("OrderError",serviceResponse);
			}
			cursor_clear();
		}

	}),


	/**
	 * Removes an item from shopping cart on the shipping & billing page. A message is displayed after the service call.
	 * @constructor
	 */
	wcService.declare({
		id: "AjaxDeleteOrderItemForShippingBillingPage",
		actionId: "AjaxDeleteOrderItemForShippingBillingPage",
		url: getAbsoluteURL() + "AjaxRESTOrderItemDelete",
		formId: ""

		/**
		 * display a success message
		 * @param (object) serviceResponse The service response object, which is the
		 * JSON object returned by the service invocation
		 */
		,successHandler: function(serviceResponse) {
			MessageHelper.hideAndClearMessage();
			MessageHelper.displayStatusMessage(MessageHelper.messages["SHOPCART_REMOVEITEM"]);
		}

		/**
		 * display an error message
		 * @param (object) serviceResponse The service response object, which is the
		 * JSON object returned by the service invocation
		 */
		,failureHandler: function(serviceResponse) {
			if (serviceResponse.errorMessage) {
				MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
			}
			else {
				 if (serviceResponse.errorMessageKey) {
					MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
				 }
			}
			cursor_clear();
		}
	}),


	/**
	 * Remove an item from shopping cart. A message is only displayed if the service
	 * call returns an error Message. It is used to remove an item from the shopping
	 * cart and add the same item to the wish list.
	 * @constructor
	 */
	wcService.declare({
		id: "AjaxDeleteOrderItemFromCart",
		actionId: "AjaxDeleteOrderItem",
		url: getAbsoluteURL() + "AjaxRESTOrderItemDelete",
		formId: ""
	 /**
	 * display an error message
	 * @param (object) serviceResponse The service response object, which is the
	 * JSON object returned by the service invocation
	 */
		,failureHandler: function(serviceResponse) {

			if (serviceResponse.errorMessage) {
				MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
			}
			else {
				 if (serviceResponse.errorMessageKey) {
					MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
				 }
			}
			cursor_clear();
		}


	}),

	/**
	 * Remove an item from shopping cart.
	 * Upon a successful request, this function will load the AjaxOrderItemDisplayView page or the OrderShippingBillingView page depending on what page the service was invoked from.
	 * An error message will be displayed otherwise.
	 * @constructor
	 */
	wcService.declare({
		id: "AjaxDeleteOrderItem1",
		actionId: "AjaxDeleteOrderItem",
		url: getAbsoluteURL() + "AjaxRESTOrderItemDelete",
		formId: ""

	/**
	 *redirect to the Shopping Cart Page
	 * @param (object) serviceResponse The service response object, which is the
	 * JSON object returned by the service invocation
	 */
		,successHandler: function(serviceResponse) {
			MessageHelper.hideAndClearMessage();
			MessageHelper.displayStatusMessage(MessageHelper.messages["SHOPCART_REMOVEITEM"]);
			if (!CheckoutHelperJS.pendingOrderDetailsPage)
			{
				setDeleteCartCookie();
				if(CheckoutHelperJS.shoppingCartPage){

					document.location.href = appendWcCommonRequestParameters("AjaxOrderItemDisplayView?storeId=" + ServicesDeclarationJS.storeId + "&catalogId=" + ServicesDeclarationJS.catalogId + "&langId=" + ServicesDeclarationJS.langId);
				}else{
					document.location.href = appendWcCommonRequestParameters("OrderShippingBillingView?storeId=" + ServicesDeclarationJS.storeId + "&catalogId=" + ServicesDeclarationJS.catalogId + "&langId=" + ServicesDeclarationJS.langId + "&orderId=" + serviceResponse.orderId);
				}
			}
			else
			{
				cursor_clear();
			}
		}

	/**
	 * display an error message
	 * @param (object) serviceResponse The service response object, which is the
	 * JSON object returned by the service invocation
	 */
		,failureHandler: function(serviceResponse) {

			if (serviceResponse.errorMessage) {
				MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
			}
			else {
				 if (serviceResponse.errorMessageKey) {
					MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
				 }
			}
			cursor_clear();
		}

	}),


	/**
	 * This service updates an order item in the shopping cart.
	 * A message is displayed after the service call.
	 * @constructor
	 */
	wcService.declare({
		id: "AjaxUpdateOrderItem",
		actionId: "AjaxUpdateOrderItem",
		url: getAbsoluteURL() + "AjaxRESTOrderItemUpdate",
		formId: ""

	/**
	 * hides all the messages and the progress bar
	 * @param (object) serviceResponse The service response object, which is the
	 * JSON object returned by the service invocation
	 */
		,successHandler: function(serviceResponse) {
			MessageHelper.hideAndClearMessage();
			MessageHelper.hideFormErrorHandle();
			cursor_clear();
		}

	/**
	 * display an error message
	 * @param (object) serviceResponse The service response object, which is the
	 * JSON object returned by the service invocation
	 */
		,failureHandler: function(serviceResponse) {

			if (serviceResponse.errorMessage) {
				if (serviceResponse.errorMessageKey == "_ERR_RETRIEVE_PRICE") {
					MessageHelper.displayErrorMessage(MessageHelper.messages["ERROR_RETRIEVE_PRICE_QTY_UPDATE"]);
				}
				else{
					MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
				}
			}
			else {
				 if (serviceResponse.errorMessageKey) {
					MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
				 }
			}
			if(serviceResponse.errorCode){
				wcTopic.publish("OrderError",serviceResponse);
			}
			cursor_clear();
		}

	}),

	/**
	 * Updates an order item in the shopping cart.
	 * Upon a successful request, this function will load the AjaxOrderItemDisplayView page
	 * An error message will be displayed otherwise.
	 * @constructor
	 */
	wcService.declare({
		id: "AjaxUpdateOrderItem1",
		actionId: "AjaxUpdateOrderItem",
		url: getAbsoluteURL() + "AjaxRESTOrderItemUpdate",
		formId: ""
	/**
	 *redirect to the Shopping Cart Page
	 * @param (object) serviceResponse The service response object, which is the
	 * JSON object returned by the service invocation
	 */
		,successHandler: function(serviceResponse) {
			if (!CheckoutHelperJS.pendingOrderDetailsPage)
			{
				if(CheckoutHelperJS.shoppingCartPage){
					document.location.href = appendWcCommonRequestParameters("AjaxOrderItemDisplayView?storeId=" + ServicesDeclarationJS.storeId + "&catalogId=" + ServicesDeclarationJS.catalogId + "&langId=" + ServicesDeclarationJS.langId);
				}
			}
			else
			{
				cursor_clear();
			}
		}

	/**
	 * display an error message
	 * @param (object) serviceResponse The service response object, which is the
	 * JSON object returned by the service invocation
	 */
		,failureHandler: function(serviceResponse) {

			if (serviceResponse.errorMessage) {
				if (serviceResponse.errorMessageKey == "_ERR_RETRIEVE_PRICE") {
					MessageHelper.displayErrorMessage(MessageHelper.messages["ERROR_RETRIEVE_PRICE_QTY_UPDATE"]);
				}
				else{
					MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
				}
			}
			else {
				 if (serviceResponse.errorMessageKey) {
					MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
				 }
			}
			cursor_clear();
		}

	}),

	/**
	 * This service updates shipping information (shipping mode, shipping address)
	 * for a shopping cart. A message is displayed after the service call.
	 * @constructor
	 */
	wcService.declare({
		id: "AjaxUpdateOrderShippingInfo",
		actionId: "AjaxUpdateOrderShippingInfo",
		url: getAbsoluteURL() + "AjaxRESTOrderShipInfoUpdate",
		formId: ""
	/**
	 * hides all the messages and the progress bar
	 * @param (object) serviceResponse The service response object, which is the
	 * JSON object returned by the service invocation
	 */
		,successHandler: function(serviceResponse) {
			MessageHelper.hideAndClearMessage();
			cursor_clear();
		}

	 /**
	 * display an error message
	 * @param (object) serviceResponse The service response object, which is the
	 * JSON object returned by the service invocation
	 */
		,failureHandler: function(serviceResponse) {

			if (serviceResponse.errorMessage) {
				MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
			}
			else {
				 if (serviceResponse.errorMessageKey) {
					MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
				 }
			}
			cursor_clear();
		}

	}),

	/**
	 * This service prepares an order for submission. Upon success, it submits the order.
	 * @constructor
	 */
	wcService.declare({
		id: "AjaxPrepareOrderForSubmit",
		actionId: "AjaxPrepareOrderForSubmit",
		url: getAbsoluteURL() + "AjaxRESTOrderPrepare",
		formId: ""

	/**
	 * On success, checkout the order by calling order submit.
	 * @param (object) serviceResponse The service response object, which is the
	 * JSON object returned by the service invocation
	 */
		,successHandler: function(serviceResponse) {
			CheckoutHelperJS.setOrderPrepared("true");
			CheckoutHelperJS.checkoutOrder(CheckoutHelperJS.getSavedParameter('tempOrderId'),CheckoutHelperJS.getSavedParameter('tempUserType'),CheckoutHelperJS.getSavedParameter('tempEmailAddresses'),CheckoutHelperJS.getSavedParameter('tempIsQuote'));
		}

	/**
	 * display an error message
	 * @param (object) serviceResponse The service response object, which is the
	 * JSON object returned by the service invocation
	 */
		,failureHandler: function(serviceResponse) {

			if (serviceResponse.errorMessage) {
				MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
			}
			else {
				 if (serviceResponse.errorMessageKey) {
					MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
				 }
			}
			cursor_clear();
		}

	}),


	/**
	 * This service submits the order. Upon success, the order billing confirmation
	 * page is shown. A error message is displayed otherwise.
	 * @constructor
	 */
	wcService.declare({
		id: "AjaxSubmitOrder",
		actionId: "AjaxSubmitOrder",
		url: getAbsoluteURL() + "AjaxRESTOrderSubmit",
		formId: ""

	/**
	 *redirect to the Order Confirmation page
	 * @param (object) serviceResponse The service response object, which is the
	 * JSON object returned by the service invocation
	 */
		,successHandler: function(serviceResponse) {
			nullCartTotalCookie(serviceResponse.orderId);
			var shipmentTypeId = CheckoutHelperJS.getShipmentTypeId();
			document.location.href = appendWcCommonRequestParameters("OrderShippingBillingConfirmationView?storeId=" + ServicesDeclarationJS.storeId + "&catalogId=" + ServicesDeclarationJS.catalogId + "&langId=" + ServicesDeclarationJS.langId + "&orderId=" + serviceResponse.orderId + "&shipmentTypeId=" + shipmentTypeId);
		}

	/**
	 * display an error message
	 * @param (object) serviceResponse The service response object, which is the
	 * JSON object returned by the service invocation
	 */
		,failureHandler: function(serviceResponse) {

			if (serviceResponse.errorMessage) {
				MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
			}
			else {
				 if (serviceResponse.errorMessageKey) {
					MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
				 }
			}
			cursor_clear();
		}

	}),

	/**
	 * This service submits the quote. Upon success, the quote  confirmation
	 * page is shown. A error message is displayed otherwise.
	 * @constructor
	 */
	wcService.declare({
		id: "AjaxSubmitQuote",
		actionId: "AjaxSubmitQuote",
		url: getAbsoluteURL() + "AjaxSubmitQuote",
		formId: ""

   /**
	*redirect to the Quote Confirmation page
	* @param (object) serviceResponse The service response object, which is the
	* JSON object returned by the service invocation
	*/
		,successHandler: function(serviceResponse) {
			var redirectURL = "OrderShippingBillingConfirmationView?storeId=" + ServicesDeclarationJS.storeId
			+ "&catalogId=" + ServicesDeclarationJS.catalogId
			+ "&langId=" + ServicesDeclarationJS.langId
			+ "&orderId=" + CheckoutHelperJS.getOrderId()
			+ "&shipmentTypeId=" + CheckoutHelperJS.getShipmentTypeId()
			+ "&isQuote=true"
			+ "&quoteId=" + serviceResponse.outOrderId// outOrderId is the id of the new quote created.

			if(serviceResponse.outExternalQuoteId != undefined && serviceResponse.outExternalQuoteId != null){
				redirectURL += redirectURL + "&externalQuoteId=" + serviceResponse.outExternalQuoteId;
			}
			document.location.href = appendWcCommonRequestParameters(redirectURL);
		}

   /**
	* display an error message
	* @param (object) serviceResponse The service response object, which is the
	* JSON object returned by the service invocation
	*/
		,failureHandler: function(serviceResponse) {

			if (serviceResponse.errorMessage) {
				MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
			}
			else {
				 if (serviceResponse.errorMessageKey) {
					MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
				 }
			}
			cursor_clear();
		}

	}),

	/**
	 * This service adds an address for the person. An error message is displayed
	 * if the service failed.
	 * @constructor
	 */
	wcService.declare({
		id: "AjaxAddAddressForPerson",
		actionId: "AjaxAddAddressForPerson",
		url: getAbsoluteURL() + "AjaxPersonChangeServiceAddressAdd",
		formId: ""

	/**
	 * hides all the messages and the progress bar
	 * @param (object) serviceResponse The service response object, which is the
	 * JSON object returned by the service invocation
	 */
		,successHandler: function(serviceResponse) {
			AddressHelper.updateOrderAfterAddressUpdate();
			MessageHelper.hideAndClearMessage();
			cursor_clear();
		}

	 /**
	 * display an error message
	 * @param (object) serviceResponse The service response object, which is the
	 * JSON object returned by the service invocation
	 */
		,failureHandler: function(serviceResponse) {

			if (serviceResponse.errorMessage) {
				MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
			}
			else {
				 if (serviceResponse.errorMessageKey) {
					MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
				 }
			}
			cursor_clear();
		}

	}),

	/**
	 * This service adds an address for the person. An error message is displayed
	 * if the service failed.
	 * @constructor
	 */
	wcService.declare({
		id: "AjaxUpdateAddressForPerson",
		actionId: "AjaxUpdateAddressForPerson",
		url: getAbsoluteURL() + "AjaxPersonChangeServiceAddressUpdate",
		formId: ""

	/**
	 * hides all the messages and the progress bar
	 * @param (object) serviceResponse The service response object, which is the
	 * JSON object returned by the service invocation
	 */
		,successHandler: function(serviceResponse) {
			AddressHelper.updateOrderAfterAddressUpdate();
			MessageHelper.hideAndClearMessage();
			cursor_clear();
		}
	 /**
	 * display an error message
	 * @param (object) serviceResponse The service response object, which is the
	 * JSON object returned by the service invocation
	 */
		,failureHandler: function(serviceResponse) {

			if (serviceResponse.errorMessage) {
				MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
			}
			else {
				 if (serviceResponse.errorMessageKey) {
					MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
				 }
			}
			cursor_clear();
		}

	}),

	/**
	 * This service calls AjaxRESTOrderItemUpdate to update order total after shipping address is updated in the order.
	 */
	wcService.declare({
		id: "AjaxUpdateOrderAfterAddressUpdate",
		actionId: "AjaxUpdateOrderAfterAddressUpdate",
		url: getAbsoluteURL() + "AjaxRESTOrderItemUpdate",
		formId: ""

	/**
	 * hides all the messages and the progress bar
	 * @param (object) serviceResponse The service response object, which is the
	 * JSON object returned by the service invocation
	 */
		,successHandler: function(serviceResponse) {
			MessageHelper.hideAndClearMessage();
			cursor_clear();
		}

	/**
	 * display an error message
	 * @param (object) serviceResponse The service response object, which is the
	 * JSON object returned by the service invocation
	 */
		,failureHandler: function(serviceResponse) {

			if (serviceResponse.errorMessage) {
				MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
			}
			else {
				 if (serviceResponse.errorMessageKey) {
					MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
				 }
			}
			cursor_clear();
		}

	}),

	/**
	 * This service adds an item to the wishlist. This is different from
	 * AjaxInterestItemAddAndDeleteFromCart in that this function does not remove
	 * the item from the shopping cart. It is used mainly in catalog browsing.
	 * @constructor
	 */
	wcService.declare({
		id: "AjaxInterestItemAdd",
		actionId: "AjaxInterestItemAdd",
		url: getAbsoluteURL() + "AjaxInterestItemAdd",
		formId: ""
	/**
	 * hides all the messages and the progress bar
	 * @param (object) serviceResponse The service response object, which is the
	 * JSON object returned by the service invocation
	 */
		,successHandler: function(serviceResponse) {
			MessageHelper.hideAndClearMessage();
			cursor_clear();
			MessageHelper.displayStatusMessage(MessageHelper.messages["WISHLIST_ADDED"]);
			if(categoryDisplayJS)
			categoryDisplayJS.selectedAttributes = [];
		}
	 /**
	 * display an error message
	 * @param (object) serviceResponse The service response object, which is the
	 * JSON object returned by the service invocation
	 */
		,failureHandler: function(serviceResponse) {

			if (serviceResponse.errorMessage) {
				MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
			}
			else {
				 if (serviceResponse.errorMessageKey) {
					MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
				 }
			}
			cursor_clear();
		}

	}),

	/**
	 * This service adds an item to the wishlist in non-Ajax mode. Upon success,
	 * the shopping cart page is displayed. This is different from
	 * AjaxInterestItemAddAndDeleteFromCart in that this function does not remove
	 * the item from the shopping cart. It is used mainly in catalog browsing.
	 * @constructor
	 */
	wcService.declare({
		id: "AjaxInterestItemAdd_shopCart",
		actionId: "AjaxInterestItemAdd",
		url: getAbsoluteURL() + "AjaxInterestItemAdd",
		formId: ""

	/**
	 * hides all the messages and the progress bar
	 * @param (object) serviceResponse The service response object, which is the
	 * JSON object returned by the service invocation
	 */
		,successHandler: function(serviceResponse) {
			document.location.href = appendWcCommonRequestParameters("AjaxOrderItemDisplayView?storeId=" + ServicesDeclarationJS.storeId + "&catalogId=" + ServicesDeclarationJS.catalogId + "&langId=" + ServicesDeclarationJS.langId);
		}

	 /**
	 * display an error message
	 * @param (object) serviceResponse The service response object, which is the
	 * JSON object returned by the service invocation
	 */
		,failureHandler: function(serviceResponse) {

			if (serviceResponse.errorMessage) {
				MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
			}
			else {
				 if (serviceResponse.errorMessageKey) {
					MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
				 }
			}
			cursor_clear();
		}

	}),

  /**
   * This service deletes an item from the wish list. An error message will be
   * displayed if the service call failed.
   */
	wcService.declare({
		id: "AjaxInterestItemDelete",
		actionId: "AjaxInterestItemDelete",
		url: getAbsoluteURL() + "AjaxInterestItemDelete",
		formId: ""

	/**
	 * hides all the messages and the progress bar
	 * @param (object) serviceResponse The service response object, which is the
	 * JSON object returned by the service invocation
	 */
		,successHandler: function(serviceResponse) {
			MessageHelper.hideAndClearMessage();
		}

	 /**
	 * display an error message
	 * @param (object) serviceResponse The service response object, which is the
	 * JSON object returned by the service invocation
	 */
		,failureHandler: function(serviceResponse) {

			if (serviceResponse.errorMessage) {
				MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
			}
			else {
				 if (serviceResponse.errorMessageKey) {
					MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
				 }
			}
			cursor_clear();
		}

	}),

	/**
	 * This service sends the wish list to a specified email address.
	 */
	wcService.declare({
		id: "AjaxInterestItemListMessage",
		actionId: "AjaxInterestItemListMessage",
		url: getAbsoluteURL() + "AjaxInterestItemListMessage",
		formId: ""

	/**
	 * hides all the messages and the progress bar
	 * @param (object) serviceResponse The service response object, which is the
	 * JSON object returned by the service invocation
	 */
		,successHandler: function(serviceResponse) {
			MessageHelper.hideAndClearMessage();
		}
	 /**
	 * display an error message
	 * @param (object) serviceResponse The service response object, which is the
	 * JSON object returned by the service invocation
	 */
		,failureHandler: function(serviceResponse) {

			if (serviceResponse.errorMessage) {
				MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
			}
			else {
				 if (serviceResponse.errorMessageKey) {
					MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
				 }
			}
			cursor_clear();
		}

	}),

	/**
	 * This service applies the promotion code to the order(s).
	 */
	wcService.declare({
		id: "AjaxPromotionCodeManage",
		actionId: "AjaxPromotionCodeManage",
		url: getAbsoluteURL() + "AjaxRESTPromotionCodeApply",
		formId: ""

    /**
     * hides all the messages and the progress bar
     * @param (object) serviceResponse The service response object, which is the
     * JSON object returned by the service invocation
     */
		,successHandler: function(serviceResponse) {
			MessageHelper.hideAndClearMessage();

			var params = [];
			
			params.storeId		= ServicesDeclarationJS.storeId;
			params.catalogId	= ServicesDeclarationJS.catalogId;
			params.langId		= ServicesDeclarationJS.langId;
			params.orderItemId 	= "";
			params.orderId = serviceResponse.orderId;
			if(CheckoutHelperJS.shoppingCartPage){	
				params.calculationUsage = "-1,-2,-5,-6,-7";
			}else{
				params.calculationUsage = "-1,-2,-3,-4,-5,-6,-7";
			}
			params.calculateOrder = "1";
			
			wcService.invoke("AjaxUpdateOrderItem",params);
			
		}

     /**
     * display an error message
     * @param (object) serviceResponse The service response object, which is the
     * JSON object returned by the service invocation
     */
		,failureHandler: function(serviceResponse) {

			if (serviceResponse.errorMessage) {
				MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
			} 
			else {
				 if (serviceResponse.errorMessageKey) {
					MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
				 }
			}
			cursor_clear();
		}

	}),

	/**
	 * This service applies the promotion code to the order(s).
	 */
	wcService.declare({
		id: "AjaxPromotionCodeDelete",
		actionId: "AjaxPromotionCodeManage",
		url: getAbsoluteURL() + "AjaxRESTPromotionCodeRemove",
		formId: ""

    /**
     * hides all the messages and the progress bar
     * @param (object) serviceResponse The service response object, which is the
     * JSON object returned by the service invocation
     */
		,successHandler: function(serviceResponse) {
			MessageHelper.hideAndClearMessage();

			var params = [];
			
			params.storeId		= ServicesDeclarationJS.storeId;
			params.catalogId	= ServicesDeclarationJS.catalogId;
			params.langId		= ServicesDeclarationJS.langId;
			params.orderItemId 	= "";
			params.orderId = serviceResponse.orderId;
			if(CheckoutHelperJS.shoppingCartPage){	
				params.calculationUsage = "-1,-2,-5,-6,-7";
			}else{
				params.calculationUsage = "-1,-2,-3,-4,-5,-6,-7";
			}
			params.calculateOrder = "1";
			
			wcService.invoke("AjaxUpdateOrderItem",params);
			
		}

     /**
     * display an error message
     * @param (object) serviceResponse The service response object, which is the
     * JSON object returned by the service invocation
     */
		,failureHandler: function(serviceResponse) {

			if (serviceResponse.errorMessage) {
				MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
			} 
			else {
				 if (serviceResponse.errorMessageKey) {
					MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
				 }
			}
			cursor_clear();
		}

	}),

  /**
   * This services adds or removes a coupon from the order(s).
   */
	wcService.declare({
		id: "AjaxCouponsAdd",
		actionId: "AjaxCouponsAddRemove",
		url: getAbsoluteURL() + "AjaxRESTCouponsAdd",
		formId: ""

    /**
     * Hides all the messages and the progress bar. It will then called the
     * AjaxRESTOrderItemUpdate service
     * @param (object) serviceResponse The service response object, which is the
     * JSON object returned by the service invocation
      */
		,successHandler: function(serviceResponse) {
			MessageHelper.hideAndClearMessage();
			
			var params = [];
			
			params.storeId		= ServicesDeclarationJS.storeId;
			params.catalogId	= ServicesDeclarationJS.catalogId;
			params.langId		= ServicesDeclarationJS.langId;
			params.orderItemId	= "";
			params.orderId = serviceResponse.orderId;
			if(CheckoutHelperJS.shoppingCartPage){	
				params.calculationUsage = "-1,-2,-5,-6,-7";
			}else{
				params.calculationUsage = "-1,-2,-3,-4,-5,-6,-7";
			}
			params.calculateOrder = "1";
			
			wcService.invoke("AjaxUpdateOrderItem",params);

		}

	 /**
	 * display an error message
	 * @param (object) serviceResponse The service response object, which is the
	 * JSON object returned by the service invocation
	 */
		,failureHandler: function(serviceResponse) {

			if (serviceResponse.errorMessage) {
				MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
			}
			else {
				 if (serviceResponse.errorMessageKey) {
					MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
				 }
			}
			cursor_clear();
		}

	}),

  /**
   * This services adds or removes a coupon from the order(s).
   */
	wcService.declare({
		id: "AjaxCouponsRemove",
		actionId: "AjaxCouponsAddRemove",
		url: getAbsoluteURL() + "AjaxRESTCouponsRemove",
		formId: ""

    /**
     * Hides all the messages and the progress bar. It will then called the
     * AjaxRESTOrderItemUpdate service
     * @param (object) serviceResponse The service response object, which is the
     * JSON object returned by the service invocation
      */
		,successHandler: function(serviceResponse) {
			MessageHelper.hideAndClearMessage();
			
			var params = [];
			
			params.storeId		= ServicesDeclarationJS.storeId;
			params.catalogId	= ServicesDeclarationJS.catalogId;
			params.langId		= ServicesDeclarationJS.langId;
			params.orderItemId	= "";
			params.orderId = serviceResponse.orderId;
			if(CheckoutHelperJS.shoppingCartPage){	
				params.calculationUsage = "-1,-2,-5,-6,-7";
			}else{
				params.calculationUsage = "-1,-2,-3,-4,-5,-6,-7";
			}
			params.calculateOrder = "1";
			
			wcService.invoke("AjaxUpdateOrderItem",params);

		}

	 /**
	 * display an error message
	 * @param (object) serviceResponse The service response object, which is the
	 * JSON object returned by the service invocation
	 */
		,failureHandler: function(serviceResponse) {

			if (serviceResponse.errorMessage) {
				MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
			}
			else {
				 if (serviceResponse.errorMessageKey) {
					MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
				 }
			}
			cursor_clear();
		}

	}),

	/**
	 * This service adds a billing address to the order(s).
	 */
	wcService.declare({
		id: "AddBillingAddress",
		actionId: "AddBillingAddress",
		url: getAbsoluteURL() + "AjaxPersonChangeServiceAddressAdd",
		formId: ""

	/**
	 * hides all the messages and the progress bar
	 * @param (object) serviceResponse The service response object, which is the
	 * JSON object returned by the service invocation
	 */
		,successHandler: function(serviceResponse) {
			MessageHelper.hideAndClearMessage();
		}

	 /**
	 * display an error message
	 * @param (object) serviceResponse The service response object, which is the
	 * JSON object returned by the service invocation
	 */
		,failureHandler: function(serviceResponse) {

			if (serviceResponse.errorMessage) {
				MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
			}
			else {
				 if (serviceResponse.errorMessageKey) {
					MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
				 }
			}
			cursor_clear();
		}

	}),

/**
 * This service schedules an order based on the input order date and order interval parameters.
 */
wcService.declare({
	id: "ScheduleOrder",
	actionId: "ScheduleOrder",
	url: getAbsoluteURL() + "AjaxRESTScheduleOrder",
	formId: ""

	/**
	 * Hides all the messages and the progress bar.
	 * Constructs a URL that deletes the current order and forward to the order confirmation page.
	 * @param (object) serviceResponse The service response object, which is the JSON object returned by the service invocation
	 */
	,successHandler: function(serviceResponse) {
		MessageHelper.hideAndClearMessage();
		var originalOrderId = document.getElementById("orderIdToSchedule").value;
		var newOrderId = serviceResponse.orderId;
		nullCartTotalCookie(serviceResponse.orderId);
		var shipmentTypeId = CheckoutHelperJS.getShipmentTypeId();
		var purchaseOrderNumber = "";
		if(document.forms["purchaseOrderNumberInfo"].purchase_order_number.value != null){
			purchaseOrderNumber = document.forms["purchaseOrderNumberInfo"].purchase_order_number.value;
		}
		var url = "RESTOrderCancel?orderId=" + originalOrderId + "&storeId="  + ServicesDeclarationJS.storeId + "&catalogId=" + ServicesDeclarationJS.catalogId + "&langId=" + ServicesDeclarationJS.langId + "&URL=OrderShippingBillingConfirmationView%3ForderId%3D" + newOrderId + "%26originalOrderId%3D" + originalOrderId + "%26shipmentTypeId%3D" + shipmentTypeId + "%26purchaseOrderNumber%3D" + purchaseOrderNumber;
		document.location.href = appendWcCommonRequestParameters(url);
	}

	/**
	 * Displays an error message if the the service call failed.
	 * @param (object) serviceResponse The service response object, which is the
	 * JSON object returned by the service invocation
	 */
	,failureHandler: function(serviceResponse) {
		if (serviceResponse.errorMessage) {
			MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
		} else {
			 if (serviceResponse.errorMessageKey) {
				MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
			 }
		}
		cursor_clear();
	}
}),

/**
 * This service schedules an order based on the input order date and order interval parameters.
 */
wcService.declare({
	id: "SubmitRecurringOrder",
	actionId: "SubmitRecurringOrder",
	url: getAbsoluteURL() + "AjaxRESTSubmitRecurringOrSubscription",
	formId: ""

	/**
	 * Hides all the messages and the progress bar.
	 * Constructs a URL that deletes the current order and forward to the order confirmation page.
	 * @param (object) serviceResponse The service response object, which is the JSON object returned by the service invocation
	 */
	,successHandler: function(serviceResponse) {
		MessageHelper.hideAndClearMessage();
		nullCartTotalCookie(serviceResponse.orderId);
		var shipmentTypeId = CheckoutHelperJS.getShipmentTypeId();
		var url = "OrderShippingBillingConfirmationView?storeId=" + ServicesDeclarationJS.storeId + "&catalogId=" + ServicesDeclarationJS.catalogId + "&langId=" + ServicesDeclarationJS.langId + "&orderId=" + serviceResponse.orderId + "&shipmentTypeId=" + shipmentTypeId;
		document.location.href = appendWcCommonRequestParameters(url);
		cursor_clear();
	}

	/**
	 * Displays an error message if the the service call failed.
	 * @param (object) serviceResponse The service response object, which is the
	 * JSON object returned by the service invocation
	 */
	,failureHandler: function(serviceResponse) {
		if (serviceResponse.errorMessage) {
			MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
		} else {
			 if (serviceResponse.errorMessageKey) {
				MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
			 }
		}
		cursor_clear();
	}
}),

/**
 * This service updates the free gift choices made by the shopper for the
 * promotion.
 */
wcService.declare({
	id: "AjaxUpdateRewardOption",
	actionId: "AjaxUpdateRewardOption",
	url: getAbsoluteURL() + "AjaxRESTOrderRewardOptionUpdate",
	formId: ""

/**
 * Hides all the messages and the progress bar.
 * @param (object) serviceResponse The service response object, which is the
 * JSON object returned by the service invocation
 */
	,successHandler: function(serviceResponse) {
		MessageHelper.hideAndClearMessage();
		cursor_clear();

	}
 /**
 * Display an error message.
 * @param (object) serviceResponse The service response object, which is the
 * JSON object returned by the service invocation
 */
	,failureHandler: function(serviceResponse) {

		if (serviceResponse.errorMessage) {
			MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
		}
		else {
			 if (serviceResponse.errorMessageKey) {
				MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
			 }
		}
		cursor_clear();
	}

}),

	/**
	 * Create a new saved order.
	 * Perform the service or command call.
	 */
	wcService.declare({
		id: "AjaxOrderCreate",
		actionId: "AjaxOrderCreate",
		url: getAbsoluteURL() + "AjaxRESTOrderCreate",
		formId: ""

	 /**
	 * display a success message
	 * @param (object) serviceResponse The service response object, which is the
	 * JSON object returned by the service invocation
	 */
		,successHandler: function(serviceResponse) {
			MessageHelper.hideAndClearMessage();
			MessageHelper.displayStatusMessage(MessageHelper.messages["MYACCOUNT_SAVEDORDERLIST_CREATE_SUCCESS"]);

			cursor_clear();

		}

	 /**
	 * display an error message
	 * @param (object) serviceResponse The service response object, which is the
	 * JSON object returned by the service invocation
	 */
		,failureHandler: function(serviceResponse) {

			if (serviceResponse.errorMessage) {

				 if (serviceResponse.errorCode == "CMN0409E")
				 {
					 MessageHelper.displayErrorMessage(MessageHelper.messages["MYACCOUNT_SAVEDORDERLIST_CREATE_FAIL"]);
				 }
				 else
				 {
					 MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
				 }
			}
			else {
				 if (serviceResponse.errorMessageKey) {
					MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
				 }
			}
			cursor_clear();
		}
	}),

	/**
	 * Cancel a single saved order.
	 * Perform the service or command call.
	 */
	wcService.declare({
		id: "AjaxSingleOrderCancel",
		actionId: "AjaxSingleOrderCancel",
		url: getAbsoluteURL() + "AjaxRESTOrderCancel",
		formId: ""

	 /**
	 * display a success message
	 * @param (object) serviceResponse The service response object, which is the
	 * JSON object returned by the service invocation
	 */
		,successHandler: function(serviceResponse) {
			MessageHelper.hideAndClearMessage();
			MessageHelper.displayStatusMessage(MessageHelper.messages["MYACCOUNT_SAVEDORDERLIST_DELETE_SUCCESS"]);
			cursor_clear();
		}

	 /**
	 * display an error message
	 * @param (object) serviceResponse The service response object, which is the
	 * JSON object returned by the service invocation
	 */
		,failureHandler: function(serviceResponse) {

			if (serviceResponse.errorMessage) {
				 if (serviceResponse.errorCode == "CMN0409E")
				 {
					 MessageHelper.displayErrorMessage(MessageHelper.messages["MYACCOUNT_SAVEDORDERLIST_DELETE_FAIL"]);
				 }
				 else
				 {
					 MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
				 }
			}
			else {
				 if (serviceResponse.errorMessageKey) {
					MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
				 }
			}
			cursor_clear();
		}
	}),

	/**
	 * Cancel a saved order. This service is used to delete multiple saved orders one at a time.
	 * Perform the service or command call.
	 */
	wcService.declare({
		id: "AjaxOrderCancel",
		actionId: "AjaxOrderCancel",
		url: getAbsoluteURL() + "AjaxRESTOrderCancel",
		formId: ""

	 /**
	 * display a success message
	 * @param (object) serviceResponse The service response object, which is the
	 * JSON object returned by the service invocation
	 */
		,successHandler: function(serviceResponse) {
			if (typeof(savedOrdersJS) != null && typeof(savedOrdersJS) != 'undefined') {
				// Call again to delete any other orders in the list.
				savedOrdersJS.cancelSavedOrder(false);
			}
		}

	 /**
	 * display an error message
	 * @param (object) serviceResponse The service response object, which is the
	 * JSON object returned by the service invocation
	 */
		,failureHandler: function(serviceResponse) {

			if (serviceResponse.errorMessage) {
				 if (serviceResponse.errorCode == "CMN0409E")
				 {
					 MessageHelper.displayErrorMessage(MessageHelper.messages["ORDER_NOT_CANCELLED"]);
				 }
				 else
				 {
					 MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
				 }
			}
			else {
				 if (serviceResponse.errorMessageKey) {
					MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
				 }
			}
			cursor_clear();
		}
	}),

	/**
	 * Update the description of a saved order. This service is used to update the description of multiple saved orders one at a time.
	 * Perform the service or command call.
	 */
	wcService.declare({
		id: "AjaxOrderSave",
		actionId: "AjaxOrderSave",
		url: getAbsoluteURL() + "AjaxRESTOrderCopy",
		formId: ""

	 /**
	 * display a success message
	 * @param (object) serviceResponse The service response object, which is the
	 * JSON object returned by the service invocation
	 */
		,successHandler: function(serviceResponse) {
			if (typeof(savedOrdersJS) != null && typeof(savedOrdersJS) != 'undefined') {
				// Call again to delete any other orders in the list.
				savedOrdersJS.saveOrder(false);
			}
		}

	 /**
	 * display an error message
	 * @param (object) serviceResponse The service response object, which is the
	 * JSON object returned by the service invocation
	 */
		,failureHandler: function(serviceResponse) {

			if (serviceResponse.errorMessage) {
				 if (serviceResponse.errorCode == "CMN0409E")
				 {
					 MessageHelper.displayErrorMessage(MessageHelper.messages["ORDER_NOT_SAVED"]);
				 }
				 else
				 {
					 MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
				 }
			}
			else {
				 if (serviceResponse.errorMessageKey) {
					MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
				 }
			}
			cursor_clear();
		}
	}),

	/**
	 * Set the current order to be that of a saved order.
	 * Perform the service or command call.
	 */
	wcService.declare({
		id: "AjaxSetPendingOrder",
		actionId: "AjaxSetPendingOrder",
		url: getAbsoluteURL() + "AjaxRESTSetPendingOrder",
		formId: ""

	 /**
	 * display a success message
	 * @param (object) serviceResponse The service response object, which is the
	 * JSON object returned by the service invocation
	 */

		,successHandler: function(serviceResponse) {

			MessageHelper.hideAndClearMessage();

			MessageHelper.displayStatusMessage(MessageHelper.messages["MYACCOUNT_SAVEDORDERLIST_SET_AS_CURRENT_SUCCESS"]);
			
			if (typeof(savedOrdersJS) != null && typeof(savedOrdersJS) != 'undefined') {
				savedOrdersJS.determinePageForward("AjaxSetPendingOrder");
			}

			cursor_clear();

		}
	 /**
	 * display an error message
	 * @param (object) serviceResponse The service response object, which is the
	 * JSON object returned by the service invocation
	 */
		,failureHandler: function(serviceResponse) {

			if (serviceResponse.errorMessage) {
				 if (serviceResponse.errorCode == "CMN0409E" || serviceResponse.errorCode == "CMN1024E")
				 {
					 MessageHelper.displayErrorMessage(MessageHelper.messages["MYACCOUNT_SAVEDORDERLIST_SET_AS_CURRENT_FAIL"]);
				 }
				 else
				 {
					 MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
				 }
			}
			else {
				 if (serviceResponse.errorMessageKey) {
					MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
				 }
			}
			cursor_clear();
		}

	}),


	/**
	 * Updates the current pending order setting it to the current shopping cart.
	 * This service does not cause a refresh of the ListOrdersDisplay_Controller registered widgets.
	 * The main function of this service is to keep the cpendorder database table in line with the current shopping cart.
	 * Perform the service or command call.
	 * @constructor
	 */
	wcService.declare({
		id: "AjaxUpdatePendingOrder",
		actionId: "AjaxUpdatePendingOrder",
		url: getAbsoluteURL() + "AjaxRESTSetPendingOrder",
		formId: ""

	 /**
	 * There is nothing to do in the event of a success of this service since it is executed in the background.
	 * @param (object) serviceResponse The service response object, which is the
	 * JSON object returned by the service invocation
	 */

		,successHandler: function(serviceResponse) {
			if (typeof(savedOrdersJS) != null && typeof(savedOrdersJS) != 'undefined') {
				savedOrdersJS.determinePageForward("AjaxUpdatePendingOrder");
			}
			cursor_clear();

		}
	 /**
	 * display an error message
	 * @param (object) serviceResponse The service response object, which is the
	 * JSON object returned by the service invocation
	 */
		,failureHandler: function(serviceResponse) {

			if (serviceResponse.errorMessage) {
				if (serviceResponse.errorCode == "CMN0409E")
				 {
					 MessageHelper.displayErrorMessage(MessageHelper.messages["ORDER_NOT_SET_CURRENT"]);
				 }
				 else
				 {
					 MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
				 }
			}
			else {
				 if (serviceResponse.errorMessageKey) {
					MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
				 }
			}
			cursor_clear();
		}

	}),

	/**
	 * Copy a saved order.
	 * Perform the service or command call.
	 */
	wcService.declare({
		id: "AjaxSingleOrderCopy",
		actionId: "AjaxSingleOrderCopy",
		url: getAbsoluteURL() + "AjaxRESTOrderCopy",
		formId: ""

	 /**
	 * display a success message
	 * @param (object) serviceResponse The service response object, which is the
	 * JSON object returned by the service invocation
	 */

		,successHandler: function(serviceResponse) {

		var params = [];

		params.storeId		= this.storeId;
		params.catalogId	= this.catalogId;
		params.langId		= this.langId;
		params.URL="";
		params.updatePrices = "1";

		params.orderId = serviceResponse.orderId;
		params.calculationUsageId = "-1";

		wcService.invoke("AjaxSingleOrderCalculate", params);
			MessageHelper.hideAndClearMessage();

		}

	 /**
	 * display an error message
	 * @param (object) serviceResponse The service response object, which is the
	 * JSON object returned by the service invocation
	 */
		,failureHandler: function(serviceResponse) {

			if (serviceResponse.errorMessage) {
				 if (serviceResponse.errorCode == "CMN0409E")
				 {
					 MessageHelper.displayErrorMessage(MessageHelper.messages["ORDER_NOT_COPIED"]);
				 }
				 else
				 {
					 MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
				 }
			}
			else {
				 if (serviceResponse.errorMessageKey) {
					MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
				 }
			}
			cursor_clear();
		}

	}),

	/**
	 * Copy a saved order.
	 * Perform the service or command call.
	 */
	wcService.declare({
		id: "AjaxOrderCopy",
		actionId: "AjaxOrderCopy",
		url: getAbsoluteURL() + "AjaxRESTOrderCopy",
		formId: ""

	/**
	* display a success message
	* @param (object) serviceResponse The service response object, which is the
	* JSON object returned by the service invocation
	*/

		,successHandler: function(serviceResponse) {

		var params = [];

		params.storeId		= ServicesDeclarationJS.storeId;
		params.catalogId	= ServicesDeclarationJS.catalogId;
		params.langId		= ServicesDeclarationJS.langId;
		params.URL="";
		params.updatePrices = "1";

		params.orderId = serviceResponse.orderId;
		params.calculationUsageId = "-1";

		wcService.invoke("AjaxOrderCalculate", params);
			MessageHelper.hideAndClearMessage();

		}

	/**
	* display an error message
	* @param (object) serviceResponse The service response object, which is the
	* JSON object returned by the service invocation
	*/
		,failureHandler: function(serviceResponse) {

			if (serviceResponse.errorMessage) {
				 if (serviceResponse.errorCode == "CMN0409E")
				 {
					 MessageHelper.displayErrorMessage(MessageHelper.messages["ORDER_NOT_COPIED"]);
				 }
				 else
				 {
					 MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
				 }
			}
			else {
				 if (serviceResponse.errorMessageKey) {
					MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
				 }
			}
			cursor_clear();
		}

	}),

	/**
	 * Perform the order calculation operations to compute the contract prices for the order items in an order.
	 * Perform the service or command call.
	 */
	wcService.declare({
		id: "AjaxSingleOrderCalculate",
		actionId: "AjaxSingleOrderCalculate",
		url: getAbsoluteURL() + "AjaxRESTOrderCalculate",
		formId: ""

	 /**
	 * display a success message
	 * @param (object) serviceResponse The service response object, which is the
	 * JSON object returned by the service invocation
	 */

		,successHandler: function(serviceResponse) {

			MessageHelper.hideAndClearMessage();
			MessageHelper.displayStatusMessage(MessageHelper.messages["MYACCOUNT_SAVEDORDERLIST_CALCULATE_SUCCESS"]);
			cursor_clear();
		}

	 /**
	 * display an error message
	 * @param (object) serviceResponse The service response object, which is the
	 * JSON object returned by the service invocation
	 */
		,failureHandler: function(serviceResponse) {

			if (serviceResponse.errorMessage) {
				if (serviceResponse.errorCode == "CMN0409E")
				 {
					 MessageHelper.displayErrorMessage(MessageHelper.messages["MYACCOUNT_SAVEDORDERLIST_CALCULATE_FAIL"]);
				 }
				 else
				 {
					 MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
				 }
			}
			else {
				 if (serviceResponse.errorMessageKey) {
					MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
				 }
			}
			cursor_clear();
		}

	}),

	/**
	 * Perform the order calculation operations to compute the contract prices for the order items in an order.
	 * Perform the service or command call.
	 */
	wcService.declare({
		id: "AjaxCurrentOrderCalculate",
		actionId: "AjaxCurrentOrderCalculate",
		url: getAbsoluteURL() + "AjaxRESTOrderCalculate",
		formId: ""

	 /**
	 * display a success message
	 * @param (object) serviceResponse The service response object, which is the
	 * JSON object returned by the service invocation
	 */

		,successHandler: function(serviceResponse) {

			MessageHelper.hideAndClearMessage();
			MessageHelper.displayStatusMessage(MessageHelper.messages["ORDER_SET_CURRENT"]);
			cursor_clear();
		}

	 /**
	 * display an error message
	 * @param (object) serviceResponse The service response object, which is the
	 * JSON object returned by the service invocation
	 */
		,failureHandler: function(serviceResponse) {

			if (serviceResponse.errorMessage) {
				if (serviceResponse.errorCode == "CMN0409E")
				 {
					 MessageHelper.displayErrorMessage(MessageHelper.messages["ORDER_NOT_COPIED"]);
				 }
				 else
				 {
					 MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
				 }
			}
			else {
				 if (serviceResponse.errorMessageKey) {
					MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
				 }
			}
			cursor_clear();
		}

	}),

	/**
	 * Perform the order calculation operations to compute the contract prices for the order items in an order.
	 * Perform the service or command call.
	 */
	wcService.declare({
		id: "AjaxOrderCalculate",
		actionId: "AjaxOrderCalculate",
		url: getAbsoluteURL() + "AjaxRESTOrderCalculate",
		formId: ""

	 /**
	 * display a success message
	 * @param (object) serviceResponse The service response object, which is the
	 * JSON object returned by the service invocation
	 */

		,successHandler: function(serviceResponse) {

			MessageHelper.hideAndClearMessage();
			if (typeof(savedOrdersJS) != null && typeof(savedOrdersJS) != 'undefined') {
				// Call again to copy any other orders in the list.
				savedOrdersJS.copyOrder(false);
			}
		}

	 /**
	 * display an error message
	 * @param (object) serviceResponse The service response object, which is the
	 * JSON object returned by the service invocation
	 */
		,failureHandler: function(serviceResponse) {

			if (serviceResponse.errorMessage) {
				if (serviceResponse.errorCode == "CMN0409E")
				 {
					 MessageHelper.displayErrorMessage(MessageHelper.messages["ORDER_NOT_COPIED"]);
				 }
				 else
				 {
					 MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
				 }
			}
			else {
				 if (serviceResponse.errorMessageKey) {
					MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
				 }
			}
			cursor_clear();
		}

	}),


	/**
	 * Processes a punchout payment request.
	 */
	wcService.declare({
		id: "AjaxPunchoutPay",
		actionId: "AjaxPunchoutPay",
		url: "AjaxRESTOrderRePay",
		formId: ""

		/**
		 * Calls PunchoutJS.handleResponse to render the punchout payment section on the page.
		 * @param (object) serviceResponse The service response object, which is the JSON object returned by the service invocation
		 */
		,successHandler: function(serviceResponse) {
			PunchoutJS.handleResponse(serviceResponse.orderId);
			MessageHelper.hideAndClearMessage();
			cursor_clear();
		}

		/**
		 * Displays an error message on the page if the request failed.
		 * @param (object) serviceResponse The service response object, which is the JSON object returned by the service invocation.
		 */
		,failureHandler: function(serviceResponse) {
			if (serviceResponse.errorMessage) {
				MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
			} else {
				if (serviceResponse.errorMessageKey) {
					MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
				}
			}
			cursor_clear();
		}
	}),


	/**
	 * Subscribes to or unsubscribes from receiving information related to a particular category in the store.
	 */
	wcService.declare({
		id: "AjaxCategorySubscribe",
		actionId: "AjaxCategorySubscribe",
		url: "AjaxRESTMarketingTriggerProcessServiceEvaluate",
		formId: ""

		/**
		 * Clear messages on the page.
		 * @param (object) serviceResponse The service response object, which is the JSON object returned by the service invocation
		 */
		,successHandler: function(serviceResponse) {
			MessageHelper.hideAndClearMessage();
			MessageHelper.displayStatusMessage(MessageHelper.messages["SUBSCRIPTION_UPDATED"]);
		}

		/**
		 * Displays an error message on the page if the request failed.
		 * @param (object) serviceResponse The service response object, which is the JSON object returned by the service invocation.
		 */
		,failureHandler: function(serviceResponse) {
			if (serviceResponse.errorMessage) {
				MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
			} else {
				if (serviceResponse.errorMessageKey) {
					MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
				}
			}
			cursor_clear();
		}
	}),

	/**
	 * Registers a marketing event for input parameters
	 */
	wcService.declare({
		id: "AjaxMarketingTriggerInvoke",
		actionId: "AjaxMarketingTriggerInvoke",
		url: "AjaxRESTMarketingTriggerProcessServiceEvaluate",
		formId: ""

		/**
		 * Clear messages on the page.
		 * @param (object) serviceResponse The service response object, which is the JSON object returned by the service invocation
		 */
		,successHandler: function(serviceResponse) {
			console.debug("marketing event logged");
		}

		/**
		 * Displays an error message on the page if the request failed.
		 * @param (object) serviceResponse The service response object, which is the JSON object returned by the service invocation.
		 */
		,failureHandler: function(serviceResponse) {
			console.debug("marketing event logging failed");
		}
	})
//-----------------------------------------------------------------
// Licensed Materials - Property of IBM
//
// WebSphere Commerce
//
// (C) Copyright IBM Corp. 2009, 2016 All Rights Reserved.
//
// US Government Users Restricted Rights - Use, duplication or
// disclosure restricted by GSA ADP Schedule Contract with
// IBM Corp.
//-----------------------------------------------------------------

//<%--
//********************************************************************


/**
 * @fileOverview This class contains key-value paired variables that are
 * mapped to their respective services. The variables are used to determine
 * which refresh areas to update. For example, the order_updated variable is
 * used update order related refresh areas.
 */


/**
 * map order_updated to all the services that result in changes to an order
 * @static
 */
var order_updated = {	'AjaxAddOrderItem':'AjaxAddOrderItem',
											'AjaxAddOrderItemWithShipingInfo':'AjaxAddOrderItemWithShipingInfo',
											'AjaxDeleteOrderItem':'AjaxDeleteOrderItem',
											'AjaxUpdateOrderItem':'AjaxUpdateOrderItem',
											'AjaxUpdateOrderShippingInfo':'AjaxUpdateOrderShippingInfo',
											'AjaxOrderCalculate':'AjaxOrderCalculate',
											'AjaxLogoff':'AjaxLogoff',
											'AjaxSetPendingOrder':'AjaxSetPendingOrder',
											'AjaxUpdatePendingOrder':'AjaxUpdatePendingOrder',
											'AjaxSingleOrderCancel':'AjaxSingleOrderCancel',
											'AjaxUpdateRewardOption':'AjaxUpdateRewardOption'
										};

/**
 *  map address_updated to all the services that result in changes to a shopper's
 *  address book
 *  @static
 */
var address_updated = {	'AjaxDeleteAddressForPerson':'AjaxDeleteAddressForPerson',
			'AjaxAddAddressForPerson':'AjaxAddAddressForPerson',
			'AjaxUpdateAddressForPerson':'AjaxUpdateAddressForPerson',
			'AjaxAddShippingAndBillingAddressForPersonDuringCheckout':'AjaxAddShippingAndBillingAddressForPersonDuringCheckout',
			'AjaxUpdateShippingAndBillingAddressForPersonDuringCheckout':'AjaxUpdateShippingAndBillingAddressForPersonDuringCheckout'
		};

/**
 *  map user_changed to all the services that result in the user in session
 *  change
 *  @static
 */
var user_changed = {	'AjaxLogonService':'AjaxLogonService',
											'AjaxLogoff':'AjaxLogoff'
										};

/**
 *  map wishlist_changed to all the services that result in the changes to a wish list
 *  @static
 */
var wishlist_changed = {	'AjaxInterestItemAdd':'AjaxInterestItemAdd',
												'AjaxInterestItemDelete':'AjaxInterestItemDelete',
												'AjaxLogonService':'AjaxLogonService',
												'AjaxLogoff':'AjaxLogoff'
											};
//-----------------------------------------------------------------
// Licensed Materials - Property of IBM
//
// WebSphere Commerce
//
// (C) Copyright IBM Corp. 2009, 2016 All Rights Reserved.
//
// US Government Users Restricted Rights - Use, duplication or
// disclosure restricted by GSA ADP Schedule Contract with
// IBM Corp.
//-----------------------------------------------------------------

wcTopic.subscribe("ajaxRequestInitiated", incrementNumAjaxRequest);
wcTopic.subscribe("ajaxRequestCompleted", decrementNumAjaxRequest);
wcTopic.subscribe("ajaxRequestCompleted", initializeInactivityWarning);

/**
 * @fileOverview This file provides the common functions which are specific to the Aurora store.
 * This JavaScript file is used by StoreCommonUtilities.jspf.
 */

// Handle Order error.
wcTopic.subscribe("OrderError", function (errorObj){
    if(errorObj.errorCode == 'CMN4512I'){
        //CMN4512I is OrderLocked error. So refresh miniCart.
        setDeleteCartCookie();
        //Since cart cookie is deleted, we don't need to pass currency/lang. It will be fetched from server
        loadMiniCart(null,null);
    }
});

/** This variable indicates whether the dropdown is shown or not. */
var showDropdown = false;

/** This variable stores the current dropdown dialog element. */
var dropDownDlg = null;

/** This variable stores the current product added dropdown dialog element. */
var productAddedDropDownDlg = null;

/** This variable is used to store the width of the mini shopping cart on page load. It is used when shopper's browser is IE6. */
var originalMiniCartWidth = 0;

/** This variable indicates whether the browser used is Internet Explorer or not. */
var isIE = (document.all) ? true : false;

/** Initializes the variable to false. **/
    var correctBrowser = false;

/**
 * This variable indicates whether a request has been submitted or not.
 * The value is initialized to true and resets to false on full page load.
 */
var requestSubmitted = true;

/**
 * This variable stores the id of the element (ex: button/link) which the user clicked.
 * This id is set when the user clicks an element which triggers an Ajax request.
 */
var currentId = "";

/**
 * This variable keeps track of the number of active ajax requests currently running on the page
 * The value is initialized to 0.
 */
var numAjaxRequests = 0,

widgetsList = [];

/**
 * Variable to save whether a tab or shift-tab was pressed
 */
var tabPressed = false;

/** This variable is used to keep track of the quick info/compare touch events */
var currentPopup = '';

/** This variable indicates whether Android is used or not */
var android = null;

/** This variable indicates whether iOS is used or not */
var ios = null;

/**
 * This variable contains the cookie domain for current store cookies.
 * Modify the cookie domain once here and it will be applied everywhere else for the particular store.
 */
var cookieDomain = "";

/** Base Text Direction Preference */
var _BTD_PREFS = "WC_Base_Text_Direction",

detectedLocale = Utils.getLocale();

/**
 * Initialize the client side inactivity warning dialog, this function is called at every page load and at
 * every the time when ajax request completed.  Be default, 30 seconds before the session timeout, a dialog
 * will popup and display a warning to let the user to extend the time.  The timing of when the dialog
 * will be displayed can be modified with "inactivityWarningDialogBuffer" variable in CommonJSToInclude.jspf
 */
function initializeInactivityWarning() {

    // only set timer if user is not guest, in a full-auth session, and is able to retrieve inactivityTimeout from server
    if (storeUserType != "G" && inactivityTimeout != 0 && document.cookie.indexOf("WC_USERACTIVITY_") > 0) {
        // Reset the inactivity timer dialog
        if (inactivityTimeoutTracker != null) {
            clearTimeout(inactivityTimeoutTracker);
        }

        // setup the inactivity timout tracker
        inactivityTimeoutTracker = setTimeout(showInactivityWarningDialog, inactivityTimeout - inactivityWarningDialogBuffer);
    }
}

/**
 * Show the inactivity warning dialog, the dialog will be closed in 20 seconds.  The timing of when the dialog
 * will be closed can be modified with "inactivityWarningDialogDisplayTimer" variable in CommonJSToInclude.jspf
 */
function showInactivityWarningDialog() {
    $("#inactivityWarningPopup").data("wc-WCDialog").open();
    if (dialogTimeoutTracker != null) {
        clearTimeout(dialogTimeoutTracker);
    }
    dialogTimeoutTracker = setTimeout(hideInactivityWarningDialog, inactivityWarningDialogDisplayTimer);
}

/**
 * Hide the inactivity warning dialog
 */
function hideInactivityWarningDialog() {
    $("#inactivityWarningPopup").hide();
}

/**
 * Send a Ping request to server to reset the inactivity timer.  The client side timer to display the inactivity warning
 * dialog will also be reset.
 */
function resetServerInactivity() {
    $.post({
        url: getAbsoluteURL() + "Ping",
        //handleAs: "json-comment-filtered",
        success: function(data, textStatus, jqXHR) {
            if (data.success) {
                initializeInactivityWarning();
            } else {
                console.error("Ping service failed");
            }
        },
        error: function(jqXHR, textStatus, error) {
            console.error("Ping service failed");
        }
    });
}

/**
 * DOM Shorthand
 */
function byId(r){
    return document.getElementById(r);
}

/**
 * Sends back focus to the first focusable element on tabbing from the last focusable element.
 */
function focusSetter(){
    if($("#MiniCartFocusReceiver1").length)
        $("#MiniCartFocusReceiver1").focus();
    else
        $("#MiniCartFocusReceiver2").focus();
}

/**
 * Sends back focus to the last focusable element on reverse tabbing from the first focusable element.
 *
 * @param {object} event The event triggered from user actions
 */
function determineFocus(event) {
        if(event.shiftKey && event.keyCode === KeyCodes.TAB)
        {
            if(event.srcElement)
            {
                if(event.srcElement.id=="MiniCartFocusReceiver1")
                {
                    $("#WC_MiniShopCartDisplay_link_5").focus();
                    Utils.stopEvent(event);
                }
                else if(event.srcElement.id=="MiniCartFocusReceiver2")
                {
                    $("#MiniCartFocusReceiver2").focus();
                    Utils.stopEvent(event);
                }
            }
            else
            {
                if(event.target.id=="MiniCartFocusReceiver1")
                {
                    $("#WC_MiniShopCartDisplay_link_5").focus();
                    Utils.stopEvent(event);
                }
                else if(event.target.id=="MiniCartFocusReceiver2")
                {
                    $("#MiniCartFocusReceiver2").focus();
                    Utils.stopEvent(event);
                }
            }
        }
}

/**
 * Destroys the existing dialogs with outdated data.
 * @param {string} contentId The identifier of the dialog to destroy. If undefined, the default is 'quick_cart_container'.
 */
function destroyDialog(contentId){
    if(contentId == undefined){
        contentId = 'quick_cart_container';
    }
    //If data has changed, then we should destroy the quick_cart_container dialog and recreate it with latest data
    var dialog = $("#" + contentId).data("wc-WCDialog");
    if (dialog) {
        dialog.destroy();
    }

    if(contentId != undefined && contentId == 'quick_cart_container'){
         dropDownDlg = null;
    } else {
        productAddedDropDownDlg = null;
    }
}

/**
 * Loads the specified URL.
 *
 * @param {string} url The URL of the page to be loaded.
 */
function loadLink(url){
    document.location.href=url;
}

/**
 * Clears the Search term string displayed in Simple Search field.
 */
function clearSearchField() {
    searchText = $("#SimpleSearchForm_SearchTerm").val()
    if(searchText == $("#searchTextHolder").html()){
        $("#SimpleSearchForm_SearchTerm").val("");
    }
    else{
        document.getElementById("SimpleSearchForm_SearchTerm").select();
        showAutoSuggestIfResults();
        autoSuggestHover = false;
    }
}

/**
 * Displays the Search term string in Simple Search field.
 */
function fillSearchField() {
    if ($("#SimpleSearchForm_SearchTerm").val()== "") {
        document.getElementById("SimpleSearchForm_SearchTerm").className = "search_input gray_color";
        $("#SimpleSearchForm_SearchTerm").val($("#searchTextHolder").html());
    }
    // hide the search box results
    if(!autoSuggestHover) {
        showAutoSuggest(false);
    }
}

/**
 * Displays the top dropdown menu, including the category dropdowns and the mini shopping cart.
 */
function showDropDownMenu(){
    $("#header_menu_dropdown").css("display", "block");
    $("#outerCartContainer").css("display", "block");
}

/**
 * Displays the progress bar dialog to indicate a request is currently running.
 * There are certain cases where displaying the progress bar causes problems in Opera,
 * the optional parameter "checkForOpera" is passed to specifically check if the browser used is Opera,
 * if so, do not display the progress bar in these cases.
 *
 * @param {boolean} checkForOpera Indicates whether to check if the browser is Opera or not.
 */
function cursor_wait(checkForOpera) {
    var showPopup = true;

    //Since dijit does not support Opera
    //Some progress bar dialog will be blocked in Opera to avoid error
    if(checkForOpera == true){
        if(Utils.isOpera()){
            showPopup = false;
        }
    }

    //For all other browsers and pages that work with Opera
    //Display the progress bar dialog
    if(showPopup){
        //Delay the progress bar from showing up
        setTimeout('showProgressBar()',500);
    }
}

/**
 * Helper method for cursor_wait() to display the progress bar pop-up.
 * Displays progress bar, next to the element if the element id was specified in currentId,
 * or defaults to the center of the page if currentId is empty.
 * Progress bar will only be displayed if the submitted request has not been completed.
 * This method is only called implicitly by the cursor_wait() method, which is triggered before a request is submitted.
 */
function showProgressBar(){
    //After the delay, if the request is still not finished
    //Then continue and show the progress bar
    //Otherwise, do not execute the following code
    if(!requestSubmitted){
        return;
    }

    displayProgressBar();

}


/**
 * Helper method for showProgressBar() to display the progress bar pop-up.
 * It can also be forced to show the progress bar directly in special cases.
 * The function also displays the progress bar next to the element if the element id was specified in currentId,
 * or defaults to the center of the page if currentId is empty.
 * This method can be called implicitly by the cursor_wait() method or explicitly by itself.
 */
function displayProgressBar() {
    var dialog = $('#progress_bar_dialog').data("wc-WCDialog");

    //Make sure the dialog is created
    if (dialog) {

        var progressBar = $('#progress_bar');
        progressBar.css("display", "block");

        //Check whether or not an element ID is provided
        //If yes, point the progress bar to this element
        //Otherwise, show the progress bar in a dialog
        if (this.currentId !== "") {
            dialog.option("position", {
                my: "left top",
                at: "right top",
                of: $("#" + this.currentId)
            });
        } else {
            //dialog.containerNode.innerHTML === "";
            progressBar.css("left", '');
            progressBar.css("top", '');
            dialog.element.html(progressBar);
            //dialog.containerNode.appendChild(progressBar);

        }
        dialog.open();
        //Make sure the progress bar dialog goes away after 30 minutes
        //and does not hang if server calls does not return
        //Assuming the longest server calls return before 30 minutes
        setTimeout("cursor_clear()", 1800000);
    }
}

/**
 * Stores the id of the element (ex: button/link) that triggered the current submitted request.
 * Store the new element id only when no request is currently running.
 *
 * @param {string} id The id of element triggering the submitted request.
 */
function setCurrentId(id){
    //If there is no request already submitted, update the id
    if(!requestSubmitted && this.currentId === ""){
        this.currentId = id;
    }
}

/**
 * This function trims the spaces from the pased in word.
 * Delete all pre and trailing spaces around the word.
 *
 * @param {string} inword The word to trim.
 */
function trim(inword)
{
    word = inword.toString();
    var i = 0,
    j = word.length-1;
    while(word.charAt(i) == " ") i++;
    while(word.charAt(j) == " ") j=j-1;
    if (i > j) {
        return word.substring(i,i);
    } else {
        return word.substring(i,j+1);
    }
}

/**
 * Hides the progress bar dialog when the submitted request has completed.
 * Set the visibility of the progress bar dialog to hide from the page.
 */
function cursor_clear() {
    //Reset the flag
    requestSubmitted = false;

    wcTopic.publish("requestSubmittedChanged", requestSubmitted);
    //Hide the progress bar dialog
    var dialog = $('#progress_bar_dialog').data("wc-WCDialog"),
    progressBar = document.getElementById('progress_bar');
    if(dialog != null){
        if(progressBar != null){
            $(progressBar).css("display", 'none');
        }
        dialog.close();
        this.currentId="";
    }
}

function escapeXml (str, fullConversion){
    if(fullConversion){
        str = str.replace(/&(?!(quot;|#34;|#034;|#x27;|#39;|#039;))/gm, "&amp;").replace(/</gm, "&lt;").replace(/>/gm, "&gt;");
    }
    str = str.replace(/"/gm, "&#034;").replace(/'/gm, "&#039;");
    return str;
}
/**
 * Checks whether a request can be submitted or not.
 * A new request may only be submitted when no request is currently running.
 * If a request is already running, then the new request will be rejected.
 *
 * @return {boolean} Indicates whether the new request was submitted (true) or rejected (false).
 */
function submitRequest() {
    if(!requestSubmitted) {
        requestSubmitted  = true;
        wcTopic.publish("requestSubmittedChanged", requestSubmitted);
        return true;
    }
    return false;
}

function resetRequest() {
    requestSubmitted = false;
    wcTopic.publish("requestSubmittedChanged", requestSubmitted);
}

/**
 * Set the current page to a new URL.
 * Takes a new URL as input and set the current page to it, executing the command in the URL.
 * Used for Non-ajax calls that requires multiple clicks handling.
 *
 * @param {string} newPageLink The URL of the new page to redirect to.
 */
function setPageLocation(newPageLink) {
    //For Handling multiple clicks
    if(!submitRequest()){
        return;
    }

    document.location.href = newPageLink;
}

/**
 * Submits the form parameter.
 * Requires a form element to be passed in and submits form with its inputs.
 * Used for Non-ajax calls that requires multiple clicks handling.
 *
 * @param {element} form The form to be submitted.
 */
function submitSpecifiedForm(form) {
    if(!submitRequest()){
        return;
    }
    console.debug("form.action == "+form.action);
    processAndSubmitForm(form);
}

/**
 * get location information of a given url
 * @param href
 * @returns url
 */
function getLocation(href) {
    var urlHref = href;
    if (!urlHref.match(/^[a-zA-Z]+:\/\//))
    {
        urlHref = 'http://' + urlHref;
    }
     var urlLocation = document.createElement("a");
     urlLocation.href = urlHref;

     return urlLocation;
}

/**
 * If the return URL belongs to a different domain from the current host,
 * return a blank page while go back button is clicked
 * @param url
 * @returns {String}
 */
function getReturnUrl(url) {
    var returnUrl;
    var urlLocation = this.getLocation(decodeURIComponent(url));
    if (urlLocation.hostname === location.hostname)
         returnUrl = url;
    else returnUrl = 'about:blank';
    location.href = returnUrl;
}

/**
 * solve issues in case cache is turned on, sometimes url is cached with
 * http or https portocol while accessed from an https or http protocol later on.
 * In this case we will match the protocol for ajax calls consistent with document.location.href
 * protocol
 * @param url
 * @returns {URL}
 */
function matchUrlProtocol(url){
	if(!stringStartsWith(url, "http")){
		//If it is relative URL, just return it.
		return url;
	}
    var href = document.location.href,
    index = href.lastIndexOf("s", 4),
    newUrl = url,
    urlIndex = newUrl.lastIndexOf("s", 4);
    if (index != -1 && urlIndex == -1){
         newUrl=newUrl.substring(0,4) + "s" + (newUrl.substring(4));
    }
    else if(index == -1 && urlIndex != -1)
    {
        newUrl = newUrl.substring(0,4) + (newUrl.substring(5));
    }
    return newUrl;
}

 /**
  * This function is used to hide an element with the specified id.
  * @param {string} elementId The id of the element to be hidden.
  */

  function hideElementById(elementId){
        $("#" + elementId).css("display", "none");
 }

/**
  * This function is used to display an element with the specified id.
  * @param {string} elementId The id of the element to be displayed.
  */

   function showElementById(elementId){
       $("#" + elementId).css("display", "block");
}

/**
  * This function is used to hide the background image of an element.
  * @param {DomNode} element The node whose background image is to be hidden.
  */
    function hideBackgroundImage(element){
        $(element).css("backgroundImage", 'none');
}

/**
  * This function is used to display the background image of a product onhover.
  * @param {DomNode} element The node for which the product hover background image is to be displayed.
  */

     function showBackgroundImage(element){
        $(element).css("backgroundImage", 'url('+getImageDirectoryPath()+getStyleDirectoryPath()+'product_hover_background.png)');
}
    /**
    * checkIE8Browser checks to see if the browser is IE 8 or less. It then sets correctBrowser to true if it is.
    *
    **/

    function checkIE8Browser() {
       if( Utils.get_IE_version() && Utils.get_IE_version() <= 8 ){
            correctBrowser = true;
       }
   }

    /**
    * ApprovalToolLink provides the appropriate URL if the browser is correct, otherwise displays a message.
    *
    * @param {String} idTag Used to identify the id tag in the jsp that is calling it.
    * @param {String} approvalToolLinkURL This is a URL which is passed from the calling jsp.
    *
    **/

    function ApprovalToolLink(idTag, approvalToolLinkURL) {

        //checks if the browser is IE 8 or less.
        checkIE8Browser();

        if (correctBrowser) {
          RFQwindow=window.open(approvalToolLinkURL);
        }
        else {
          MessageHelper.formErrorHandleClient(idTag,MessageHelper.messages["ERROR_INCORRECT_BROWSER"]); return;
        }
    }


/**
 * Updates view (image/detailed) and starting index of pagination of product display in SetCurrencyPreferenceForm when currency is changed from the drop-down menu.
 * These are later passed as url parameters.
 */

function updateViewAndBeginIndexForCurrencyChange(){
    if($("#fastFinderResultControls").length && document.getElementById('fastFinderResultControls')!='')
    {
        if(document.SetCurrencyPreferenceForm.pageView!=null){
            document.SetCurrencyPreferenceForm.pageView.value = document.FastFinderForm.pageView.value;
        }
        if(document.SetCurrencyPreferenceForm.beginIndex!=null){
            document.SetCurrencyPreferenceForm.beginIndex.value = document.FastFinderForm.beginIndex.value;
        }
    }
    else if($("#CategoryDisplay_Widget").length && document.getElementById('CategoryDisplay_Widget')!='')
    {
        if(wcRenderContext.getRenderContextProperties('CategoryDisplay_Context').properties['pageView'] !== '' && document.SetCurrencyPreferenceForm.pageView!=null){
            document.SetCurrencyPreferenceForm.pageView.value = wcRenderContext.getRenderContextProperties('CategoryDisplay_Context').properties['pageView'];
        }
        if(wcRenderContext.getRenderContextProperties('CategoryDisplay_Context').properties['beginIndex'] !== '' && document.SetCurrencyPreferenceForm.beginIndex!=null){
            document.SetCurrencyPreferenceForm.beginIndex.value = wcRenderContext.getRenderContextProperties('CategoryDisplay_Context').properties['beginIndex'];
        }
    }
    else if($("#Search_Result_Summary").length && document.getElementById('Search_Result_Summary')!='')
    {
        if(wcRenderContext.getRenderContextProperties('catalogSearchResultDisplay_Context').properties['searchResultsView'] !== '' && document.SetCurrencyPreferenceForm.pageView!=null){
            document.SetCurrencyPreferenceForm.pageView.value = wcRenderContext.getRenderContextProperties('catalogSearchResultDisplay_Context').properties['searchResultsView'];
        }
        if(wcRenderContext.getRenderContextProperties('catalogSearchResultDisplay_Context').properties['searchResultsPageNum'] !== '' && document.SetCurrencyPreferenceForm.beginIndex!=null){
            document.SetCurrencyPreferenceForm.beginIndex.value=wcRenderContext.getRenderContextProperties('catalogSearchResultDisplay_Context').properties['searchResultsPageNum']
        }
    }
    else if($("#Search_Result_Summary2").length && document.getElementById('Search_Result_Summary2')!='')
    {
        if(wcRenderContext.getRenderContextProperties('contentSearchResultDisplay_Context').properties['searchResultsView'] !== '' && document.SetCurrencyPreferenceForm.pageView!=null){
            document.SetCurrencyPreferenceForm.pageView.value = wcRenderContext.getRenderContextProperties('contentSearchResultDisplay_Context').properties['searchResultsView'];
        }
        if(wcRenderContext.getRenderContextProperties('contentSearchResultDisplay_Context').properties['searchResultsPageNum'] !== '' && document.SetCurrencyPreferenceForm.beginIndex!=null){
            document.SetCurrencyPreferenceForm.beginIndex.value=wcRenderContext.getRenderContextProperties('contentSearchResultDisplay_Context').properties['searchResultsPageNum']
        }
    }

    //allow coshopper to change currency. Only used for coshopping
    try {
        if (window.top._ceaCollabDialog!=undefined || window.top._ceaCollabDialog!=null) {
            $('#SetCurrencyPreferenceForm')[0].URL.value=
                    $('#SetCurrencyPreferenceForm')[0].URL.value + "&coshopChangeCurrency=" +
                    $('#currencySelection').find(":selected").text();
        }
    }catch(err) {
        console.log(err);
    }
}


/**
 * Updates view (image/detailed) and starting index of pagination of product display in LanguageSelectionForm when language is changed from the drop-down menu.
 * These are later passed as url parameters.
 */

function updateViewAndBeginIndexForLanguageChange(){
    if($("#fastFinderResultControls").length && document.getElementById('fastFinderResultControls')!='')
    {
        if(document.LanguageSelectionForm.pageView!= null){
            document.LanguageSelectionForm.pageView.value = document.FastFinderForm.pageView.value;
        }
        if(document.LanguageSelectionForm.beginIndex!= null){
            document.LanguageSelectionForm.beginIndex.value = document.FastFinderForm.beginIndex.value;
        }
    }
    else if($("#CategoryDisplay_Widget").length && document.getElementById('CategoryDisplay_Widget')!='')
    {
        if(wcRenderContext.getRenderContextProperties('CategoryDisplay_Context').properties['pageView'] !== '' && document.LanguageSelectionForm.pageView!= null){
            document.LanguageSelectionForm.pageView.value = wcRenderContext.getRenderContextProperties('CategoryDisplay_Context').properties['pageView'];
        }
        if(wcRenderContext.getRenderContextProperties('CategoryDisplay_Context').properties['beginIndex'] !== '' && document.LanguageSelectionForm.beginIndex!= null){
            document.LanguageSelectionForm.beginIndex.value = wcRenderContext.getRenderContextProperties('CategoryDisplay_Context').properties['beginIndex'];
        }
    }
    else if($("#Search_Result_Summary").length && document.getElementById('Search_Result_Summary')!='')
    {
        if(wcRenderContext.getRenderContextProperties('catalogSearchResultDisplay_Context').properties['searchResultsView'] !== '' && document.LanguageSelectionForm.pageView!= null){
            document.LanguageSelectionForm.pageView.value = wcRenderContext.getRenderContextProperties('catalogSearchResultDisplay_Context').properties['searchResultsView'];
        }
        if(wcRenderContext.getRenderContextProperties('catalogSearchResultDisplay_Context').properties['searchResultsPageNum'] !== '' && document.LanguageSelectionForm.beginIndex!= null){
            document.LanguageSelectionForm.beginIndex.value = wcRenderContext.getRenderContextProperties('catalogSearchResultDisplay_Context').properties['searchResultsPageNum'];
        }
    }
    else if($("#Search_Result_Summary2").length && document.getElementById('Search_Result_Summary2')!='')
    {
        if(wcRenderContext.getRenderContextProperties('contentSearchResultDisplay_Context').properties['searchResultsView'] !== '' && document.LanguageSelectionForm.pageView!= null){
            document.LanguageSelectionForm.pageView.value = wcRenderContext.getRenderContextProperties('contentSearchResultDisplay_Context').properties['searchResultsView'];
        }
        if(wcRenderContext.getRenderContextProperties('contentSearchResultDisplay_Context').properties['searchResultsPageNum'] !== '' && document.LanguageSelectionForm.beginIndex!= null){
            document.LanguageSelectionForm.beginIndex.value = wcRenderContext.getRenderContextProperties('contentSearchResultDisplay_Context').properties['searchResultsPageNum'];
        }
    }

    //appending landId to the URL. Only used for coshopping
    try {
        if (window.top._ceaCollabDialog!=undefined || window.top._ceaCollabDialog!=null) {
            $('#LanguageSelectionForm').attr("action",  $("#LanguageSelectionForm").attr("action") + "&langId=" +
                $('#languageSelection').find(":selected").text());
        }
    }catch(err) {
        console.log(err);
    }
}

/**
 * Displays the header links in two lines.
 */
function showHeaderLinksInTwoLines(){
    if($("#header_links").length){
        if($("#header_links").width() > 750){
            $("#header_links1").css("display", "block");
            $("#headerHomeLink").css("display", "none");
            $("#headerShopCartLink").css("display", "none");
        }
        $("#header_links").css("visibility", "visible");
    }
}

/**
  * Displays the header links in one line.
  */
 function showLinksInOneLine(){
    $("#header_links").css("visibility", "visible");
 }

/**
 * Validates if the input value is a non-negative integer using regular expression.
 *
 * @param {String} value The value to validate.
 *
 * @return {Boolean} Indicates if the given value is a non-negative integer.
 */
function isNonNegativeInteger(value){
    var regExpTester = new RegExp(/^\d*$/);
    return (value != null && value !== "" && regExpTester.test(value));
}

/**
* Validates if the input value is a positive integer.
*
* @param {String} value The value to validate.
*
* @return {Boolean} Indicates if the given value is a positive integer.
*/
function isPositiveInteger(value){
    return (isNonNegativeInteger(value) && value != 0);
}

/**
 * This function closes all dialogs on the page.
 */
function closeAllDialogs(){
    $("[data-widget-type='wc.WCDialog']").each(function (i, e) {
        $(e).hide();
    });
}

/**
 * This function store a error key in the cookie. The error key will be used to retrieve error messages.
 * @param {String} errorKey  The key used to retrieve error/warning messages.
 */
function setWarningMessageCookie(errorKey) {
    setCookie("signon_warning_cookie",errorKey, {path: "/", domain: cookieDomain});
}
/**
* This function removes a cookie
* @param {String} name the name of the cookie to be removed.
*/
function removeCookie(name) {
    setCookie(name, null, {expires: -1});
}
/**
* This function gets a cookie
* @param {String} c the name of the cookie to be get.
*/
function getCookie(c) {
    var cookies = document.cookie.split(";");
    for (var i = 0; i < cookies.length; i++) {
        var index = cookies[i].indexOf("="),
        name = cookies[i].substr(0,index);
        name = name.replace(/^\s+|\s+$/g,"");
        if (name == c) {
            return decodeURIComponent(cookies[i].substr(index + 1));
        }
    }
}

function deleteOnBehalfRoleCookie(){
    var deleteOnBhealfRoleCookieVal = getCookie("WC_OnBehalf_Role_"+WCParamJS.storeId);

    if(deleteOnBhealfRoleCookieVal != null){
        setCookie("WC_OnBehalf_Role_"+WCParamJS.storeId, null, {expires:-1,path:'/', domain:cookieDomain});
    }
}

/**
* This function gets a cookie by name which starts with the provided string
* @param {String} c the partial name (starts with) of the cookie to be get.
*/
function getCookieName_BeginningWith(c) {
    var cookies = document.cookie.split(";");
    for (var i = 0; i < cookies.length; i++) {
        var index = cookies[i].indexOf("="),
        name = cookies[i].substr(0,index);
        name = name.replace(/^\s+|\s+$/g,"");
        if (stringStartsWith(name,c)) {
            return name;
        }
    }
}

/**
* This function checks to see if the string start with the specified set of characters
* @param {String} basestr the string
* @param {String} c the substring to check for
*/
function stringStartsWith(basestr, str) {
    return str.length > 0 && basestr.substring( 0, str.length ) === str
}

/**
 * checks if the store is in preview mode
 * @param {String} contextPathUsed The context path being used by the Store.
 * @param {String} criteria criteria used to check if contextPathUsed is the preview context.
 */
function isStorePreview(contextPathUsed,criteria) {
    return contextPathUsed.indexOf(criteria) > -1;
}

/**
 * checks hides the ESpot info popup window
 * @param {String} The id of the popup dialog
 * @param {String} The browser event
 */
function hideESpotInfoPopup(id,event) {
    if(event!=null && event.type=="keypress" && event.keyCode !== KeyCodes.ESCAPE) {
        return;
    }
    else {
        var quickInfo = $("#" + id);
        if(quickInfo.length) {
            quickInfo.data("wc-WCDialog").close();
        }
    }
}

/**
 * checks shows the ESpot info popup window
 * @param {String} The id of the popup dialog
 * @param {String} The browser event
 */
function showESpotInfoPopup(id, event) {
    if (event != null && event.type == "keypress" && event.keyCode !== KeyCodes.RETURN) {
        return;
    } else {
        if (!parent.checkPopupAllowed()) {
            return;
        }
        var quickInfo = $("#" + id).data("wc-WCDialog");
        if (quickInfo) {
            // Bring this Dialog on top of other dialogs
	        quickInfo.bringToFront(); 
            // Bring this Dialog on top of eSpot overlay button
            quickInfo.bringToFront($(".ESpotInfo"));
            quickInfo.open();    
            quickInfo.reposition();
        }
    }
}

/**
* This function increments the numAjaxRequests counter by 1.
*/
function incrementNumAjaxRequest(){
    if(numAjaxRequests != 'undefined'){
        numAjaxRequests++;
    }
}

/**
* This function decrements the numAjaxRequests counter by 1.
*/
function decrementNumAjaxRequest(){
    if(numAjaxRequests != 'undefined'){
        if(numAjaxRequests != 0){
            numAjaxRequests--;
        }
    }
}

/**
* updateParamObject This function updates the given params object with a key to value pair mapping.
*                   If the toArray value is true, It creates an Array for duplicate entries otherwise it overwrites the old value.
*                   This is useful while making a service call which accepts a few parameters of type array.
*                   This function is used to prepare a a map of parameters which can be passed to XMLHttpRequests.
*                   The keys in this parameter map will be the name of the parameter to send and the value is the corresponding value for each parameter key.
* @param {Object} params The parameters object to add name value pairs to.
* @param {String} key The new key to add.
* @param {String} value The new value to add to the specified key.
* @param {Boolean} toArray Set to true to turn duplicate keys into an array, or false to override previous values for a specified key.
* @param {int} index The index in an array of values for a specified key in which to place a new value.
*
* @return {Object} params A parameters object holding name value pairs.
*
**/
function updateParamObject(params, key, value, toArray, index){

    if(params == null) {
        params = [];
    }
    if(params[key] != null && toArray) {
        if($.isArray(params[key])) {
            //3rd time onwards
            if(index != null && index !== "") {
                //overwrite the old value at specified index
                params[key][index] = value;
            } else {
                params[key].push(value);
            }
        } else {
            //2nd time
            var tmpValue = params[key];
            params[key] = [];
            params[key].push(tmpValue);
            params[key].push(value);
        }
   } else {
       //1st time
       if(index != null && index !== "" && index != -1) {
           //overwrite the old value at specified index
           params[key+"_"+index] = value;
       } else if(index == -1) {
           var i = 1;
           while(params[key + "_" + i] != null) {
               i++;
           }
           params[key + "_" + i] = value;
       } else {
           params[key] = value;
       }
   }
   return params;
 }

/**
 * Show the html element
 *
 * @param {string} id The id of the section to show.
 */
function showSection (id){
    $("#" + id).css("visibility", "visible");
}

/**
 * Hides the html element.
 *
 * @param {string} id The id of the section to hide.
 */
function hideSection (id){
    $("#" + id).css("visibility", "");
}

/**
 * hides the section if the user clicks shift+tab.
 *
 * @param {string} id The id of the div area to hide.
 * @param {event} event The keystroke event entered by the user.
 */
function shiftTabHideSection (id, event){
    if (event.shiftKey && (event.keyCode === KeyCodes.TAB)){
        hideSection(id);
    }
}

/**
 * hides the section if the user clicks tab.
 *
 * @param {string} id The id of the div area to hide.
 * @param {event} event The keystroke event entered by the user.
 */
function tabHideSection (id, event, nextId){
    if (!event.shiftKey && (event.keyCode === KeyCodes.TAB)){
        if(null != nextId){
            $("#" + nextId).focus();
        }
        hideSection(id);
        Utils.stopEvent(event);
    }
}

/**
 * Saves whether the shift and tab keys were pressed or not.  Ignores tab.
 * @param {event} event The event that happened by pressing a key
 */
function saveShiftTabPress(event) {
    if (event.shiftKey == true && event.keyCode === KeyCodes.TAB) {
        tabPressed = true;
    }
}

/**
 * Saves whether the tab key was pressed or not.  Ignores SHIFT-tab.
 * @param {event} event The event that happened by pressing a key
 */
function saveTabPress(event) {
    if (event.shiftKey == false && event.keyCode === KeyCodes.TAB) {
        tabPressed = true;
    }
}
/**
 * Sets the focus to the given form element if a tab or shift-tab was pressed.  Workaround to tabbing from a country dropdown
 * to a dynamic state element that becomes a dropdown when it was a textbox and vice versa.  Defect was Firefox specific.
 * @param {String} formElementId The form element id to set the focus to
 */
function setFocus(formElementId) {
    if (tabPressed) {
        tabPressed = false;
        document.getElementById(formElementId).focus();
    }
}

/**
 * Increase the height of a container due to the addition of a message
 * @param ${String} The id of the container whose height will be increased
 * @param ${Integer} Number of pixels to increase height by
 */
function increaseHeight(containerId, increase) {
    var temp = document.getElementById(containerId).offsetHeight;
    $("#" + containerId).css("height", (temp + increase) + 'px');
}

/**
 * Reload the current page.
 * @param ${forcedUrl} The url which sends user to the expected page.
 */
function redirectToSignOn(forcedUrl) {
	var widgetId = 'Header_GlobalLogin'; // This widgetId is defined in Header_UI.jspf / GlobalLoginActions.js / UserTimeoutView.jsp
	setCookie("WC_RedirectToPage_"+WCParamJS.storeId, forcedUrl, {path:'/', domain:cookieDomain});			
	GlobalLoginJS.InitHTTPSecure(widgetId);
}

/**
 * Keeps track of the current quick info/compare touch event in tablets
 * @param ${String} link The link of the product detail page
 * @param ${String} newPopup The id of the new product quick info/compare touched
 */
function handlePopup(link,newPopup) {
    if (currentPopup == newPopup){
        document.location.href = link;
    } else {
        currentPopup = newPopup;
    }
}

/**
 * Check to see if the device in use is running the android OS
 * @return {boolean} Indicates whether the device is running android
 */
function isAndroid() {
    if(android == null){
        if(navigator != null){
            if(navigator.userAgent != null){
                var ua = navigator.userAgent.toLowerCase();
                android = ua.indexOf("android") > -1;
            }
        }
    }
    return android;
}

/**
 * Check to see if the device in use is running iOS
 * @return {boolean} Indicates whether the device is running iOS
 */
function isIOS() {
    if(ios == null){
        if(navigator != null){
            if(navigator.userAgent != null){
                var ua = navigator.userAgent.toLowerCase();
                ios = (ua.indexOf("ipad") > -1) || (ua.indexOf("iphone") > -1) || (ua.indexOf("ipod") > -1);
            }
        }
    }
    return ios;
}


/**
* This function highlight all marketing spots and catalog objects in preview mode, overwriting the implementation in site level (StorePreviewerHeader.jsp)
*/
function outlineSpots(){
    $(document.body).addClass('editMode');
    $(".carousel > .content").css("zIndex", 'auto');
    $(".ESpotInfo").css("display", "block" );
    $(".searchScore").css("display", "block" );
    $(".editManagedContent").css("display", "block" );
    $(".genericESpot,.product,.searchResultSpot,.productDetail,.categorySpot").each(function (i, currEl) {
        if ($(currEl).hasClass("emptyESpot")) {
            var elementWidth = $('.ESpotInfo', currEl)[0].offsetWidth + 4,
                elementHeight = $('.ESpotInfo', currEl)[0].offsetHeight + 4;
            $(currEl).attr("_width", $(currEl).css('width'));
            $(currEl).attr("_height", $(currEl).css('height'));
            $(currEl).css({
                'width': +elementWidth + 'px',
                'height': elementHeight + 'px'
            });

        }
        if ($(".borderCaption").length) {
            $(currEl).prepend("<div class='borderCaption'></div>");
        } else {
            $(".borderCaption", currEl).css({
                'display': 'block'
            });
        }
        if (currEl.addEventListener) {
            currEl.addEventListener('mouseover', function (evt) {
                if (!window.parent.frames[0].isSpotsShown()) {
                    return;
                }
                $(".caption").css("display", "none"
                );
                $(".caption", this).first().css({
                    display: "block"
                });
                evt.stopPropagation();
            }, false);
            currEl.addEventListener('mouseout', function (evt) {
                if (!window.parent.frames[0].isSpotsShown()) {
                    return;
                }
                $(".caption", this).css({
                    display: "none"
                });
                evt.stopPropagation();
            }, false);
        } else if (currEl.attachEvent) {
            currEl.onmouseover = (
                (function (currEl) {
                    return (function () {
                        if (!window.parent.frames[0].isSpotsShown()) {
                            return;
                        }
                        $(".caption").css("display", "none");
                        $(".caption", currEl).first().css({
                            display: "block"
                        });
                        window.event.cancelBubble = true;
                    });
                })(currEl)
            );
            currEl.onmouseleave = (
                (function (currEl) {
                    return (function () {
                        if (!window.parent.frames[0].isSpotsShown()) {
                            return;
                        }
                        $(".caption", currEl).css({
                            display: "none"
                        });
                        window.event.cancelBubble = true;

                    });
                })(currEl)
            );
        }
    });
}

/**
* This function un-highlight all marketing spots and catalog objects in preview mode, overwriting the implementation in site level (StorePreviewerHeader.jsp)
*/
function hideSpots(){
    $(document.body).removeClass("editMode");
    $(".carousel > .content").css("zIndex", '');
    $(".ESpotInfo").css("display", "none");
    $(".caption").css("display", "none");
    $(".searchScore").css("display", "none");
    $(".editManagedContent").css("display", "none");
    $(".borderCaption").css("display", "none");
    $(".emptyESpot").each(function (i, e) {
        $(e).css({
            'width': $(e).attr("_width") + 'px'
        });
        $(e).css({
            'height': $(e).attr("_height") + 'px'
        });
    });

}

/**
* This function resets the mini cart cookie values, then continues to log off the shopper.
*/
function logout(url){
    setDeleteCartCookie();
    document.location.href = url;
}

/**
 * This function submits the Language and Currency selection form.
 * @param formName The name of the Language and Currency selection form.
 */
function switchLanguageCurrency(formName) {
    //to get the browser current url
    var browserURL = document.location.href,
    currentLangSEO = '/'+$("#currentLanguageSEO").val()+'/';

    // get rid of anything after pound sign(#) in the URL if it is a SearchDisplay request.
    // search processes the query parameters and cannot handle a redirect URL with pound sign(#)
    if ((browserURL.indexOf('SearchDisplay') !== -1 || browserURL.indexOf('CategoryDisplay') !== -1) && browserURL.indexOf('#') !== -1) {
        var poundTokens = browserURL.split('#');
        browserURL = poundTokens[0];
    }

    //set the form URL to the updated URL with the new language keyword
    //for example: replace /en/ with the new keyword
    var modifiedFormURL = browserURL;
    if (browserURL.indexOf(currentLangSEO) !== -1) {
        if (document.getElementById('langSEO'+document.getElementById('languageSelection').options[document.getElementById('languageSelection').selectedIndex].value)) {
            var newLangSEO = '/'+document.getElementById('langSEO'+document.getElementById('languageSelection').options[document.getElementById('languageSelection').selectedIndex].value).value+'/';
            modifiedFormURL = browserURL.replace(currentLangSEO,newLangSEO);
        }
    }
    //replace langId with the newly selected langId
    if (modifiedFormURL.indexOf('&') !== -1) {
        var tokens = modifiedFormURL.split('&');
        modifiedFormURL = "";
        for (var i=0; i<tokens.length; i++) {
            if (tokens[i].indexOf('langId=') === -1) {
                if (modifiedFormURL === '') {
                    modifiedFormURL = tokens[i];
                } else {
                    modifiedFormURL = modifiedFormURL + "&" + tokens[i];
                }
            } else if (tokens[i].indexOf('langId=') > 0) {
                if (i==0) {
                    //langId is the first token next to ?
                    modifiedFormURL = tokens[0].substring(0,tokens[0].indexOf('langId='));
                } else {
                    modifiedFormURL = modifiedFormURL + "&";
                }
                modifiedFormURL = modifiedFormURL + "langId=" + document.getElementById('languageSelection').options[document.getElementById('languageSelection').selectedIndex].value;
            }
        }
    }
    modifiedFormURL = switchLanguageCurrencyFilter(modifiedFormURL);
    document.forms[formName].URL.value = modifiedFormURL;
    document.forms[formName].languageSelectionHidden.value = document.getElementById('languageSelection').options[document.getElementById('languageSelection').selectedIndex].value;

    //hide pop up and submit the form
    $('#widget_language_and_currency_popup').data("wc-WCDialog").close();
    //delete buyOnBehalfOf cookie if exists
    //if (typeof(GlobalLoginShopOnBehalfJS) != 'undefined' && GlobalLoginShopOnBehalfJS != null ){
    //  GlobalLoginShopOnBehalfJS.deleteBuyerUserNameCookie();
    //}
    if (typeof changeStoreViewLanguage == 'function') {
        changeStoreViewLanguage(document.forms[formName].languageSelectionHidden.value);
    }
    document.getElementById(formName).submit();
}

/**
 * This function checks replaces url in a exclusion list with string from the replacement list
 * @param url The url to process
*/
function switchLanguageCurrencyFilter(url) {
    var filterList = [];

    // Add any new exclude and replace view name in filterList
    // exclude UserRegistrationAdd in URL and replace with UserRegistrationForm?new=Y
    var paramList = [{"key": "registerNew", "value": "Y"}];
    filterList.push({"exclude": "UserRegistrationAdd", "replace": "UserRegistrationForm", "param": paramList});

    for (var i=0; i<filterList.length; i++) {
        if (url.indexOf(filterList[i].exclude) > 0) {
            url = url.replace(filterList[i].exclude, filterList[i].replace);
            if (filterList[i].param != undefined) {
                var urlParamList = filterList[i].param;
                for (var j=0; j<urlParamList.length; j++) {
                    url = appendToURL(url, urlParamList[j].key, urlParamList[j].value, false);
                }
            }
            break;
        }
    }
    return url;
}

/**
 * This function check the <code>url</code> <code>paramterName</code> pair against the URLConfig exclusion list.
 * @param url The url to send request.
 * @param parameterName The name of the parameter to be sent with request.
 * @returns {Boolean} True if the parameter and url is not in an exclusion list, false otherwise.
 */
function isParameterExcluded(url, parameterName){
    try{
    if(typeof URLConfig === 'object'){
        if (typeof URLConfig.excludedURLPatterns === 'object'){
            for ( var urlPatternName in URLConfig.excludedURLPatterns){
                var exclusionConfig = URLConfig.excludedURLPatterns[urlPatternName],
                urlPattern = urlPatternName;
                if(typeof exclusionConfig === 'object'){
                    if(exclusionConfig.urlPattern){
                        urlPattern = exclusionConfig.urlPattern;
                    }
                    console.debug("URL pattern to match : " + urlPattern);
                    urlPattern = new RegExp(urlPattern);

                    if(url.match(urlPattern)){
                        var excludedParametersArray = exclusionConfig.excludedParameters;
                        for(var excludedParameter in excludedParametersArray){
                            if(parametername == excludedParameter){
                                return true;
                            }
                        }
                    }
                }
            }
        } else {
            console.debug("The parameter " + parameterName + " is not excluded");
        }
    } else {
        console.debug("No URLConfig defined.")
    }
    } catch (err){
        console.debug("An error occured while trying to exclude " + err);
    }
return false;
}

/**
 *  The utility function to append name value pair to a URL
 *  @param allowMultipleValues (boolean) Indicates whether a parameterName can have multiple values or not, default value is <code>false</code>.
 *  @returns url The updated url.
 */
function appendToURL(url, parameterName, value, allowMultipleValues){
    allowMultipleValues = (null == allowMultipleValues) ? false : allowMultipleValues;
    var paramPattern = new RegExp(parameterName + "=[^&]+"),
    newParamString = parameterName + "=" + value;
    if ( url.indexOf(newParamString) !== -1 ) {
        //console.debug("parameter value pair " + newParamString + " is already indcluded.");
    } else if (!paramPattern.test(url) || allowMultipleValues){
        if (url.indexOf('?') === -1 ){
            url = url + '?';
        }else{
            url = url + '&';
        }
        url = url + newParamString;
    } else {
        // replace it if the old one does not match with the one in wcCommonRequestParameters, possible caching case?
        url = url.replace(paramPattern, newParamString);
        //console.debug("replace " + url.match(paramPattern) + " with " + newParamString);
    }
    return url;
}


/**
 * The function append parameters, such as <code>forUserId</code>, in <code>wcCommonRequestParameters</code>
 * as URL parameters to the give URL.
 * @param allowMultipleValues (boolean) Indicates whether a parameterName can have multiple values or not, default value is <code>false</code>
 * @returns url The updated url.
 */
function appendWcCommonRequestParameters(url, allowMultipleValues){
    allowMultipleValues = (null == allowMultipleValues) ? false : allowMultipleValues;
    if(typeof wcCommonRequestParameters === 'object'){
        for(var parameterName in wcCommonRequestParameters){
            if(!isParameterExcluded(url, parameterName)){
                url = appendToURL(url, parameterName, wcCommonRequestParameters[parameterName], allowMultipleValues);
            }
            //else {
            //console.debug("parameter " + parameterName + " is excluded.");
            //}
        }
    }
    return url;
}

/**
 *  Update the form the <code>wcCommonRequestParameters</code>.
 *  @param form The form to update.
 */
function updateFormWithWcCommonRequestParameters(form, allowMultipleValues) {
    allowMultipleValues = (null == allowMultipleValues) ? false : allowMultipleValues;
    if(typeof wcCommonRequestParameters === 'object'){
        for(var parameterName in wcCommonRequestParameters){
            if(form.action !== undefined && null !== form.action && !isParameterExcluded(form.action, parameterName) ){
                var exist = false;
                $("input[name=" + "'" + parameterName + "']", form).each(function(i, param){
                    if (param.value == wcCommonRequestParameters[parameterName]){
                        exist = true;
                        //console.debug("parameter " + parameter + " with same value alreday exist.")
                    } else if (!allowMultipleValues) {
                        form.removeChild(param);
                    }
                });
                if (!exist ) {
                    if (form.method == 'get') {
                        //the parameter in the URL for form get is not read, need to use hidden input.
                        $("<input></input>", {name: parameterName, type:'hidden', value: wcCommonRequestParameters[parameterName]}).appendTo(form);
                    } else {
                        //post action url probably already has this parameter, use 'appendToURL' to handle duplication
                        form.action = appendToURL(form.action, parameterName, wcCommonRequestParameters[parameterName], allowMultipleValues);
                    }
                }
            }
        }
    }
}

function addAuthToken(form){
    try{
        if($("#csrf_authToken").length){
            $("<input></input>", {name: "authToken", type:'hidden', value: $("#csrf_authToken").val()}).appendTo(form);
        } else {
            console.debug("auth token is missing from the HTML DOM");
        }
        return true;
    } catch (err){
        console.debug("An error occured while trying to add authToken to the form..." + err);
    }
    return false;
}

/**
 *  Process the form update and submit. All forms' submission are recommended to be done this function.
 *  @param form The form to submit.
 */
function processAndSubmitForm (form) {
    updateFormWithWcCommonRequestParameters(form);
    addAuthToken(form);
    form.submit();
}


function getCommonParametersQueryString(){
    return "storeId="+WCParamJS.storeId+"&langId="+WCParamJS.langId+"&catalogId="+WCParamJS.catalogId;
}

/**
 *  Handle service requests after user login for these scenarios:
 *  - timeout while trying to execute an Ajax request
 *  - need authentication while trying to execute an Ajax request
 *
 *  The nextUrl is a parameter returned from wc dojo framework when an error has occured when excuting an AJAX action.
 *  It specifies the next Ajax action to be performed after the user has logged on
 **/

    /**
    * This function checks to see if the passed in URL contains a parameter named 'finalView'. If it does, it will construct a new URL
    * using value from 'finalView' paramter as the view name
    * @param {String} myURL The URL to check if it contains finalView param
    */
    function getFinalViewURL(myURL) {
        var finalViewBeginIndex = myURL.indexOf('finalView');

        // check if finalView parameter is passed in the URL
        if (finalViewBeginIndex != -1){

            // index after parameter 'finalView', when it is -1, that means final view is the last paramter in the URL
            var finalViewEndIndex = myURL.indexOf('&', finalViewBeginIndex);
            if (finalViewEndIndex == -1) {
                var finalViewName = myURL.substring(finalViewBeginIndex + 10);
            } else {
                var finalViewName = myURL.substring(finalViewBeginIndex + 10, finalViewEndIndex);
            }
            var originalActionEndIndex = myURL.indexOf('?');

            // firstPartURL is everything after the '?' sign and before finalView parameter
            var firstPartURL = myURL.substring(originalActionEndIndex + 1, finalViewBeginIndex);
            // secondPartURL is everything after finalView parameter
            if (finalViewEndIndex == -1) {
                var secondPartURL = "";
            } else {
                var secondPartURL = myURL.substring(finalViewEndIndex);
            }

            // to make things simple, remove all leading and trailing '&' for firstPartURL and secondPartURL
            if (firstPartURL.charAt(firstPartURL.length - 1) == '&') {
                firstPartURL = firstPartURL.substring(0, firstPartURL.length-1);
            }
            if (firstPartURL.charAt(0) == '&') {
                firstPartURL = firstPartURL.substring(1);
            }
            if (secondPartURL.charAt(secondPartURL.length - 1) == '&') {
                secondPartURL = secondPartURL.substring(0, secondPartURL.length-1);
            }
            if (secondPartURL.charAt(0) == '&') {
                secondPartURL = secondPartURL.substring(1);
            }

            var finalURL = "";
            if (firstPartURL !== "") {
                finalURL = finalViewName + '?' + firstPartURL;
                if (secondPartURL !== "") {
                    finalURL = finalURL + '&' + secondPartURL;
                }
            } else {
                finalURL = finalViewName + '?' + secondPartURL;
            }
            return finalURL;
        } else {
            return "";
        }
    }

    wcService.declare({
        id: "MyAcctAjaxAddOrderItem",
        actionId: "AjaxAddOrderItem",
        url: "",
        formId: ""
        ,successHandler: function(serviceResponse) {
            MessageHelper.hideAndClearMessage();
            MessageHelper.displayStatusMessage(Utils.getLocalizationMessage("SHOPCART_ADDED"));
            setCookie("WC_nextURL_"+WCParamJS.storeId, null, {expires:-1,path:'/', domain:cookieDomain});
            cursor_clear();
        }
        ,failureHandler: function(serviceResponse) {
            if (serviceResponse.errorMessage) {
                if(serviceResponse.errorMessageKey == "_ERR_NO_ELIGIBLE_TRADING"){
                    MessageHelper.displayErrorMessage(Utils.getLocalizationMessage("ERROR_CONTRACT_EXPIRED_GOTO_ORDER"));
                } else {
                    MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
                }
            }
            else {
                 if (serviceResponse.errorMessageKey) {
                    MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
                 }
            }
            cursor_clear();
        }

    });

    wcService.declare({
        id: "MyAcctGenericService",
        actionId: "",
        url: "",
        formId: ""
        ,successHandler: function(serviceResponse) {
            setCookie("WC_nextURL_"+WCParamJS.storeId, null, {expires:-1,path:'/', domain:cookieDomain});
            MessageHelper.hideAndClearMessage();
            finalViewURL = getFinalViewURL(this.url);
            if (finalViewURL !== "") {
                document.location.href = finalViewURL;
            } else {
                MessageHelper.displayStatusMessage(Utils.getLocalizationMessage("MYACCOUNT_ACTION_PERFORMED"));
                cursor_clear();
            }
        }
        ,failureHandler: function(serviceResponse) {
            if (serviceResponse.errorMessage) {
                MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
            }
            else {
                 if (serviceResponse.errorMessageKey) {
                    MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
                 }
            }
            cursor_clear();
        }

    });

    function invokeItemAdd(inUrl) {
        wcService.getServiceById("MyAcctAjaxAddOrderItem").url=inUrl;
        var addToCartParams = [];
        // PasswordRequestAuthenticated is required by PasswordRequestCmdImpl - to indicate password is already entered by user. As we are in the my
        // account page, password is already entered and accepted.
        addToCartParams.PasswordRequestAuthenticated = 'TRUE';

        /*For Handling multiple clicks. */
        if(!submitRequest()){
            return;
        }
        cursor_wait();
        setCookie("WC_nextURL_"+WCParamJS.storeId, null, {expires:-1,path:'/', domain:cookieDomain});
        wcService.invoke("MyAcctAjaxAddOrderItem", addToCartParams);
    }
    function invokeOtherService(inUrl) {
        wcService.getServiceById("MyAcctGenericService").url=inUrl;
        var params = {PasswordRequestAuthenticated: 'TRUE'};

        /*For Handling multiple clicks. */
        if(!submitRequest()){
            return;
        }
        cursor_wait();
        setCookie("WC_nextURL_"+WCParamJS.storeId, null, {expires:-1,path:'/', domain:cookieDomain});
        wcService.invoke("MyAcctGenericService", params);
    }

    /**
     * In order to handle the case that IE handles cookie domain differently from other browsers,
     * Use this centerlized function to handle cookie value assignment and ingore domain prop for cookie
     * creation when domain name is an empty string.
     */
    function setCookie(cookieName, cookieVal, props) {
        var createCookie = function(name, value, props){
            if (!props) {
                props = {};
            }

            var exp = props.expires;
            if (exp) {
                if(typeof exp == "number"){
                    var d = new Date();
                    d.setTime(d.getTime() + exp*24*60*60*1000);
                    exp = d;
                }
                if (exp.toUTCString){
                    props.expires = exp.toUTCString();
                } else {
                    props.expires = exp;
                }
            }

            value = encodeURIComponent(value);
            var propString = name + "=" + value;
            for(var name in props){
                propString += "; " + name;
                var propValue = props[name];
                if(propValue !== true){
                    propString += "=" + propValue;
                }
            }
            document.cookie = propString;
        };

        if (!props) {
            createCookie(cookieName, cookieVal);
        } else {
            var cookieProps = props;
            for (var propName in cookieProps) {
                if (!cookieProps[propName]) {
                    delete cookieProps[propName];
                }
            }
            createCookie(cookieName, cookieVal, cookieProps);
        }
    }

    function getBaseTextDir() {
        // summary:
        //      returns the value of the "baseTextDirection" preference.
        var btd = getCookie(_BTD_PREFS);
        if (!btd){
            return "";
        }
        return btd;
    }

    function setBaseTextDir(btd) {
        // summary:
        //      Sets the value of the baseTextDirection" preferences.
        var oldItem = getCookie(_BTD_PREFS);
        if (oldItem != btd){
            setCookie(_BTD_PREFS, btd.toLowerCase());
        }
    }

    function isRTLValue(stringValue) {
        for (var ch in stringValue) {
            if (isBidiChar(stringValue.charCodeAt(ch)))
                return true;
            else if(isLatinChar(stringValue.charCodeAt(ch)))
                return false;
        }
        return false;
    }

    function isBidiChar(c)  {
        if (c >= 0x05d0 && c <= 0x05ff)
            return true;
        else if (c >= 0x0600 && c <= 0x065f)
            return true;
        else if (c >= 0x066a && c <= 0x06ef)
            return true;
        else if (c >= 0x06fa && c <= 0x07ff)
            return true;
        else if (c >= 0xfb1d && c <= 0xfdff)
            return true;
        else if (c >= 0xfe70 && c <= 0xfefc)
            return true;
        else
            return false;
    }

    function isLatinChar(c){
        if((c > 64 && c < 91)||(c > 96 && c < 123))
            return true;
        else
            return false;
    }

    function resolveBaseTextDir(value, txtDir) {
        if (txtDir == "auto") {
            if (isRTLValue(value)) {
                return "rtl";
            } else {
                return "ltr";
            }
        }
        else {
            return txtDir;
        }
    }

    function handleTextDirection(requiredElement) {
        var txtDir = getBaseTextDir();
        if (requiredElement != null && txtDir !== "") {
            if (["INPUT", "TEXTAREA"].indexOf(requiredElement.tagName) > -1) {
                $(requiredElement).css("direction", resolveBaseTextDir(requiredElement.value, txtDir));
            }
        }
    }

    function enforceTextDirectionOnPage() {
        var txtDir = getBaseTextDir();
        if (txtDir !== "") {
            $(".bidiAware").each(function(i, element) {
                element.dir = $(element).css("direction", resolveBaseTextDir(element.value || element.text || element.outerText || element.innerHTML, txtDir));
            });
        }
    }

    /**
    * Common failure handler function which can be used with most of the
    * service definitions.
    * This function displays errorMessage present in serviceResponse object.
    * If errorMessage is null, then it displays errorMessageKey.
    */
    function commonServiceFailureHandler(serviceResponse) {
        if (serviceResponse.errorMessage) {
            MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
        } else {
            if (serviceResponse.errorMessageKey) {
                MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
            }
        }
        cursor_clear();
    }

    function isChrome(){
        return /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor);
    }

    function isSafari(){
        return /Safari/.test(navigator.userAgent) && /Apple Computer/.test(navigator.vendor);
    }

    /**
    * Success handler function used with services which does URL chaining.
    * This function retrieves the next URL in the URLChain and invokes ajax service
    * with appropriate input parameters specified for the URL.
    * If the next URL is specified with requestType = 'GET', then it just
    * redirects the page to nextURL without invoking any further service
    */
    function successHandlerForURLChainingService(serviceResponse){
        console.debug("Success Handler of AjaxCustomServiceForURLChaining", serviceResponse);
        if(this.postRefreshHandlerParameters != null && this.postRefreshHandlerParameters !== ''){
            var nextServiceURL = "";
            // Retrieve the first element from the array...
            nextServiceURLObject = this.postRefreshHandlerParameters.splice(0,1)[0];
            console.debug("nextServiceURLObject ",nextServiceURLObject);

            var params = [];
            if(nextServiceURLObject != null && typeof(nextServiceURLObject) != 'undefined'){
                var nextServiceURL = nextServiceURLObject["URL"],
                requestType = nextServiceURLObject["requestType"],
                requestParams = nextServiceURLObject["requestParams"];
                console.debug("nextServiceURL ", nextServiceURL);
                console.debug("requestType ", requestType);
                console.debug("requestParams ", requestParams);
            }
            if(nextServiceURL !== "") {
                if(requestType == "GET"){
                    if(nextServiceURL.indexOf("?") === -1){
                        nextServiceURL = nextServiceURL + "?" + getCommonParametersQueryString();
                    }
                    for(var key in requestParams){
                        nextServiceURL = nextServiceURL+"&"+ key +"=" + requestParams[key];
                    }
                    document.location.href = nextServiceURL;
                } else {
                    var service = getCustomServiceForURLChaining(nextServiceURL, this.postRefreshHandlerParameters);
                    wcService.invoke(service.getParam("id"), requestParams);
                }
            } else {
                console.debug("End of URL chaining with AjaxCustomServiceForURLChaining service");
                //TODO.. should we show generic success message here ???
            }
        }
    }

    /**
    * This is a common service which can be used to chain 'N' number of service calls.
    *
    * Input parameters to this function are:
    * @url -> The URL for this service definition.
    * @postRefreshHandlerParameters -> JSON object specifying the chained service URLS along with input parameters for each of the service URLs.
    * @formId -> Form that needs to be submitted with the initial service invocation.
    * @return -> wc.service object.
    *
    * Example code:
    *
    * // Define the initial URL
    * initialURL = 'AjaxPersonChangeServiceAddressAdd';
    *
    * // Form to be submitted along with initial request.
    * formId = "addressForm"
    *
    * // Define subsequent set of chained requests
    * var postRefreshHandlerParameters = {};
    * postRefreshHandlerParameters.push({"URL":"AjaxRESTOrderPIDelete", "requestParams":{"piId":"12345"}});
    * postRefreshHandlerParameters.push({"URL":"AjaxRESTOrderItemUpdate", "requestParams":{calculationUsage:"-1,-2,-3,-4,-5,-6,-7", calculateOrder:"1", orderItemId="10001"}});
    * postRefreshHandlerParameters.push({"URL":"DOMOrderShippingBillingView","requestType":"GET", "requestParams":{"payInStore":1}});
    *
    * // Get the service definition.
    * var service = getCustomServiceForURLChaining(initialURL,postRefreshHandlerParameters,formId);
    *
    * // Invoke the service.
    * wcService.invoke(service.id, null);
    *
    * With above sample code, the request chain will be:
    * Request 1: POST : AjaxPersonChangeServiceAddressAdd?<addressForm parameters>
    * Request 2: POST : AjaxRESTOrderPIDelete?piId=12345
    * Request 3: POST : AjaxRESTOrderItemUpdate?calculationUsage=-1,-2,-3,-4,-5,-6,-7&calculateOrder=1&orderItemId=10001
    * Request 4: GET  : DOMOrderShippingBillingView?payInStore=1
    */
    function getCustomServiceForURLChaining(url, postRefreshHandlerParameters,formId){
        var service = wcService.getServiceById('AjaxCustomServiceForURLChaining');

        if(service == null || service == undefined){
            console.debug("Start creating AjaxCustomServiceForURLChaining");
            wcService.declare({
                id: "AjaxCustomServiceForURLChaining",
                actionId: "AjaxCustomServiceForURLChaining",
                url: "",
                formId: "",
                successHandler: successHandlerForURLChainingService,
                failureHandler: commonServiceFailureHandler
            });
            service = wcService.getServiceById('AjaxCustomServiceForURLChaining');
        }

        if(url != null && url != 'undefined'){
            if (!stringStartsWith("url", "http")) {
                service.setUrl(getAbsoluteURL() + url);
            } else {
                service.setUrl(url);
            }
        }
        if(postRefreshHandlerParameters != null && postRefreshHandlerParameters != 'undefined'){
            service.setParam("postRefreshHandlerParameters", postRefreshHandlerParameters);
        } else {
            service.setParam("postRefreshHandlerParameters", null);
        }
        if(formId != null && formId != 'undefined'){
            service.setFormId(formId);
        } else {
            service.setFormId(null);
        }
        console.debug("Return AjaxCustomServiceForURLChaining", service);
        return service;
    }//-----------------------------------------------------------------
// Licensed Materials - Property of IBM
//
// WebSphere Commerce
//
// (C) Copyright IBM Corp. 2012, 2015 All Rights Reserved.
//
// US Government Users Restricted Rights - Use, duplication or
// disclosure restricted by GSA ADP Schedule Contract with
// IBM Corp.
//-----------------------------------------------------------------

/**
 * @fileOverview This file contains functions that are used to manage the cookies that are used by the Store Locator
 * feature.
 *
 * @version 1.0
 *
 */
 
/**
 * The functions defined in the class are used for managing the physical store IDs and the store locator user 
 * inputs.  Both information is stored in the cookie.
 *
 * @class This PhysicalStoreCookieJSStore class defines all the variables and functions to add / update / delete physical
 * store IDs and store locator user inputs.
 *
 */
PhysicalStoreCookieJSStore = {
	/* the store array is used to store physical store IDs to the cookie */
	storeArray: null,
	
	/* the maximum number of physical store IDs to be saved */
	arrayMaxSize: 5,
	
	/**
	 * This function retrieves the physical store IDs from the cookie.  These physical stores IDs are saved
	 * in the store array.  If no physical store IDs is found in the cookie, an empty store array is created.
	 *
	 * @returns {Array} The store array that contains all physical store IDs saved in the cookie.
	 *
	 */
	getStoreIdsFromCookie:function() {
        var cookieValue = getCookie("WC_physicalStores");
		this.storeArray = new Array;
	
		if (cookieValue != null) {
			var subValue = "";
			var remainingString = cookieValue;
			var length = cookieValue.length;
			var end = remainingString.indexOf(",");
			
			/* more than 1 entry */
			if (end > 0) {
				while (end >=0) {
					subValue = remainingString.substring(0, end);
					this.addToStoreArray(subValue);
					remainingString = remainingString.substring(end+1,length);
					length = remainingString.length;
					end = remainingString.indexOf(",")
				}
				
				subValue = remainingString;
				this.addToStoreArray(subValue);
			}
			/* 0 to 1 entry */
			else {
				/* 1 entry */
				if (length > 0) {
					this.addToStoreArray(remainingString);
				}
			}
		}
		return this.storeArray;
	},
	
	/**
	 * This function checks whether adding one more physical store ID to the cookie will exceed the maximum
	 * number of stores allowed to be saved limit.  The function is default to return false; otherwise, true is
	 * returned. 
	 *
	 * @returns {boolean} The flag to indicate check result.
	 *
	 */
	isAddOneStoreIdExceedMax:function() {
		var exceedMax = false;
		
		if ((this.getNumStores() + 1) > this.arrayMaxSize) {
			exceedMax = true;
		}
		
		return exceedMax;
	},
	
	/**
	 * This function saves all the physical store IDs in the store array to the cookie.  It loops through the store 
	 * array and saves all physical store IDs into the cookie.  It also ensures the cookie do not expire after the 
	 * session closes.  
	 *
	 */
	setStoreIdsToCookie:function() {
		var newCookieValue = "";
		
		for (i=0; i<this.storeArray.length; i++) {
			newCookieValue = newCookieValue + this.storeArray[i];
			if (i < (this.storeArray.length-1)) {
				newCookieValue = newCookieValue + ",";
			}
		}
		
		if (newCookieValue.length == 0) {
			/* delete the cookie then */
			setCookie("WC_physicalStores", null, {path: "/", expires: -1, domain: cookieDomain});
		}
		else {
			/* add or update the cookie */
			setCookie("WC_physicalStores", newCookieValue, {path: "/", domain: cookieDomain});
		}
	},
	
	/**
	 * This function adds the store ID to the store array.  It ensures that the store array does contain the 
	 * information from the cookie and the store ID to be added does not exist in the store array.
	 *
	 * @param {String} record The physical store ID to be added. 
	 *
	 */
	addToStoreArray:function(record) {
		if (this.storeArray == null) {
			this.getStoreIdsFromCookie();
		}
		
		for (i=0; i<this.storeArray.length; i++) {
			if (this.storeArray[i] == record) {
				return;
			}
		}
		
		/* do not add the new record if the array has reached the max size */
		if (this.storeArray.length < this.arrayMaxSize) {
			this.storeArray.push(record);
		}
	},
	
	/**
	 * This function adds the store ID to the cookie by calling the following 2 functions:
	 *       addToStoreArray()
	 *       setStoreIdsToCookie()
	 *
	 * @param {String} record The physical store ID to be added. 
	 *
	 */
	addToCookie:function(record) {
		this.addToStoreArray(record);
		this.setStoreIdsToCookie();
	},
	
	/**
	 * This function removes the store ID from the store array.  It ensures that the store array does contain the
	 * information from the cookie and the store ID to be removed does exist in the store array.
	 *
	 * @param {String} record The physical store ID to be removed. 
	 *
	 */
	removeFromStoreArray:function(record) {
		if (this.storeArray == null) {
			this.getStoreIdsFromCookie();
		}
		
		var recordIndex = -1;
		
		for (i=0; i<this.storeArray.length; i++) {
			if (this.storeArray[i] == record) {
				recordIndex = i;
				i = this.storeArray.length;
			}
		}
				
		this.storeArray.splice(recordIndex, 1);
	},
	
	/**
	 * This function removes the store ID from the cookie by calling the following 2 functions:
	 *       removeFromStoreArray()
	 *       setStoreIdsToCookie()
	 *
	 * @param {String} record The physical store ID to be removed. 
	 *
	 */
	removeFromCookie:function(record) {
		this.removeFromStoreArray(record);
		this.setStoreIdsToCookie();
	},
	
	/**
	 * This function empties the store array.
	 *
	 */
	clearStoreArray:function() {
		this.storeArray = new Array;
	},
	
	/**
	 * This function updates the cookie with the empty store array.
	 *
	 */
	clearCookie:function() {
		this.clearStoreArray();
		this.setStoreIdsToCookie();
	},
	
	/**
	 * This function returns the number of physical stores saved in the cookie.  It ensures the store array contains 
	 * the information retrieved from the cookie before getting the number of stores.
	 *
	 * @returns {int} The number of physical stores saved.
	 *
	 */
	getNumStores:function() {
		if (this.storeArray == null) {	
			this.getStoreIdsFromCookie();
		}
		
		return this.storeArray.length;
	},
	
	/**
	 * This function retrieves the pick up store ID from the cookie.  If no pick up store ID is found in the cookie, 
	 * null is returned.
	 *
	 * @returns {String} The pick up store IDs.
	 *
	 */
	getPickUpStoreIdFromCookie:function() {
        var pickUpStoreId = getCookie("WC_pickUpStore");
		return pickUpStoreId;
	},

	/**
	 * This function adds or updates the pick up store ID to the cookie.
	 *
	 * @param {String} value The new pick up store ID. 
	 *
	 * @returns {element} .
	 *
	 */
	setPickUpStoreIdToCookie:function(value) {
		var newPickUpStoreId = value;
		if (newPickUpStoreId != null && newPickUpStoreId != "undefined" && newPickUpStoreId != "") {
			var currentPickUpStoreId = this.getPickUpStoreIdFromCookie();
			if (newPickUpStoreId != currentPickUpStoreId) {
				setCookie("WC_pickUpStore", null, {path: "/", expires: -1, domain: cookieDomain});
				setCookie("WC_pickUpStore", newPickUpStoreId, {path: "/", domain: cookieDomain});
			}
		}
	},

	/**
	 * This function clears the pick up store ID from the cookie when the parameter matches the current pick up 
	 * store ID in the cookie.
	 *
	 * @param {String} value The pick up store ID for comparison. 
	 *
	 */
	clearPickUpStoreIdFromCookie:function(value) {
		var newPickUpStoreId = value;
		if (newPickUpStoreId != null && newPickUpStoreId != "undefined" && newPickUpStoreId != "") {
			var currentPickUpStoreId = this.getPickUpStoreIdFromCookie();
			if (newPickUpStoreId == currentPickUpStoreId) {
				setCookie("WC_pickUpStore", null, {path: "/", expires: -1, domain: cookieDomain});
			}
		}
	},
	
	/**
	 * This generic function retrieves the value from the cookie based on the cookie key.  It is used to store 
	 * "country: WC_stCntry", "province: WC_stProv", "city: WC_stCity" and "search performed flag: WC_stFind".  If no 
	 * value is found in the cookie for the cookie key, null is returned.
	 *
	 * @param {String} cookieKey The key of the cookie. 
	 *
	 * @returns {String} The value obtained from the cookie.
	 *
	 */
	getValueFromCookie:function(cookieKey) {
        var cookieValue = getCookie(cookieKey);
		return cookieValue;
	},

	/**
	 * This function adds or updates the value to the cookie using the key provided.  It is used to store 
	 * "country: WC_stCntry", "province: WC_stProv", "city: WC_stCity" and "search performed flag: WC_stFind".
	 *
	 * @param {String} cookieKey The key of the cookie. 
	 * @param {String} cookieValue The new value of the cookie. 
	 *
	 */
	setValueToCookie:function(cookieKey, cookieValue) {
		var newValue = cookieValue;
		if (newValue != null && newValue != "undefined" && newValue != "") {
			var currentValue = this.getValueFromCookie(cookieKey);
			if (newValue != currentValue) {
				setCookie(cookieKey, null, {path: "/", expires: -1, domain: cookieDomain});
				setCookie(cookieKey, newValue, {path: "/", domain: cookieDomain});
			}
		}
	},

	/**
	 * This function clears the value referred by a key from the cookie.
	 *
	 * @param {String} cookieKey The key of the cookie. 
	 *
	 */
	clearValueFromCookie:function(cookieKey) {
		var currentValue = this.getValueFromCookie(cookieKey);
		if (currentValue != null && currentValue != "undefined") {
			setCookie(cookieKey, null, {path: "/", expires: -1, domain: cookieDomain});
		}
	}

}
//<%--
//********************************************************************
//*-------------------------------------------------------------------
//* Licensed Materials - Property of IBM
//*
//* WebSphere Commerce
//*
//* (c) Copyright IBM Corp.  2008, 2013
//* All Rights Reserved
//*
//* US Government Users Restricted Rights - Use, duplication or
//* disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
//*
//*-------------------------------------------------------------------
//*
//--%>

/**
 * @fileOverview This file contains functions that are used by Store Locator.
 *
 * @version 1.0
 *
 */


/**
 * The functions defined in the class are used for the Store Locator feature.
 *
 * @class This storeLocatorJSStore class defines all the functions to be used on pages that contain the Store Locator feature.
 *
 */
storeLocatorJSStore = {

    /**
     * This function initializes the state/province selection drop down list by extracting the selected value
     * of the country selection.  Nothing is done when no selected country is found.
     *
     */
    initProvinceSelections: function () {
        var countrySelectedIndex = $("#selectCountry").prop("selectedIndex");
        if (countrySelectedIndex > -1) {
            var indexToUse = countrySelectedIndex;
            var indexFromSavedId = storeLocatorJSStore.getSavedCountrySelectionIndex();

            if (indexFromSavedId != null && indexFromSavedId != countrySelectedIndex) {
                indexToUse = indexFromSavedId;
                $("#selectCountry")[0].options[indexToUse].selected = true;
            }
            wcRenderContext.updateRenderContext('provinceSelectionsContext', {
                'countryId': $("#selectCountry")[0].options[indexToUse].value
            });
        }
    },

    /**
     * This function refreshes the city selection drop down list by extracting the selected value of the
     * state/province selection.  Nothing is done when no selected state/province is found.
     *
     */
    refreshCities: function () {
        var stateSelectedIndex = $("#selectState").prop("selectedIndex");
        if (stateSelectedIndex > -1) {
            var indexToUse = stateSelectedIndex;
            var indexFromSavedId = storeLocatorJSStore.getSavedProvinceSelectionIndex();
            if (indexFromSavedId != null && indexFromSavedId != stateSelectedIndex) {
                indexToUse = indexFromSavedId;
                $("#selectState")[0].options[indexToUse].selected = true;
            }
            wcRenderContext.updateRenderContext('citySelectionsContext', {
                'provinceId': $("#selectState")[0].options[indexToUse].value
            });
        }
    },

    /**
     * This function refreshes the store location search results by extracting the selected value of the city
     * selection.  Nothing is done when no selected city is found.  Store location search results are refreshed
     * automatically once when a search intend (i.e. Find button is pressed) was done before.
     *
     * @param {String} fromPage Parameter value passed by the calling page.
     *
     */
    refreshSearchResults: function (fromPage) {
        var citySelectedIndex = $("#selectCity").selectedIndex;
        if (citySelectedIndex > -1) {
            var indexToUse = citySelectedIndex;
            var indexFromSavedId = storeLocatorJSStore.getSavedCitySelectionIndex();
            if (indexFromSavedId != null && indexFromSavedId != citySelectedIndex) {
                indexToUse = indexFromSavedId;
                $("#selectCountry")[0].options[indexToUse].value("selectCity").options[indexToUse].selected = true;
            }

            var performFindFlag = PhysicalStoreCookieJSStore.getValueFromCookie("WC_stFind");
            if (performFindFlag != null) {
                wcRenderContext.updateRenderContext('storeLocatorResultsContext', {
                    'cityId': document.getElementById("selectCountry").options[indexToUse].value("selectCity").options[indexToUse].value,
                    'fromPage': fromPage
                });
            }
        }
    },

    /**
     * This function adds the user selected physical store to the cookie when the maximum number of physical
     * stores has not reached; otherwise, a message is displayed.
     *
     * @param {String} physicalStoreId The physical store Unique ID to be added.
     * @param {String} optionIndex The index of the physical store to be added.
     *
     * @returns {boolean} A flag to indicate whether the add is performed.
     *
     */
    addPhysicalStore: function (physicalStoreId, optionIndex) {
        if (PhysicalStoreCookieJSStore.isAddOneStoreIdExceedMax() == true) {
            if (document.getElementById("addPhysicalStoreToCookieButton" + optionIndex) != null) {
                MessageHelper.formErrorHandleClient("addPhysicalStoreToCookieButton" + optionIndex, MessageHelper.messages["EXCEED_PHYSICAL_STORE_SIZE"]);
                return false;
            } else {
                MessageHelper.displayErrorMessage(MessageHelper.messages["EXCEED_PHYSICAL_STORE_SIZE"]);
                return false;
            }
        }

        if (!submitRequest()) {
            return;
        }
        cursor_wait();

        PhysicalStoreCookieJSStore.addToCookie(physicalStoreId);
        storeLocatorJSStore.showRemoveOption(physicalStoreId);
        return true;
    },

    /**
     * This function removes the user selected physical store from the cookie.
     *
     * @param {String} physicalStoreId The physical store Unique ID to be removed.
     *
     */
    removePhysicalStore: function (physicalStoreId) {
        PhysicalStoreCookieJSStore.removeFromCookie(physicalStoreId);
        PhysicalStoreCookieJSStore.clearPickUpStoreIdFromCookie(physicalStoreId);
        storeLocatorJSStore.showAddOption(physicalStoreId);
    },

    /**
     * This function shows the disabled "add physical store" option and hides the "add physical store" option
     * of the physical store.
     *
     * @param {String} physicalStoreId The physical store Unique ID.
     *
     */
    showRemoveOption: function (physicalStoreId) {
        var addDisabledDiv = $("#addPhysicalStoreToCookieDisabled" + physicalStoreId);
        var addDiv = $("#addPhysicalStoreToCookie" + physicalStoreId);

        if (addDisabledDiv != null && addDisabledDiv != "undefined") {
            $(addDisabledDiv).css("display", "block");
        }

        if (addDiv != null && addDiv != "undefined") {
            $(addDiv).css("display", "none");
        }
    },

    /**
     * This function shows the "add physical store" option and hides the disabled "add physical store" option
     * of the physical store.
     *
     * @param {String} physicalStoreId The physical store Unique ID.
     *
     */
    showAddOption: function (physicalStoreId) {
        var addDisabledDiv = $("#addPhysicalStoreToCookieDisabled" + physicalStoreId);
        var addDiv = $("#addPhysicalStoreToCookie" + physicalStoreId);

        if (addDisabledDiv != null && addDisabledDiv != "undefined") {
            $(addDisabledDiv).css("display", "none");
        }

        if (addDiv != null && addDiv != "undefined") {
            $(addDiv).css("display", "block");
        }
    },

    /**
     * This function manages the cookie values when OK button is pressed from city search.
     *
     */
    manageCookieFromCity: function () {
        PhysicalStoreCookieJSStore.setValueToCookie('WC_stFind', 1);
    },

    /**
     * This function refreshes the result area when a city is selected.  It refreshes the physical store
     * information.
     *
     * @param form The form that contains the "city" selections.
     * @param {String} fromPage The fromPage parameter value passed by the calling page.
     *
     */
    refreshResultsFromCity: function (form, fromPage) {
        if (form.selectCity.selectedIndex < 0) {
            MessageHelper.formErrorHandleClient(form.selectCity.id, MessageHelper.messages["MISSING_CITY"]);
            return;
        }

        /* manage cookie values */
        storeLocatorJSStore.manageCookieFromCity();

        /* refresh the result area */
        wcRenderContext.updateRenderContext('storeLocatorResultsContext', {
            'cityId': form.selectCity.options[form.selectCity.selectedIndex].value,
            'fromPage': fromPage,
            'geoCodeLatitude': '',
            'geoCodeLongitude': '',
            'errorMsgKey': ''
        });
    },

    /**
     * This function refreshes the result area when the geolocation feature is used.  It refreshes the
     * physical store information.
     *
     * @param {String} geoCodeLatitude The user's latitude coordinate.
     * @param {String} geoCodeLongitude The user's longitude coordinate.
     *
     */
    refreshResultsFromNearest: function (geoCodeLatitude, geoCodeLongitude) {
        PhysicalStoreCookieJSStore.clearValueFromCookie("WC_stCntry");
        PhysicalStoreCookieJSStore.clearValueFromCookie("WC_stProv");
        PhysicalStoreCookieJSStore.clearValueFromCookie("WC_stCity");
        PhysicalStoreCookieJSStore.clearValueFromCookie("WC_stFind");

        /* refresh the result area */
        wcRenderContext.updateRenderContext('storeLocatorResultsContext', {
            'geoCodeLatitude': geoCodeLatitude,
            'geoCodeLongitude': geoCodeLongitude,
            'errorMsgKey': ''
        });
    },

    /**
     * This function refreshes the result area when the geolocation feature is used.  It refreshes the
     * physical store information.
     *
     * @param {String} errorMsgKey The resource key for the error message.
     *
     */
    refreshResultsWithLocationError: function (errorMsgKey) {
        PhysicalStoreCookieJSStore.clearValueFromCookie("WC_stFind");

        /* refresh the result area */
        wcRenderContext.updateRenderContext('storeLocatorResultsContext', {
            'errorMsgKey': errorMsgKey
        });
    },

    /**
     * This function refreshes the store list area.
     *
     * @param {String} fromPage The fromPage parameter value passed by the calling page.
     *
     */
    refreshStoreList: function (fromPage) {
        /* refresh the store list area */
        wcRenderContext.updateRenderContext('selectedStoreListContext', {
            'fromPage': fromPage
        });
    },

    removeFromStoreList: function (fromPage, tableRowId) {
        var numStores = PhysicalStoreCookieJSStore.getNumStores();
        if (numStores == 0) {
            // Refresh to remove complete table and display status message
            this.refreshStoreList(fromPage);
        } else {
            // Just remove store from the table.
            var tableRow = document.getElementById(tableRowId);
            tableRow.remove();
        }
    },

    /**
     * This function hides the store list area.
     *
     */
    hideStoreList: function () {
        var storeListDiv = $("#selectedStoreList");
        var showListHeaderDiv = $("#showStoreListHeader");
        var hideListHeaderDiv = $("#hideStoreListHeader");

        if (storeListDiv != null && storeListDiv != "undefined") {
            $(storeListDiv).css("display", "none");
        }
        if (showListHeaderDiv != null && showListHeaderDiv != "undefined") {
            $(showListHeaderDiv).css("display", "block");
        }
        if (hideListHeaderDiv != null && hideListHeaderDiv != "undefined") {
            $(hideListHeaderDiv).css("display", "none");
        }
    },

    /**
     * This function shows the store list area.
     *
     */
    showStoreList: function () {
        var storeListDiv = $("#selectedStoreList");
        var showListHeaderDiv = $("#showStoreListHeader");
        var hideListHeaderDiv = $("#hideStoreListHeader");

        if (storeListDiv != null && storeListDiv != "undefined") {
            $(storeListDiv).css("display", "block");
        }
        if (showListHeaderDiv != null && showListHeaderDiv != "undefined") {
            $(showListHeaderDiv).css("display", "none");
        }
        if (hideListHeaderDiv != null && hideListHeaderDiv != "undefined") {
            $(hideListHeaderDiv).css("display", "block");
        }
    },

    /**
     * This function is called after the counry selection list is changed.
     *
     * @param {String} countryId The unique ID of the selected country.
     *
     */
    changeCountrySelection: function (countryId) {
        PhysicalStoreCookieJSStore.setValueToCookie("WC_stCntry", countryId);
        PhysicalStoreCookieJSStore.clearValueFromCookie("WC_stProv");
        PhysicalStoreCookieJSStore.clearValueFromCookie("WC_stCity");
        PhysicalStoreCookieJSStore.clearValueFromCookie("WC_stFind");

        wcRenderContext.updateRenderContext("provinceSelectionsContext", {
            "countryId": countryId
        });
    },

    /**
     * This function is called after the province selection list is changed.
     *
     * @param {String} provinceId The unique ID of the selected province.
     *
     */
    changeProvinceSelection: function (provinceId) {
        PhysicalStoreCookieJSStore.setValueToCookie("WC_stProv", provinceId);
        PhysicalStoreCookieJSStore.clearValueFromCookie("WC_stCity");
        PhysicalStoreCookieJSStore.clearValueFromCookie("WC_stFind");

        wcRenderContext.updateRenderContext("citySelectionsContext", {
            "provinceId": provinceId
        });
    },

    /**
     * This function is called after the city selection list is changed.
     *
     * @param {String} cityId The unique ID of the selected city.
     *
     */
    changeCitySelection: function (cityId) {
        PhysicalStoreCookieJSStore.setValueToCookie("WC_stCity", cityId);
        PhysicalStoreCookieJSStore.clearValueFromCookie("WC_stFind");
    },

    /**
     * This function retrieves the index of the country selection list which has a value matches the one saved in
     * the cookie.  Null is returned when cookie does not contain any saved country ID.
     *
     * @returns {int} The index of the country selection list which has a value matches the one saved in the
     * cookie.
     *
     */
    getSavedCountrySelectionIndex: function () {
        var index = null;
        var savedCountryId = PhysicalStoreCookieJSStore.getValueFromCookie("WC_stCntry");
        if (savedCountryId != null) {
            /* search for matching ID */
            var selectedCountryList = $("#selectCountry");
            if (selectedCountryList != null && selectedCountryList != "undefined") {
                var listSize = selectedCountryList.length;
                for (i = 0; i < listSize; i++) {
                    if (savedCountryId == selectedCountryList[0].options[i].value) {
                        index = i;
                        i = listSize;
                    }
                }
            }
        }

        return index;
    },

    /**
     * This function retrieves the index of the province selection list which has a value matches the one saved in
     * the cookie.  Null is returned when cookie does not contain any saved province ID.
     *
     * @returns {int} The index of the province selection list which has a value matches the one saved in the
     * cookie.
     *
     */
    getSavedProvinceSelectionIndex: function () {
        var index = null;
        var savedProvinceId = PhysicalStoreCookieJSStore.getValueFromCookie("WC_stProv");
        if (savedProvinceId != null) {
            /* search for matching ID */
            var selectedProvinceList = $("#selectState");
            if (selectedProvinceList != null && selectedProvinceList != "undefined") {
                var listSize = selectedProvinceList.length;
                for (i = 0; i < listSize; i++) {
                    if (savedProvinceId == selectedProvinceList[0].options[i].value) {
                        index = i;
                        i = listSize;
                    }
                }
            }
        }

        return index;
    },

    /**
     * This function retrieves the index of the city selection list which has a value matches the one saved in
     * the cookie.  Null is returned when cookie does not contain any saved city ID.
     *
     * @returns {int} The index of the city selection list which has a value matches the one saved in the
     * cookie.
     *
     */
    getSavedCitySelectionIndex: function () {
        var index = null;
        var savedCityId = PhysicalStoreCookieJSStore.getValueFromCookie("WC_stCity");
        if (savedCityId != null) {
            /* search for matching ID */
            var selectedCityList = $("#selectCity");
            if (selectedCityList != null && selectedCityList != "undefined") {
                var listSize = selectedCityList[0].options.length;
                for (i = 0; i < listSize; i++) {
                    if (savedCityId == selectedCityList[0].options[i].value) {
                        index = i;
                        i = listSize;
                    }
                }
            }
        }

        return index;
    }

}
//<%--
//********************************************************************
//*-------------------------------------------------------------------
//* Licensed Materials - Property of IBM
//*
//* WebSphere Commerce
//*
//* (c) Copyright IBM Corp.  2008, 2009
//* All Rights Reserved
//*
//* US Government Users Restricted Rights - Use, duplication or
//* disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
//*
//*-------------------------------------------------------------------
//*
//--%>

/**
 * @fileOverview This file declares the contexts of the store locator.
 *
 * @version 1.0
 *
 */


/**
 * The functions defined in the class are used to initialize the common parameters of the contexts and set the 
 * properties of a specific context.
 *
 * @class This StoreLocatorContextsJSStore class defines all the variables and functions for manipuating the contexts
 * of the store locator.
 *
 */
StoreLocatorContextsJSStore = {
    /* common paramater declarations */
    langId: "-1",
    storeId: "",
    catalogId: "",
    orderId: "",
    fromPage: "StoreLocator",

    /**
     * This function initializes the common parameters. 
     *
     * @param {String} langId The language ID. 
     * @param {String} storeId The store ID.
     * @param {String} catalogId The catalog ID.
     * @param {String} orderId The order ID.
     * @param {String} fromPage The constants indicates what the calling page is.
     *
     */
    setCommonParameters: function (langId, storeId, catalogId, orderId, fromPage) {
        this.langId = langId;
        this.storeId = storeId;
        this.catalogId = catalogId;
        this.orderId = orderId;
        this.fromPage = fromPage;
    },

    /**
     * This function sets a property of a context. 
     *
     * @param {String} contextId The context identifier. 
     * @param {String} property The property name.
     * @param {String} value The property value.
     *
     */
    setContextProperty: function (contextId, property, value) {
        wcRenderContext.getRenderContextProperties(contextId)[property] = value;
    }

}


/* context declaration for "provinceSelectionsContext" */
wcRenderContext.declare("provinceSelectionsContext", ["provinceSelections"], ""),

    /* context declaration for "citySelectionsContext" */
    wcRenderContext.declare("citySelectionsContext", ["citySelections"], ""),

    /* context declaration for "storeLocatorResultsContext" */
    wcRenderContext.declare("storeLocatorResultsContext", ["storeLocatorResults"], ""),

    /* context declaration for "selectedStoreListContext" */
    wcRenderContext.declare("selectedStoreListContext", ["selectedStoreList"], "")
//<%--
//********************************************************************
//*-------------------------------------------------------------------
//* Licensed Materials - Property of IBM
//*
//* WebSphere Commerce
//*
//* (c) Copyright IBM Corp.  2008, 2009
//* All Rights Reserved
//*
//* US Government Users Restricted Rights - Use, duplication or
//* disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
//*
//*-------------------------------------------------------------------
//*
//--%>

/**
 * @fileOverview This file declares the controllers of the store locator.
 *
 * @version 1.0
 *
 */

/**
 * The functions defined in the class are used to initialize the common parameters of the controllers and set the 
 * URL of a specific controller.
 *
 * @class This StoreLocatorContextsJSStore class defines all the variables and functions for manipuating the controllers
 * of the store locator.
 *
 */
StoreLocatorControllersDeclarationJSStore = {
    /* common paramater declarations */
    langId: "-1",
    storeId: "",
    catalogId: "",
    orderId: "",
    fromPage: "StoreLocator",

    /**
     * This function initializes the common parameters. 
     *
     * @param {String} langId The language ID. 
     * @param {String} storeId The store ID.
     * @param {String} catalogId The catalog ID.
     * @param {String} orderId The order ID.
     * @param {String} fromPage The constants indicates what the calling page is.
     *
     */
    setCommonParameters: function (langId, storeId, catalogId, orderId, fromPage) {
        this.langId = langId;
        this.storeId = storeId;
        this.catalogId = catalogId;
        this.orderId = orderId;
        this.fromPage = fromPage;
    },

	/* refresh controller declaration for "provinceSelectionsController" */
	provinceSelectionsRefreshArea: function () {

		var myWidgetObj = $("#provinceSelections"),
			myRCProperties = wcRenderContext.getRenderContextProperties("provinceSelectionsContext");

		myWidgetObj.refreshWidget({
			formId: "",


			renderContextChangedHandler: function () {

				cursor_wait();
				myWidgetObj.refreshWidget("refresh", myRCProperties);
			},

			postRefreshHandler: function () {

				storeLocatorJSStore.refreshCities();
				cursor_clear();
			}
		});
	},

	/* refresh controller declaration for "citySelectionsController" */
	citySelectionsRefreshController: function () {

		var myWidgetObj = $("#citySelections"),
			myRCProperties = wcRenderContext.getRenderContextProperties("citySelectionsContext");

		myWidgetObj.refreshWidget({
			formId: "",


			renderContextChangedHandler: function () {

				cursor_wait();
				myWidgetObj.refreshWidget("refresh", myRCProperties);
			},


			postRefreshHandler: function (widget) {

				storeLocatorJSStore.refreshSearchResults(StoreLocatorControllersDeclarationJSStore.fromPage);
				cursor_clear();
			}

		});
	},


	/* refresh controller declaration for "storeLocatorResultsController" */
	storeLocatorResultsRefreshController: function () {

		var myWidgetObj = $("#storeLocatorResults"),
			myRCProperties = wcRenderContext.getRenderContextProperties("storeLocatorResultsContext");

		myWidgetObj.refreshWidget({
			formId: "",

			renderContextChangedHandler: function () {
				cursor_wait();
				myWidgetObj.refreshWidget("refresh", myRCProperties);
			},

			postRefreshHandler: function () {

				var bopisTable = $("#bopis_table");
				if (bopisTable != null && bopisTable != "undefined") {
					bopisTable.focus();
				}
				var noStoreMsg = $("#no_store_message");
				if (noStoreMsg != null && noStoreMsg != "undefined") {
					noStoreMsg.focus();
				}

				cursor_clear();
			}

		});
	},

	/* refresh controller declaration for "selectedStoreListController" */
	selectedStoreListRefreshController: function () {

		var myWidgetObj = $("#selectedStoreList"),
			myRCProperties = wcRenderContext.getRenderContextProperties("selectedStoreListContext");

		myWidgetObj.refreshWidget({
			formId: "",


			renderContextChangedHandler: function () {

				cursor_wait();
				myWidgetObj.refreshWidget("refresh", myRCProperties);
			},

			postRefreshHandler: function () {

				var bopisTable = $("#bopis_table");
				if (bopisTable != null && bopisTable != "undefined") {
					bopisTable.focus();
				}

				cursor_clear();
			}

		})
	}
}
//-----------------------------------------------------------------
// Licensed Materials - Property of IBM
//
// WebSphere Commerce
//
// (C) Copyright IBM Corp. 2006, 2016 All Rights Reserved.
//
// US Government Users Restricted Rights - Use, duplication or
// disclosure restricted by GSA ADP Schedule Contract with
// IBM Corp.
//-----------------------------------------------------------------

/** 
 * @fileOverview This javascript is used by AddressBookForm.jsp and UnregisteredCheckout.jsp.
 * @version 1.0
 */

/**
 *  The functions defined in this class enable the customer to maintain an address book. 
 *	@class The AddressBookFormJS class defines all the functions and variables to update an address book. The customer can add or
 *  remove an address form the address book. The fields that can be entered while creating an address are first name, last name, 
 *  street address, city, country/region, state/province, ZIP/postal code, phone number, e-mail address.
 */

AddressBookFormJS = {
	/* The common parameters used in service calls. */
		langId: "-1",
		storeId: "",
		catalogId: "",
	/* flag set on address delete which is used to display the success message. */ 
		addressDeleted: "false",
	/* flag set on creation of new address which is used to display the success message. */ 
		addressNew: "false",
	/* variable set on address update which is used to display the success message. */  
		pageVar: "",
	
	/**
	 * This function initializes common parameters used in all service calls.
	 * @param {int} langId The language id to use.
	 * @param {int} storeId The store id to use.
	 * @param {int} catalogId The catalog id to use.
	 */
	setCommonParameters:function(langId,storeId,catalogId){
		this.langId = langId;
		this.storeId = storeId;
		this.catalogId = catalogId;
	},

	/**
	 * This function returns the handler for the refresh controller corresponding to the action.
	 * @param {string} handlerKey The key of the handler.
	 * @param {string} actionName The name of the action to be performed.
	 * 
	 * @return function handler.
	 */
	getControllerActionHandler: function(handlerKey, actionName){
		console.debug("entering getControllerActionHandler(controller, handlerKey, actionName): "+actionName);
		var handler = AddressBookFormJS[actionName+'s'][handlerKey];
		if(handler){
			return function(message, widget, controller){
				handler(message, widget, controller);	
				
			}
		}else{
			return function(message, widget, controller){
				console.debug("empty handler. This is a no-op");
			}
		}
	},
	
	/**
	 *  This defines function registries for handling address forms. We register functions that handle different operations
	 *	on address forms. The key of each function will be the value of the property "addressFormAreaAction" in render context. 
	 *  Each function takes three parameters: message, widget, and controller. The parameters message and widget are the same as those for
	 *	a controller's renderContextChangedHandler(). The parameter controller is the controller that will call this function.
	 */
	addressFormAreaActions: { 
		/* The function that loads an empty address for for creating new address. */
		create: function(message, widget, controller){
			widget.refresh(controller.renderContext.properties);
			controller.renderContext.properties['addressFormAreaState'] = 'create';
		}, 	
		
		/* The function that loads an address form that contains the information of currently displayed address, so that the
		 * address can be edited.
		 */
		edit: function(message, widget, controller){
			console.debug("starting to getting editing area");
			widget.refresh(controller.renderContext.properties);
			controller.renderContext.properties['addressFormAreaState'] = 'edit';
		}, 

		/* Destroy the address forms that are handled by this controller. */
		clean: function(message, widget, controller){
			widget.setInnerHTML("");	
			controller.renderContext.properties['addressFormAreaState'] = 'clean';
		},

		/* This function behaves same as {@link clean} function. */ 
		handleModelChange: function(message, widget, controller){
			widget.setInnerHTML("");
			controller.renderContext.properties['addressFormAreaState'] = 'clean';
		}
			
	}, 
	
	/*
	 * This defines function registries handling address display.The registered functions handle operations on 
     * the refresh area that displays user addresses.Each function takes three parameters: message, widget, and controller.
	 *
	 * @see AddressBookFormJS.addressFormAreaActions
	 */
	addressDisplayAreaActions: {
		
		/* This function reloads the refresh areas that display user addresses. */
		reload: function(message, widget, controller){
			console.debug("reloading "+widget);
			widget.refresh(controller.renderContext.properties);
		},
		
		/* This function behaves similar to {@link reload} function. */
		handleModelChange: function(message, widget, controller){
			console.debug("reloading "+widget);
			widget.refresh(controller.renderContext.properties);
		}
	}, 
	
	/*
	 * This defines function registries for handling the display of states and province. The registered functions displays states upon changes made 
	 * in address country. Each function takes three parameters: message, widget, and controller.
	 */
	statesDisplayAreaActions: {
		 
		/* This function  refreshes the area that displays states/provinces corresponding to the updated country */
		countryUpdated: function(message, widget, controller){
			console.debug("IN countryUpdated handler: message = "+message);
			
			var paramPrefix = controller.renderContext.properties['paramPrefix'];
			if(widget.widgetId.match(paramPrefix)){
				console.debug("matchin paramPrefix: "+paramPrefix+" refreshing "+widget.widgetId);
				
				widget.refresh(controller.renderContext.properties);	
			}else{
				console.debug("no maching paramPrefix "+paramPrefix);
			}
			
		}
		
	}, 
	
	/**
	 *  This function displays the address that has the selected address Id, and hides all the other addresses.
	 *  This function is supposed to be called when an addressId is selected from an HTML form selection control. 
	 *	This function makes a few assumptions. It assumes each ddress is displayed in the same way. Each chunk 
	 *	of address information has the same class, tableClass. It also assumes the area that displays
	 *	an address has an ID in the form of <tableIdPrefix><addressId>.
	 *  @param {DomNode} selection The DomNode of a form selection. This node contains selected addressId.
	 *  @param {string} tableClass The class of the table that contains an address.
	 *  @param {string} tableIdPrefix The prefix of the Id of each address table.
	 */
	toggleAddressDisplay: function(selection, tableClass, tableIdPrefix){
		console.debug('toggle address display');
		var selectedAddressId = selection.options[selection.selectedIndex].value;
			$("."+tableClass).each(function(i, div){
			var tableId = tableIdPrefix+selectedAddressId;
			if(div.id == tableId && selectedAddressId != "MyBillingAddress"){
				$(div).css("display", "block");	
			}else{
				$(div).css("display", "none");
			}
		});
	}, 

	/*
	 * This function is used to load the details corresponding to an address selection. When the customer
	 * selects an address from the dropdown, this function displays the stored address details 
	 * corresponding to the selection.
	 * @param {string} selection The id of the address dropdown box.
	 * @param {array} addresses Array of address objects.
	 * @param {object} form The actual HTML form object containing address information.
	 */
	populateTextFields: function(selection, addresses, form){

		if(document.getElementById("adding").style.display=='block')
		{
			var hidediv = document.getElementById("adding");
			hideElementById(hidediv);
			var div = document.getElementById("normal");
			div.style.display = "block";
		}
		var selectedAddressId = selection.options[selection.selectedIndex].value;
		
		var radioButton = form.sbAddress;
		for (var i=0; i<radioButton.length; i++)  
		{
			if (radioButton[i].value == addresses[selectedAddressId].addressType)  
			{
				radioButton[i].checked = "checked";
			} 
		}
		form.nickName.value = addresses[selectedAddressId].nickName;	
		form.firstName.value = addresses[selectedAddressId].firstName;	
		form.lastName.value = addresses[selectedAddressId].lastName;	
		form.address1.value = addresses[selectedAddressId].address1;
		form.address2.value = addresses[selectedAddressId].address2;		
		form.country.value = addresses[selectedAddressId].country;	
		form.zipCode.value = addresses[selectedAddressId].zipCode;	
		form.email1.value = addresses[selectedAddressId].email1;	
		form.phone1.value = addresses[selectedAddressId].phone1;	
		form.city.value = addresses[selectedAddressId].city;	
		AddressHelper.loadStatesUI('AddressForm','','stateDiv','state');
		form.state.value = addresses[selectedAddressId].state;
		if(form.middleName)
			form.middleName.value = addresses[selectedAddressId].middleName;
		document.getElementById("addr_title").innerHTML="<h2 class='status_msg'>"+addresses[selectedAddressId].nickName+"</h2>";
	},
	
	/*
	 * This function displays the default customer address on load of the address book page.
	 * @param {string} selection The id of the address dropdown box.
	 * @param {array} addresses Array of address objects.
	 * @param {object} form The actual HTML form object containing address information.
	 */

	populateTextFieldsOnLoad: function(selection, addresses, form){

		var selectedAddressId = selection.options[selection.selectedIndex].value;
		
		var radioButton = form.sbAddress;
		for (var i=0; i<radioButton.length; i++)  
		{
			if (radioButton[i].value == addresses[selectedAddressId].addressType)  
			{
				radioButton[i].checked = "checked";
			} 
		}
		form.nickName.value = addresses[selectedAddressId].nickName;	
		form.firstName.value = addresses[selectedAddressId].firstName;	
		form.lastName.value = addresses[selectedAddressId].lastName;	
		form.address1.value = addresses[selectedAddressId].address1;
		form.address2.value = addresses[selectedAddressId].address2;	
		form.state.value = addresses[selectedAddressId].state;	
		form.country.value = addresses[selectedAddressId].country;	
		form.zipCode.value = addresses[selectedAddressId].zipCode;	
		form.email1.value = addresses[selectedAddressId].email1;	
		form.phone1.value = addresses[selectedAddressId].phone1;	
		form.city.value = addresses[selectedAddressId].city;	
		if(form.middleName)
			form.middleName.value = addresses[selectedAddressId].middleName;
		AddressHelper.loadStatesUI('AddressForm','','stateDiv','state', true);
		document.getElementById("addr_title").innerHTML="<h2 class='status_msg'>"+addresses[selectedAddressId].nickName+"</h2>";
	},
	
	/**
	 *  This function is used to clear the values of all the form input fields in the address book.
	 *  The function obtains each form field by id and clears its value. This is usually done after form submit.
	 */

	clearTextFields: function(form){
		form.nickName.value="";
		form.firstName.value="";
		form.lastName.value="";
		form.address1.value="";
		form.address2.value="";
		form.city.value="";
		form.state.value="";
		form.country.value="";
		form.zipCode.value="";
		form.email1.value="";
		form.phone1.value="";
		if(form.middleName) {
			form.middleName.value="";
		}
	},

	/**
	 *  This function loads the address form when addnew button is clicked. This loads the form with all the input fields cleared. 
	 */
	showAdd: function(){
		
		var hidediv = document.getElementById("normal");
		hideElementById(hidediv);
		var div = document.getElementById("adding");
		div.style.display = "block";
	},

	
	/**
	 * This function is used during Unregistered checkout and makes the Shipping address same as the Billing address.
	 * This function takes shipping and billing forms as input and copies the billing address information to the shipping address.
	 * @param {string} fromName The name of the Billing address form.
	 * @param {string} toName The name of the Shipping address form.
	 */
	copyBillingFormNew: function(fromName,toName){
		
			var form = document.forms[fromName];
			var to = document.forms[toName];
			var sameaddress = document.getElementById("SameShippingAndBillingAddress");
			if (sameaddress.checked){
				hideElementById("shippingAddressCreateEditFormDiv_1");
			
				to.firstName.value = form.firstName.value;
				to.lastName.value = form.lastName.value;
				to.address1.value = form.address1.value;
				to.address2.value = form.address2.value;
				to.city.value = form.city.value;
				if(isIE){(document.getElementById("stateDiv2").firstChild).value = (document.getElementById("stateDiv1").firstChild).value;}
				else {to.state.value = form.state.value;}
				to.zipCode.value = form.zipCode.value;
				to.country.value = form.country.value;
				to.phone1.value = form.phone1.value;
				to.email1.value = form.email1.value;
				if(form.middleName)
					to.middleName.value = form.middleName.value;
			}

			if (!sameaddress.checked){
				showElementById("shippingAddressCreateEditFormDiv_1");
				to.firstName.value = "";
				to.lastName.value = "";
				to.address1.value = "";
				to.address2.value = "";
				to.city.value = "";
				if(isIE){(document.getElementById("stateDiv2").firstChild).value= "";}
				else{to.state.value = "";}
				to.zipCode.value = "";
				to.phone1.value = "";
				to.email1.value = "";
				if(to.middleName)
					to.middleName.value = "";
			}	
		}

};
//-----------------------------------------------------------------
// Licensed Materials - Property of IBM
//
// WebSphere Commerce
//
// (C) Copyright IBM Corp. 2006, 2016 All Rights Reserved.
//
// US Government Users Restricted Rights - Use, duplication or
// disclosure restricted by GSA ADP Schedule Contract with
// IBM Corp.
//-----------------------------------------------------------------

/** 
 * @fileOverview This javascript is used by the store jsp's related to address creation and maintenance.
 * @version 1.0
 */

/**
 * The functions defined in this class enable address creation across the store.
 * @class The functions and variables defined in this class validate the form input field values entered by 
 * the customer. Another set of functions help in loading the UI for the state field when there is a change
 * in the country field. Another set of functions enable creating an address in the shopcart page and
 * guest user checkout page.
 */
 

AddressHelper = {
	/* The name of the state field div. */
	stateDivName : "stateDiv",
	/* styling class for the state field. */
	stateClass   : null,
	 
	/**
	 * This function sets the name for the state field.
	 * @param {string} stateDivName The name to be set for the state field.  
	 */
	setStateDivName:function(stateDivName){
		this.stateDivName = stateDivName; 
	 },
	
	 /**
	  * This function sets the styling class for the state field. 
	  * @param {string} stateClass The name of the styling class to be set for the state field. 
	  */
	setStateClass:function(stateClass){
		this.stateClass = stateClass;
	},
	
	
	/** 
	 * This function return an array of countries from a global variable called countries.
	 * If that variable does not already exist then it will be created and populated from a JSON of country objects which should
	 * have been loaded into a div on the page prior to calling this function.
	 *
	 * @returns {Array} countries An array of countries.
	 **/
	 getCountryArray:function()
	{
		
		//If the countries array does not already exist then create it.
		
			if (document["countries"] == null)
			{
				countries = new Array();
				var theDiv = document.getElementById("countryListSelectionHelper");
		
				if (typeof theDiv == 'undefined') return null;
				var divJSON = eval('('+ theDiv.innerHTML +')');
				var countriesObject = divJSON.countries;
				
				for (var i = 0; i < countriesObject.length; i++)
				{
					var countryObject = countriesObject[i];
					countries[countryObject.code] = new Object();
					countries[countryObject.code].name = countryObject.displayName;
					countries[countryObject.code].countryCallingCode = countryObject.callingCode;
					
					if (countryObject.states.length > 0)
					{
						countries[countryObject.code].statesArray = new Array();
						countries[countryObject.code].states = new Object();
						for (var j = 0; j < countryObject.states.length; j++)
						{
							var state = countryObject.states[j];
							countries[countryObject.code].statesArray.push({value:state.code, label:state.displayName});
							countries[countryObject.code].states[state.code] = state.displayName;
						}
					}
				}
			}

			return countries;
			 
	},
	
	
	/**
	 * This function will load the state field depending on the country selection.
	 * @param {string} formName  The name of the address form containing the state field and country field.
	 * @param {string} stateDiv  The name of the state field.
	 * @param {string} id The id of the state field to be created.
	 * @param {boolean} keepCurrentState A true or false value used to determine whether to keep the current value in the state field or to remove it.
	 * @param {string} copyValue The value to be copied to the newly generated state field.
	 */
	loadStatesUI:function(formName,paramPrefix,stateDiv,id, keepCurrentState, copyValue){
		 
		this.getCountryArray();
		var form = document.getElementById(formName);
		if(paramPrefix == null || paramPrefix == 'undefined' || paramPrefix == ""){
			paramPrefix = "";
		}
		var newid = paramPrefix + id;
		var currentState;
		var required;
		if ($("#" + newid).length) {
			required = ($("#" + newid)).attr("aria-required");
		}
		if (keepCurrentState != null && keepCurrentState != 'undefined' && keepCurrentState == true)
		{
			currentState = $("#" + newid).val()
		}
		else
		{
			currentState = "";
		}
		
		if(copyValue != null && copyValue != 'undefined' && copyValue != '')
		{
			currentState = copyValue;
		}
		if(id=="_state1"){
			this.setStateClass("form_input");
			var currentCountryCode =form[paramPrefix + "_country"].value;
		} else{
			var currentCountryCode =form[paramPrefix + "country"].value;
		} 

		var stateDivObj = document.getElementById(stateDiv);
		if(Utils.get_IE_version()){ /* For IE */
			var stateClass = ($("#" + newid)).attr("className");
		} else {
			var stateClass = ($("#" + newid)).attr("class");
		}

		if(stateClass!="drop_down_country") {
			this.setStateClass(stateClass);
		}
		while(stateDivObj.hasChildNodes()) {
			stateDivObj.removeChild(stateDivObj.firstChild);
		}

		if (countries[currentCountryCode].states) {
			/* switch to state list. */
			stateDivObj.appendChild(this.createStateWithOptions(paramPrefix, currentCountryCode, currentState, id, required));
		} else {
			/* switch to state text input. */
			stateDivObj.appendChild(this.createState(paramPrefix, currentState, id, required));
		}
	},
	
	/**
	 *	This function creates an input element to represent the state.
	 *  @param {string} paramPrefix The value can be shipping, billing or blank.
	 *  @param {string} currentState The value in the state field.
	 *  @param {string} id The id of the state field.
	 */
	createState:function(paramPrefix,currentState,id,required){
		var stateInput = document.createElement("input");
		stateInput.setAttribute("id",paramPrefix + id);
		if(id=="_state1"){
		stateInput.setAttribute("name", paramPrefix + "_state");}
		else{
		stateInput.setAttribute("name", paramPrefix + "state");}
		if (required) {
			stateInput.setAttribute("aria-required", "true");
		}
		stateInput.setAttribute("class", this.stateClass);
		stateInput.setAttribute("className",this.stateClass);
		stateInput.setAttribute("size", "35");
		stateInput.setAttribute("maxlength", "49");
		if (currentState != null && currentState != 'undefined')
		{
			stateInput.setAttribute("value", currentState);
		}
		return stateInput;
	},
	
	/**
	 * This function creates a <select> element to represent the state field and loads it with the 
	 * states corresponding to the country field.
     * @param {string} paramPrefix The value can be shipping, billing or blank.
	 * @param {string} currentCountryCode The country code of the selected country.
	 * @param {string} currentState The value in the state field.
	 * @param {string} id The id of the state field.
	 */
	createStateWithOptions:function(paramPrefix, currentCountryCode, currentState, id, required){
		
		this.getCountryArray();
		var stateSelect = document.createElement("select");
		stateSelect.setAttribute("id", paramPrefix + id);
		if(id=="_state1"){
		stateSelect.setAttribute("name", paramPrefix + "_state");}
		else{
		stateSelect.setAttribute("name", paramPrefix + "state");}
		if (required) {
			stateSelect.setAttribute("aria-required", "true");
		}
		stateSelect.setAttribute("class","drop_down_country");
		stateSelect.setAttribute("className","drop_down_country");
		/*clear old options. */
		stateSelect.options.length = 0;
		
		/* add all states. */
		for (state_code in countries[currentCountryCode].states) {
			
			aOption = document.createElement("option");
			stateSelect.options[stateSelect.length] = aOption;
			aOption.text = countries[currentCountryCode].states[state_code];
			aOption.value = state_code;

			if (state_code == currentState || countries[currentCountryCode].states[state_code] == currentState) {
				aOption.selected = true;
			}
		}
		
		return stateSelect;
	},
	
	/**
	 * This function will load the state field for selection dropdown using wc.Select in AdressForm.jsp depending on the country selection.
	 * @param {string} formName  The name of the address form containing the state field and country field.
	 * @param {string} stateDiv  The name of the state field.
	 * @param {string} id The id of the state field to be created.
	 * @param {boolean} keepCurrentState A true or false value used to determine whether to keep the current value in the state field or to remove it.
	 * @param {string} copyValue The value to be copied to the newly generated state field.
	 * @param {boolean} addEmptyOption - If true, it adds 'Please Select' as the first option with value set to ''.
	 */
	loadAddressFormStatesUI:function(formName,paramPrefix,stateDiv,id, keepCurrentState, copyValue, addEmptyOption){
		 
		this.getCountryArray();
		var form = document.getElementById(formName);
		if(paramPrefix == null || paramPrefix == 'undefined' || paramPrefix == ""){
			paramPrefix = "";
		}
		var newid = paramPrefix + id;
		var currentState;
		var required = false;
		if ($("#" + newid).length) {
			required = ($("#" + newid)).attr("aria-required");
		}
		if (keepCurrentState != null && keepCurrentState != 'undefined' && keepCurrentState == true)
		{
			currentState = $("#" + newid).val()
		}
		else
		{
			currentState = "";
		}
		
		if(copyValue != null && copyValue != 'undefined' && copyValue != '')
		{
			currentState = copyValue;
		}
		
		if(id=="_state1") {
			this.setStateClass("form_input");
			var currentCountryCode = form[paramPrefix + "_country"].value;
		} else {
			var currentCountryCode =form[paramPrefix + "country"].value;
		}
				
		var stateDivObj = document.getElementById(stateDiv);
		var stateClass = ($("#" + newid)).attr("class");
		
		if(stateClass!=="drop_down_country") {
			this.setStateClass(stateClass);
		}
		
		while(stateDivObj.hasChildNodes()) {
			stateDivObj.removeChild(stateDivObj.firstChild);
		}
		
		if (countries[currentCountryCode] && countries[currentCountryCode].statesArray) {
			/* switch to state list. */	
			var statesData = countries[currentCountryCode].statesArray;
			if(addEmptyOption){
				var option1 = new Object({
					label: Utils.getLocalizationMessage("PLEASE_SELECT"),
					value: ''
				});
				statesData.unshift(option1);
			}

			if(this.stateClass == "" || this.stateClass == null || this.stateClass == undefined || this.stateClass == "null") {
				this.stateClass = "wcSelect";
			}
			
			$('<select>').attr({
				'name': paramPrefix + 'state',
				'id': paramPrefix + id,
				'class': this.stateClass,
				required: 'required'	
			}).appendTo(stateDivObj);
			statesData.forEach(function( item ) {
				$('<option>').attr({'value':item.value})
							.html(item.label)
							.appendTo('#' + paramPrefix + id);
			});   

			var options = {
					"wcMenuClass": "wcSelectMenu",
			}
			var statesSelect = $("#" + paramPrefix + id).Select(options);
			statesSelect.val(currentState);
			statesSelect.Select("refresh_noResizeButton");

		} else {
			/* switch to state text input. */
			stateDivObj.appendChild(this.createState(paramPrefix, currentState, id, required));
		}
	},
	
	/**
	 * This function validates the address form independently from the order of the fields displayed on the form, i.e. independent from the locale.
	 * A hidden field named "fields" must be set in the jsp/jspf file that calls this method. The purpose of this hidden field is 
	 * to set all the mandatory input fields and the order of these fields displayed on each locale-specific address entry page, so that
	 * this method knows which input fields to validate and in which order it should validate them.
	 *
	 * assumptions:1. Mandatory fields use UPPER CASE, non-mandatory fields use lower case.
	 *	     	   2. The error messages used in this method are declared in the jsp/jspf files that call this method. 
	 * @param {string} form The name of the address form obtained from the page containing address input fields.
	 * @param {string} prefix The value is set to shipping or billing.
	 * 
	 * @return {boolean} return true if no error was found, or the hidden field "fields" were not set in the jsp/jspf file that calls this method,
	 * return false if form could not be found, or if there was an error validating a particular field.
	 */

	validateAddressForm: function(form,prefix){
		reWhiteSpace = new RegExp(/^\s+$/);
		if(prefix == null){prefix = ""};
		if(prefix){this.setStateDivName(prefix + "stateDiv")};
		if(form != null){
			var fields="";
			if(form["UserDetailsForm_FieldsOrderByLocale"] != null && form["UserDetailsForm_FieldsOrderByLocale"].value != null && form["UserDetailsForm_FieldsOrderByLocale"].value != ""){
				fields = form["UserDetailsForm_FieldsOrderByLocale"].value.split(",");
			}
			else if(form["UserAddressForm_FieldsOrderByLocale"] != null && form["UserAddressForm_FieldsOrderByLocale"].value != null && form["UserAddressForm_FieldsOrderByLocale"].value != ""){
				fields = form["UserAddressForm_FieldsOrderByLocale"].value.split(",");
			}
			else if(form[prefix + "AddressForm_FieldsOrderByLocale"] != null && form[prefix + "AddressForm_FieldsOrderByLocale"].value != null && form[prefix + "AddressForm_FieldsOrderByLocale"].value != ""){
				fields = form[prefix + "AddressForm_FieldsOrderByLocale"].value.split(",");
			}
			else if(form["AddressForm_FieldsOrderByLocale"] != null && form["AddressForm_FieldsOrderByLocale"].value != null && form["AddressForm_FieldsOrderByLocale"].value != ""){
				fields = form["AddressForm_FieldsOrderByLocale"].value.split(",");
			}
			else if(document.getElementById("AddressForm_FieldsOrderByLocale").value!= null && document.getElementById("AddressForm_FieldsOrderByLocale").value!= ""){
				fields=document.getElementById("AddressForm_FieldsOrderByLocale").value.split(",");
			}
			var nickName = prefix + "nickName";
			var lastName = prefix + "lastName";
			var firstName = prefix + "firstName";
			var middleName = prefix + "middleName";
			var address1 = prefix + "address1";
			var address2 = prefix + "address2";
			var city = prefix + "city";
			var state = prefix + "state";
			var country = prefix + "country";
			var zipCode = prefix + "zipCode";
			var email1 = prefix + "email1";
			var phone1 = prefix + "phone1";

			for(var i=0; i<fields.length; i++){
				var field = fields[i];
				if(field == "NICK_NAME" || field == "nick_name"){
					form[nickName].value = trim(form[nickName].value);
					if(field == "NICK_NAME" && (form[nickName].value == "" || reWhiteSpace.test(form[nickName].value))){
						MessageHelper.formErrorHandleClient(form[nickName].id, MessageHelper.messages["ERROR_RecipientEmpty"]);
						return false;
					}
					if(!MessageHelper.isValidUTF8length(form[nickName].value, 254)){ 
						MessageHelper.formErrorHandleClient(form.nickName.id, MessageHelper.messages["ERROR_RecipientTooLong"]); 
						return false;
					}
				}else if(field == "LAST_NAME" || field == "last_name"){
					form[lastName].value = trim(form[lastName].value);
					if(field == "LAST_NAME" && (form[lastName].value == "" || reWhiteSpace.test(form[lastName].value))){ 
						MessageHelper.formErrorHandleClient(form[lastName].id, MessageHelper.messages["ERROR_LastNameEmpty"]);
						return false;
					}
					if(!MessageHelper.isValidUTF8length(form[lastName].value, 128)){ 
						MessageHelper.formErrorHandleClient(form[lastName].id, MessageHelper.messages["ERROR_LastNameTooLong"]);
						return false;
					}
				}else if(field == "FIRST_NAME" || field == "first_name"){
					form[firstName].value = trim(form[firstName].value);
					if(field == "FIRST_NAME" && (form[firstName].value == "" || reWhiteSpace.test(form[firstName].value))){ 
						MessageHelper.formErrorHandleClient(form[firstName].id, MessageHelper.messages["ERROR_FirstNameEmpty"]);
						return false;
					}
					if(!MessageHelper.isValidUTF8length(form[firstName].value, 128)){ 
						MessageHelper.formErrorHandleClient(form[firstName].id, MessageHelper.messages["ERROR_FirstNameTooLong"]); 
						return false;
					}
				}else if(field == "MIDDLE_NAME" || field == "middle_name"){
					form[middleName].value = trim(form[middleName].value);
					if(field == "MIDDLE_NAME" && (form[middleName].value == "" || reWhiteSpace.test(form[middleName].value))){ 
						MessageHelper.formErrorHandleClient(form[middleName].id, MessageHelper.messages["ERROR_MiddleNameEmpty"]);
						return false;
					}
					if(!MessageHelper.isValidUTF8length(form[middleName].value, 128)){ 
						MessageHelper.formErrorHandleClient(form[middleName].id, MessageHelper.messages["ERROR_MiddleNameTooLong"]); 
						return false;
					}
				}else if(field == "use_org_address" || field == 'new_line'|| field == "PASSWORD" || field == "PASSWORD_VERIFY"){
				}else if(field == "ADDRESS" || field == "address"){
					form[address1].value = trim(form[address1].value);
					form[address2].value = trim(form[address2].value);
					if(field == "ADDRESS" && ((form[address1].value == "" || reWhiteSpace.test(form[address1].value)) && (form[address2].value=="" || reWhiteSpace.test(form[address2].value)))){ 
						MessageHelper.formErrorHandleClient(form[address1].id, MessageHelper.messages["ERROR_AddressEmpty"]);
						return false;
					}
					if(!MessageHelper.isValidUTF8length(form[address1].value, 100)){ 
						MessageHelper.formErrorHandleClient(form[address1].id, MessageHelper.messages["ERROR_AddressTooLong"]); 
						return false;
					}
					if(!MessageHelper.isValidUTF8length(form[address2].value, 50)){ 
						MessageHelper.formErrorHandleClient(form[address2].id, MessageHelper.messages["ERROR_AddressTooLong"]);
						return false;
					}
				}else if(field == "CITY" || field == "city"){
					form[city].value = trim(form[city].value);
					if(field == "CITY" && (form[city].value == "" || reWhiteSpace.test(form[city].value))){ 
						MessageHelper.formErrorHandleClient(form[city].id, MessageHelper.messages["ERROR_CityEmpty"]);
						return false;
					}
					if(!MessageHelper.isValidUTF8length(form[city].value, 128)){
						MessageHelper.formErrorHandleClient(form[city].id, MessageHelper.messages["ERROR_CityTooLong"]);
						return false;
					}
				}else if(field == "STATE/PROVINCE" || field == "state/province"){
					var state = form[state];
					if(state == null || state == ""){
						state = document.getElementById(this.stateDivName).firstChild;
					}
					state.value = trim(state.value);
					if(field == "STATE/PROVINCE" && (state.value == null || state.value == "" || reWhiteSpace.test(state.value))){
						if(state.tagName == "SELECT" || state.tagName == "select") {
							MessageHelper.formErrorHandleClient(state.id + "-button", MessageHelper.messages["ERROR_StateEmpty"]);
						} else {
							MessageHelper.formErrorHandleClient(state.id, MessageHelper.messages["ERROR_StateEmpty"]);
						}
						return false;
					}
					if(!MessageHelper.isValidUTF8length(state.value, 128)){
						if(state.tagName == "SELECT" || state.tagName == "select") {
							MessageHelper.formErrorHandleClient(state.id + "-button", MessageHelper.messages["ERROR_StateTooLong"]);
						} else {
							MessageHelper.formErrorHandleClient(state.id, MessageHelper.messages["ERROR_StateTooLong"]);
						}
						return false;
					}
				}else if(field == "COUNTRY/REGION" || field == "country/region"){
					console.log(form[country].value);
					form[country].value = trim(form[country].value);
					if(field == "COUNTRY/REGION" && (form[country].value == "" || reWhiteSpace.test(form[country].value))){ 
						MessageHelper.formErrorHandleClient(form[country].id + "-button", MessageHelper.messages["ERROR_CountryEmpty"]);
						return false;
					}
					if(!MessageHelper.isValidUTF8length(form[country].value, 128)){ 
						MessageHelper.formErrorHandleClient(form[country].id + "-button", MessageHelper.messages["ERROR_CountryTooLong"]);
						return false;
					}
				}else if(field == "ZIP" || field == "zip"){
					form[zipCode].value = trim(form[zipCode].value);
					//check zip code for validation
					if(field == "ZIP" && (form[zipCode].value=="" || reWhiteSpace.test(form[zipCode].value))){ 
						MessageHelper.formErrorHandleClient(form[zipCode].id, MessageHelper.messages["ERROR_ZipCodeEmpty"]);
						return false;
					}
					if(!MessageHelper.isValidUTF8length(form[zipCode].value, 40)){ 
						MessageHelper.formErrorHandleClient(form[zipCode].id, MessageHelper.messages["ERROR_ZipCodeTooLong"]);
						return false;
					}
				}else if(field == "EMAIL1" || field == "email1"){
					form[email1].value = trim(form[email1].value);
					if(field == "EMAIL1" && (form[email1].value == "" || reWhiteSpace.test(form[email1].value))){
						MessageHelper.formErrorHandleClient(form[email1].id, MessageHelper.messages["ERROR_EmailEmpty"]);
						return false;
					}
					if(!MessageHelper.isValidUTF8length(form[email1].value, 256)){ 
						MessageHelper.formErrorHandleClient(form[email1].id, MessageHelper.messages["ERROR_EmailTooLong"]);
						return false;
					}
					if(!MessageHelper.isValidEmail(form[email1].value)){
						MessageHelper.formErrorHandleClient(form[email1].id, MessageHelper.messages["ERROR_INVALIDEMAILFORMAT"]);
						return false;
					}
				}else if(field == "PHONE1" || field == "phone1"){
					form[phone1].value = trim(form[phone1].value);
					if(field == "PHONE1" && (form[phone1].value == "" || reWhiteSpace.test(form[phone1].value))){
						MessageHelper.formErrorHandleClient(form[phone1].id, MessageHelper.messages["ERROR_PhonenumberEmpty"]);
						return false;
					}
					if(!MessageHelper.isValidUTF8length(form[phone1].value, 32)){ 
						MessageHelper.formErrorHandleClient(form[phone1].id, MessageHelper.messages["ERROR_PhoneTooLong"]);
						return false;
					}
					if(!MessageHelper.IsValidPhone(form[phone1].value)){
						MessageHelper.formErrorHandleClient(form[phone1].id, MessageHelper.messages["ERROR_INVALIDPHONE"]);
						return false;
					}
				}else{
					console.debug("error: mandatory field name " + mandatoryField + " is not recognized.");
					return false;
				}
			}
			if (form[address1] && form[address1].value == "" && form[address2].value != "") {
		
			form[address1].value = form[address2].value;
			form[address2].value = "";
			}
			return true;
		}
		return false;
	},
	
	/**
	 * This function saves the address entry form when a registered customer wants to edit/add a new address 
	 * during checkout from  his/her shopping cart.
	 * @param {string} The id of the service that was invoked, e.g. AjaxUpdateAddressForPerson, AjaxAddAddressForPerson, etc.
	 * @param {string} The name of the form containing address information.
	 * @param {string} The addressTypeIn being saved.
	 */
	
	saveShopCartAddress: function(serviceId, formName, addressTypeIn){
		var form = document.forms[formName];
		if( addressTypeIn == 'ShippingAndBilling' || addressTypeIn == 'Shipping'){
			if (serviceId == 'AjaxUpdateAddressForPerson') {
				serviceId = 'AjaxUpdateShippingAndBillingAddressForPersonDuringCheckout';	
			} else {
				serviceId = 'AjaxAddShippingAndBillingAddressForPersonDuringCheckout';
			}
		}
		if(this.validateAddressForm(form)){
			this.saveAddress(serviceId, formName);
		}
	},
	
	
	/**
	 * This function saves the address entry form on an unregistered user's checkout page.
	 * @param {string} formName1 The name of the billing address form.
	 * @param {string} formName2 The name of the shipping address form.
	 * @param {string} stateDivName1 The name of the state field in the billing address form.
	 * @param {string} stateDivName2 The name of the state field in the shipping address form.
	 */
	
	saveUnregisteredCheckoutAddress: function(formName1, formName2, stateDivName1, stateDivName2)
	{
		var form1 = document.forms[formName1];
		
		this.setStateDivName(stateDivName1);
		/*Validate form input fields */
		if(this.validateAddressForm(form1))
		{
			var sameaddress = document.getElementById("SameShippingAndBillingAddress");
			if (!sameaddress.checked)
			{
				var form2 = document.forms[formName2];
				this.setStateDivName(stateDivName2);
				/*Validate form input fields */
				if(this.validateAddressForm(form2))
				{
					this.saveAddress('AddBillingAddress', 'billingAddressCreateEditFormDiv_1');
				}
			}
			else
			{
				form1.addressType.value='ShippingAndBilling';
				this.saveAddress('AddShippingAddress', 'billingAddressCreateEditFormDiv_1');
			}
		}
	},
	
	/**
	 * This function saves an address entry form to the associated service.
	 * @param {string} serviceId The id of the service that was invoked, e.g. AjaxUpdateAddressForPerson, AjaxAddAddressForPerson, etc. 
	 * @param {string} formName The name of the form containing address information.
	 */
	
	saveAddress:function(serviceId, formName) {
		var form = document.forms[formName];
		if (form.address1.value == "" && form.address2.value != "") {
			form.address1.value = form.address2.value;
			form.address2.value = "";
		}
	 	var addressService = wcService.getServiceById(serviceId);
	 	addressService.setFormId(formName);
		/* For Handling multiple clicks */
		if(!submitRequest()){
			return;
		}   	 	
	 	cursor_wait();
	 	wcService.invoke(serviceId);
	},
	
	/**
	 * This function calls UpdateOrderItem/AjaxUpdateOrderItem service to update order calculation
	 */
	
	updateOrderAfterAddressUpdate:function() {
		var params = {
			storeId: this.storeId,
			catalogId: this.catalogId,
			langId: this.langId
			};
		params.calculationUsage = "-1,-2,-3,-4,-5,-6,-7";
		params.calculateOrder = "1";
		params.orderId = ".";
			
	 	cursor_wait();
	 	wcService.invoke("AjaxUpdateOrderAfterAddressUpdate", params);
	},

	/**
	 *  This function populates the country code to mobile phone based on the selected country.
	 *  @param {string} countryDropDownId The id of the mobile country drop down list
	 *  @param {string} countryCallingCodeId The id of the mobile country calling code text box.
	 */
	
	loadCountryCode:function(countryDropDownId,countryCallingCodeId){
		this.getCountryArray();
		var countryCode = $("#" + countryDropDownId).val()
		if ( countryCode === undefined || countryCode === null )
		// we are using wc.Select
		{
			var countryDropDownWidget = $("#" + countryDropDownId);
			if (countryDropDownWidget !== undefined && countryDropDownWidget !== null)
			{
				countryCode = countryDropDownWidget.val();
			}
		}
		$("#" + countryCallingCodeId).val(countries[countryCode].countryCallingCode);
	},
	
	/**
	 *  This function checks for an entry in the Mobile Phone Number field. 
	 *  If a Mobile Phone number has been entered, it enables the SMS Notifications/Promotions checkbox,
	 *  else it disables the SMS Notifications/Promotions checkbox.
	 *  @param {string} form The name of the form containing the Mobile Phone Number entry field.
	 *  @param {string} jspStoreImgDir The directory for images
	 */
	enableSMSNotifications:function(form, jspStoreImgDir){
		var form = document.forms[form];
		if(form.mobilePhone1.value !== ""){
			form.sendMeSMSNotification.disabled = false;
			form.sendMeSMSPreference.disabled = false;
			$(".checkedCheckBox.mobileOption").removeClass("disabled").attr("tabindex", "0");
		}
		else{
			form.sendMeSMSNotification.disabled = true;
			form.sendMeSMSPreference.disabled = true;
			form.sendMeSMSNotification.checked = false;
			form.sendMeSMSPreference.checked = false;
			$(".checkedCheckBox.mobileOption").addClass("disabled").attr("tabindex", "-1")
					.removeClass("checked").attr("aria-checked", "false").attr("src", jspStoreImgDir + "images/checkbox.png");
		}
	},
	/**
	 * Sets the address type when a user wants to add a new address of type shipping and billing during order check out.
	 * @param {Object} checkbox The HTML checkbox input object.
	 * @param {Object} form The form that contains the new address information.
	 */
	setAddressTypeInCreatingNewAddressDuringCheckout: function(checkbox, form){
		if(form.addressType != null && form.originalAddressType != null){
			if(checkbox.checked){
				form.addressType.value = 'ShippingAndBilling';
			}else{
				form.addressType.value = form.originalAddressType.value;
			}
		}
	},
  
	/**
	 * Set checkbox state to true when checked and false when unchecked
	 * @param String jspStoreImgDir The directory for store images.
	 * @param String checkbox The checkbox element.
	 * @param String checkboxImg The checkbox image element.
	 * @param String checkedValue The value of the input when checked.
	 * @param String uncheckedValue The value of the input when unchecked.
	 */
	changeCheckboxState: function(jspStoreImgDir, checkbox, checkboxImg, checkedValue, uncheckedValue){
		var $checkboxImg = $("#" + checkboxImg),
			$checkbox = $("#" + checkbox);
		if (!$checkboxImg.hasClass("disabled")) {
			if ($checkboxImg.hasClass("checked")){
				$checkboxImg.removeClass("checked");
				$checkboxImg.attr("aria-checked", "false");
				$checkboxImg.attr("src", jspStoreImgDir + "images/checkbox.png");
				$checkbox.attr("value", uncheckedValue);
				$checkbox.removeAttr("checked");
			} else {
				$checkboxImg.addClass("checked");
				$checkboxImg.attr("src", jspStoreImgDir + "images/checkbox_checked.png");
				$checkboxImg.attr("aria-checked", "true");
				$checkbox.attr("value", checkedValue);
				$checkbox.attr("checked", "checked");
			}
		}
	}
}
//-----------------------------------------------------------------
// Licensed Materials - Property of IBM
//
// WebSphere Commerce
//
// (C) Copyright IBM Corp. 2007, 2015 All Rights Reserved.
//
// US Government Users Restricted Rights - Use, duplication or
// disclosure restricted by GSA ADP Schedule Contract with
// IBM Corp.
//-----------------------------------------------------------------

/**
 * @fileOverview This javascript is used by UserRegistrationAddForm.jsp and CheckoutLogon.jsp.
 * @version 1.0
 */

/**
 *  The functions defined in the class helps the customer to register with the store. Another function enables a returning
 *  customer to Sign in for quickcheckout from the shopping cart page.
 *
 *  @class This LogonForm class defines all the functions and variables used to validate the information provided by the
 *  customer to register with the store.To register, a customer creates a logon ID and password. Then, the customer provides their first name,
 *  last name, street address, city, country/region, state/province, ZIP/postal code, e-mail address and phone number. Other registration options
 *  include promotional e-mails, preferred language and currency, age, gender, and the remember me option.
 */
LogonForm ={

    /**
     * This function validates the logon ID and password for returning customers to sign in and complete the checkout process.
     * @param {string} form The name of the form containing logon ID and password fields.
     */
    SubmitAjaxLogin:function(form){

        if(!this.validateAjaxLogin(form)){
            return;
        };

        /*For Handling multiple clicks. */
        if(!submitRequest()){
            return;
        }
        setDeleteCartCookie();

        form.submit();

    },

    validateAjaxLogin:function(form){
        reWhiteSpace = new RegExp(/^\s+$/);

        if(form.logonId != null && reWhiteSpace.test(form.logonId.value) || form.logonId.value == ""){
            MessageHelper.formErrorHandleClient(form.logonId.id,MessageHelper.messages["LOGON_REQUIRED_FIELD_ENTER"]); return false;}

        if(form.logonPassword != null && reWhiteSpace.test(form.logonPassword.value) || form.logonPassword.value == ""){
            MessageHelper.formErrorHandleClient(form.logonPassword.id,MessageHelper.messages["PASSWORD_REQUIRED_FIELD_ENTER"]); return false;}

        return true;
    },

    /**
     * This function is called when the Submit button is clicked on the Registration page. All the fields containing customer
     * information are validated and PersonProcessServicePersonRegistration is called.
     * @param {string} form The name of the registration form containing all the customer information.
     */
    prepareSubmit:function (form){
        //cursor_clear();
        if(CSRWCParamJS.env_shopOnBehalfSessionEstablished == 'true' || CSRWCParamJS.env_shopOnBehalfEnabled_CSR == 'true'){
            var random = Math.random();
            var randomPassword = random.toString(36).slice(-7); // Get last 7 chars. Will add one numeric char to make it 8 char long...
            var randomInt = Math.floor((random * 9) + 1);
            randomPassword += randomInt; //Password should contain atleast one numeric character...
            if ($("#logonPassword").val() == null || $("#logonPassword").val() == "") {
                $('<input>').attr({
                    type: 'hidden',
                    value: randomPassword,
                    name: "logonPassword",
                    id: "logonPassword",
                }).appendTo('form');
            }

            if ($("#logonPasswordVerify").val() == null || $("#logonPasswordVerify").val() == "") {
                $('<input>').attr({
                    type: 'hidden',
                    value: randomPassword,
                    name: "logonPasswordVerify",
                    id: "logonPasswordVerify"
                }).appendTo('form');
            }

            if ($("#passwordExpired").val() == null || $("#passwordExpired").val() == "") {
                $("#passwordExpired").val("1");
            }
        }
        if (!this.validatePrepareForm(form)){
            return;
        }
        /* For Handling multiple clicks. */
        if(!submitRequest()){
            return;
        }
        setCookie("WC_SHOW_USER_ACTIVATION_" + WCParamJS.storeId, "true", {path:'/', domain:cookieDomain});
        if(CSRWCParamJS.env_shopOnBehalfEnabled_CSR == 'true' ||
                (CSRWCParamJS.env_shopOnBehalfSessionEstablished == 'true' &&  form.userId != null && form.userId.value != null)){
            // CSR is creating the user OR
            // OnBehalf session is started and CSR is registering existing guestUser.
            // Uses UserRegistrationAdminAddCmd
            if(registeredCustomersJS != null) {
                registeredCustomersJS.createRegisteredUser(form.landingURL_CSR.value);
            }
        } else {
            // 1. Normal guest / generic user registering for themselves. OR
            // 2. CSR registering guest / generic user using the guest / generic user flow. And not using UserRegistrationAdminAddCmd.
            form.submit();
        }
    },

    /**
     * The function is called to validate and prepare the form.
     * @param {string} form The name of the registration form containing all the customer information.
     * @return (Boolean) true if the form is ready to submit, false otherwise.
     */
    validatePrepareForm: function(form){
        reWhiteSpace = new RegExp(/^\s+$/);
        if(form.logonId != null && reWhiteSpace.test(form.logonId.value) || form.logonId.value == ""){
            MessageHelper.formErrorHandleClient(form.logonId.id,MessageHelper.messages["ERROR_LogonIdEmpty"]); return false;
        } else if (typeof this.validateLoginId == "function") {
                if (!this.validateLoginId(form.logonId)) {
                    return false;
                }
        }

        if (form.ancestorOrgs != null) {
            if (form.ancestorOrgs.value == "") {
                MessageHelper.formErrorHandleClient(form.ancestorOrgs.id,MessageHelper.messages["ERROR_OrgNameEmpty"]);
                return false;
            } else if (form.ancestorOrgs.value == "Default Organization") {
                MessageHelper.formErrorHandleClient(form.ancestorOrgs.id,MessageHelper.messages["ERROR_DefaultOrgRegistration"]);
                return false;
            }
        }

        if(form.logonPassword != null && reWhiteSpace.test(form.logonPassword.value) || form.logonPassword.value == ""){
            MessageHelper.formErrorHandleClient(form.logonPassword.id,MessageHelper.messages["ERROR_PasswordEmpty"]); return false;}
        if(form.logonPasswordVerify != null && reWhiteSpace.test(form.logonPasswordVerify.value) || form.logonPasswordVerify.value == ""){
            MessageHelper.formErrorHandleClient(form.logonPasswordVerify.id,MessageHelper.messages["ERROR_VerifyPasswordEmpty"]); return false;}
        if(form.logonPassword.value!= form.logonPasswordVerify.value){
            MessageHelper.formErrorHandleClient(form.logonPasswordVerify.id,MessageHelper.messages["PWDREENTER_DO_NOT_MATCH"]);
            return false;
        }

        /** Uses the common validation function defined in AddressHelper class for validating first name,
         *  last name, street address, city, country/region, state/province, ZIP/postal code, e-mail address and phone number.
         */
        if(!AddressHelper.validateAddressForm(form)){
            return false;
        }

        /* Checks whether the customer has registered for promotional e-mails. */
        if(form.sendMeEmail && form.sendMeEmail.checked){
            form.receiveEmail.value = true;
        }
        else {
            form.receiveEmail.value = false;
        }

        if(form.sendMeSMSNotification &&  form.sendMeSMSNotification.checked){
            form.receiveSMSNotification.value = true;
        }
        else {
            form.receiveSMSNotification.value = false;
        }

        if(form.sendMeSMSPreference && form.sendMeSMSPreference.checked){
            form.receiveSMS.value = true;
        }
        else {
            form.receiveSMS.value = false;
        }

        if(form.mobileDeviceEnabled != null && form.mobileDeviceEnabled.value == "true"){
            if(!MyAccountDisplay.validateMobileDevice(form)){
                return false;
            }
        }
        if(form.birthdayEnabled != null && form.birthdayEnabled.value == "true"){
            if(!MyAccountDisplay.validateBirthday(form)){
                return false;
            }
        }
        return true;
    },

    /**
     *  This function validates the customer's input for age. If the user is under age, pop up a message to ask the user to review the store policy.
     *  @param {string} The name of the form containing personal information of the customer.
     */
    validateAge: function(form){

        var birth_year = parseInt(form.birth_year.value);
        var birth_month = parseInt(form.birth_month.value);
        var birth_date = parseInt(form.birth_date.value);

        if (birth_year == 0 || birth_month == 0 || birth_date == 0) {
            return;
        }

        var curr_year = parseInt(form.curr_year.value);
        var curr_month = parseInt(form.curr_month.value);
        var curr_date = parseInt(form.curr_date.value);

        /*Check whether age is less than 13, if so, pop up a message to ask the user to review the store policy. */
        if((curr_year - birth_year) < 13){
            alert(MessageHelper.messages["AGE_WARNING_ALERT"]);
        }else if((curr_year - birth_year) == 13){
            if(curr_month < birth_month){
                alert(MessageHelper.messages["AGE_WARNING_ALERT"]);
            }else if((curr_month == birth_month) && (curr_date < birth_date)){
                alert(MessageHelper.messages["AGE_WARNING_ALERT"]);
            }
        }
    },

    /**
      * This function is used when "Age" option is changed.
      * This will show one alert message if the user age is under 13.
      * @param {string} form The name of the registration form containing customer's age.
      */

    checkAge:function (form)
    {
        if(form.age.value==1) {
            alert(MessageHelper.messages["AGE_WARNING_ALERT"]);
        }
    }
}
//-----------------------------------------------------------------
// Licensed Materials - Property of IBM
//
// WebSphere Commerce
//
// (C) Copyright IBM Corp. 2010, 2016 All Rights Reserved.
//
// US Government Users Restricted Rights - Use, duplication or
// disclosure restricted by GSA ADP Schedule Contract with
// IBM Corp.
//-----------------------------------------------------------------

MultipleWishLists = {

    /** 
     * This variable stores the ID of the language that the store currently uses. Its default value is set to -1, which corresponds to United States English.
     * @private
     */
    langId: "-1",

    /** 
     * This variable stores the ID of the current store. Its default value is empty.
     * @private
     */
    storeId: "",

    /** 
     * This variable stores the ID of the catalog. Its default value is empty.
     * @private
     */
    catalogId: "",

    /**
     * variable that stores the default gift list ID
     * @private
     */
    defaultListId: null,

    /**
     * indicate whether or not an item should be added after the wish list is created. 
     * @private
     */
    addItemAfterCreate: false,

    /**
     * stores the preferred default wish list name
     * @private
     */
    preferredDefaultWishListName: "",

    /**
     * stores the wish list prefix
     * @private
     */
    wishListPrefix: "",

    /**
     * Indicates whether to update wish list display context after switching to a new wish list
     */
    updateAfterSwitch: false,

    /**
     * This is the variable that controls how many characters from the wish list name are displayed before dots are added as suffix
     * @private
     */
    maxCharsToDisplay: 30,

    /**
     * Sets the common parameters for the current page. 
     * For example, the language ID, store ID, and catalog ID.
     *
     * @param {Integer} langId The ID of the language that the store currently uses.
     * @param {Integer} storeId The ID of the current store.
     * @param {Integer} catalogId The ID of the catalog.
     */
    setCommonParameters: function (langId, storeId, catalogId) {
        this.langId = langId;
        this.storeId = storeId;
        this.catalogId = catalogId;
    }

    /**
     * switch to show a different wish list, by switching to a new wish list, the newly selected wish list will
     * also become the default wish list
     * @param {string} newListId The wish list id of wish list to be switched to 
     */
    ,
    switchList: function (newListId) {

        /*For Handling multiple clicks. */
        if (!submitRequest()) {
            return;
        }
        cursor_wait();
        $("#multipleWishlistController_select").attr('disabled', 'true');
        this.updateAfterSwitch = true;
        this.setAsDefault(newListId);
    }

    /** update wish list display context after switching to a new wish list 
     * @param {string} newListId The wish list id of new default wish list 
     */
    ,
    updateContextPostSwitch: function (newListId) {
        if (this.updateAfterSwitch) {
            wcRenderContext.updateRenderContext('WishlistDisplay_Context', {
                'giftListId': newListId
            });
            wcRenderContext.updateRenderContext('WishlistSelect_Context', {
                'giftListId': newListId
            });
        }
        this.updateAfterSwitch = false;
    }

    /**
     * remove item from a wish list
     * @param {long} giftItemId ID of the wish list item to be removed
     */
    ,
    removeItem: function (giftItemId) {
        var params = {};
        params["storeId"] = this.storeId;
        params["catalogId"] = this.catalogId;
        params["langId"] = this.langId;
        params["quantity"] = 0;

        if (($("#multipleWishlistController_select") != null && $("#multipleWishlistController_select") != 'undefined') && $("#multipleWishlistController_select").val() != 0) {
            // get wish list ID
            params["giftListId"] = $("#multipleWishlistController_select").val();

            if (!this.empty(giftItemId)) {

                params["giftListItemId"] = giftItemId;

                /*For Handling multiple clicks. */
                if (!submitRequest()) {
                    return;
                }

                cursor_wait();
                wcService.invoke('ShoppingListServiceRemoveItem', params); //calling the service to save the new list name

            }
        }
    }

    /**
     * This function is used to set the selected wish list ID for the email form.
     * @param {string} formId  The formId of the email form.
     */
    ,
    getWishListIdForEmail: function (formId) {
        var form = document.getElementById(formId);
        if (($("#multipleWishlistController_select") != null && $("#multipleWishlistController_select") != 'undefined') && $("#multipleWishlistController_select").val() != 0) {
            form.giftListId.value=$('#multipleWishlistController_select').val();
        }
    }

    /**
     * This function is used to check user input in the wish list email form, if user input is valid, it invokes the InterestItemListMessage service to send out the email.
     * @param {string} formId  The formId of the email form.
     */
    ,
    checkSOAEmailForm: function (formId) {
        $("#WishListEmailSucMsg_Div").css('display', 'none');
        var form = document.getElementById(formId);
        form.sender_name.value = form.sender_name.value.replace(/^\s+/g, "");
        form.recipient.value = form.recipient.value.replace(/^\s+/g, "");

        if (form.recipient.value == '') {
            MessageHelper.formErrorHandleClient(document.getElementById('SendWishListForm_Recipient_Email').id, Utils.getLocalizationMessage("WISHLIST_MISSINGEMAIL"));
            return;
        }
        if (!MultipleWishLists.validateWishListEmailString(form.recipient.value)) {
            MessageHelper.formErrorHandleClient(document.getElementById('SendWishListForm_Recipient_Email').id, Utils.getLocalizationMessage("WISHLIST_INVALIDEMAILFORMAT"));
            return;
        }
        if (form.sender_name.value == '') {
            MessageHelper.formErrorHandleClient(document.getElementById('SendWishListForm_Sender_Name').id, Utils.getLocalizationMessage("WISHLIST_MISSINGNAME"));
            return;
        }
        if (!MultipleWishLists.validateWishListEmailString(form.sender_email.value)) {
            MessageHelper.formErrorHandleClient(document.getElementById('SendWishListForm_Sender_Email').id, Utils.getLocalizationMessage("WISHLIST_INVALIDEMAILFORMAT"));
            return;
        }
        if (form.giftListId.value == '' || form.wishListHasItem.value == "false" || form.giftListId.value == '-1') {
            MessageHelper.displayErrorMessage(Utils.getLocalizationMessage("WISHLIST_EMPTY"));
            return;
        }
        if (!MultipleWishLists.validateSenderName(form.sender_name.value)) {
            // show error message saying that
            form.sender_name.value = ''
            MessageHelper.displayErrorMessage(Utils.getLocalizationMessage("WISHLIST_INVALIDSENDERNAME"));
            return;
        }

        // maps email input to param required by AjaxGiftListAnnouncement
        form.recipientEmail.value = form.recipient.value;
        form.recipient.value = "";
        form.senderName.value = form.sender_name.value;
        if (form.sender_email.value != '') {
            form.senderEmail.value = form.sender_email.value;
        }
        if (form.wishlist_message.value != '') {
            form.message.value = form.wishlist_message.value;
        }

        /* Handles multiple clicks */
        if (!submitRequest()) {
            return;
        }

        cursor_wait();
        wcService.getServiceById("AjaxGiftListAnnouncement").setFormId(formId);
        wcService.invoke("AjaxGiftListAnnouncement");


        // reset values
        form.senderEmail.value = "SOAWishListEmail@SOAWishListEmail.com";
        form.message.value = "SOAWishListEmail";
    }

    /**
     * set a specified wish list as default wish list	 
     *	@param {long} giftListId ID of the wish list to be set as default
     */
    ,
    setAsDefault: function (giftListId) {

        if (giftListId != '-1') {
            var params = {};
            params["storeId"] = this.storeId;
            params["catalogId"] = this.catalogId;
            params["langId"] = this.langId;
            params["giftListId"] = giftListId;
            params["giftListState"] = 'Default';
            cursor_wait();
            wcService.invoke('AjaxGiftListServiceChangeGiftListStatus', params);
        } else {
            MultipleWishLists.setDefaultListId('-1');
            MultipleWishLists.updateContextPostSwitch('-1');
        }
    }

    /**
     *return true if a string is undefined or null
     *@param {string} String to be checked
     */
    ,
    empty: function (str) {
        return (str == null || str == undefined || str == "");
    }

    /**
     * sets the default wish list Id
     * @param {String} id the default wish list id
     */
    ,
    setDefaultListId: function (id) {
        this.defaultListId = id;
    }

    /**
     * returns the default wish list Id
     */
    ,
    getDefaultListId: function () {
        return this.defaultListId;
    }

    /**
     * sets the preferred default wish list name
     * @param {String} name default wish list name
     */
    ,
    setPreferredDefaultWishListName: function (name) {
        this.preferredDefaultWishListName = name;
    }

    /**
     * Sets the wish list prefix. It's the text displayed before the wish list name.
     * @param {String} prefix wish list prefix
     */
    ,
    setWishListPrefix: function (prefix) {
        this.wishListPrefix = prefix;
    }

   
    /**
     * validate the sender name
     */
    ,
    validateSenderName: function (senderName) {
            var invalidChars = "~!@#$%^&*()+=[]{};:,<>?/|`"; // invalid chars
            invalidChars += "\t\'\"\\\/"; // escape sequences

            // look for presence of invalid characters.  if one is
            // found return false.  otherwise return true
            for (var i = 0; i < senderName.length; i++) {
                if (invalidChars.indexOf(senderName.substring(i, i + 1)) >= 0) {
                    return false;
                }
            }
            return true;
        }
        /**
         * validate the email string (which can be a comma separated list)
         */
        ,
    validateWishListEmailString: function (emailString) {
        var allEmailsAreGood = true;
        var emails = emailString.split(",");
        // validate each email
        for (var i = 0; i < emails.length; i++) {
            if (!MessageHelper.isValidEmail(emails[i])) {
                allEmailsAreGood = false;
            }
        }
        return allEmailsAreGood;
    }
}
//-----------------------------------------------------------------
// Licensed Materials - Property of IBM
//
// WebSphere Commerce
//
// (C) Copyright IBM Corp. 2009 All Rights Reserved.
//
// US Government Users Restricted Rights - Use, duplication or
// disclosure restricted by GSA ADP Schedule Contract with
// IBM Corp.
//-----------------------------------------------------------------

/** 
 * @fileOverview This file provides the controller variables and functions for My Account pages, 
 * and links these controllers to listen to the defined render contexts in CommonContextsDeclarations.js.
 */

/** 
 * @class The MyAccountControllersDeclarationJS class defines the common variables and functions that control 
 * the defined render contexts on the My Account store pages. Controller provides the JavaScript logic 
 * that listens to changes in the render context and the model. A defined render context is a set of 
 * client-side context information which keeps track of information about a page. The context information 
 * helps decide if changes to refresh areas are needed. 
 */
MyAccountControllersDeclarationJS = {
        declareProcessedOrdersStatusDisplayRefreshArea: function() {
            // ============================================
            // div: ProcessedOrdersStatusDisplay refresh area
            // Declares a new refresh controller for the processed orders status display.
            var myWidgetObj = $("#ProcessedOrdersStatusDisplay");
            var myRCProperties = wcRenderContext.getRenderContextProperties("ProcessedOrdersStatusDisplay_Context");
            
            /** 
             * Displays the previous/next page of order items on the processed order status page.
             * This function is called when a render context changed event is detected. 
             */
            var renderContextChangedHandler = function() {
                if (wcRenderContext.testForChangedRC("ProcessedOrdersStatusDisplay_Context", ["beginIndex"])) {
                    myWidgetObj.refreshWidget("refresh", myRCProperties);
                }
            };
            
            /** 
             * Clears the progress bar
             */
            var postRefreshHandler = function() {
                 cursor_clear();
            };
            
            // initialize widget
            myWidgetObj.refreshWidget({renderContextChangedHandler: renderContextChangedHandler, postRefreshHandler: postRefreshHandler});
        },
        
        declareWaitingForApprovalOrdersStatusDisplayRefreshArea: function() {
            // ============================================
            // div: WaitingForApprovalOrdersStatusDisplay refresh area
            // Declares a new refresh controller for the waiting-for-approval orders status display.
            var myWidgetObj = $("#WaitingForApprovalOrdersStatusDisplay");
            var myRCProperties = wcRenderContext.getRenderContextProperties("WaitingForApprovalOrdersStatusDisplay_Context");
            
            /** 
             * Displays the previous/next page of order items in the order status page.
             * This function is called when a render context changed event is detected. 
             */
            var renderContextChangedHandler = function() {
                if(wcRenderContext.testForChangedRC("WaitingForApprovalOrdersStatusDisplay_Context", ["beginIndex"])){
                    myWidgetObj.refreshWidget("refresh", myRCProperties);
                }
            }
            
            /** 
             * Clears the progress bar
             */
            var postRefreshHandler = function() {
                 cursor_clear();
            }
            
            // initialize widget
            myWidgetObj.refreshWidget({renderContextChangedHandler: renderContextChangedHandler, postRefreshHandler: postRefreshHandler});
        }
        
}



//-----------------------------------------------------------------
// Licensed Materials - Property of IBM
//
// WebSphere Commerce
//
// (C) Copyright IBM Corp. 2007, 2016 All Rights Reserved.
//
// US Government Users Restricted Rights - Use, duplication or
// disclosure restricted by GSA ADP Schedule Contract with
// IBM Corp.
//-----------------------------------------------------------------

/**
 * @fileOverview This javascript is used by jsp's related to 'Personal Information','My Orders' and 'My Coupons'.
 * @version 1.0
 */

/**
 * The functions defined in this class are used for enabling 'My Account' related customer operations.
 *
 * @class This MyAccountDisplay class defines all the variables and functions for 'My Account' page history tracking.
 *  Another function enables customers to update their current personal information.
 *  Another function enables the customer to create a new order by duplicating a previous order.Another function is
 *  used to remove a coupon from the coupon wallet.
 */
MyAccountDisplay={

    /*Flag which indicates if a context change happened. */
    contextChanged:false,

    /*Flag which indicates whether refresh is caused by browser back or forward event. */
    isHistory:false,

    /* This indicates the current link highlighted in the leftSideBar. */
    currentSelection:"",

    /**
     * This variable stores the identifier of the tab currently being displayed.
     * The default value is "PreviouslyProcessed".
     */
    currentTabId: "PreviouslyProcessed",

    /**
     * This variable keeps track of whether the preferred language is updated
     */
    isPreferredLanguageUpdated: false,

    /**
     * This variable stores the current dropdown dialog element.
     * @private
     */
    dropDownDlg: null,

    /**
     * This variable stores the identifier of the tab currently being displayed in the recurring order details page.
     * The default value is "recurring_order_details".
     */
    currentOrderTabId: "recurring_order_details",

    /**
     * This variable stores the expiry date of a subscription. For renewal, the start date is expiry date plus one day.
     */
    subscriptionDate: "",

    /**
     * This variable stores the orderId for subscription renewal
     */
    subscriptionOrderId: "",

    /**
     * This variable stores the orderItemId for subscription renewal
     */
    subscriptionOrderItemId: "",

    /**
     * set the isPreferredLanguageUpdated variable
     * @param {boolean} value either true or false. True if preferred language is updated. False otherwise.
     */
    setPreferredLanguageUpdated: function (value) {
        this.isPreferredLanguageUpdated = value;
    },

    /**
     * return a boolean value which indicates whether preferred lanaguage is changed.
     */
    getPreferredLanguageUpdated: function () {
        return this.isPreferredLanguageUpdated;
    },

    /**
     * set the subscriptionDate variable
     * @param {string} The expiry date of the subscription to be renewed.
     */
    setSubscriptionDate: function (value) {
        this.subscriptionDate = value;
    },

    /**
     * get the last order record info in render context
     * @param {Integer} The current page number.
     * @param {string} The last order external id in current page.
     * @param {string} The last order record info in render context.
     * @param {boolean} value either true or false. True if it's for next page. False otherwise.
     */
    getLastRecordInfo: function (currentPage, lastExtOrderId, lastRecordInfoInContext, nextOrNot) {
        var lastRecordArray = lastRecordInfoInContext.split(";");
        var refinedRecordInfoIncontext;

        if(!nextOrNot){
            //previous page
            if(lastRecordInfoInContext != '' && lastRecordInfoInContext != undefined){
                if(lastRecordInfoInContext.lastIndexOf(";")>-1){
                    refinedRecordInfoIncontext = lastRecordInfoInContext.substring(0, lastRecordInfoInContext.lastIndexOf(";"));
                }else{
                    refinedRecordInfoIncontext = "";
                }
            }
        }else{
            //next page
            if(currentPage==1 || currentPage==''|| currentPage == undefined){
                //first page
                if(lastExtOrderId !='' && lastExtOrderId!=undefined){
                    refinedRecordInfoIncontext = lastExtOrderId;
                }else{
                    refinedRecordInfoIncontext = " ";
                }
            }else{
                if(lastRecordInfoInContext != '' && lastRecordInfoInContext != undefined){
                    if(lastExtOrderId !='' && lastExtOrderId!=undefined){
                        refinedRecordInfoIncontext = lastRecordInfoInContext.concat(";").concat(lastExtOrderId);
                    }else{
                        refinedRecordInfoIncontext = lastRecordInfoInContext.concat(";").concat(" ");
                    }
                }
            }

        }

        return refinedRecordInfoIncontext;
    },

    /**
     * update the last order record info for current page in render context
     * @param {string} The context id.
     * @param {Integer} The begin index for next page or previous page.
     * @param {Integer} The page size.
     * @param {boolean} value either true or false. True if it's for quote. False otherwise.
     * @param {Integer} The current page number.
     * @param {string} The last order external id in current page.
     * @param {string} The last order record info in render context.
     * @param {boolean} value either true or false. True if it's for next page. False otherwise.
     * @param {integer} The record set total.
     */
    updateRenderContextForPagination:function(contextId, beginIndex, pageSize, isQuote, currentPage, lastExtOrderId, lastRecordInfoInContext, nextOrNot, recordSetTotal){
        var currentBeginIndex;
        var lastRecordInfo = this.getLastRecordInfo(currentPage, lastExtOrderId, lastRecordInfoInContext, nextOrNot);
        if(!nextOrNot){
            currentBeginIndex = parseInt(beginIndex) - parseInt(pageSize);

        }else{
            currentBeginIndex = parseInt(beginIndex) + parseInt(pageSize);
        }
        wcRenderContext.updateRenderContext(contextId,{'beginIndex':currentBeginIndex,'pageSize':pageSize,'isQuote':isQuote,'lastExternalOrderIds':lastRecordInfo,'recordSetTotal':recordSetTotal});
    },

    escapeXML: function(value) {
        //don't use jazz.util.html.escape(value). This function doesn't encode character "
        if (!value) {
            return ProcessAuthoringConstants.EMPTY;
        }
        return value.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\"/g, "&quot;").replace(/\'/g, "&#039;"); //$NON-NLS-1$ //$NON-NLS-2$  //$NON-NLS-3$ //$NON-NLS-4$ //$NON-NLS-5$
    },

    /**
     * return a string which indicates the start date of the renewed subscription. The start date is one day plus the end date of that subscription.
     */
    getSubscriptionDate: function () {
        var year = parseInt(this.subscriptionDate.substring(0,4),10);
        var month = parseInt(this.subscriptionDate.substring(5,7),10);
        var date = parseInt(this.subscriptionDate.substring(8,10),10);

        if(month == 2){
            if((year % 4 == 0) && (year % 100 != 0) && (year % 400 == 0))
            {
                if(date != 29)
                {
                    date = date + 1;
                    if(date < 10)
                        date = "0" + date;
                    month = "02";
                }
                else
                {
                    date = "01";
                    month = "03";
                }
            }
            else
            {
                if(date != 28)
                {
                    date = date + 1;
                    if(date < 10)
                        date = "0" + date;
                    month = "02";
                }
                else
                {
                    date = "01";
                    month = "03";
                }
            }
        }
        else if(month == 12){
            if(date != 31)
            {
                date = date + 1;
                if(date < 10)
                    date = "0" + date;
                month = "12";
            }
            else
            {
                date = "01";
                month = "01";
                year = year + 1;
            }
        }
        else if(month == 4 || month == 6 || month == 9 || month == 11){
            if(date != 30)
            {
                date = date + 1;
                if(date < 10)
                    date = "0" + date;
            }
            else
            {
                date = "01";
                month = month + 1;
            }
            if(month < 10)
                month = "0" + month;
        }
        else{
            if(date != 31)
            {
                date = date + 1;
                if(date < 10)
                    date = "0" + date;
            }
            else
            {
                date = "01";
                month = month + 1;
            }
            if(month < 10)
                month = "0" + month;
        }

        var start = this.subscriptionDate.indexOf("T",0);
        var end = this.subscriptionDate.indexOf("Z",start);
        var appendString= this.subscriptionDate.substring(start+1,end);
        var newDateString = year+'-'+month+'-'+date+'T'+appendString+'Z';
        return(newDateString);
    },

    /**
     * Hides the tab with the specified identifier.
     * This function unhides the 'off' tab,
     * and hides the 'on' tab by setting the style.display attribute respectively.
     *
     * @param {string} id The identifier of the HTML element representing the tab to hide.
     */
    setOff:function(id){
        document.getElementById(id+"_On").style.display = "none";
        document.getElementById(id+"_Off").style.display = "inline";
        document.getElementById(id).style.display = "none";
    },

    /**
     * Displays the tab with the specified identifier.
     * This function unhides the 'on' tab,
     * and hides the 'off' tab by setting the style.display attribute respectively.
     *
     * @param {string} id The identifier of the HTML element representing the tab to display.
     */
    setOn:function(id){
        document.getElementById(id+"_On").style.display = "inline";
        document.getElementById(id+"_Off").style.display = "none";
        document.getElementById(id).style.display = "block";
    },

    /**
     * Switches a tab selection to the tab specified by 'tabId' parameter.
     * Turns off the currently selected tab and hides it's content.
     * Also, this function turns on the tab indicated by the 'tabId' and displays it's contents.
     *
     * @param {string} tabId The HTML element identifier to turn 'on'.
     */
    selectTab:function(tabId){
        this.currentSelection='trackOrderStatus';
        this.setOff(this.currentTabId);
        this.setOn(tabId);
        this.currentTabId = tabId;
    },


    /**
     * This function sets the url for ordercopy service and then it invokes the service to copy the old order.
     * @param {string} OrderCopyURL The url for the order copy service.
     */
    prepareOrderCopy:function(OrderCopyURL){

        /*For Handling multiple clicks. */
        if(!submitRequest()){
            return;
        }
        cursor_wait();
        wcService.getServiceById("OrderCopy").setUrl(OrderCopyURL);
        wcService.invoke("OrderCopy");
    },

    /**
     * This function sets the url for ssfs order copy service and then it invokes the service to copy the old order.
     * @param {string} SSFSOrderCopyUrl The url for the ssfs order copy service.
     */
    prepareSSFSOrderCopy:function(SSFSOrderCopyUrl){

        /*For Handling multiple clicks. */
        if(!submitRequest()){
            return;
        }
        cursor_wait();
        wcService.getServiceById("SSFSOrderCopy").setUrl(SSFSOrderCopyUrl);
        wcService.invoke("SSFSOrderCopy");
    },

    /**
     * This function sets the url for subscriptionrenew service and then it invokes the service to renew the subscription.
     * @param {string} SubscriptionCopyURL The url for the subscription copy service.
     */
    prepareSubscriptionRenew:function(SubscriptionCopyURL){

        /*For Handling multiple clicks. */
        if(!submitRequest()){
            return;
        }
        cursor_wait();
        wcService.getServiceById("SubscriptionRenew").url = SubscriptionCopyURL;
        wcService.invoke("SubscriptionRenew");
    },


    /**
     * This function sets the parameters for the AjaxScheduledOrderCancel service and invokes the service to cancel the order.
     * @param {Integer} orderId The Id of the order to cancel.
     */
    cancelScheduledOrder:function(orderId){

        /*For Handling multiple clicks. */
        if(!submitRequest()){
            return;
        }
        cursor_wait();
        var params = [];
        params["orderId"] = orderId;
        params["URL"] = "";
        params["storeId"] = MyAccountServicesDeclarationJS.storeId;
        params["catalogId"] = MyAccountServicesDeclarationJS.catalogId;
        params["langId"] = MyAccountServicesDeclarationJS.langId;
        wcService.invoke("AjaxScheduledOrderCancel", params);
    },

    /**
     *  This function will highlight the selection in MyAccount left sidebar. When the user clicks on any of the links in left sidebar,
     *  the link is made bold indicating that it is selected.
     *  @param {string} url This is the url of the link that is selected in the left sidebar.
     */
    changeSelection: function(url){
        var start = url.indexOf("currentSelection",0);
        if(start != '-1'){
            var end = url.indexOf("Slct",start);
            var id= url.substring(start+17,end);
        }
        /*The previously highlighted link is deselected. */
        if(this.currentSelection){
            document.getElementById(this.currentSelection).setAttribute("class","");
            document.getElementById(this.currentSelection).setAttribute("className","");/*For IE */
        }
        document.getElementById('MyAccountBreadcrumbLink').style.display = "none";
        if(document.getElementById("RecurringOrderBreadcrumb")){
            document.getElementById("RecurringOrderBreadcrumb").style.display = "none";
            document.getElementById("RecurringOrderBreadcrumb1").style.display = "none";
        }
        if(document.getElementById("SubscriptionBreadcrumb")){
            document.getElementById("SubscriptionBreadcrumb").style.display = "none";
            document.getElementById("SubscriptionBreadcrumb1").style.display = "none";
        }
        if(document.getElementById("OrderHistoryBreadcrumb")){
            document.getElementById("OrderHistoryBreadcrumb").style.display = "none";
            document.getElementById("OrderHistoryBreadcrumb1").style.display = "none";
        }
        if(id){
            if(id == "trackOrderStatus"){
                document.getElementById("OrderHistoryBreadcrumb1").style.display = "inline";
            }
            else if(id == "OrderDetail"){
                document.getElementById("OrderHistoryBreadcrumb").style.display = "inline";
                var start1 = url.indexOf("breadCrumb",0);
                if(start1 != '-1'){
                    var end1 = url.indexOf("Brcmb", start1);
                    var id1 = url.substring(start1+11, end1);
                }
                id1 = id1.replace(/%[0-9]*B/g," ");
                document.getElementById("OrderHistoryDetailBreadcrumbLink").innerHTML = id1.replace(/\+/g, " ");
            }
            else if(id == "trackRecurringOrderStatus"){
                document.getElementById("RecurringOrderBreadcrumb1").style.display = "inline";
            }
            else if(id == "RecurringOrderDetail"){
                document.getElementById("RecurringOrderBreadcrumb").style.display = "inline";
                var start1 = url.indexOf("breadCrumb",0);
                if(start1 != '-1'){
                    var end1 = url.indexOf("Brcmb", start1);
                    var id1 = url.substring(start1+11, end1);
                }
                id1 = id1.replace(/%[0-9]*B/g," ");
                document.getElementById("RecurringOrderDetailBreadcrumbLink").innerHTML = id1.replace(/\+/g, " ");
            }
            else if(id == "trackSubscriptionStatus"){
                document.getElementById("SubscriptionBreadcrumb1").style.display = "inline";
            }
            else if(id == "SubscriptionDetail"){
                document.getElementById("SubscriptionBreadcrumb").style.display = "inline";
                var start1 = url.indexOf("breadCrumb",0);
                if(start1 != '-1'){
                    var end1 = url.indexOf("Brcmb", start1);
                    var id1 = url.substring(start1+11, end1);
                }
                id1 = id1.replace(/%[0-9]*B/g," ");
                document.getElementById("SubscriptionDetailBreadcrumbLink").innerHTML = id1.replace(/\+/g, " ");
            }
            /* The newly selected link is highlighted. */
            else if(document.getElementById(id)){
                document.getElementById('MyAccountBreadcrumbLink').style.display = "inline";
                document.getElementById(id).setAttribute("class","strong");
                document.getElementById(id).setAttribute("className","strong");/* For IE */
                this.currentSelection = id;
            }
        }
        else{
            document.getElementById('MyAccountBreadcrumbLink').style.display = "inline";
        }
    },

    /**
     * This function enables customers to update their current personal information. The user can also
     * update their password through this function.
     * @param {string} form The name of the form containing personal information of the customer.
     * @param {string} logonPassword The value of the 'password' field.
     * @param {string} logonPasswordVerify The value of the 'verify password' field.
     */
    prepareSubmit:function(form,logonPassword,logonPasswordVerify){

        /** Uses the common validation function defined in AddressHelper class for validating first name,
         *  last name, street address, city, country/region, state/province, ZIP/postal code, e-mail address and phone number.
         */

        if(!AddressHelper.validateAddressForm(form)){
            return;
        }

        /* Checks whether the customer has registered for promotional e-mails. */
        if(form.sendMeEmail && form.sendMeEmail.checked){
            form.receiveEmail.value = true;
        }
        else {
            form.receiveEmail.value = false;
        }

        if(form.sendMeSMSNotification && form.sendMeSMSNotification.checked){
            form.receiveSMSNotification.value = true;
        }
        else {
            form.receiveSMSNotification.value = false;
        }

        if(form.sendMeSMSPreference && form.sendMeSMSPreference.checked){
            form.receiveSMS.value = true;
        }
        else {
            form.receiveSMS.value = false;
        }

        if(form.mobileDeviceEnabled != null && form.mobileDeviceEnabled.value == "true"){
            if(!this.validateMobileDevice(form)){
                return;
            }
        }
        if(form.birthdayEnabled != null && form.birthdayEnabled.value == "true"){
            if(!this.validateBirthday(form)){
                return;
            }
        }

        /* For Handling multiple clicks. */
        if(!submitRequest()){
            return;
        }

        processAndSubmitForm(form);
        if(CSRWCParamJS.env_shopOnBehalfSessionEstablished != "true"){
            // Update shopperName only if they are updating it for themself.
            // If CSR is updating onBehalf of shopper, then no need to update the logonUserId.
            // LogonUserId will be of CSR in that case and it doesn't match with shopper name read from personal information form.
            var shopperName = getCookie("WC_LogonUserId_"+WCParamJS.storeId);
            if (trim(shopperName) != (form.firstName.value + " " + form.lastName.value)){
                setCookie("WC_LogonUserId_"+WCParamJS.storeId, form.firstName.value + " " + form.lastName.value , {path:'/', domain:cookieDomain});
            }
        }
    },

    /**
     *  This function opens up the passed in url in a new browser window.
     *  @param {string} URL The url to be invoked from the new window.
     */
    popupWindow:function(URL) {

        window.open(URL, "mywindow", "status=1,scrollbars=1,resizable=1");
    },

   /**
    * This function removes a coupon. If a customer has a that has not been applied to an order
    * then this function can be used to remove that coupon from the customer's coupon wallet.
    * @param {string} formName The name of the form that contains the table which holds the coupon to be deleted.
    * @param {string} returnView The view to return to after the request has been processed.
    * @param {string} couponId The unique ID of the coupon. This is set in the form to be sent to the service.
    */

    deleteCoupon:function(formName,couponId)
    {

        var form = document.forms[formName];

        form.couponId.value = couponId;
        form.taskType.value= "D";

        /* For Handling multiple clicks. */
        if(!submitRequest()){
             return;
        }
        var service = wcService.getServiceById('AjaxRESTWalletCouponsDelete');
        service.setFormId(formName);
        //CommonContextsJS.setContextProperty("CouponDisplay_Context","returnView",returnView);
        cursor_wait();
        wcService.invoke('AjaxRESTWalletCouponsDelete');
    },

    /**
     * This function cancels a recurring order.
     * @param {String} subscriptionId The unique ID of the subscription to cancel.
     * @param {int} popupIndex the index of the action drop down
     */
    cancelRecurringOrder:function(subscriptionId, popupIndex){

        /*For Handling multiple clicks. */
        if(!submitRequest()){
            return;
        }
        cursor_wait();
        // Destroy the action drop down associated with this recurring order/subscription
        $("[data-widget-type='wc.WCDialog'][data-popupIndex='" + popupIndex + "']").data("wc-WCDialog").destroy();

        var params = {
            subscriptionId: subscriptionId,
            URL: "",
            storeId: MyAccountServicesDeclarationJS.storeId,
            catalogId: MyAccountServicesDeclarationJS.catalogId,
            langId: MyAccountServicesDeclarationJS.langId
        };
        wcService.invoke("AjaxCancelSubscription", params);
    },

    /**
     * Updates the list of contracts that are available to the current user.
     * @param {string} formName  The name of the form that contains the table of selected contracts.
      * @param {string} currentContracts  The IDs of the active contracts that are in the current trading agreement.
      * @param {string} errorMessage  An error message ID which displays the error message thrown by the server
      * and is to be displayed if the optional parameter is passed in.
     */
    updateContract:function(formName, currentContracts, errorMessage){
        var form = document.forms[formName];
        var selected = false;

        /* For Handling multiple clicks. */
        if(!submitRequest()){ return; }

        if(form.contractId.length != undefined){
            for(var i = 0; i < form.contractId.length; i++){
                if(form.contractId[i].checked){
                    selected = true;
                    break;
                }
            }
            if(!selected){
                var current = currentContracts.split(";");
                for(var t = 0; t < current.length; t++){
                    document.getElementById("WC_B2BMyAccountParticipantRole_checkbox_"+current[t]).checked = true;
                }
                MessageHelper.displayErrorMessage(errorMessage);
                resetRequest();
            }
        }else if(form.contractId.checked){
            selected = true;
        }else{
            document.getElementById("WC_B2BMyAccountParticipantRole_checkbox_"+form.contractId.value).checked = true;
            MessageHelper.displayErrorMessage(errorMessage);
            resetRequest();
        }

        if(selected){
            processAndSubmitForm(form);
        }
    },

    /**
     * Changes the organization that is used by the current user.
     * @param {string} formName  The name of the form that contains the table with the selected organization.
     */
    updateOrganization:function(formName){
        var form = document.forms[formName];
        /* For Handling multiple clicks. */
        if(!submitRequest()){ return; }
        processAndSubmitForm(form);
    },

    /**
     * This function forms history state object for history tracking.
     * @param {string} workAreaModeValue A value to uniquely identify a context, which is among the following:
     * myAccountMain, personalInformation, addressBook, checkoutProfile, wishList,trackOrderStatus, mycoupons ,bookmarkedPage
     * @param {string} elementId The id of the widget.
     * @param {string} changeUrl url to update the context of the refresh area.
     */
    HistoryTracker:function(workAreaModeValue, elementId, changeUrl){

        this.workAreaModeValue = workAreaModeValue;
        this.elementId = elementId;
        this.changeUrl =  changeUrl;

    },

    /**
     * This function validates the customer's input for birthday, i.e. whether the year/month/date combination is correct.
     * @param {string} form The name of the form containing personal information of the customer.
     *
     * @return {boolean} This indicates whether the birthday entered is valid or not.
     */

    validateBirthday: function(form){
        if(form.birth_year != null && form.birth_month != null && form.birth_date != null){
            if(form.birth_year.value != 0 || form.birth_month.value != 0 || form.birth_date.value != 0){
                /* if any of the year/month/date fields contains non-empty inforamtion, validate. */
                if(form.birth_month.value == 0){
                    MessageHelper.formErrorHandleClient(form.birth_month.id + "-button", MessageHelper.messages["ERROR_SpecifyMonth"]);
                    return false;
                }
                if(form.birth_date.value == 0){
                    MessageHelper.formErrorHandleClient(form.birth_date.id + "-button", MessageHelper.messages["ERROR_SpecifyDate"]);
                    return false;
                }

                /* set the number of days in Feburary for validation. */
                var febDays = 29;
                if(form.birth_year.value != 0 && ((form.birth_year.value % 4) != 0)){
                    febDays = 28;
                }

                var months = ["4","6","9","11"]; /* these months only have 30 days in total. */
                var monthFound = false;
                for(var i=0; i<months.length; i++){
                    if(months[i] == form.birth_month.value){
                        monthFound = true;
                        break;
                    }
                }
                if(monthFound && (form.birth_date.value > 30)){
                    /* if month entered is April/June/Sept/Nov, check if the date is larger than 30 */
                    MessageHelper.formErrorHandleClient(form.birth_date.id + "-button", MessageHelper.messages["ERROR_InvalidDate1"]);
                    return false;
                }

                if((form.birth_month.value == 2) && (form.birth_date.value > febDays)){
                    /* in the case if the month entered is Feburary, validate the date against febDays. */
                    MessageHelper.formErrorHandleClient(form.birth_date.id + "-button", MessageHelper.messages["ERROR_InvalidDate1"]);
                    return false;
                }
                if(form.curr_year != null && form.curr_month != null && form.curr_date != null){
                    var birth_year = parseInt(form.birth_year.value);
                    var birth_month = parseInt(form.birth_month.value);
                    var birth_date = parseInt(form.birth_date.value);

                    var curr_year = parseInt(form.curr_year.value);
                    var curr_month = parseInt(form.curr_month.value);
                    var curr_date = parseInt(form.curr_date.value);

                    if(birth_year > curr_year){
                        /* if birth year entered is in the future. */
                        MessageHelper.formErrorHandleClient(form.birth_year.id + "-button", MessageHelper.messages["ERROR_InvalidDate2"]);
                        return false;
                    }else if((birth_year == curr_year) && (birth_month > curr_month)){
                        /* if birth year entered is the same as the current year, then check the month entered. */
                        MessageHelper.formErrorHandleClient(form.birth_month.id + "-button", MessageHelper.messages["ERROR_InvalidDate2"]);
                        return false;
                    }else if((birth_year == curr_year) && (birth_month == curr_month) && (birth_date > curr_date)){
                        /* if birth year and month entered are the same as the current year and month, then check the date entered. */
                        MessageHelper.formErrorHandleClient(form.birth_date.id + "-button", MessageHelper.messages["ERROR_InvalidDate2"]);
                        return false;
                    }else{
                        /* the date of birth provided is valid, now verify if the user is under age. */
                        if(form.dateOfBirthTemp != null){
                            if(form.birth_month.value != 0 && form.birth_date.value != 0){
                                var final_birth_year = birth_year;
                                var final_birth_month = birth_month;
                                var final_birth_date = birth_date;
                                if(birth_year == 0){
                                    /* If the user does not specify the year in his/her date of birth, set the year to 1896. */
                                    final_birth_year = 1896;
                                }
                                if(birth_month < 10){
                                    final_birth_month = '0' + birth_month;
                                }
                                if(birth_date < 10){
                                    final_birth_date = '0' + birth_date;
                                }
                                form.dateOfBirthTemp.value = final_birth_year + '-' + final_birth_month + '-' + final_birth_date;
                                document.getElementById(form.dateOfBirthTemp.id).name = 'dateOfBirth';
                            }else{
                                form.dateOfBirthTemp.value = null;
                            }
                        }
                    }
                }
                return true;
            }else{
                if(form.dateOfBirthTemp != null){
                    form.dateOfBirthTemp.value = "";
                    if(document.getElementById(form.dateOfBirthTemp.id) != null){
                        document.getElementById(form.dateOfBirthTemp.id).name = 'dateOfBirth';
                    }
                }
                return true;
            }
        }
        return true;
    },

    /**
     *  This function validates the Mobile phone number provided by the customer.
     *  The Mobile Phone number option is not a required input by default, but if the customer has entered something,
     *  this method will be called to validate the mobile phone information entered by the customer.
     *  @param {string} form The name of the registration form containing the customer's mobile phone number.
     *  @return {boolean} returns true if the mobile number entered is valid, else returns false.
     */

    validateMobileDevice: function(form){
        if(form.mobilePhone1 != null && form.mobilePhone1!="" ){
            if(!MessageHelper.isValidUTF8length(form.mobilePhone1.value, 32)){
                MessageHelper.formErrorHandleClient(form.mobilePhone1.id, MessageHelper.messages["ERROR_PhoneTooLong"]);
                return false;
            }

            if(!MessageHelper.IsValidPhone(form.mobilePhone1.value)){
                MessageHelper.formErrorHandleClient(form.mobilePhone1.id, MessageHelper.messages["ERROR_INVALIDPHONE"]);
                return false;
            }
        }
        return true;
    },

    /**
     * Displays the actions list drop down panel.
     * @param {object} event The event to retrieve the input keyboard key.
     * @param {string} dialogId The id of the content pane containing the action popup details
     */
    showActionsPopup: function(event, dialogId){
        if(event == null || event.keyCode == KeyCodes.DOWN_ARROW){
            var dialog = $("#" + dialogId).data("wc-WCDialog");
            if(dialog) {
                this.dropDownDlg = dialog;
                this.dropDownDlg.open();
            }
        }

    },

    /**
     *This function displays the Recurring Order / Subscription action popup.
     *@param {String} action This variable can be either reccuring_order or subscription.
     *@param {String} subscriptionId This variable gives the subscription id to be canceled.
     *@param {String} popupIndex the index of the action popup (required to close it later)
     *@param {String} message This variable gives the message regarding cancel notice period.
     */
    showPopup:function(action, subscriptionId, popupIndex, message){
        var popup = $("#Cancel_"+action+"_popup").data("wc-WCDialog");
        if (popup !=null) {
            closeAllDialogs(); //close other dialogs(quickinfo dialog, etc) before opening this.
            popup.element.attr("data-popupIndex", popupIndex);
            popup.open();
            document.getElementById("Cancel_yes_"+action).setAttribute("onclick", "MyAccountDisplay.cancelRecurringOrder("+ subscriptionId + "," + popupIndex + ");");

            if(document.getElementById("cancel_notice_"+action) && document.getElementById(message)){
                $("#cancel_notice_"+action).html($("#" + message).val());
            }
        }else {
            console.debug("Cancel_subscription_popup"+" does not exist");
        }
    },

    /**
     * Switches a tab selection to the tab specified by 'tabId' parameter.
     * Turns off the currently selected tab and hides it's content.
     * Also, this function turns on the tab indicated by the 'tabId' and displays it's contents.
     *
     * @param {string} tabId The HTML element identifier to turn 'on'.
     */
    selectRecurringOrderTab:function(tabId){

        this.setOff(this.currentOrderTabId);
        this.setOn(tabId);
        this.currentOrderTabId = tabId;
    }
}
//-----------------------------------------------------------------
// Licensed Materials - Property of IBM
//
// WebSphere Commerce
//
// (C) Copyright IBM Corp. 2008, 2015 All Rights Reserved.
//
// US Government Users Restricted Rights - Use, duplication or
// disclosure restricted by GSA ADP Schedule Contract with
// IBM Corp.
//-----------------------------------------------------------------

/**
 * @fileOverview This javascript contains declarations of AJAX services used within
 * WebSphere Commerce.
 */

/**
 * @class This class stores common parameters needed to make the service call.
 */
MyAccountServicesDeclarationJS = {
	/* The common parameters used in service calls */
	langId: "-1",
	storeId: "",
	catalogId: "",
	/**
	 * This function initializes common parameters used in all service calls.
	 * @param {int} langId The language id to use.
	 * @param {int} storeId The store id to use.
	 * @param {int} catalogId The catalog id to use.
	 */

	setCommonParameters:function(langId,storeId,catalogId){
			this.langId = langId;
			this.storeId = storeId;
			this.catalogId = catalogId;
	}
}

	/**
	 *  Removes an item from the customer wishlist in Ajax mode.
	 *  @constructor
	 */
	wcService.declare({
		id: "InterestItemDelete",
		actionId: "InterestItemDelete",
		url: "AjaxInterestItemDelete",
		formId: ""

	/**
	 * display a success message.
	 * @param (object) serviceResponse The service response object, which is the
	 * JSON object returned by the service invocation.
	 */
		,successHandler: function(serviceResponse) {
			MessageHelper.displayStatusMessage(MessageHelper.messages["WISHLIST_REMOVEITEM"]);
			for (var prop in serviceResponse) {
				console.debug(prop + "=" + serviceResponse[prop]);
			}
			cursor_clear();
		}
	/**
	 * display an error message.
	 * @param (object) serviceResponse The service response object, which is the
	 * JSON object returned by the service invocation.
	 */
		,failureHandler: function(serviceResponse) {
			if (serviceResponse.errorMessage) {
				MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
			}
			else {
				 if (serviceResponse.errorMessageKey) {
					MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
				 }
			}
			cursor_clear();
		}

	}),

	/**
	 *  Adds an item to the customer wishlist in Ajax mode.
	 *  @constructor
	 */
	wcService.declare({
		id: "AjaxInterestItemAdd",
		actionId: "AjaxInterestItemAdd",
		url: "AjaxInterestItemAdd",
		formId: ""
	/**
	 * display a success message.
	 * @param (object) serviceResponse The service response object, which is the
	 * JSON object returned by the service invocation.
	 */
		,successHandler: function(serviceResponse) {
			MessageHelper.hideAndClearMessage();
			cursor_clear();
			MessageHelper.displayStatusMessage(MessageHelper.messages["WISHLIST_ADDED"]);
		}
	/**
	 * display an error message.
	 * @param (object) serviceResponse The service response object, which is the
	 * JSON object returned by the service invocation.
	 */
		,failureHandler: function(serviceResponse) {

			if (serviceResponse.errorMessage) {
				MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
			}
			else {
				 if (serviceResponse.errorMessageKey) {
					MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
				 }
			}
			cursor_clear();
		}

	}),

	/**
	 *  This service enables the customer to email his/her wishlist.
	 *  @constructor
	 */
	wcService.declare({
		id: "InterestItemListMessage",
		actionId: "InterestItemListMessage",
		url: "AjaxInterestItemListMessage",
		formId: ""

	/**
	 * hdes the progress bar and displays a success message.
	 * @param (object) serviceResponse The service response object, which is the
	 * JSON object returned by the service invocation.
	 */
		,successHandler: function(serviceResponse) {
			for (var prop in serviceResponse) {
				console.debug(prop + "=" + serviceResponse[prop]);
			}
			cursor_clear();
		}
	/**
	 * display an error message.
	 * @param (object) serviceResponse The service response object, which is the
	 * JSON object returned by the service invocation.
	 */
		,failureHandler: function(serviceResponse) {
			if (serviceResponse.errorMessage) {
				MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
			}
			else {
				 if (serviceResponse.errorMessageKey) {
					MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
				 }
			}
			cursor_clear();
		}

	}),

	/**
	 * This service adds a billing address to the order(s).
	 * @constructor
	 */
	wcService.declare({
		id: "AddBillingAddress",
		actionId: "AddBillingAddress",
		url: "AjaxPersonChangeServiceAddressAdd",
		formId: ""

	 /**
	  *	 calls the saveAddress function defined in the AddressHelper class.
	  *  @param (object) serviceResponse The service response object, which is the
	  *  JSON object returned by the service invocation.
	  */
		,successHandler: function(serviceResponse) {
			resetRequest();
			javascript:AddressHelper.saveAddress('AddShippingAddress','shippingAddressCreateEditFormDiv_1');
		}

	/**
	 * display an error message.
	 * @param (object) serviceResponse The service response object, which is the
	 * JSON object returned by the service invocation.
	 */
		,failureHandler: function(serviceResponse) {
			if (serviceResponse.errorMessage) {
						 MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
				  } else {
						 if (serviceResponse.errorMessageKey) {
								MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
						 }
				  }
		}

	}),

	/**
	 *  This service adds a shipping address to the order(s).
	 *  @constructor
	 */
	wcService.declare({
		id: "AddShippingAddress",
		actionId: "AddShippingAddress",
		url: "AjaxPersonChangeServiceAddressAdd",
		formId: ""

	/**
	 *  redirects to the Shipping and Billing Method page.
	 * @param (object) serviceResponse The service response object, which is the
	 * JSON object returned by the service invocation.
	 */
		,successHandler: function(serviceResponse) {
			//document.location.href=appendWcCommonRequestParameters("OrderShippingBillingView?langId="+MyAccountServicesDeclarationJS.langId+"&storeId="+MyAccountServicesDeclarationJS.storeId+"&catalogId="+MyAccountServicesDeclarationJS.catalogId+"&shipmentType=single&orderPrepare=true");
			CheckoutHelperJS.updateAddressIdForOrderItem(serviceResponse.addressId);
		}

	/**
	 * display an error message.
	 * @param (object) serviceResponse The service response object, which is the
	 * JSON object returned by the service invocation.
	 */
		,failureHandler: function(serviceResponse) {
			if (serviceResponse.errorMessage) {
						 MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
				  } else {
						 if (serviceResponse.errorMessageKey) {
								MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
						 }
				  }
		}

	}),

  /**
   * This services adds or removes a coupon from the order(s).
   * @constructor
   */
	wcService.declare({
		id: "AjaxCouponsAddRemove",
		actionId: "AjaxCouponsAddRemove",
		url: "AjaxCouponsAddRemove",
		formId: ""

   /**
	 * Hides all the messages and the progress bar.
	 * @param (object) serviceResponse The service response object, which is the
	 * JSON object returned by the service invocation.
	 */
		,successHandler: function(serviceResponse) {
			MessageHelper.hideAndClearMessage();
			cursor_clear();
		}

	/**
	 * display an error message.
	 * @param (object) serviceResponse The service response object, which is the
	 * JSON object returned by the service invocation.
	 */
		,failureHandler: function(serviceResponse) {

			if (serviceResponse.errorMessage) {
				MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
			}
			else {
				 if (serviceResponse.errorMessageKey) {
					MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
				 }
			}
			cursor_clear();
		}

	}),
	

	/**
	 * This services deletes a coupon from the wallet.
	 * 
	 * @constructor
	 */
	wcService.declare({
		id : "AjaxRESTWalletCouponsDelete",
		actionId : "AjaxCouponsAddRemove",
		url : "AjaxRESTWalletCouponsDelete",
		formId : ""

		/**
		 * Hides all the messages and the progress bar.
		 * 
		 * @param (object)
		 *            serviceResponse The service response object,
		 *            which is the JSON object returned by the
		 *            service invocation.
		 */
		,
		successHandler : function(serviceResponse) {
			MessageHelper.hideAndClearMessage();
			cursor_clear();
		}

		/**
		 * display an error message.
		 * 
		 * @param (object)
		 *            serviceResponse The service response object,
		 *            which is the JSON object returned by the
		 *            service invocation.
		 */
		,
		failureHandler : function(serviceResponse) {

			if (serviceResponse.errorMessage) {
				MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
			} else {
				if (serviceResponse.errorMessageKey) {
					MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
				}
			}
			cursor_clear();
		}

	}),

	/**
	 * This service adds or removes a wallet item.
	 * @constructor
	 */
	wcService.declare({
		id: "AjaxWalletItemProcessServiceDelete",
		actionId: "AjaxWalletItemProcessServiceDelete",
		url: "AjaxWalletItemProcessServiceDelete",
		formId: ""

	/**
	 * Hides all messages and the progress bar.
	 * @param (object) serviceResponse The service response object, which is the
	 * JSON object returned by the service invocation.
	 */
	,successHandler: function(serviceResponse) {
		MessageHelper.hideAndClearMessage();
		cursor_clear();
	}

	/**
	 * Displays an error message in case of a failure.
	 * @param (object) serviceResponse The service response object, which is the
	 * JSON object returned by the service invocation.
	 */
	,failureHandler: function(serviceResponse) {
		if (serviceResponse.errorMessage) {
			MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
		} else {
			if (serviceResponse.errorMessageKey) {
				MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
			}
		}
		cursor_clear();
		}

	}),

	/**
	 * This service cancels a subscription.
	 * @constructor
	 */
	wcService.declare({
		id: "AjaxCancelSubscription",
		actionId: "AjaxCancelSubscription",
		url: "AjaxRESTRecurringOrSubscriptionCancel",
		formId: ""

		/**
		 * Clear messages on the page.
		 * @param (object) serviceResponse The service response object, which is the JSON object returned by the service invocation
		 */
		,successHandler: function(serviceResponse) {
			MessageHelper.hideAndClearMessage();
			cursor_clear();
            closeAllDialogs();
			if(serviceResponse.subscriptionType == "RecurringOrder"){
				if(serviceResponse.state == "PendingCancel"){
					MessageHelper.displayStatusMessage(MessageHelper.messages["SCHEDULE_ORDER_PENDING_CANCEL_MSG"]);
				}
				else{
					MessageHelper.displayStatusMessage(MessageHelper.messages["SCHEDULE_ORDER_CANCEL_MSG"]);
				}
			}
			else{
				if(serviceResponse.state == "PendingCancel"){
					MessageHelper.displayStatusMessage(MessageHelper.messages["SUBSCRIPTION_PENDING_CANCEL_MSG"]);
				}
				else{
					MessageHelper.displayStatusMessage(MessageHelper.messages["SUBSCRIPTION_CANCEL_MSG"]);
				}
			}
		}

		/**
		 * Displays an error message on the page if the request failed.
		 * @param (object) serviceResponse The service response object, which is the JSON object returned by the service invocation.
		 */
		,failureHandler: function(serviceResponse) {
			if (serviceResponse.errorMessage) {
				MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
			} else {
				if (serviceResponse.errorMessageKey) {
					MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
				}
			}
			cursor_clear();
		}
	}),


	/**
	 *  This service enables customer to Reorder an already existing order.
	 *  @constructor
	 */
	wcService.declare({
		id: "OrderCopy",
		actionId: "OrderCopy",
		url: "AjaxRESTOrderCopy",
		formId: ""

	 /**
	  *  Copies all the items from the existing order to the shopping cart and redirects to the shopping cart page.
	  *  @param (object) serviceResponse The service response object, which is the
	  *  JSON object returned by the service invocation.
	  */
		,successHandler: function(serviceResponse) {
			for (var prop in serviceResponse) {
				console.debug(prop + "=" + serviceResponse[prop]);
			}
			if (serviceResponse.newOrderItemsCount != null && serviceResponse.newOrderItemsCount<=0){
				MessageHelper.displayErrorMessage(MessageHelper.messages["CANNOT_REORDER_ANY_MSG"]);
			}
			else {
				setDeleteCartCookie();

				var postRefreshHandlerParameters = [];
				var initialURL = "AjaxRESTOrderPrepare";
				var urlRequestParams = [];
				urlRequestParams["orderId"] = serviceResponse.orderId;

				postRefreshHandlerParameters.push({"URL":"AjaxCheckoutDisplayView","requestType":"GET", "requestParams":{}}); 
				var service = getCustomServiceForURLChaining(initialURL,postRefreshHandlerParameters,null);
				wcService.invoke(service.getParam("id"), urlRequestParams);

			}
		}

	/**
	 * display an error message.
	 * @param (object) serviceResponse The service response object, which is the
	 * JSON object returned by the service invocation.
	 */
		,failureHandler: function(serviceResponse) {
			if (serviceResponse.errorMessageKey == "_ERR_PROD_NOT_ORDERABLE") {
				MessageHelper.displayErrorMessage(MessageHelper.messages["PRODUCT_NOT_BUYABLE"]);
			} else if (serviceResponse.errorMessageKey == "_ERR_INVALID_ADDR") {
				MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
			}else {
				if (serviceResponse.errorMessage) {
					MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
				}
				else {
					 if (serviceResponse.errorMessageKey) {
						MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
					 }
				}
			}
			cursor_clear();
		}

	}),

	/**
	 *  This service enables customer to Reorder an already existing order in external system.
	 *  @constructor
	 */
	wcService.declare({
		id: "SSFSOrderCopy",
		actionId: "SSFSOrderCopy",
		url: "AjaxSSFSOrderCopy",
		formId: ""

		 /**
		  *  Copies all the items from the existing order to the shopping cart and redirects to the shopping cart page.
		  *  @param (object) serviceResponse The service response object, which is the
		  *  JSON object returned by the service invocation.
		  */
		,successHandler: function(serviceResponse) {
			for (var prop in serviceResponse) {
				console.debug(prop + "=" + serviceResponse[prop]);
			}

			setDeleteCartCookie();
			document.location.href=appendWcCommonRequestParameters("AjaxCheckoutDisplayView?langId="+MyAccountServicesDeclarationJS.langId+"&storeId="+MyAccountServicesDeclarationJS.storeId+"&catalogId="+MyAccountServicesDeclarationJS.catalogId);
		}

		/**
		* display an error message.
		* @param (object) serviceResponse The service response object, which is the
		* JSON object returned by the service invocation.
		*/
		,failureHandler: function(serviceResponse) {
			if (serviceResponse.errorMessageKey == "_ERR_PROD_NOT_ORDERABLE") {
				MessageHelper.displayErrorMessage(MessageHelper.messages["PRODUCT_NOT_BUYABLE"]);
			} else if (serviceResponse.errorMessageKey == "_ERR_INVALID_ADDR") {
				MessageHelper.displayErrorMessage(MessageHelper.messages["INVALID_CONTRACT"]);
			}else {
				if (serviceResponse.errorMessage) {
					MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
				}
				else {
					 if (serviceResponse.errorMessageKey) {
						MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
					 }
				}
			}
			cursor_clear();
		}

	}),


	/**
	 *  This service enables customer to Renew a subscription.
	 *  @constructor
	 */
	wcService.declare({
		id: "SubscriptionRenew",
		actionId: "SubscriptionRenew",
		url: "AjaxRESTOrderCopy",
		formId: ""

	 /**
	  *  Copies all the items from the existing subscription to the shopping cart and calls service to update requested shipping date.
	  *  @param (object) serviceResponse The service response object, which is the
	  *  JSON object returned by the service invocation.
	  */
		,successHandler: function(serviceResponse) {
			for (var prop in serviceResponse) {
				console.debug(prop + "=" + serviceResponse[prop]);
			}

			var params = [];

			params.storeId		= MyAccountServicesDeclarationJS.storeId;
			params.catalogId	= MyAccountServicesDeclarationJS.catalogId;
			params.langId		= MyAccountServicesDeclarationJS.langId;
			params.orderId      = serviceResponse.orderId;
			params.calculationUsage  = "-1,-2,-3,-4,-5,-6,-7";
			params.requestedShipDate = MyAccountDisplay.getSubscriptionDate();

			MyAccountDisplay.subscriptionOrderId = serviceResponse.orderId;
			MyAccountDisplay.subscriptionOrderItemId = serviceResponse.orderItemId[0];

			wcService.invoke("SetRequestedShippingDate",params);
		}

	/**
	 * display an error message.
	 * @param (object) serviceResponse The service response object, which is the
	 * JSON object returned by the service invocation.
	 */
		,failureHandler: function(serviceResponse) {
			if (serviceResponse.errorMessageKey == "_ERR_PROD_NOT_ORDERABLE") {
				MessageHelper.displayErrorMessage(MessageHelper.messages["PRODUCT_NOT_BUYABLE"]);
			} else if (serviceResponse.errorMessageKey == "_ERR_INVALID_ADDR") {
				MessageHelper.displayErrorMessage(MessageHelper.messages["INVALID_CONTRACT"]);
			}else {
				if (serviceResponse.errorMessage) {
					MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
				}
				else {
					 if (serviceResponse.errorMessageKey) {
						MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
					 }
				}
			}
			cursor_clear();
		}

	}),


	/**
	 *  This service sets the requested shipping date for a subscription renewal.
	 *  @constructor
	 */
	wcService.declare({
		id: "SetRequestedShippingDate",
		actionId: "SetRequestedShippingDate",
		url: "AjaxRESTOrderShipInfoUpdate",
		formId: ""
	/**
	 * hides all the messages and the progress bar
	 * @param (object) serviceResponse The service response object, which is the
	 * JSON object returned by the service invocation
	 */
		,successHandler: function(serviceResponse) {
			cursor_clear();
			document.location.href=appendWcCommonRequestParameters("RESTOrderPrepare?langId="+MyAccountServicesDeclarationJS.langId+"&storeId="+MyAccountServicesDeclarationJS.storeId+"&catalogId="+MyAccountServicesDeclarationJS.catalogId+"&orderId="+serviceResponse.orderId+"&URL=AjaxCheckoutDisplayView?langId="+MyAccountServicesDeclarationJS.langId+"&storeId="+MyAccountServicesDeclarationJS.storeId+"&catalogId="+MyAccountServicesDeclarationJS.catalogId);
		}

	 /**
	 * display an error message
	 * @param (object) serviceResponse The service response object, which is the
	 * JSON object returned by the service invocation
	 */
		,failureHandler: function(serviceResponse) {
			if (serviceResponse.errorMessageKey == "_ERR_ORDER_ITEM_FUTURE_SHIP_DATE_OVER_MAXOFFSET") {
				var params = [];

				params.storeId		= MyAccountServicesDeclarationJS.storeId;
				params.catalogId	= MyAccountServicesDeclarationJS.catalogId;
				params.langId		= MyAccountServicesDeclarationJS.langId;
				params.orderId      = MyAccountDisplay.subscriptionOrderId;
				params.orderItemId      = MyAccountDisplay.subscriptionOrderItemId;
				params.calculationUsage  = "-1,-2,-3,-4,-5,-6,-7";
				wcService.invoke("RemoveSubscriptionItem",params);

				MessageHelper.displayStatusMessage(MessageHelper.messages["CANNOT_RENEW_NOW_MSG"]);
			}
			else{
				if (serviceResponse.errorMessage) {
					MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
				}
				else {
					if (serviceResponse.errorMessageKey) {
						MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
					 }
				}
				cursor_clear();
			}
		}

	}),

	/**
	 * This service removes the subscription item from the shopping cart if renewal fails.
	 * @constructor
	 */
	wcService.declare({
		id: "RemoveSubscriptionItem",
		actionId: "RemoveSubscriptionItem",
		url: "AjaxRESTOrderItemDelete",
		formId: ""

		/**
		 * @param (object) serviceResponse The service response object, which is the
		 * JSON object returned by the service invocation.
		 */
		,successHandler: function(serviceResponse) {
				cursor_clear();
		}

		 /**
		 * display an error message
		 * @param (object) serviceResponse The service response object, which is the
		 * JSON object returned by the service invocation
		 */
		,failureHandler: function(serviceResponse) {
			if (serviceResponse.errorMessage) {
				MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
			}
			else {
				 if (serviceResponse.errorMessageKey) {
					MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
				 }
			}
			if(serviceResponse.errorCode){
				wcTopic.publish("OrderError",serviceResponse);
			}
			cursor_clear();
		}

	}),

/**
 *  This service enables customer to cancel a scheduled order or an order waiting for approval.
 *  @constructor
 */
wcService.declare({
	id: "AjaxScheduledOrderCancel",
	actionId: "AjaxScheduledOrderCancel",
	url: "AjaxRESTRecurringOrSubscriptionCancel",
	formId: ""

	/**
	 * Displays a success message.
	 * @param (object) serviceResponse The service response object, which is the
	 * JSON object returned by the service invocation.
	 */
	,successHandler: function(serviceResponse) {
		MessageHelper.hideAndClearMessage();
		cursor_clear();
		MessageHelper.displayStatusMessage(MessageHelper.messages["MO_ORDER_CANCELED_MSG"]);
	}

	/**
	 * Displays an error message.
	 * @param (object) serviceResponse The service response object, which is the
	 * JSON object returned by the service invocation.
	 */
	,failureHandler: function(serviceResponse) {

		if (serviceResponse.errorMessage) {
			MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
		}
		else {
			 if (serviceResponse.errorMessageKey) {
				MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
			 }
		}
		cursor_clear();
	}
})
//-----------------------------------------------------------------
// Licensed Materials - Property of IBM
//
// WebSphere Commerce
//
// (C) Copyright IBM Corp. 2007, 2016 All Rights Reserved.
//
// US Government Users Restricted Rights - Use, duplication or
// disclosure restricted by GSA ADP Schedule Contract with
// IBM Corp.
//-----------------------------------------------------------------
//

/** 
 * @fileOverview This javascript is used by AjaxMyAccountQuickCheckoutProfileForm.jsp and MyAccountQuickCheckoutProfileForm.jsp.
 * @version 1.0
 */

/**
 * The functions defined in this class enable the customer to update an existing quickcheckout profile.
 * @class This QuickCheckoutProfile class defines all the functions and variables to manage a quickcheckout profile.
 * A quick address profile can be used to identify shipping addresses, billing addresses, or both shipping and billing addresses when completing the quick checkout process. 
 * The fields that can be entered into the quick checkout profile are first name, last name, street address, city, country/region, state/province, ZIP/postal code, 
 * phone number, e-mail address, payment method, and shipping method.
 */
QuickCheckoutProfile = {
		/* The common parameters used in service calls. */
		langId: "-1",
		storeId: "",
		catalogId: "",
		/* variable set on quickcheckout profile update which is used to display the success message. */   
		pageVar: "aa",
		/** flag to indicate whether the credit card field is updated or not. The value is automatically populated
		 *  by the jsp using the {@link valueChanged} function.
		 *
		 *  @private
		 */
		changed: "false",		
				
	/**
	 * This function initializes common parameters used in all service calls.
	 * @param {int} langId The language id to use.
	 * @param {int} storeId The store id to use.
	 * @param {int} catalogId The catalog id to use.
	 */

	setCommonParameters:function(langId,storeId,catalogId){
		this.langId = langId;
		this.storeId = storeId;
		this.catalogId = catalogId;
		
	},
    
	/**
	 * This function will declare a refreshArea controller if no controller with the same controller ID exits yet. The
	 * declared controller is designed to handle address specific tasks. If user passes a "url" parameter when updating context, it will 
     * replace the value of its own "url" parameter to the one given by the user.
	 * @param {string} controllerId The ID of the controller that is going to be declared.
	 * @param {string} defaultURL The url this controller used for getting data from server. It will be set to controller.url.
	 */
/*
	declareRefreshAreaController: function(controllerId, defaultURL){
		if(wc.render.getRefreshControllerById(controllerId)){
			console.debug("controller with id = "+controllerId+" already exists. No declaration will be done");
			return;
		}
		wc.render.declareRefreshController({
			id: controllerId, 
			renderContext: wc.render.getContextById("default"),
			url: defaultURL,
			renderContextChangedHandler: function(message, widget) {
				console.debug("entering renderContextChangedHandler for "+controllerId);
			
				var controller = this;
				var renderContext = this.renderContext;
				
				if(typeof actionName == "undefined" || !Common.getRenderContextProperty(renderContext, actionName)){
					console.debug("no actionName is specified. This handler will not be called. Exiting...");
					return;	
				}
				
				if(Common.getRenderContextProperty(renderContext, "url")){
					controller.url = Common.getRenderContextProperty(renderContext, "url");
				}
				
				widget.refresh(controller.renderContext.properties);
				
				// Make sure this handler will always know whether a user gives an addressDisplayAreaAction in the future.
				delete renderContext.properties[actionName];  
				delete renderContext.properties["url"];
			}, 
			
			modelChangedHandler: function(message, widget){
				console.debug(message);
				widget.refresh(this.renderContext.properties);
				
				cursor_clear();
			}
		});
		
	}, */

	/**
	 * This function is used when the creditcard field is updated by the user.
	 * @param {boolean} value The value assigned to the {@ link changed} variable of the QuickCheckoutProfile class.   
	 */
	valueChanged:function(value){
		QuickCheckoutProfile.changed = value;
	},
	
	/**
	 * This function is used to validate all the quickcheckout profile form input fields.
	 * @param {string} formName The name of the form containing all the information required to create a quick address profile. 
	 * 
	 * @private
	 *
	 * @return {boolean} The validation is successful or not.
	 */
	validateForm:function(formName){
		reWhiteSpace = new RegExp(/^\s+$/);
		var form = document.forms[formName];
		var expiry = null;
		if (form.pay_expire_year != null) {
			expiry = new Date(form.pay_expire_year.value,form.pay_expire_month.value - 1,1);
		}
		var currMonth = form.curr_month.value;
		if (currMonth.length == 1) {
			currMonth = "0" + currMonth;
		} else {
			currMonth = form.curr_month.value;
		}
		
		/** Uses the common validation function defined in AddressHelper class for validating first name, 
		 *  last name, street address, city, country/region, state/province, ZIP/postal code, e-mail address and phone number. 
		 */
		if(!AddressHelper.validateAddressForm(form,"billing_")){return false;}
		if(!AddressHelper.validateAddressForm(form,"shipping_")){return false;}

		var payMethodId = $('#payMethodId');
		if (payMethodId.find(":selected").val() != null) {
			if (form.pay_temp_account != null && reWhiteSpace.test(form.pay_temp_account.value) || form.pay_temp_account.value == "") {
				  MessageHelper.formErrorHandleClient(form.pay_temp_account.id,MessageHelper.messages["REQUIRED_FIELD_ENTER"]); return false;
			}
			if(QuickCheckoutProfile.changed == 'true')
			{
				form.pay_temp_account.name = 'pay_account';
			}
			else
				QuickCheckoutProfile.changed = 'false';
			/* Checks for a valid credit card expiry date. */
			 if (form.pay_expire_year != null && form.pay_expire_year.value < form.curr_year.value) {
				  MessageHelper.formErrorHandleClient(form.pay_expire_year.id,MessageHelper.messages["INVALID_EXPIRY_DATE"]); return false;
			 }
			 else if ( (form.pay_expire_year != null) && (form.pay_expire_year.value == form.curr_year.value) && (currMonth > form.pay_expire_month.value)) {
				 MessageHelper.formErrorHandleClient(form.pay_expire_month.id,MessageHelper.messages["INVALID_EXPIRY_DATE"]); return false;
			 }
		}
		return true;
	},
	
	/** 
	 * This function loads the current quickcheckout profile.
	 * @param {array} addresses This is a shippingProfile or billingProfile address object.
	 * @param {string} prefix The value is set to shipping or billing.
 	 */
	getCurrentProfile: function(addresses, prefix){
		var firstname = $("input[name=" + prefix + "_firstName]")[0];
		var lastname = $("input[name=" + prefix + "_lastName]")[0];
		var address1 = $("input[name=" + prefix + "_address1]")[0];
		var address2 = $("input[name=" + prefix + "_address2]")[0];
		var zipCode = $("input[name=" + prefix + "_zipCode]")[0];
		var email1 = $("input[name=" + prefix + "_email1]")[0];
		var phone1 = $("input[name=" + prefix + "_phone1]")[0];
		var city = $("input[name=" + prefix + "_city]")[0];
		var middleName = "";
		if($("input[name=" + prefix + "_middleName]")[0]) 
			middleName = $("input[name=" + prefix + "_middleName]")[0];
			
		firstname.value = addresses.firstName;	
		lastname.value = addresses.lastName;	
		address1.value = addresses.address1;
		address2.value = addresses.address2;
		zipCode.value = addresses.zipCode;	
		email1.value = addresses.email1;	
		phone1.value = addresses.phone1;	
		city.value = addresses.city;	
		if(middleName)
		{
			middleName.value = addresses.middleName;
		}
		
		var stateId = prefix+'_WC_QuickCheckoutAddressForm_AddressEntryForm_FormInput_'+prefix+'_state_1';
		var state = $('#' + stateId);
		if(addresses.state != ''){
			if (state !== undefined && state !== null){
				state.val(addresses.state);
				state.Select("refresh_noResizeButton");
			} else {
				state = $("input[name=" + prefix + "_state]")[0].val();
				state.val(addresses.state);
			}
		}

		if(addresses.country != '') {
			var country = $('#' + 'WC_QuickCheckoutAddressForm_AddressEntryForm_FormInput_'+prefix+'_country_1');
			country.val(addresses.country);
			country.Select("refresh_noResizeButton");
			AddressHelper.loadAddressFormStatesUI('QuickCheckout',prefix + "_", prefix+'_stateDiv','WC_QuickCheckoutAddressForm_AddressEntryForm_FormInput_'+ prefix + '_state_1', false, addresses.state);
		}
	},
	
	/**
	 * This function is used to show/hide the shipping address div if the 'same as my billing address' checkbox is unchecked/checked.
	 * @param {string} form The name of the form containing all the information required to create a quick address profile.
	 */

	showHide:function(form){
		var sameaddress = document.getElementById("SameShippingAndBillingAddress");
		if (sameaddress.checked){
				hideElementById("shipAddr");
				this.copyBillingAddress(form);
		}
		else{
			showElementById("shipAddr");
			$("input[name=shipping_firstName]")[0].value = "";
			$("input[name=shipping_lastName]")[0].value = "";
			$("input[name=shipping_address1]")[0].value = "";
			$("input[name=shipping_address2]")[0].value = "";
			$("input[name=shipping_city]")[0].value = "";
			$("input[name=shipping_zipCode]")[0].value = "";
			$("input[name=shipping_phone1]")[0].value = "";
			$("input[name=shipping_email1]")[0].value = "";
			$("select,input[name=shipping_state]")[0].value = "";
			if($("input[name=shipping_middleName]")[0]) 
				$("input[name=shipping_middleName]")[0].value = "";
		}
	},
	
	/**
	 * This function makes the shipping same as the billing address.
	 * @param {string} form The name of the quickcheckout profile form.
	 */
	copyBillingAddress:function(form){
		$("input[name=shipping_firstName]")[0].value = form.billing_firstName.value;
		$("input[name=shipping_lastName]")[0].value = form.billing_lastName.value;
		$("input[name=shipping_address1]")[0].value = form.billing_address1.value;
		$("input[name=shipping_address2]")[0].value = form.billing_address2.value;
		$("input[name=shipping_city]")[0].value = form.billing_city.value;
		$("input[name=shipping_zipCode]")[0].value = form.billing_zipCode.value;
		$("input[name=shipping_phone1]")[0].value = form.billing_phone1.value;
		$("input[name=shipping_email1]")[0].value = form.billing_email1.value;
		if ($("input[name=shipping_middleName]")[0]) 
			$("input[name=shipping_middleName]")[0].value = form.billing_middleName.value;
			
		var country = $('#WC_QuickCheckoutAddressForm_AddressEntryForm_FormInput_shipping_country_1');
		country.val(form.billing_country.value);
		country.Select("refresh_noResizeButton");

		AddressHelper.loadAddressFormStatesUI('QuickCheckout','shipping_','shipping_stateDiv','WC_QuickCheckoutAddressForm_AddressEntryForm_FormInput_shipping_state_1', false, form.billing_state.value);
	},
	
	/**
	 * This function updates the quickCheckout profile.
	 * @param {string} form The name of the form containing all the information required to create a quick address profile.
	 */
	UpdateProfile: function(form){
		var sameaddress = document.getElementById("SameShippingAndBillingAddress");
		if (sameaddress.checked){
			this.copyBillingAddress(form);
		}
		/* validates the form input fields. */
		if(this.validateForm(form.name))
		{
			var paymentMethodWidget = $("#payMethodId");
			var paymentMethod;
			if (paymentMethodWidget.length !== 0) {
					paymentMethod = paymentMethodWidget.val();
			}

			form.pay_payment_method.value = paymentMethod;
			form.pay_cc_brand.value = paymentMethod;
			form.pay_payMethodId.value = paymentMethod;
			
			/*For Handling multiple clicks. */
			if(!submitRequest()){
				return;
			}
			
			processAndSubmitForm(form);
		}
	}
}
//-----------------------------------------------------------------
// Licensed Materials - Property of IBM
//
// WebSphere Commerce
//
// (C) Copyright IBM Corp. 2007, 2016 All Rights Reserved.
//
// US Government Users Restricted Rights - Use, duplication or
// disclosure restricted by GSA ADP Schedule Contract with
// IBM Corp.
//-----------------------------------------------------------------

//
//

/**
* @fileOverview This file holds methods to perform display logic in History Order Details page when the order info is retrieved from Sterling Selling And Fulfillment Suite.<b>  
*			This file is referenced in SBSOrderDetails.jsp, SBSOrderDetailSummary.jsp and SBSMSOrderItemDetailSummary.jsp.
*
* @version 1.0
**/

/**
* @class sterlingIntegrationJS This class defines all the variables and functions used by the SterlingIntegration.js. Any page that will use a function in this file
*		can access that function thru this class. Pages that use sterlingIntegrationJS include SBSOrderDetails.jsp, SBSOrderDetailSummary.jsp and SBSMSOrderItemDetailSummary.jsp.
*
**/

sterlingIntegrationJS={
	
			/** The language ID currently in use **/
			langId: "-1",
			
			/** The store ID currently in use **/
			storeId: "",
			
			/** The catalog ID currently in use **/
			catalogId: "",
			
			/** The locale currently in use **/
			locale: "",
			
			/** The image files directory in current store **/ 
			jspStoreImgDir: "",
			
			orderBeingCanceled: "",
				/**
				* setCommonParameters This function initializes storeId, catalogId, langId, locale and store image directory.
				*
				* @param {String} langId The language id to use.
				* @param {String} storeId The store id to use.
				* @param {String} catalogId The catalog id to use.
				* @param {String} locale The locale to use.
				* @param (String) jspStoreImgDir the store image files directory to use.
				* 
				**/
				setCommonParameters:function(langId,storeId,catalogId,locale,jspStoreImgDir){
					this.langId = langId;
					this.storeId = storeId;
					alert('-1 '+this.storeId);
					this.catalogId = catalogId;
					this.locale = locale;
					this.jspStoreImgDir = jspStoreImgDir;
				},
				
				/**
				* populateOrderLevelInfo This function populates the order level information for the order retrieved from Sterling * in history order details page.
				*
				* @param {String} orderStr The json string for complete order information.
				* 
				**/
				populateOrderLevelInfo:function(orderStr){
					//alert('0 '+this.storeId);
					//orderStr = orderStr.replace("'", '&quot;');
					var jsonOrder = eval("("+orderStr+")");
					var locale = document.getElementById('Locale_String').innerHTML;
					var shipmentType = 2;
					if(!this.isNullObj(jsonOrder.Root.Order.shipmentTypeId)){
						shipmentType = jsonOrder.Root.Order.shipmentTypeId;
					}
					var pmTotalNumber = 0;
					if(!this.isNullObj(jsonOrder.Root.Order.countOfPaymentMethods)){
						pmTotalNumber = jsonOrder.Root.Order.countOfPaymentMethods;
					}
					var oiTotalNumber = 1;
					if(!this.isNullObj(jsonOrder.Root.Order.countOfOrderLines)){
						oiTotalNumber = jsonOrder.Root.Order.countOfOrderLines;
					}
					
					//Order Number field
					if(!this.isNullObj(jsonOrder.Root.Order.OrderNo)){
						var orderNo = jsonOrder.Root.Order.OrderNo;	
						if(!this.isNullObj(jsonOrder.Root.Order.EntryType)){
							var entryType = jsonOrder.Root.Order.EntryType;
							if(entryType == 'WCS'){
								document.getElementById('OrderNo').innerHTML = orderNo.substring(3);
							}else{
								document.getElementById('OrderNo').innerHTML = orderNo;
							}
						}else{
							document.getElementById('OrderNo').innerHTML = orderNo;
						}
					}
					
					//Order Date field
					if(!this.isNullObj(jsonOrder.Root.Order.OrderDate)){
						var orderDate = jsonOrder.Root.Order.OrderDate;
						var parsedOrderDate = new Date(orderDate);
						document.getElementById('OrderDate').innerHTML = Globalize.formatDate(parsedOrderDate, {date: "long"});
					}
					
					//Single Shipment
					if(shipmentType == 1){
						
						//Shipping Address
						var shippingAddress = null;				
						var orderLinePersonInfoShipTo = null;
						
						if(!this.isNullObj(jsonOrder.Root.Order.OrderLines.OrderLine)){							
							if(!this.isNullObj(jsonOrder.Root.Order.OrderLines.OrderLine.PersonInfoShipTo)){								
								orderLinePersonInfoShipTo = jsonOrder.Root.Order.OrderLines.OrderLine.PersonInfoShipTo;
							}else if(!this.isNullObj(jsonOrder.Root.Order.OrderLines.OrderLine[0])){								
								if(!this.isNullObj(jsonOrder.Root.Order.OrderLines.OrderLine[0].PersonInfoShipTo)){
									orderLinePersonInfoShipTo = jsonOrder.Root.Order.OrderLines.OrderLine[0].PersonInfoShipTo;							
								}
							}				
						}
						if(!this.isNullObj(orderLinePersonInfoShipTo)){
							this.populateAddress(orderLinePersonInfoShipTo, 'Single_Shipping_Address', locale);
						}else if(!this.isNullObj(jsonOrder.Root.Order.PersonInfoShipTo)){
							this.populateAddress(jsonOrder.Root.Order.PersonInfoShipTo, 'Single_Shipping_Address', locale);
						}
								
						//Shipping Method
						var shippingMethod = null;		
						if(!this.isNullObj(jsonOrder.Root.Order.Shipments)){
						if(!this.isNullObj(jsonOrder.Root.Order.Shipments.Shipment)){			
						 	if(!this.isNullObj(jsonOrder.Root.Order.Shipments.Shipment.shipModeDescription)){
								shippingMethod = jsonOrder.Root.Order.Shipments.Shipment.shipModeDescription;
							}else if(!this.isNullObj(jsonOrder.Root.Order.Shipments.Shipment[0])){
								if(!this.isNullObj(jsonOrder.Root.Order.Shipments.Shipment[0].shipModeDescription)){
									shippingMethod = jsonOrder.Root.Order.Shipments.Shipment[0].shipModeDescription;
								}
							}
						}
						}
						if(this.isNullObj(shippingMethod)){
							if(!this.isNullObj(jsonOrder.Root.Order.OrderLines.OrderLine)){							
								if(!this.isNullObj(jsonOrder.Root.Order.OrderLines.OrderLine.shipModeDescription)){								
									shippingMethod = jsonOrder.Root.Order.OrderLines.OrderLine.shipModeDescription;
								}else if(!this.isNullObj(jsonOrder.Root.Order.OrderLines.OrderLine[0])){								
									if(!this.isNullObj(jsonOrder.Root.Order.OrderLines.OrderLine[0].shipModeDescription)){
										shippingMethod = jsonOrder.Root.Order.OrderLines.OrderLine[0].shipModeDescription;									
									}
								}				
							}
						}
						if(this.isNullObj(shippingMethod)){
							if(!this.isNullObj(jsonOrder.Root.Order.CarrierServiceCode)){
								shippingMethod = jsonOrder.Root.Order.shipModeDescription;			
							}	
						}								
						if(!this.isNullObj(shippingMethod)){
							document.getElementById('Single_Shipping_Method').innerHTML = shippingMethod;
						}
						
						//Shipping Instruction
						if(!this.isNullObj(document.getElementById('Single_Shipping_Instruction'))){
							var instructions = null;
							if(!this.isNullObj(jsonOrder.Root.Order.OrderLines.OrderLine)){							
								if(!this.isNullObj(jsonOrder.Root.Order.OrderLines.OrderLine.Instructions)){								
									instructions = jsonOrder.Root.Order.OrderLines.OrderLine.Instructions;
								}else if(!this.isNullObj(jsonOrder.Root.Order.OrderLines.OrderLine[0])){								
									if(!this.isNullObj(jsonOrder.Root.Order.OrderLines.OrderLine[0].Instructions)){
										instructions = jsonOrder.Root.Order.OrderLines.OrderLine[0].Instructions;
									}
								}				
							}
							if(!this.isNullObj(instructions)){
								if(!this.isNullObj(instructions.Instruction)){					
									var instruction = instructions.Instruction;
									if(!this.isNullObj(instruction.InstructionType)){				
										if(instruction.InstructionType=='SHIP'){								
											if(!this.isNullObj(instruction.InstructionText)){
												document.getElementById('Single_Shipping_Instruction_Label').style.display = 'inline';
												document.getElementById('Single_Shipping_Instruction').innerHTML = instruction.InstructionText;
											}
										}
									}else if(!this.isNullObj(instructions.Instruction[0])){
										//more than one instruction
										for(var k in instructions.Instruction){						
											if(!this.isNullObj(instructions.Instruction[k].InstructionType)){
												if(instructions.Instruction[k].InstructionType=='SHIP'){									
													if(!this.isNullObj(instructions.Instruction[k].InstructionText)){
														document.getElementById('Single_Shipping_Instruction_Label').style.display = 'inline';
														document.getElementById('Single_Shipping_Instruction').innerHTML = document.getElementById('Single_Shipping_Instruction').innerHTML + instructions.Instruction[k].InstructionText+'<br/>';
													}
												}
											}
										}
									}				
								}else{
									//no instruction
								}
							}//no instructions
							
						}
					}
					
					//Ship As Complete
					if(!this.isNullObj(document.getElementById('Shipping_As_Complete_Y'))){
						if(!this.isNullObj(jsonOrder.Root.Order.IsShipComplete)){
							var shipAsComplete = jsonOrder.Root.Order.IsShipComplete;
							if(shipAsComplete == 'Y'){
								document.getElementById('Shipping_As_Complete_Y').style.display = 'inline';
								document.getElementById('Shipping_As_Complete_N').style.display = 'none';
							}else{
								document.getElementById('Shipping_As_Complete_Y').style.display = 'none';
								document.getElementById('Shipping_As_Complete_N').style.display = 'inline';
							}
						}
					}
					
					var currencyCode = 'USD';
					if(!this.isNullObj(jsonOrder.Root.Order.PriceInfo.Currency)){
						currencyCode = jsonOrder.Root.Order.PriceInfo.Currency;
					}
					var currencyDecimals = 2;
					if(!this.isNullObj(jsonOrder.Root.Order.PriceInfo.currencyDecimal)){
						currencyDecimals = jsonOrder.Root.Order.PriceInfo.currencyDecimal;
					}
					var currencySymbol = '$'
					if(!this.isNullObj(jsonOrder.Root.Order.PriceInfo.currencySymbol)){
						currencySymbol = jsonOrder.Root.Order.PriceInfo.currencySymbol;
					}
					//Line SubTotal
					if(!this.isNullObj(jsonOrder.Root.Order.OverallTotals.LineSubTotal)){
						document.getElementById('Order_SubTotal').innerHTML = this.formatCurrency(jsonOrder.Root.Order.OverallTotals.LineSubTotal, currencyDecimals, currencySymbol, currencyCode, locale);
					}	
					
					//Grand Discount
					var grandDiscount = jsonOrder.Root.Order.OverallTotals.GrandDiscount;
					if(!this.isNullObj(grandDiscount)){
						if(grandDiscount > 0){
							grandDiscount = (0 - grandDiscount) + "";
						}
						document.getElementById('Order_Discount').innerHTML = this.formatCurrency(grandDiscount, currencyDecimals, currencySymbol, currencyCode, locale);
					}
					
					//Grand Shipping Base Charge
					if(!this.isNullObj(jsonOrder.Root.Order.OverallTotals.GrandShippingBaseCharge)){
						document.getElementById('Order_Shipping').innerHTML = this.formatCurrency(jsonOrder.Root.Order.OverallTotals.GrandShippingBaseCharge, currencyDecimals, currencySymbol, currencyCode, locale);
					}
					
					//Total Tax
					if(!this.isNullObj(jsonOrder.Root.Order.OverallTotals.salesTax)){
						document.getElementById('Order_Tax').innerHTML = this.formatCurrency(jsonOrder.Root.Order.OverallTotals.salesTax, currencyDecimals, currencySymbol, currencyCode, locale);
					}
					
					//Shipping Tax
					if(!this.isNullObj(jsonOrder.Root.Order.OverallTotals.shippingTax)){
						document.getElementById('Order_ShippingTax').innerHTML = this.formatCurrency(jsonOrder.Root.Order.OverallTotals.shippingTax, currencyDecimals, currencySymbol, currencyCode, locale);
					}
					
					//Grand Total
					if(!this.isNullObj(jsonOrder.Root.Order.OverallTotals.GrandTotal)){
						document.getElementById('Order_Totals').innerHTML = this.formatCurrency(jsonOrder.Root.Order.OverallTotals.GrandTotal, currencyDecimals, currencySymbol, currencyCode, locale);
					}
					
					//Billing Address When No Payment Method
					if(pmTotalNumber == 0){
						if(!this.isNullObj(jsonOrder.Root.Order.PersonInfoBillTo)){			
							this.populateAddress(jsonOrder.Root.Order.PersonInfoBillTo, 'Billing_Address_With_No_Payment_Method', locale);			
						}
					}
					
					//Payment section
						for(var i=0; i<pmTotalNumber; i++ ){	
							var paymentMethod = null;
							if(pmTotalNumber == 1){
								paymentMethod = jsonOrder.Root.Order.PaymentMethods.PaymentMethod;
							}else{		
								paymentMethod = jsonOrder.Root.Order.PaymentMethods.PaymentMethod[i];
							}			
							
							//Payment Method Billing Address
							if(!this.isNullObj(paymentMethod.PersonInfoBillTo)){
								this.populateAddress(paymentMethod.PersonInfoBillTo, 'Billing_Address_'+i, locale);
							}else if(!this.isNullObj(jsonOrder.Root.Order.PersonInfoBillTo)){
								this.populateAddress(jsonOrder.Root.Order.PersonInfoBillTo, 'Billing_Address_'+i, locale);
							}
							
							//Payment Method Name
							if(!this.isNullObj(paymentMethod.paymentMethodName)){
								document.getElementById('Payment_Method_Name_'+i).innerHTML = paymentMethod.paymentMethodName;
							}
							//for CAAS
							/*if(!this.isNullObj(paymentMethod.PaymentType)){
								if(paymentMethod.PaymentType == 'CREDIT_CARD'){
									if(!this.isNullObj(paymentMethod.CreditCardType)){
										document.getElementById('Payment_Method_Name_'+i).innerHTML = paymentMethod.CreditCardType;
									}
								}else{
									document.getElementById('Payment_Method_Name_'+i).innerHTML = paymentMethod.PaymentType;
								}
							}*/
							
							if(!this.isNullObj(paymentMethod.PaymentType)){
								if(paymentMethod.PaymentType == 'CREDIT_CARD'){
									document.getElementById('Div_CreditCard_'+i).style.display = 'inline';
									document.getElementById('Div_Check_'+i).style.display = 'none';
									document.getElementById('Div_LineOfCredit_'+i).style.display = 'none';
									
									if(!this.isNullObj(paymentMethod.DisplayCreditCardNo)){
										document.getElementById('CreditCard_Account_'+i).innerHTML = '************'+ paymentMethod.DisplayCreditCardNo;
									}
									if(!this.isNullObj(paymentMethod.CreditCardExpDate)){
										document.getElementById('CreditCard_Expiration_Month_'+i).innerHTML = paymentMethod.CreditCardExpDate.substring(0,2);
										document.getElementById('CreditCard_Expiration_Year_'+i).innerHTML = paymentMethod.CreditCardExpDate.substring(3,7);
										//document.getElementById('CreditCard_Expiration_Year_'+i).innerHTML = paymentMethod.CreditCardExpDate.substring(2,6);
									}					
								}
								if(paymentMethod.PaymentType == 'Check'){
									document.getElementById('Div_CreditCard_'+i).style.display = 'none';
									document.getElementById('Div_Check_'+i).style.display = 'inline';
									document.getElementById('Div_LineOfCredit_'+i).style.display = 'none';
									
									if(!this.isNullObj(paymentMethod.DisplayPaymentReference1)){
										document.getElementById('Check_Account_'+i).innerHTML = '************'+ paymentMethod.DisplayPaymentReference1;
									}
								}
								
								if(paymentMethod.PaymentType == 'LineOfCreidt'){
									document.getElementById('Div_CreditCard_'+i).style.display = 'none';
									document.getElementById('Div_Check_'+i).style.display = 'none';
									document.getElementById('Div_LineOfCredit_'+i).style.display = 'inline';
									
									if(!this.isNullObj(paymentMethod.DisplayCustomerAccountNo)){
										document.getElementById('LineOfCredit_Account_'+i).innerHTML = '************'+ paymentMethod.DisplayCustomerAccountNo;
									}
								}
								
								if(!this.isNullObj(paymentMethod.MaxChargeLimit)){
									document.getElementById('Payment_Method_Amount_'+i).innerHTML = this.formatCurrency(paymentMethod.MaxChargeLimit, currencyDecimals, currencySymbol, currencyCode, locale);
								}
							}	
										
						}
				},
				
				populateAddress: function(address, addrDiv, locale){					
					var addressId = '';
					if(!this.isNullObj(address.AddressID)){addressId = address.AddressID;}
					var firstName = '';
					if(!this.isNullObj(address.FirstName)){firstName = address.FirstName;}
					var middleName = '';
					if(!this.isNullObj(address.MiddleName)){middleName = address.MiddleName;}
					var lastName = '';
					if(!this.isNullObj(address.LastName)){lastName = address.LastName;}
					var addressLine1 = '';
					if(!this.isNullObj(address.AddressLine1)){addressLine1 = address.AddressLine1;}
					var addressLine2 = '';
					if(!this.isNullObj(address.AddressLine2)){addressLine2 = address.AddressLine2;}
					var city = '';
					if(!this.isNullObj(address.City)){city = address.City;}
					var state = '';
					if(!this.isNullObj(address.stateDisplayName)){state = address.stateDisplayName;}	
					var country = '';
					if(!this.isNullObj(address.countryDisplayName)){country = address.countryDisplayName;}					
					var zipCode = '';
					if(!this.isNullObj(address.ZipCode)){zipCode = address.ZipCode;}	
					var telephone = '';
					if(!this.isNullObj(address.DayPhone)){telephone = address.DayPhone;}	
					var email = '';
					if(!this.isNullObj(address.EMailID)){email = address.EMailID;}	
							
					var addressContent = '<p>'+addressId+'</p>';
					if(locale == 'ar_EG'){
						
						if(firstName.length > 0 || middleName.length > 0 || lastName.length > 0){
							addressContent = addressContent + firstName + '&nbsp;' + middleName + '&nbsp;' + lastName + '<br />';
						}
						if(addressLine1.length > 0 || addressLine2.length > 0){
							addressContent = addressContent + addressLine1 + '&nbsp;'+ addressLine2 + '<br />';
						}
						if(city.length > 0){
							addressContent = addressContent + city +'<br />';
						}
						if(state.length > 0){
							addressContent = addressContent + state +'<br />';
						}
						if(country.length > 0){
							addressContent = addressContent + country +'<br />';
						}
						if(telephone.length > 0){
							addressContent = addressContent + telephone +'<br />';
						}
						
					}else if(locale == 'ja_JP' || locale == 'ko_KR' || locale == 'zh_CN' || locale == 'zh_TW'){
						
						if(lastName.length > 0 || firstName.length > 0){
							addressContent = addressContent + lastName + '&nbsp;' + firstName + '<br />';
						}
						if(country.length > 0 || zipCode.length > 0){
							addressContent = addressContent + country +'&nbsp;'+ zipCode +'&nbsp;<br />';
						}
						if(state.length > 0 || city.length > 0){
							addressContent = addressContent + state +'&nbsp;'+ city +'&nbsp;<br />';
						}
						if(addressLine1.length > 0 || addressLine2.length > 0){
							addressContent = addressContent + addressLine1 + '&nbsp;'+ addressLine2 + '<br />';
						}
						if(telephone.length > 0){
							addressContent = addressContent + telephone +'<br />';
						}
						
					}else if(locale == 'de_DE' || locale == 'es_ES' || locale == 'fr_FR' || locale == 'it_IT' || locale == 'pl_PL' || locale == 'ro_RO' || locale == 'ru_RU'){
						
						if(firstName.length > 0 || middleName.length > 0 || lastName.length > 0){
							addressContent = addressContent + firstName + '&nbsp;' + middleName + '&nbsp;' + lastName + '<br />';
						}
						if(addressLine1.length > 0 || addressLine2.length > 0){
							addressContent = addressContent + addressLine1 + '&nbsp;'+ addressLine2 + '<br />';
						}
						if(zipCode.length > 0 || city.length > 0){
							addressContent = addressContent + zipCode +'&nbsp;'+ city +'&nbsp;<br />';
						}
						if(state.length > 0){
							addressContent = addressContent + state +'<br />';
						}
						if(country.length > 0){
							addressContent = addressContent + country +'<br />';
						}
						if(telephone.length > 0){
							addressContent = addressContent + telephone +'<br />';
						}
						
					}else{
						
						if(firstName.length > 0 || lastName.length > 0){
							addressContent = addressContent + firstName + '&nbsp;' + lastName + '<br />';
						}
						if(addressLine1.length > 0 || addressLine2.length > 0){
							addressContent = addressContent + addressLine1 + '&nbsp;'+ addressLine2 + '<br />';
						}
						if(city.length > 0 || state.length > 0){
							addressContent = addressContent + city +'&nbsp;'+ state +'&nbsp;<br />';
						}
						if(country.length > 0 || zipCode.length > 0){
							addressContent = addressContent + country +'&nbsp;'+ zipCode +'&nbsp;<br />';
						}
						if(telephone.length > 0){
							addressContent = addressContent + telephone +'<br />';
						}
						if(email.length > 0){
							addressContent = addressContent + email +'<br />';
						}
						
					}
					document.getElementById(addrDiv).innerHTML = addressContent;
				},
				
				isNullObj: function(obj){
					if(obj != null && typeof(obj) != undefined){
						return false;
					}else{
						return true;
					}
				},
				
				formatCurrency: function(amount, decimals, symbol, currency, locale){
					return Utils.formatCurrency(amount, {
						minimumFractionDigits: parseInt(decimals),
						maximumFractionDigits: parseInt(decimals),
						currency: currency,
						locale: locale
					});
				},
				
				/**
				 * This function replace the special chars back for the path related string.
				 * 
				 * @param {String} str The string relates to path.
				 * @return (String) The replaced String.
				 */
				revertAllSpecialChars: function (str) {
					if(!this.isNullObj(str)){
						return str.replace(/&#62;/g, ">").replace(/&#60;/g, "<").replace(/&#39;/g, "'").replace(/&#34;/g, "\"").replace(/&#92;/g, "\\").replace(/&#38;/g, "&");
					} else {
						return str;
					}
				},
				
				/**
				* populateOrderLineInfoForSingleShipment This function populates the order line level information for the order 
				* retrieved from Sterling in history order details page with single shipment layout.
				*
				* @param {String} orderStr The json string for complete order information.
				* @param {Integer} beginIndex The begin index of the current order items page.
				* @param {Integer} pageSize The page size of the current order items page.
				*
				**/
				populateOrderLineInfoForSingleShipment: function(orderStr, beginIndex, pageSize){
					//alert('1 '+this.storeId);
					if(orderStr == null || orderStr === "") return;
					
					orderStr = orderStr.replace("'", "27%");
					var jsonOrder = eval("("+orderStr+")");
					var imgDir = document.getElementById('Image_Dir').innerHTML;
					var endIndex = document.getElementById('endIndex').innerHTML;
					var locale = document.getElementById('Locale_String_S').innerHTML;
					
					var orderLineNum = 1;
					if(!this.isNullObj(jsonOrder.Root.Order.countOfOrderLines)){
						orderLineNum = jsonOrder.Root.Order.countOfOrderLines;
					}
					//alert(document.getElementById('order_details').childNodes[1]);
					//alert(document.getElementById('order_details').childNodes[1].tagName);
					if(document.getElementById('order_details').childNodes[0].tagName == 'TBODY'){
						var parentTable = document.getElementById('order_details').childNodes[0];
					}else if(document.getElementById('order_details').childNodes[1].tagName == 'TBODY'){
						var parentTable = document.getElementById('order_details').childNodes[1];
					}
					
					
					for(var i=beginIndex; i<endIndex; i++){
						var orderLine = null;
						if(orderLineNum == 1){
							if(!this.isNullObj(jsonOrder.Root.Order.OrderLines.OrderLine[0])){
							    orderLine = jsonOrder.Root.Order.OrderLines.OrderLine[0];
							} else {
							    orderLine = jsonOrder.Root.Order.OrderLines.OrderLine;
							}
						}else{
							orderLine = jsonOrder.Root.Order.OrderLines.OrderLine[i];
						}
						var nobottom = null;
						if(!this.isNullObj(orderLine.CalculationCodes)){
							if(!this.isNullObj(orderLine.CalculationCodes.CalculationCode)){
								nobottom = 'th_align_left_no_bottom';							
							}
						}
						if(!this.isNullObj(nobottom)){
							document.getElementById('SingleShipment_rowHeader_product'+i).setAttribute('class', document.getElementById('SingleShipment_rowHeader_product'+i).getAttribute('class')+nobottom);
							document.getElementById('SingleShipment_rowHeader_product'+i).setAttribute('className', document.getElementById('SingleShipment_rowHeader_product'+i).getAttribute('className')+nobottom);
							if(!this.isNullObj(document.getElementById('WC_OrderItemDetailsSummaryf_td_requestedShippingDate_'+i))){
								document.getElementById('WC_OrderItemDetailsSummaryf_td_requestedShippingDate_'+i).setAttribute('class', document.getElementById('WC_OrderItemDetailsSummaryf_td_requestedShippingDate_'+i).getAttribute('class')+nobottom);
								document.getElementById('WC_OrderItemDetailsSummaryf_td_requestedShippingDate_'+i).setAttribute('className', document.getElementById('WC_OrderItemDetailsSummaryf_td_requestedShippingDate_'+i).getAttribute('className')+nobottom);
							}
							document.getElementById('WC_OrderItemDetailsSummaryf_td_1_'+i).setAttribute('class', document.getElementById('WC_OrderItemDetailsSummaryf_td_1_'+i).getAttribute('class')+nobottom);
							document.getElementById('WC_OrderItemDetailsSummaryf_td_1_'+i).setAttribute('className', document.getElementById('WC_OrderItemDetailsSummaryf_td_1_'+i).getAttribute('className')+nobottom);
							document.getElementById('WC_OrderItemDetailsSummaryf_td_2_'+i).setAttribute('class', document.getElementById('WC_OrderItemDetailsSummaryf_td_2_'+i).getAttribute('class')+nobottom);
							document.getElementById('WC_OrderItemDetailsSummaryf_td_2_'+i).setAttribute('className', document.getElementById('WC_OrderItemDetailsSummaryf_td_2_'+i).getAttribute('className')+nobottom);
							document.getElementById('WC_OrderItemDetailsSummaryf_td_3_'+i).setAttribute('class', document.getElementById('WC_OrderItemDetailsSummaryf_td_3_'+i).getAttribute('class')+nobottom);
							document.getElementById('WC_OrderItemDetailsSummaryf_td_3_'+i).setAttribute('className', document.getElementById('WC_OrderItemDetailsSummaryf_td_3_'+i).getAttribute('className')+nobottom);
							document.getElementById('WC_OrderItemDetailsSummaryf_td_4_'+i).setAttribute('class', document.getElementById('WC_OrderItemDetailsSummaryf_td_4_'+i).getAttribute('class')+nobottom);
							document.getElementById('WC_OrderItemDetailsSummaryf_td_4_'+i).setAttribute('className', document.getElementById('WC_OrderItemDetailsSummaryf_td_4_'+i).getAttribute('className')+nobottom);
						}
						//catalog entry info	
						var catEntryName = null;
						var thumbNail = null;
						var objectPath = null;
						var itemID = null;
						if(!this.isNullObj(orderLine.Item.CatalogEntry)){
							if(!this.isNullObj(orderLine.Item.CatalogEntry.objectPath)){
								objectPath = orderLine.Item.CatalogEntry.objectPath;
							}
							if(!this.isNullObj(orderLine.Item.CatalogEntry.CatalogEntryDescription)){
								if(!this.isNullObj(orderLine.Item.CatalogEntry.CatalogEntryDescription.catalogEntryName)){
									catEntryName = orderLine.Item.CatalogEntry.CatalogEntryDescription.catalogEntryName;
								}
								if(!this.isNullObj(orderLine.Item.CatalogEntry.CatalogEntryDescription.thumbNail)){
									thumbNail = orderLine.Item.CatalogEntry.CatalogEntryDescription.thumbNail;
								}
							}			
						}
						if(!this.isNullObj(orderLine.Item.ItemID)){
							itemID = orderLine.Item.ItemID;
						}
						
						if(!this.isNullObj(thumbNail)){
							thumbNail = this.revertAllSpecialChars(thumbNail);
							if(!this.isNullObj(objectPath)){
								objectPath = this.revertAllSpecialChars(objectPath);
								document.getElementById('Product_Thumbnail_'+i).setAttribute('src', objectPath+thumbNail);			
							}else {
								document.getElementById('Product_Thumbnail_'+i).setAttribute('src', thumbNail);			
							}
							
						}else{
							document.getElementById('Product_Thumbnail_'+i).setAttribute('src', imgDir+'images/NoImageIcon_sm.jpg');
						}		
						if(!this.isNullObj(catEntryName)){
							document.getElementById('SingleShipment_rowHeader_product'+i).setAttribute('abbr', document.getElementById('SingleShipment_rowHeader_product'+i).getAttribute('abbr')+catEntryName);
							document.getElementById('Product_Thumbnail_'+i).setAttribute('alt',	catEntryName);
							document.getElementById('Catalog_Entry_Name_'+i).innerHTML = catEntryName;
						}
						if(!this.isNullObj(itemID)){
							document.getElementById('Catalog_Entry_SKU_'+i).innerHTML = itemID;
						}
						
						//Defining attributes
						if(!this.isNullObj(orderLine.Item.CatalogEntry)){
							if(!this.isNullObj(orderLine.Item.CatalogEntry.catalogEntryAttributes)){
								document.getElementById('Catalog_Entry_Defining_Attributes_'+i).style.display = 'inline';
								for(var dAttr in orderLine.Item.CatalogEntry.catalogEntryAttributes.catalogEntryAttribute){
									document.getElementById('Catalog_Entry_Defining_Attributes_'+i).innerHTML = document.getElementById('Catalog_Entry_Defining_Attributes_'+i).innerHTML + orderLine.Item.CatalogEntry.catalogEntryAttributes.catalogEntryAttribute[dAttr].catalogEntryAttrName + ':'+ orderLine.Item.CatalogEntry.catalogEntryAttributes.catalogEntryAttribute[dAttr].catalogEntryAttrValue + '<br/>';
								}
							}
						}
						
						//Component names for DK
						if(!this.isNullObj(orderLine.componentNames)){
							var dkLabel = document.getElementById('Dynamic_Kit_Components_Label_'+i);
							if(!this.isNullObj(dkLabel)){
								document.getElementById('Dynamic_Kit_Components_Label_'+i).style.display = 'inline';
							}
							
							var ulForDK = document.getElementById('Dynamic_Kit_Components_'+i);
							if(!this.isNullObj(ulForDK)){
								var compNames = orderLine.componentNames.split(',');
								for(var j in compNames){
									var li = document.createElement('li');
									li.innerHTML = compNames[j];
									ulForDK.appendChild(li);
								}
							}
						} 
						
						//request ship date
						if(!this.isNullObj(document.getElementById('Order_Item_Requested_Ship_Date_'+i))){
							if(!this.isNullObj(orderLine.ReqShipDate)){
								var parsedReqShipDate = new Date(orderLine.ReqShipDate);
								document.getElementById('Order_Item_Requested_Ship_Date_'+i).innerHTML = Globalize.formatDate(parsedReqShipDate, {date: "long"});
							}
						}
						
						//order line status
						if(!this.isNullObj(orderLine.MaxLineStatus)){							
							document.getElementById('Order_Item_Status_'+i).innerHTML = Utils.getLocalizationMessage("ORDER_LINE_STATUS_"+orderLine.MaxLineStatus);
						}
						
						//quantity
						if(!this.isNullObj(orderLine.OrderedQty)){							
							document.getElementById('Order_Item_Quantity_'+i).innerHTML = Utils.formatNumber(orderLine.OrderedQty,{
								minimumFractionDigits:0,
								maximumFractionDigits:0
							});
						}
						
						var currencyCode = 'USD';
						if(!this.isNullObj(jsonOrder.Root.Order.PriceInfo.Currency)){
							currencyCode = jsonOrder.Root.Order.PriceInfo.Currency;
						}
						
						var currencyDecimals = 2;
						if(!this.isNullObj(jsonOrder.Root.Order.PriceInfo.currencyDecimal)){
							currencyDecimals = jsonOrder.Root.Order.PriceInfo.currencyDecimal;
						}
						
						var currencySymbol = '$'
						if(!this.isNullObj(jsonOrder.Root.Order.PriceInfo.currencySymbol)){
							currencySymbol = jsonOrder.Root.Order.PriceInfo.currencySymbol;
						}
						
						//unit price	
						if(!this.isNullObj(orderLine.LinePriceInfo.UnitPrice)){
							document.getElementById('Order_Item_Unit_Price_'+i).innerHTML = this.formatCurrency(orderLine.LinePriceInfo.UnitPrice, currencyDecimals, currencySymbol, currencyCode, locale);
						}
								
						//total price
						var isFree = false;
						if(!this.isNullObj(orderLine.Awards)){
							if(!this.isNullObj(orderLine.Awards.Award)){
								if(!this.isNullObj(orderLine.Awards.Award.AwardType)){
									if(orderLine.Awards.Award.AwardType == 'FreeGift'){
										isFree = true;
									}
								}else if(!this.isNullObj(orderLine.Awards.Award[0])){
									for(var award in orderLine.Awards.Award){
										if(orderLine.Awards.Award[award].AwardType == 'FreeGift'){
											isFree = true;
											break;
										}
									}
								}
							}
						}
						if(isFree == true){
							document.getElementById('Order_Item_Total_Price_Free_'+i).style.display = 'inline';
							document.getElementById('Order_Item_Total_Price_'+i).style.display = 'none';
						}else{
							document.getElementById('Order_Item_Total_Price_Free_'+i).style.display = 'none';
							document.getElementById('Order_Item_Total_Price_'+i).style.display = 'inline';
							if(!this.isNullObj(orderLine.ComputedPrice.ExtendedPrice)){
								document.getElementById('Order_Item_Total_Price_'+i).innerHTML = this.formatCurrency(orderLine.ComputedPrice.ExtendedPrice, currencyDecimals, currencySymbol, currencyCode, locale);
							}
						}
						
						//promotion info
						if(!this.isNullObj(orderLine.CalculationCodes)){
							
							var counter = 0;
							for(var j in orderLine.CalculationCodes.CalculationCode){
								//if(calCode.displayLevel == 0){
									var calCode = orderLine.CalculationCodes.CalculationCode[j];
									var code = calCode.code;
									code = this.revertAllSpecialChars(code);
									var tr = document.createElement('tr');
														
									parentTable.insertBefore(tr, document.getElementById('Product_Line_'+(parseInt(i)+1)));
																				
									var th = document.createElement('th');
									th.setAttribute('colSpan', '4');
									//For firefox and other browsers
									th.setAttribute('class', 'th_align_left_dotted_top_solid_bottom');
									//For IE
									th.setAttribute('className', 'th_align_left_dotted_top_solid_bottom');
									var abbrText = document.getElementById('Product_Discount_Text').innerHTML;
									th.setAttribute('abbr', abbrText+catEntryName);
									th.setAttribute('id', 'SingleShipment_rowHeader_discount'+i+'_'+counter);
									tr.appendChild(th);
									
									var div = document.createElement('div');
									div.setAttribute('id', 'WC_OrderItemDetailsSummaryf_div_3_'+i+'_'+counter);
									div.setAttribute('class', 'itemspecs');
									div.setAttribute('className', 'itemspecs');
									th.appendChild(div);
									
									var a = document.createElement('a');
									a.setAttribute('class', 'discount hover_underline');
									a.setAttribute('className', 'discount hover_underline');
									a.setAttribute('id', 'WC_OrderItemDetails_Link_ItemDiscount_1_'+i+'_'+counter);
									
									var url_innerHTML = document.getElementById('Promotion_Url').innerHTML;
									if(!this.isNullObj(url_innerHTML)){
										url_innerHTML = url_innerHTML.replace(/&amp;/g, "&");
									}
									var promotionUrl = url_innerHTML + '&code='+ encodeURIComponent(code);
									a.setAttribute('href', promotionUrl);
									div.appendChild(a);
									
									var img = document.createElement('img');
									img.setAttribute('src', imgDir+'images/empty.gif');
									img.setAttribute('alt', abbrText+catEntryName);
									a.appendChild(img);
									if(!this.isNullObj(calCode.calculationCodeDescription)){
										var calCodeDesc = this.revertAllSpecialChars(calCode.calculationCodeDescription);
										a.appendChild(document.createTextNode(calCodeDesc));
									}
														
									var td = document.createElement('td');
									td.setAttribute('class', 'th_align_left_dotted_top_solid_bottom total');
									td.setAttribute('className', 'th_align_left_dotted_top_solid_bottom total');
									td.appendChild(document.createTextNode(' '))
									tr.appendChild(td);
									
									var td1 = document.createElement('td');
									td1.setAttribute('class', 'th_align_left_dotted_top_solid_bottom total');
									td1.setAttribute('className', 'th_align_left_dotted_top_solid_bottom total');
									td1.setAttribute('id', 'WC_OrderItemDetailsSummaryf_td_5_'+i+'_'+counter);
									td1.setAttribute('headers', 'SingleShipment_rowHeader_discount'+i+'_'+counter);
									td1.appendChild(document.createTextNode(this.formatCurrency(calCode.TotalAmount, currencyDecimals, currencySymbol, currencyCode, locale)));					
									tr.appendChild(td1);
									
									counter++;
								//}
							}
						}
						
					}
				},
				
				/**
				* populateOrderLineInfoForMultipleShipment This function populates the order line level information for the order 
				* retrieved from Sterling in history order details page with multiple shipment layout.
				*
				* @param {String} orderStr The json string for complete order information.
				* @param {Integer} beginIndex The begin index of the current order items page.
				* @param {Integer} pageSize The page size of the current order items page.
				*
				**/
				populateOrderLineInfoForMultipleShipment: function(orderStr, beginIndex, pageSize){
					//orderStr = escape(orderStr);
					var jsonOrder = eval("("+orderStr+")");
					var imgDir = document.getElementById('Image_Dir').innerHTML;
					var locale = document.getElementById('Locale_String_M').innerHTML;
					var endIndex = document.getElementById('endIndex').innerHTML;
					var orderLineNum = 1;
					if(!this.isNullObj(jsonOrder.Root.Order.countOfOrderLines)){
						orderLineNum = jsonOrder.Root.Order.countOfOrderLines;
					}
					
					if(document.getElementById('order_details').childNodes[0].tagName == 'TBODY'){
						var parentTable = document.getElementById('order_details').childNodes[0];
					}else if(document.getElementById('order_details').childNodes[1].tagName == 'TBODY'){
						var parentTable = document.getElementById('order_details').childNodes[1];
					}
					for(var i=beginIndex; i<endIndex; i++){
						var orderLine = null;
						if(orderLineNum == 1){
							if(!this.isNullObj(jsonOrder.Root.Order.OrderLines.OrderLine[0])){
							    orderLine = jsonOrder.Root.Order.OrderLines.OrderLine[0];
							} else {
							    orderLine = jsonOrder.Root.Order.OrderLines.OrderLine;
							}
						}else{
							orderLine = jsonOrder.Root.Order.OrderLines.OrderLine[i];
						}
						
						var nobottom = null;
						if(!this.isNullObj(orderLine.CalculationCodes)){
							if(!this.isNullObj(orderLine.CalculationCodes.CalculationCode)){
								nobottom = 'th_align_left_no_bottom';							
							}
						}
						if(!this.isNullObj(nobottom)){
							document.getElementById('MultipleShipping_rowHeader_product'+i).setAttribute('class', nobottom+document.getElementById('MultipleShipping_rowHeader_product'+i).getAttribute('class'));
							document.getElementById('MultipleShipping_rowHeader_product'+i).setAttribute('className', nobottom+document.getElementById('MultipleShipping_rowHeader_product'+i).getAttribute('className'));
							document.getElementById('WC_MSOrderItemDetailsSummaryf_td_1_'+i).setAttribute('class', nobottom+document.getElementById('WC_MSOrderItemDetailsSummaryf_td_1_'+i).getAttribute('class'));
							document.getElementById('WC_MSOrderItemDetailsSummaryf_td_1_'+i).setAttribute('className', nobottom+document.getElementById('WC_MSOrderItemDetailsSummaryf_td_1_'+i).getAttribute('className'));
							document.getElementById('WC_MSOrderItemDetailsSummaryf_td_2_'+i).setAttribute('class', nobottom+document.getElementById('WC_MSOrderItemDetailsSummaryf_td_2_'+i).getAttribute('class'));
							document.getElementById('WC_MSOrderItemDetailsSummaryf_td_2_'+i).setAttribute('className', nobottom+document.getElementById('WC_MSOrderItemDetailsSummaryf_td_2_'+i).getAttribute('className'));
							document.getElementById('WC_MSOrderItemDetailsSummaryf_td_3_'+i).setAttribute('class', nobottom+document.getElementById('WC_MSOrderItemDetailsSummaryf_td_3_'+i).getAttribute('class'));
							document.getElementById('WC_MSOrderItemDetailsSummaryf_td_3_'+i).setAttribute('className', nobottom+document.getElementById('WC_MSOrderItemDetailsSummaryf_td_3_'+i).getAttribute('className'));
							document.getElementById('WC_MSOrderItemDetailsSummaryf_td_4_'+i).setAttribute('class', nobottom+document.getElementById('WC_MSOrderItemDetailsSummaryf_td_4_'+i).getAttribute('class'));
							document.getElementById('WC_MSOrderItemDetailsSummaryf_td_4_'+i).setAttribute('className', nobottom+document.getElementById('WC_MSOrderItemDetailsSummaryf_td_4_'+i).getAttribute('className'));
							document.getElementById('WC_MSOrderItemDetailsSummaryf_td_5_'+i).setAttribute('class', nobottom+document.getElementById('WC_MSOrderItemDetailsSummaryf_td_5_'+i).getAttribute('class'));
							document.getElementById('WC_MSOrderItemDetailsSummaryf_td_5_'+i).setAttribute('className', nobottom+document.getElementById('WC_MSOrderItemDetailsSummaryf_td_5_'+i).getAttribute('className'));
							document.getElementById('WC_MSOrderItemDetailsSummaryf_td_6_'+i).setAttribute('class', nobottom+document.getElementById('WC_MSOrderItemDetailsSummaryf_td_6_'+i).getAttribute('class'));
							document.getElementById('WC_MSOrderItemDetailsSummaryf_td_6_'+i).setAttribute('className', nobottom+document.getElementById('WC_MSOrderItemDetailsSummaryf_td_6_'+i).getAttribute('className'));
						}
						//catalog entry info	
						var catEntryName = null;
						var thumbNail = null;
						var objectPath = null;
						var itemID = null;
						if(!this.isNullObj(orderLine.Item.CatalogEntry)){
							if(!this.isNullObj(orderLine.Item.CatalogEntry.objectPath)){
								objectPath = orderLine.Item.CatalogEntry.objectPath;
							}
							if(!this.isNullObj(orderLine.Item.CatalogEntry.CatalogEntryDescription)){
								if(!this.isNullObj(orderLine.Item.CatalogEntry.CatalogEntryDescription.catalogEntryName)){
									catEntryName = orderLine.Item.CatalogEntry.CatalogEntryDescription.catalogEntryName;
								}
								if(!this.isNullObj(orderLine.Item.CatalogEntry.CatalogEntryDescription.thumbNail)){
									thumbNail = orderLine.Item.CatalogEntry.CatalogEntryDescription.thumbNail;
								}
							}			
						}		
						if(!this.isNullObj(orderLine.Item.ItemID)){
							itemID = orderLine.Item.ItemID;
						}
						if(!this.isNullObj(thumbNail)){
							thumbNail = this.revertAllSpecialChars(thumbNail);
							if(!this.isNullObj(objectPath)){
								objectPath = this.revertAllSpecialChars(objectPath);
								document.getElementById('Product_Thumbnail_'+i).setAttribute('src', objectPath+thumbNail);			
							}else {
								document.getElementById('Product_Thumbnail_'+i).setAttribute('src', thumbNail);			
							}
							
						}else{
							document.getElementById('Product_Thumbnail_'+i).setAttribute('src', imgDir+'images/NoImageIcon_sm.jpg');
						}
						if(!this.isNullObj(catEntryName)){
							document.getElementById('MultipleShipping_rowHeader_product'+i).setAttribute('abbr', document.getElementById('MultipleShipping_rowHeader_product'+i).getAttribute('abbr')+catEntryName);
							document.getElementById('Product_Thumbnail_'+i).setAttribute('alt',	catEntryName);
							document.getElementById('Catalog_Entry_Name_'+i).innerHTML = catEntryName;
						}
						if(!this.isNullObj(itemID)){
							document.getElementById('Catalog_Entry_SKU_'+i).innerHTML = itemID;
						}	
						
						//Defining attributes				
						if(!this.isNullObj(orderLine.Item.CatalogEntry)){
							if(!this.isNullObj(orderLine.Item.CatalogEntry.catalogEntryAttributes)){
								document.getElementById('Catalog_Entry_Defining_Attributes_'+i).style.display = 'inline';
								for(var dAttr in orderLine.Item.CatalogEntry.catalogEntryAttributes.catalogEntryAttribute){
									document.getElementById('Catalog_Entry_Defining_Attributes_'+i).innerHTML = document.getElementById('Catalog_Entry_Defining_Attributes_'+i).innerHTML + orderLine.Item.CatalogEntry.catalogEntryAttributes.catalogEntryAttribute[dAttr].catalogEntryAttrName + ':'+ orderLine.Item.CatalogEntry.catalogEntryAttributes.catalogEntryAttribute[dAttr].catalogEntryAttrValue + '<br/>';
								}
							}
						}
						
						//Component names for DK
						if(!this.isNullObj(orderLine.componentNames)){
							var dkLabel = document.getElementById('Dynamic_Kit_Components_Label_'+i);
							if(!this.isNullObj(dkLabel)){
								document.getElementById('Dynamic_Kit_Components_Label_'+i).style.display = 'inline';
							}
							
							var ulForDK = document.getElementById('Dynamic_Kit_Components_'+i);
							if(!this.isNullObj(ulForDK)){
								var compNames = orderLine.componentNames.split(',');
								for(var j in compNames){
									var li = document.createElement('li');
									li.innerHTML = compNames[j];
									ulForDK.appendChild(li);
								}
							}
						} 
						
						//Shipping address		
						if(!this.isNullObj(orderLine.PersonInfoShipTo)){			
							this.populateAddress(orderLine.PersonInfoShipTo, 'WC_MSOrderItemDetailsSummaryf_div_3_'+i, locale);
						}else if(!this.isNullObj(jsonOrder.Root.Order.PersonInfoShipTo)){			
							this.populateAddress(jsonOrder.Root.Order.PersonInfoShipTo, 'WC_MSOrderItemDetailsSummaryf_div_3_'+i, locale);
						}
								
						//Shipping method
						var shippingMethod = null;		
						if(!this.isNullObj(orderLine.ShipmentLines.ShipmentLine)){
							var shipmentKey = null;
							if(!this.isNullObj(orderLine.ShipmentLines.ShipmentLine.ShipmentKey)){
								shipmentKey = orderLine.ShipmentLines.ShipmentLine.ShipmentKey;				
							}else if(!this.isNullObj(orderLine.ShipmentLines.ShipmentLine[0].ShipmentKey)){
								shipmentKey = orderLine.ShipmentLines.ShipmentLine[0].ShipmentKey;
							}
							if(!this.isNullObj(shipmentKey)){
							if(!this.isNullObj(jsonOrder.Root.Order.Shipments)){
								if(!this.isNullObj(jsonOrder.Root.Order.Shipments.Shipment)){
									if(!this.isNullObj(jsonOrder.Root.Order.Shipments.Shipment.ShipmentKey)){
										if(jsonOrder.Root.Order.Shipments.Shipment.ShipmentKey == shipmentKey){
											if(!this.isNullObj(jsonOrder.Root.Order.Shipments.Shipment.shipModeDescription)){
												shippingMethod = jsonOrder.Root.Order.Shipments.Shipment.shipModeDescription;
											}				
										}
									}else if(!this.isNullObj(jsonOrder.Root.Order.Shipments.Shipment[0])){
										for(var s in jsonOrder.Root.Order.Shipments.Shipment){
											if(jsonOrder.Root.Order.Shipments.Shipment[s].ShipmentKey == shipmentKey){
												if(!this.isNullObj(jsonOrder.Root.Order.Shipments.Shipment[s].shipModeDescription)){
													shippingMethod = jsonOrder.Root.Order.Shipments.Shipment[s].shipModeDescription;
												}
												break;
											}
										}
									}
								}
							  }
							}					
						}		
						if(this.isNullObj(shippingMethod)){
							if(!this.isNullObj(orderLine.shipModeDescription)){
								shippingMethod = orderLine.shipModeDescription;			
							}else if(!this.isNullObj(jsonOrder.Root.Order.shipModeDescription)){
								shippingMethod = jsonOrder.Root.Order.shipModeDescription;			
							}
						}
						if(!this.isNullObj(shippingMethod)){
							document.getElementById('Shipping_Mode_Description_'+i).innerHTML = shippingMethod;
						}
								
						var isFree = false;
						if(!this.isNullObj(orderLine.Awards)){
							if(!this.isNullObj(orderLine.Awards.Award)){
								if(!this.isNullObj(orderLine.Awards.Award.AwardType)){
									if(orderLine.Awards.Award.AwardType == 'FreeGift'){
										isFree = true;
									}
								}else if(!this.isNullObj(orderLine.Awards.Award[0])){
									for(var award in orderLine.Awards.Award){
										if(orderLine.Awards.Award[award].AwardType == 'FreeGift'){
											isFree = true;
											break;
										}
									}
								}
							}
						}
						
						if(isFree == false){
							if(!this.isNullObj(document.getElementById('Shipping_Instruction_'+i))){
								//shipping instruction
								if(!this.isNullObj(orderLine.Instructions)){
									var instructions = orderLine.Instructions;
									if(!this.isNullObj(instructions.Instruction)){					
										var instruction = instructions.Instruction;
										if(!this.isNullObj(instruction.InstructionType)){				
											if(instruction.InstructionType=='SHIP'){								
												if(!this.isNullObj(instruction.InstructionText)){
													document.getElementById('Shipping_Instruction_Label_'+i).style.display = 'inline';					
													document.getElementById('Shipping_Instruction_'+i).innerHTML = instruction.InstructionText;
												}
											}
										}else if(!this.isNullObj(instructions.Instruction[0])){
											//more than one instruction
											for(var k in instructions.Instruction){						
												if(!this.isNullObj(instructions.Instruction[k].InstructionType)){
													if(instructions.Instruction[k].InstructionType=='SHIP'){									
														if(!this.isNullObj(instructions.Instruction[k].InstructionText)){
															document.getElementById('Shipping_Instruction_Label_'+i).style.display = 'inline';
															document.getElementById('Shipping_Instruction_'+i).innerHTML = document.getElementById('Shipping_Instruction_'+i).innerHTML + instructions.Instruction[k].InstructionText+'<br/>';
														}
													}
												}
											}
										}				
									}else{
										//no instruction
									}
								}//no instructions
							}
							
							if(!this.isNullObj(document.getElementById('Order_Item_Requested_Ship_Date_'+i))){
								//request ship date
								if(!this.isNullObj(orderLine.ReqShipDate)){
									document.getElementById('Requested_Shipping_Date_Label_'+i).style.display = 'inline';
									var parsedReqShipDate = new Date(orderLine.ReqShipDate);
									document.getElementById('Order_Item_Requested_Ship_Date_'+i).innerHTML = Globalize.formatDate(parsedReqShipDate, {date: "long"});
								}
							}
						}
						
						//order line status
						if(!this.isNullObj(orderLine.MaxLineStatus)){			
							//document.getElementById('Order_Item_Status_'+i).innerHTML = orderLine.Status;							
							document.getElementById('Order_Item_Status_'+i).innerHTML = Utils.getLocalizationMessage('ORDER_LINE_STATUS_'+orderLine.MaxLineStatus);
						}
						
						//quantity
						if(!this.isNullObj(orderLine.OrderedQty)){
							document.getElementById('Order_Item_Quantity_'+i).innerHTML = Utils.formatNumber(orderLine.OrderedQty,{
								minimumFractionDigits:0,
								maximumFractionDigits:0
							});
						}
						
						var currencyCode = 'USD';
						if(!this.isNullObj(jsonOrder.Root.Order.PriceInfo.Currency)){
							currencyCode = jsonOrder.Root.Order.PriceInfo.Currency;
						}
						
						var currencyDecimals = 2;
						if(!this.isNullObj(jsonOrder.Root.Order.PriceInfo.currencyDecimal)){
							currencyDecimals = jsonOrder.Root.Order.PriceInfo.currencyDecimal;
						}
						
						var currencySymbol = '$'
						if(!this.isNullObj(jsonOrder.Root.Order.PriceInfo.currencySymbol)){
							currencySymbol = jsonOrder.Root.Order.PriceInfo.currencySymbol;
						}
						
						//unit price
						if(!this.isNullObj(orderLine.LinePriceInfo.UnitPrice)){
							document.getElementById('Order_Item_Unit_Price_'+i).innerHTML = this.formatCurrency(orderLine.LinePriceInfo.UnitPrice, currencyDecimals, currencySymbol, currencyCode, locale);
						}
								
						//total price		
						if(isFree == true){
							document.getElementById('Order_Item_Total_Price_Free_'+i).style.display = 'inline';
							document.getElementById('Order_Item_Total_Price_'+i).style.display = 'none';
						}else{			
							document.getElementById('Order_Item_Total_Price_Free_'+i).style.display = 'none';
							document.getElementById('Order_Item_Total_Price_'+i).style.display = 'inline';
							if(!this.isNullObj(orderLine.ComputedPrice.ExtendedPrice)){
								document.getElementById('Order_Item_Total_Price_'+i).innerHTML = this.formatCurrency(orderLine.ComputedPrice.ExtendedPrice, currencyDecimals, currencySymbol, currencyCode, locale);
							}
						}
						
						//promotion info
						if(!this.isNullObj(orderLine.CalculationCodes)){
							
							var counter = 0;
							for(var j in orderLine.CalculationCodes.CalculationCode){
									var calCode = orderLine.CalculationCodes.CalculationCode[j];			
									var code = calCode.code;
									code = this.revertAllSpecialChars(code);
									var tr = document.createElement('tr');												
									parentTable.insertBefore(tr, document.getElementById('Product_Line_'+(parseInt(i)+1)));
									
									var th = document.createElement('th');
									th.setAttribute('colSpan', '5');
									th.setAttribute('class', 'th_align_left_dotted_top_solid_bottom');
									th.setAttribute('className', 'th_align_left_dotted_top_solid_bottom');
									var abbrText = document.getElementById('Product_Discount_Text').innerHTML;
									th.setAttribute('abbr', abbrText+catEntryName);
									th.setAttribute('id', 'MultipleShipment_rowHeader_discount'+i+'_'+counter);
									tr.appendChild(th);
									
									var div = document.createElement('div');
									div.setAttribute('id', 'WC_MSOrderItemDetailsSummaryf_div_5_'+i+'_'+counter);
									div.setAttribute('class', 'itemspecs');
									div.setAttribute('className', 'itemspecs');
									th.appendChild(div);
									
									var a = document.createElement('a');
									a.setAttribute('class', 'discount');
									a.setAttribute('className', 'discount');
									a.setAttribute('id', 'WC_OrderItemDetails_Link_ItemDiscount_1_'+i+'_'+counter);
									
									var url_innerHTML = document.getElementById('Promotion_Url').innerHTML;
									if(!this.isNullObj(url_innerHTML)){
										url_innerHTML = url_innerHTML.replace(/&amp;/g, "&");
									}
									var promotionUrl =  url_innerHTML + '&code='+ encodeURIComponent(code);
									
									a.setAttribute('href', promotionUrl);
									div.appendChild(a);
									
									var img = document.createElement('img');
									img.setAttribute('src', imgDir+'images/empty.gif');
									img.setAttribute('alt', abbrText+catEntryName);
									a.appendChild(img);
									if(!this.isNullObj(calCode.calculationCodeDescription)){
										var calCodeDesc = this.revertAllSpecialChars(calCode.calculationCodeDescription);
										a.appendChild(document.createTextNode(calCodeDesc));	
									}
									
									var td = document.createElement('td');
									td.setAttribute('class', 'th_align_left_dotted_top_solid_bottom total');
									td.setAttribute('className', 'th_align_left_dotted_top_solid_bottom total');
									td.appendChild(document.createTextNode(' '))
									tr.appendChild(td);
																																
									var td1 = document.createElement('td');
									td1.setAttribute('class', 'th_align_left_dotted_top_solid_bottom total');
									td1.setAttribute('className', 'th_align_left_dotted_top_solid_bottom total');
									td1.setAttribute('id', 'WC_MSOrderItemDetailsSummaryf_td_7_'+i+'_'+counter);
									td1.setAttribute('headers', 'MultipleShipment_rowHeader_discount'+i+'_'+counter);
									td1.appendChild(document.createTextNode(this.formatCurrency(calCode.TotalAmount, currencyDecimals, currencySymbol, currencyCode, locale)));					
									tr.appendChild(td1);
									
									counter++;				
							}
						}
						
					}
				},
				
				/**
				 * This function sets the url for ssfs order copy service and then it invokes the service to copy the old order.
				 * @param {string} OrderCancelURL The url for the ssfs order copy service.
				 * @param {string} orderHeaderKeyBeingCanceled The order header key of the order being canceled.
				 */
				cancelOrder:function(OrderCancelURL, orderHeaderKeyBeingCanceled){

					/*For Handling multiple clicks. */
					if(!submitRequest()){
						return;
					}
					cursor_wait();
					this.orderBeingCanceled = orderHeaderKeyBeingCanceled;
					wcService.getServiceById("CancelExternalOrder").setUrl(OrderCancelURL);
					wcService.invoke("CancelExternalOrder");
				}
				
}

/**
 *  This service enables customer to Cancel an existing order on the external system.
 *  @constructor
 */
wcService.declare({
	id: "CancelExternalOrder",
	actionId: "CancelExternalOrder",
	url: "AJAXProcessExternalOrder",
	formId: ""

	 /**
	  *  This method updates the order table with the 
	  *  @param (object) serviceResponse The service response object, which is the
	  *  JSON object returned by the service invocation.
	  */
	,successHandler: function(serviceResponse) {
		for (var prop in serviceResponse) {
			console.debug(prop + "=" + serviceResponse[prop]);			
		}
		//change the status to canceled.
		var idToLookFor = "OrderDetails_status_span_" + sterlingIntegrationJS.orderBeingCanceled;
		var $element = $("#" + idToLookFor);
		if($element.length){
			$element.html(MessageHelper.messages["MO_OrderStatus_X"]);
		}
		
		//Hide the cancel button
		idToLookFor = "OrderDetails_cancelButton_" + sterlingIntegrationJS.orderBeingCanceled;
		var $element = $("#" + idToLookFor);
		if($element.length){
			$element.css('display', 'none');
			$element.css('visibility', 'hidden');
		}
				
		//Show canceled message.
		MessageHelper.hideAndClearMessage();
		cursor_clear();
		MessageHelper.displayStatusMessage(MessageHelper.messages["MO_ORDER_CANCELED_MSG"]);
	}
	
	/**
	* display an error message.
	* @param (object) serviceResponse The service response object, which is the
	* JSON object returned by the service invocation.
	*/
	,failureHandler: function(serviceResponse) {
		for (var prop in serviceResponse) {
			console.debug(prop + "=" + serviceResponse[prop]);			
		}
	
		if (serviceResponse.errorMessage) {
			MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
		} 
		else {
			 if (serviceResponse.errorMessageKey) {
				MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
			 }
		}
		cursor_clear();
	}

})
//-----------------------------------------------------------------
// Licensed Materials - Property of IBM
//
// WebSphere Commerce
//
// (C) Copyright IBM Corp. 2012, 2015 All Rights Reserved.
//
// US Government Users Restricted Rights - Use, duplication or
// disclosure restricted by GSA ADP Schedule Contract with
// IBM Corp.
//-----------------------------------------------------------------

/** 
 * @fileOverview This file contains all the global variables and JavaScript functions needed by the compare product page and the compare zone. 
 */

if(typeof(CompareProductJS) == "undefined" || CompareProductJS == null || !CompareProductJS) {
	
	/**
	 * @class The functions defined in the class are used for comparing products. 
	 *
	 * This CompareProductJS class defines all the variables and functions for the page that uses the comparison functionality in the store.
	 * The compare accepts a maximum of 4 products to compare.
	 * The compare product display page compares various products' attributes side-by-side.
	 *
	 */
	CompareProductJS = {
		/**
		 * Object to store langId, storeId and catalogId of the store.
		 */
		params: [],
		
		/**
		* The compareReturnName is a string to store the current name of the category from where the compare link was clicked
		*/
		compareReturnName: "",
		
		/**
		* The returnUrl is a string to store the url of the category from where the compare link was clicked
		*/
		returnUrl: "",
		
		/**
		 * The prefix of the cookie key that is used to store item Ids. 
		 */
		cookieKeyPrefix: "CompareItems_",
		
		/**
		 * The delimiter used to separate item Ids in the cookie.
		 */
		cookieDelimiter: ";",
		
		/**
		 * The maximum number of items allowed in the compare zone. 
		 */
		maxNumberProductsAllowedToCompare: 4,
		
		/**
		 * Sets the common parameters used in all service calls like langId, storeId and catalogId.
		 * @param {String} langId The language Id.
		 * @param {String} storeId The store Id.
		 * @param {String} catalogId The catalog Id.
		 * @param {String} compareReturnName The return page name
		 * @param {String} returnUrl The url of the return page to go back
		 */
		setCommonParameters:function(langId,storeId,catalogId, compareReturnName, returnUrl){
			this.params.langId = langId;
			this.params.storeId = storeId;
			this.params.catalogId = catalogId;
			this.compareReturnName = compareReturnName;
			this.returnUrl = decodeURIComponent(returnUrl);
		},

		/**
		 * Removes an item from the products compare page.
		 * @param {String} key The Id of the item to remove.
		 */
		remove: function(key){
			var cookieKey = this.cookieKeyPrefix + this.params.storeId;
			var cookieValue = getCookie(cookieKey);
			if(cookieValue != null){
				if(cookieValue.trim() == ""){
					setCookie(cookieKey, null, {expires: -1});
				}else{
					var cookieArray = cookieValue.split(this.cookieDelimiter);
					var newCookieValue = "";
					for(index in cookieArray){
						if(cookieArray[index] != key){
							if(newCookieValue === ""){
								newCookieValue = cookieArray[index];
							}else{
								newCookieValue = newCookieValue + this.cookieDelimiter + cookieArray[index]
							}
						}
					}
					setCookie(cookieKey, newCookieValue, {path:'/', domain:cookieDomain});
				}
				
				// Now remove this catentry from URL and re-submit it...
				//replace catentryId=[0-9;]*&? with the current set of catentryIds present in cookie...
				var cookieKey = this.cookieKeyPrefix + this.params.storeId;
				var cookieValue = getCookie(cookieKey);
				var tempURL = "";
				var tokens = document.URL.split('catentryId=');
				if (tokens.length == 2) {
					tempURL = tokens[0] + 'catentryId=' + cookieValue;
					var tokens2 = tokens[1].split('&');
					for (var i=0; i<tokens2.length; i++) {
						if (i > 0) {
							tempURL = tempURL + "&" + tokens[i];
						}
					}
				}
				var tempURL = tempURL.replace(/&&/, "&"); //we might end up with &&, when newCatentryIdsToCompare is empty..Handle this scenario...
				location.href = tempURL;
			}
		},

		/**
		 * Re-directs the browser to the CompareProductsDisplay page to compare products side-by-side.
		 */
		compareProducts:function(){
			var url = "CompareProductsDisplayView?storeId=" + this.params.storeId + "&catalogId=" + this.params.catalogId + "&langId=" + this.params.langId + "&compareReturnName=" + this.compareReturnName;
			
			var cookieKey = this.cookieKeyPrefix + this.params.storeId;
			var cookieValue = getCookie(cookieKey);
			if(cookieValue != null && cookieValue.trim() != ""){
				url = url + "&catentryId=" + cookieValue;
			}
			url = url + "&returnUrl=" + encodeURIComponent(this.returnUrl);
			location.href = getAbsoluteURL() + url;
		},
		
		/**
		* add2ShopCart Adds product to the shopping cart
		* @param {String} catEntryId The catalog entry Id.
		* @param {String} quantity The quantity.
		* @param {String} productId The product Id.
		**/
		add2ShopCart: function(catEntryId, quantity, productId){
			var shoppingParams = {
                storeId: WCParamJS.storeId,
                catalogId: WCParamJS.catalogId,
                langId: WCParamJS.langId,
                orderId: "."
            };
			// Remove calculations for performance
			// shoppingParams.calculationUsage = "-1,-2,-5,-6,-7";
			shoppingParams.calculateOrder="0";
			
			//Add the catalog entry to the cart.
			updateParamObject(shoppingParams,"catEntryId",catEntryId,false,-1);
			updateParamObject(shoppingParams,"quantity",quantity,false,-1);
			
			var shopCartService = "AddOrderItem";
			
			var skuAttributes = this.getSkuAttributes(catEntryId);
			if (skuAttributes == null) {
				skuAttributes = this.getSkuAttributes(productId);
			}
			
			//For Handling multiple clicks
			if(!submitRequest()){
				return;
			}
			cursor_wait();
			
			shoppingActionsJS.saveAddedProductInfo(quantity, productId, catEntryId, skuAttributes);
			wcService.invoke(shopCartService, shoppingParams);
		},
		
		/**
		 * Returns the SKU attributes from the skuAttributesJSON div.
		 * @param {String} catEntryId The catalog entry Id.
		 * @returns {Object} The object containing all of the attributes for the SKU.
		 **/
		getSkuAttributes : function(catEntryId)
		{
			var jsonDiv = null;
			var node = $("#SKUAttributesJSON_" + catEntryId);

			if (node && node != null && node != 'undefined') {
				jsonDiv = eval('('+ node.innerHTML +')');
			}
			
			if (jsonDiv != null && jsonDiv != 'undefined') {
				return jsonDiv;
			}
			
			return null;
		}
	}
}//-----------------------------------------------------------------
// Licensed Materials - Property of IBM
//
// WebSphere Commerce
//
// (C) Copyright IBM Corp. 2011, 2016 All Rights Reserved.
//
// US Government Users Restricted Rights - Use, duplication or
// disclosure restricted by GSA ADP Schedule Contract with
// IBM Corp.
//-----------------------------------------------------------------


/**
 * @fileOverview This file provides the common functions which are specific to the Mini Shopping cart
 */

/**
 * map order_updated to all the services that result in changes to an order
 * @static
 */

var order_updated = {
    'AjaxAddOrderItem': 'AjaxAddOrderItem',
    'AddOrderItem': 'AddOrderItem',
    'AjaxAddOrderItemWithShipingInfo': 'AjaxAddOrderItemWithShipingInfo',
    'AjaxDeleteOrderItem': 'AjaxDeleteOrderItem',
    'AjaxUpdateOrderItem': 'AjaxUpdateOrderItem',
    'AjaxUpdateOrderShippingInfo': 'AjaxUpdateOrderShippingInfo',
    'AjaxOrderCalculate': 'AjaxOrderCalculate',
    'AjaxLogoff': 'AjaxLogoff',
    'AjaxSetPendingOrder': 'AjaxSetPendingOrder',
    'AjaxUpdatePendingOrder': 'AjaxUpdatePendingOrder',
    'AjaxSingleOrderCancel': 'AjaxSingleOrderCancel',
    'AjaxUpdateRewardOption': 'AjaxUpdateRewardOption'
};

/** This variable indicates whether the mini cart drop down is updated or not. */
var dialogWidget,
    update_content = false,
    dropdownUpdated = false,
    /** This is variable indicates whether the mini cart drop down is being initialized. */
    dropdownInit = false,
    productAddedList = {};

function declareMiniShoppingCartRefreshArea() {

    // ============================================
    // initialize refresh area widgets
    // ============================================

    // ============================================
    // div: MiniShoppingCart refresh area
    // Declares a new refresh controller for the Mini Shopping Cart.

    // declare render context
    wcRenderContext.declare("MiniShoppingCartContext", ["MiniShoppingCart"], { status: "init" });

    /*
    /* Refreshes the mini shopping cart.
     * This function is called when a render context changed event is detected.
     */
    var renderContextChangedHandler = function() {
        if (wcRenderContext.testForChangedRC("MiniShoppingCartContext", ["status"])) {
            wcRenderContext.getRenderContextProperties("MiniShoppingCartContext").deleteCartCookie = true;
            $("#MiniShoppingCart").refreshWidget("refresh", wcRenderContext.getRenderContextProperties("MiniShoppingCartContext"));
        }
    };

    // model change
    /*
     * Refreshes the mini shopping cart.
     * If a new order item is added via an Ajax service call, set the mini shopping cart to display the new order item in the dropdown.
     * Otherwise, only refresh the contents of mini shopping cart to the updated order information.
     * This function is called when a modelChanged event is detected.
     *
     * @param {string} event The model changed event
     * @param {object} returnData The data returned from the event
     */
    var events = $.extend({}, order_updated, { "AjaxDeleteOrderItemForShippingBillingPage": "AjaxDeleteOrderItemForShippingBillingPage" });
    wcTopic.subscribe(events, function(returnData) {
        var param = [];
        if (returnData.actionId == 'AddOrderItem') {
            if (returnData.data.orderItem != null && returnData.data.orderItem[0].orderItemId != null) {
                var addedOrderItemIdString = "";
                for (var i = 0; i < returnData.data.orderItem.length; i++) {
                    if (addedOrderItemIdString !== "") {
                        addedOrderItemIdString += ",";
                    }
                    addedOrderItemIdString += returnData.data.orderItem[i].orderItemId;
                }
                param.addedOrderItemId = addedOrderItemIdString;
            } else {
                param.addedOrderItemId = returnData.data.orderItemId + "";
            }
            showDropdown = true;
        }
        param.deleteCartCookie = true;
        if (returnData.data.addedFromSKUList != null && returnData.data.addedFromSKUList[0] != null) {
            param.addedFromSKUList = returnData.data.addedFromSKUList[0];
        }
        $("#MiniShoppingCart").refreshWidget("refresh", param);
    });

    var postRefreshHandler = function() {
        //The dialog contents has changed..so destroy the old dialog with stale data..
        destroyDialog("MiniShopCartProductAdded");

        if (showDropdown) {
            update_content = true;
            //We have added item to cart..So display the drop down with item added message..
            positionMiniShopCartDropDown("widget_minishopcart", 'MiniShopCartProductAdded', 'orderItemAdded');
            showDropdown = false;
        }

        if (!multiSessionEnabled) {
            updateCartCookie();
        }

        populateProductAddedDropdown();

        if (!multiSessionEnabled) {
            resetDeleteCartCookie();
        }
    };

    // initialize widget
    $("#MiniShoppingCart").refreshWidget({ renderContextChangedHandler: renderContextChangedHandler, postRefreshHandler: postRefreshHandler });
}

function declareMiniShopCartContentsRefreshArea() {
    // ============================================
    // div: MiniShopCartContents refresh area
    // Declares a new refresh controller for the Mini Shopping Cart contents

    // Declares a new render context for the Mini Shopping Cart contents.
    wcRenderContext.declare("MiniShopCartContentsContext", ["MiniShopCartContents"], { status: "init", relativeId: "", contentId: "", contentType: "" });

    /*
     * Refreshes the mini shopping cart contents since it is out of date.
     * This function is called when a render context changed event is detected.
     */
    var renderContextChangedHandler = function(event, data) {
        if (!dropdownUpdated) {
            wcRenderContext.getRenderContextProperties("MiniShopCartContentsContext").fetchCartContents = true;
            dropdownUpdated = true;
            $("#MiniShopCartContents").refreshWidget("refresh", wcRenderContext.getRenderContextProperties("MiniShopCartContentsContext"));
        }
    };

    /*
     * Indicate that the mini cart contents are out of date upon an order change action.
     * This function is called when a modelChanged event is detected.
     */
    var events = $.extend({}, order_updated, { "AjaxDeleteOrderItemForShippingBillingPage": "AjaxDeleteOrderItemForShippingBillingPage", "AjaxRESTOrderLockUnlockOnBehalf": "AjaxRESTOrderLockUnlockOnBehalf" });
    wcTopic.subscribe(events, function() {
        dropdownUpdated = false;
    });

    /*
     * Displays and positions the mini shop cart contents.
     * This function is called after a successful refresh.
     */
    var postRefreshHandler = function() {
        var renderContextProperties = wcRenderContext.getRenderContextProperties("MiniShopCartContentsContext");
        positionMiniShopCartDropDown(renderContextProperties.relativeId, renderContextProperties.contentId, renderContextProperties.contentType);
        //
        // This is needed for CSR solution. When CSR and shopper are browsing the store in simultaenously in
        // different browsers and if CSR locks/unlocks the shoppers cart, the miniCart in shopper's browser will
        // NOT reflect the change unless shopper takes some order related actions (add/delete from cart).
        // So to update the miniCart status loadMiniCart() function is called here.
        // It doesn't make another server call. The data returned from the MiniCartContentsUI is used
        // to refresh the miniCart summary.
        //
        updateCartCookie();
        loadMiniCart(WCParamJS.commandContextCurrency, WCParamJS.langId);
    };

    // initialize widget
    $("#MiniShopCartContents").refreshWidget({ renderContextChangedHandler: renderContextChangedHandler, postRefreshHandler: postRefreshHandler });

}

/*
 * Displays the dropdown content of the mini shopping cart when the user hovers over the
 * mini shopping cart if the contents are up-to-date or retrieve the latest contents from server.
 *
 * @param {string} relativeId The id of a placeholder element to position the dropdown relatively
 * @param {string} contentId The id of the content pane containing the mini shopping cart dropdown contents
 * @param {string} contentType The content that will be shown in the expanded mini shopping cart dropdown.
 */
function showMiniShopCartDropDown(relativeId, contentId, contentType) {
    //isOnPasswordUpdateForm flag is set at UpdatePasswordForm.jsp, in other cases the variable type will always be undefined or value equals false.
    // Need this line otherwise it'll throw a isOnPasswordUpdateForm is undefined error
    var isOnPasswordUpdateForm = isOnPasswordUpdateForm;
    if (!dropdownInit && (Utils.isUndefined(isOnPasswordUpdateForm) || isOnPasswordUpdateForm == false)) {
        dropdownInit = true;
        if (!dropdownUpdated) {
            update_content = true;
            var params = {
                status: "load",
                relativeId: relativeId,
                contentId: contentId,
                contentType: contentType,
                page_view: "dropdown"
            };
            wcRenderContext.updateRenderContext("MiniShopCartContentsContext", params);
        } else {
            positionMiniShopCartDropDown(relativeId, contentId, contentType);
        }
    }
}

function toggleMiniShopCartDropDown(relativeId, contentId, contentType) {
    if (dialogWidget && dialogWidget._isOpen) {
        dialogWidget.close();
    } else {
        showMiniShopCartDropDown(relativeId, contentId, contentType);
    }
}

/*
 * Displays the dropdown content of the mini shopping cart.
 *
 * @param {string} relativeId The id of a placeholder element to position the dropdown relatively
 * @param {string} contentId The id of the content pane containing the mini shopping cart dropdown contents
 * @param {string} contentType The content that will be shown in the expanded mini shopping cart dropdown.
 */
function positionMiniShopCartDropDown(relativeId, contentId, contentType) {
    var add_event_handlers = function(contentElement) {
        contentElement.on("wcdialogopen", function(event) {
            //deactivate(document.getElementById("header"));
            $("#" + relativeId).addClass("selected");
        });

        contentElement.on("wcdialogclose", function(event) {
            $("#" + relativeId).removeClass("selected");
        });
    };

    // Dialog is not yet created..Create one
    if (!dialogWidget) {
        var content = $("#" + contentId);
        if (contentId === "MiniShopCartProductAdded") {
            // The content may have been hidden so show it
            $("#MiniShopCartProductAddedWrapper").removeAttr("style");
        }
        dialogWidget = content.WCDialog({
            position: {
                my: "right top",
                at: "right bottom",
                of: "#widget_minishopcart"
            },
            autoOpen: false,
            open: function() {
                // Make the element show up on top of the header elements
                dialogWidget.element.parent().css("z-index", 1);


                if (contentType == 'orderItemAdded') {
                    $("#MiniShopCartProductAddedWrapper").css("display", "block");
                }
            },
            appendTo: "#headerRow1",
            title: $("#" + contentId + "_ACCE_Label").html(),
            show_title: false,
            width: "360px",
            //dialogClass: "no-close",
            modal: false


        }).data("wc-WCDialog");
        add_event_handlers(content);
        update_content = false;
		
		/* APPLEPAY BEGIN */
		if (typeof(showApplePayButtons) == "function") {
			showApplePayButtons();
		}
		/* APPLEPAY END */

    } else {
        dialogWidget.close();
        if (update_content) {
            if (contentType == 'orderItemAdded') {
                $("#MiniShopCartProductAddedWrapper").css("display", "block");
            }
            var newContent = $("#" + contentId);
            dialogWidget.update_content("#" + contentId);
            add_event_handlers(newContent);
            update_content = false;
        }

    }

    if (Utils.get_IE_version() < 7) {
        dialogWidget.css("display", "block");
    }

    $("html, body").animate({
        scrollTop: 0
    }, {
        duration: 200,
        complete: function() {
            dialogWidget.open();
            dialogWidget.reposition();
        }
    });

    dropdownInit = false;
}

/*
 * Store the current mini cart information in the mini cart cookie.
 */
function updateCartCookie() {
    //Save current order information into cookie
    if ($("#currentOrderQuantity").length && $("#currentOrderAmount").length && $("#currentOrderCurrency").length && $("#currentOrderId").length && $("#currentOrderLanguage").length) {
        var cartQuantity = $("#currentOrderQuantity").val();
        var cartAmount = $("#currentOrderAmount").val();
        var cartCurrency = $("#currentOrderCurrency").val();
        var cartLanguage = $("#currentOrderLanguage").val();
        var cartOrderId = $("#currentOrderId").val();
        var currentOrderLocked = $("#currentOrderLocked").val();

        //Clear out previous cookies
        var orderIdCookie = getCookie("WC_CartOrderId_" + WCParamJS.storeId);
        if (orderIdCookie != null) {
            setCookie("WC_CartOrderId_" + WCParamJS.storeId, null, {
                expires: -1,
                path: '/',
                domain: cookieDomain
            });
            var cartTotalCookie = getCookie("WC_CartTotal_" + orderIdCookie);
            if (cartTotalCookie != null) {
                setCookie("WC_CartTotal_" + orderIdCookie, null, {
                    expires: -1,
                    path: '/',
                    domain: cookieDomain
                });
            }
        }
        setCookie("WC_CartOrderId_" + WCParamJS.storeId, cartOrderId, {
            path: '/',
            domain: cookieDomain
        });
        if (cartOrderId !== "") {
            setCookie("WC_CartTotal_" + cartOrderId, cartQuantity + ";" + cartAmount + ";" + cartCurrency + ";" + cartLanguage + ";" + currentOrderLocked, {
                path: '/',
                domain: cookieDomain
            });
        }
    } else {
        setCookie("WC_CartOrderId_" + WCParamJS.storeId, "", { path: '/', domain: cookieDomain });
    }
}

function setProductAddedList(newProductAddedList) {
    productAddedList = newProductAddedList;
}

/*
 * Populates the Product Added dropdown upon an add to cart action.
 */
function populateProductAddedDropdown() {

    var search = '"';

    var replaceStr = "'";
    for (productId in productAddedList) {
        var productDetails = productAddedList[productId];

        if ($("#MiniShopCartAddedProdName_" + productId).length && productDetails[0] != null && productDetails[0].length != 0) {
            $("#MiniShopCartAddedProdName_" + productId).html(productDetails[0]);
        }
        if ($("#MiniShopCartAddedProdImgSrc_" + productId).length && productDetails[1] != null && productDetails[1].length != 0) {
            $("#MiniShopCartAddedProdImgSrc_" + productId).attr("src", productDetails[1]);
            document.getElementById('MiniShopCartAddedProdImgSrc_' + productId).alt = productDetails[0];
        }
        if ($("#MiniShopCartAddedProdPrice_" + productId).length && productDetails[2] != null && productDetails[2].length != 0) {
            $("#MiniShopCartAddedProdPrice_" + productId).html(productDetails[2]);
        }
        if ($("#MiniShopCartAddedProdQty_" + productId).length && productDetails[3] != null && productDetails[3].length != 0) {
            $("#MiniShopCartAddedProdQty_" + productId).html(productDetails[3]);
        }

        if ($("#MiniShopCartAddedProdAttr_" + productId).length && productDetails[4] != null && productDetails[4].length != 0) {
            $("#MiniShopCartAddedProdAttr_" + productId).html("");

            for (attrName in productDetails[4]) {
                attrValue = productDetails[4][attrName];
                if (attrValue != null && attrValue != 'undefined') {
                    attrValue = attrValue.replace(/&amp;/g, "&").replace(/&#039;/g, "'").replace(/&#034;/g, '"').replace(replaceStr, search);
                }
                document.getElementById('MiniShopCartAddedProdAttr_' + productId).innerHTML += '<div>' + attrName + ': ' + attrValue + '</div>';
            }
        }
    }
    wcTopic.publish("ProductInfo_Reset");
}

/*
 * Loads mini shop cart info upon page load.
 * @param {String} contextCurrency Current currency selected.
 * @param {String} langId Current language selected.
 */
function loadMiniCart(contextCurrency, langId) {
    var updateCart = false;

    var orderIdCookie = getCookie("WC_CartOrderId_" + WCParamJS.storeId);

    if (checkDeleteCartCookie()) {
        updateCart = true;
    } else if (orderIdCookie != undefined && orderIdCookie === "") {
        var subtotal = document.getElementById("minishopcart_subtotal");
        var formattedSubtotal = null;
        if ($("#currentOrderAmount").length) {
            formattedSubtotal = Utils.formatCurrency($("#currentOrderAmount").val(), {
                currency: contextCurrency
            });
        }
        if (formattedSubtotal == null && $("#currentOrderAmount").length) {
            formattedSubtotal = $("#currentOrderAmount").val();
        }

        if (subtotal != null) {
            subtotal.innerHTML = "\n " + formattedSubtotal + "\n ";
        }
        var items = document.getElementById("minishopcart_total");
        if (items != null) {
            var itemsMsg = null;
            if ($("#currentOrderQuantity").length) {
                itemMsg = $("#currentOrderQuantity").val();
            }
            if (itemsMsg == null) {
                itemsMsg = "0";
            }
            items.innerHTML = "\n " + itemsMsg + "\n ";
        }
    } else if (orderIdCookie != undefined && orderIdCookie !== "") {
        var cartCookie = getCookie("WC_CartTotal_" + orderIdCookie);

        if (cartCookie != undefined && cartCookie != null && cartCookie !== "") {
            var orderInfo = cartCookie.split(";");

            if (orderInfo != null && orderInfo.length > 3) {
                if (orderInfo[2] == contextCurrency && orderInfo[3] == langId) {
                    var subtotal = document.getElementById("minishopcart_subtotal");
                    if (subtotal != null) {
                        var formattedSubtotal = null;
                        formattedSubtotal = Utils.formatCurrency(orderInfo[1].toString(), {
                            currency: contextCurrency
                        });
                        if (formattedSubtotal == null) {
                            formattedSubtotal = orderInfo[1].toString();
                        }
                        subtotal.innerHTML = "\n " + formattedSubtotal + "\n ";
                    }
                    var currentOrderLocked = false;
                    if (orderInfo[4] != null && orderInfo[4] == 'true') {
                        var currentOrderLocked = true;
                    }
                    var items = document.getElementById("minishopcart_total");
                    var lock = document.getElementById("minishopcart_lock");
                    if (items != null) {
                        var itemsMsg = orderInfo[0].toString();
                        items.innerHTML = "\n " + itemsMsg + "\n ";
                        if (currentOrderLocked) {
                            $(items).addClass("nodisplay");
                            $(lock).removeClass("nodisplay");
                        } else {
                            $(items).removeClass("nodisplay");
                            $(lock).addClass("nodisplay");
                        }
                    }
                } else {
                    updateCart = true;
                }
            } else {
                updateCart = true;
            }
        } else {
            updateCart = true;
        }
    } else {
        updateCart = true;
    }
    //isOnPasswordUpdateForm flag is set at UpdatePasswordForm.jsp, in other cases the variable type will always be undefined or value equals false.
    // Need this line otherwise it'll throw a isOnPasswordUpdateForm is undefined error
    var isOnPasswordUpdateForm = isOnPasswordUpdateForm;
    if (updateCart == true && (Utils.isUndefined(isOnPasswordUpdateForm) || isOnPasswordUpdateForm == false)) {
        wcRenderContext.updateRenderContext('MiniShoppingCartContext', {
            'status': 'load'
        });
    }
}

/*
 * Turn on the flag to indicate that the mini cart cookies should be refreshed.
 */
function setDeleteCartCookie() {
    setCookie("WC_DeleteCartCookie_" + WCParamJS.storeId, true, {
        path: '/',
        domain: cookieDomain
    });
}

/*
 * Check whether the mini cart cookies need to be updated or not.
 */
function checkDeleteCartCookie() {
    var deleteCartCookieVal = getCookie("WC_DeleteCartCookie_" + WCParamJS.storeId);

    if (deleteCartCookieVal != undefined && deleteCartCookieVal !== "") {
        if (deleteCartCookieVal == 'true') {
            return true;
        }
    }
    return false;
}

/*
 * Delete the flag that indicates the mini cart cookie should be refreshed.
 */
function resetDeleteCartCookie() {
    var deleteCartCookieVal = getCookie("WC_DeleteCartCookie_" + WCParamJS.storeId);

    if (deleteCartCookieVal != null) {
        setCookie("WC_DeleteCartCookie_" + WCParamJS.storeId, null, {
            expires: -1,
            path: '/',
            domain: cookieDomain
        });
    }
}
wcTopic.subscribe("ProductInfo_Added", setProductAddedList);//-----------------------------------------------------------------
// Licensed Materials - Property of IBM
//
// WebSphere Commerce
//
// (C) Copyright IBM Corp. 2011, 2016 All Rights Reserved.
//
// US Government Users Restricted Rights - Use, duplication or
// disclosure restricted by GSA ADP Schedule Contract with
// IBM Corp.
//-----------------------------------------------------------------

if (typeof (ProductTabJS) == "undefined" || ProductTabJS == null || !ProductTabJS) {

    ProductTabJS = {
        lastTabId: null,
        /**
         * To make the tab selected and remove all other tabs from the tab order
         * See http://www.w3.org/TR/wai-aria-practices/#tabpanel for ARIA best practices
         * 
         * @param {String} tabId The ID of the tab to be selected
         */
        selectTab: function (tabId) {
            $("div.tab_container").each(function (i, tab) {
                $(tab).attr("aria-selected", "false")
                      .attr("class", "tab_container inactive_tab")
                      .attr("tabindex", "-1");
            });
            $("div.tab").each(function (i, tabPanel) {
                $(tabPanel).css("display", "none");
            });

            $("#" + tabId).attr("aria-selected", "true")
                          .attr("tabindex", "0")
                          .attr("class", "tab_container active_tab");
            $("#" + tabId + "Widget").css("display", "block");
            $("#" + tabId + "Widget").each(function (i, widget) {
                if (widget.resize) {
                    widget.resize();
                }
            });

            if (this.lastTabId == null || this.lastTabId != tabId) {
                this.lastTabId = tabId;
            }
        },

        /**
         * To select the previous or next tab with the keyboard arrow keys.  If there are no more tabs to the
         * left or right, wrap to the other end of the tab list.  
         * See http://www.w3.org/TR/wai-aria-practices/#tabpanel for ARIA best practices
         * 
         * @param {int} tabIndex The index of the tab to be selected
         * @param {int} tabSetSize The number of total tabs in the tablist
         * @param {event} event
         */
        selectTabWithKeyboard: function (tabIndex, tabSetSize, event) {
            if (event.keyCode == keys.DOWN_ARROW || event.keyCode == keys.RIGHT_ARROW) {
                tabIndex++;
                if ($("#tab" + tabIndex)) {
                    this.selectTab("tab" + tabIndex);
                    this.focusTab("tab" + tabIndex);
                } else {
                    this.selectTab("tab1");
                    this.focusTab("tab1");
                }
                this.cancelEvent(event);
            }

            if (event.keyCode == keys.UP_ARROW || event.keyCode == keys.LEFT_ARROW) {
                if ($("#tab" + (tabIndex - 1))) {
                    this.selectTab("tab" + (tabIndex - 1));
                    this.focusTab("tab" + (tabIndex - 1));
                } else {
                    this.selectTab("tab" + tabSetSize);
                    this.focusTab("tab" + tabSetSize);
                }
                this.cancelEvent(event);
            }
        },

        /**
         * Stop event propagation
         * 
         * @param {event} e
         */
        cancelEvent: function (e) {
            Utils.stopEvent(e);
        },

        /**
         * To bring the focus to the tab
         * 
         * @param {String} tabId The ID of the tab to be selected
         */
        focusTab: function (tabId) {
            if ($("#" + tabId).hasClass("focused_tab")) {
                $("> div", "#" + tabId).css("border", "1px dotted #000000");
                return;
            } else {
                $("#" + tabId).addClass("focused_tab");
                $("> div", $("#" + tabId)).css("border", "1px dotted #000000");
                $("#" + tabId).focus();
            }
        },

        /**
         * To take the focus out from the tab
         * 
         * @param {String} tabId The ID of the tab to be selected
         */
        blurTab: function (tabId) {
            $(tabId).removeClass("focused_tab");
            $("> div", "#" + tabId).css("border", "1px solid transparent");
        }
    };
}
//-----------------------------------------------------------------
// Licensed Materials - Property of IBM
//
// WebSphere Commerce
//
// (C) Copyright IBM Corp. 2011, 2016 All Rights Reserved.
//
// US Government Users Restricted Rights - Use, duplication or
// disclosure restricted by GSA ADP Schedule Contract with
// IBM Corp.
//-----------------------------------------------------------------
if(typeof(QuickInfoJS) == "undefined" || QuickInfoJS == null || !QuickInfoJS) {
	
	QuickInfoJS = {
		productImgDimensions: "1000x1000",
		quickInfoImgDimensions: "330x330",
		catEntryParams: {},
		selectedAttributes: new Object(),
		catEntryQuantity: 1,
		itemDetailsArr: new Object(),
		params: null,
		replaceOrderItemId: '', // the orderItemId to be replaced after changing the attributes
		itemId: '', // the current item in the cart to be replaced
		selectedSkuIndex: null, // selected sku index
		selectedThumbnailIndex: null, // selected thumbnail index
		
		/**
		 * Sets the replaceOrderItemId
		 */
		setReplaceOrderItemId: function(replaceOrderItemId){
			this.replaceOrderItemId = replaceOrderItemId;
		},
		
		/**
		 * Sets other values
		 */
		setValues: function(){
			if ($("#catEntryParamsForJS").length){
				this.catEntryParams = $.parseJSON($("#catEntryParamsForJS").val());
			}
			
			this.catEntryParams.attributes = this.selectedAttributes;
		},
		
		/**
		 * Setter for catEntryQuantity
		 * 
		 * @param Integer catEntryQuantity
		 */
		setCatEntryQuantity: function(catEntryQuantity){
			this.catEntryQuantity = catEntryQuantity;
		},
		
		/**
		 * To display quick info details
		 * 
		 * @param {String} productId
		 * @param {Object} params
		 * @param {String} itemId
		 * @param {String} quantity
		 */
		showDetails: function(productId, params, itemId, quantity, parentPage){
			/*
			 * If showDetails is called from merchandising association,
			 * params will be filled with cat entry of the first product to be added to shopping cart
			 */ 
			if(params){
				this.params = params;
			} else {
				// resetting to null, if no params passed
				this.params = null;
			}
			// Clearing the selected attributes
			this.selectedAttributes = new Object();
			this.selectedSkuIndex = null; // clearing selected sku index
			this.selectedThumbnailIndex = null; // clearing selected thumbnail index
			
			// For Handling multiple clicks.
			if(!submitRequest()){
				return;
			}
			this.close();
			cursor_wait();

			var contextValues = this.setCommonParams();
			if(itemId){
				this.itemId = itemId;
				contextValues.updateAttributes = "true";
			} else {
				this.itemId = '';
				contextValues.updateAttributes = "false";
			}
			if (parentPage) {
				contextValues.parentPage = parentPage;
			}
			
			if(quantity){
				this.catEntryQuantity = quantity;
			}
			
			contextValues.productId = productId;
			wcRenderContext.updateRenderContext('QuickInfoContext', contextValues);
		},
		
		/**
		 * To display quick info details - to change attribute values
		 * 
		 * @param {String} orderItemId
		 * @param {String} productId
		 * @param {String} itemId
		 * @param {String} quantity
		 */
		changeAttributes: function(orderItemId, productId, itemId, quantity){
			this.setReplaceOrderItemId(orderItemId);
			this.showDetails(productId, null, itemId, quantity);
		},
		
		/**
		 * Change the main image based on the angle thumbnail clicked
		 * 
		 */
		changeImage: function(elementId, imgSrc){
			this.selectedThumbnailIndex = elementId-1;
			$("#quickInfoMainImage").attr("src", this.getQuickInfoImage(this.catEntryParams.skus[this.selectedSkuIndex].thumbnailAttachments[this.selectedThumbnailIndex].path))
			$(".widget_quick_info_popup .other_views li").removeClass("selected");
			if (isProduct === 'true') {
				$("#quickInfoProductThumbnail" + elementId).addClass("selected");
			} else {
				$("#quickInfoThumbnail" + elementId).addClass("selected");
			}
		},
		
		/**
		* setSelectedAttribute Sets the selected attribute value for a particular attribute not in reference to any catalog entry.
		*					   When an attribute is selected from that drop down this method is called to update the selected value for that attribute.
		*
		* @param {String} selectedAttributeName The name of the attribute.
		* @param {String} selectedAttributeValue The value of the selected attribute.
		*
		*/
		setSelectedAttribute : function(selectedAttributeName , selectedAttributeValue){ 
			this.selectedAttributes[selectedAttributeName] = selectedAttributeValue;
		},
		
		/**
		 * To notify the change in attribute to other components that is subscribed to attributesChanged event.
		 */
		notifyAttributeChange: function(){
			wcTopic.publish('QuickInfo_attributesChanged', [JSON.stringify(this.selectedAttributes)]);
			this.setValues();
			var catEntryId = this.resolveSKU();
			if (catEntryId != -1) {
				wcTopic.publish('DefiningAttributes_Resolved', catEntryId, this.catEntryParams.id);
				QuickInfoJS.selectItem(true);
			}
			else {
				wcTopic.publish('DefiningAttributes_Resolved', null, null);
				var attrSelected = false;
				for (var attribute in this.selectedAttributes) {
					if (this.selectedAttributes[attribute] !== null && this.selectedAttributes[attribute] !== '') {
						attrSelected = true;
					}
				}
				
				if (!attrSelected) {
					$("div[id^='quickinfoAngleImagesArea']").css("display", 'none');
					$("div[id^='quickinfoProductAngleImagesArea']").css("display", 'block');
					
					this.showDetails(this.catEntryParams.id, null, null, null, '');
				}
			}
		},
		
		/**
		 * Selects the sku and updates the item name and price.
		 * 
		 * @param {Boolean} displayPriceRange If the value is true, then display the price range. If it is false then do not display the price range.
		 * @param {Boolean} updateItemImageOnly If the value is true, then only change the item image. If it is false then update all product details.
		 */
		selectItem: function(displayPriceRange, updateItemImageOnly){
			this.displayPriceRange = displayPriceRange;
			this.setValues();
			var catEntryId = this.resolveSKU();

			if(catEntryId == -1 && updateItemImageOnly){
				var skuId = -1;
				for(idx=0;idx<this.catEntryParams.skus.length;idx++){
					for(attribute in this.catEntryParams.skus[idx].attributes){
						if(this.catEntryParams.attributes && this.catEntryParams.skus[idx].attributes[attribute] == this.catEntryParams.attributes[attribute]){
							skuId = this.catEntryParams.skus[idx].id;
							break;
						}
					}
				}
				if(skuId != -1){
					catEntryId = skuId;
					this.updateItemImageOnly = updateItemImageOnly;
				}		
			}
			
			if(catEntryId!=-1){
				//check if the object is already present for the catEntryId.
				if(this.itemDetailsArr[catEntryId] != null && this.itemDetailsArr[catEntryId] != 'undefined'){
					this.displayItemDetails(this.itemDetailsArr[catEntryId]);
				}
				//if json object is not present, call the service to get the details.
				else{
					var params = this.setCommonParams();
					params.catalogEntryId = catEntryId;

					//Declare a service for retrieving catalog entry detailed information for an item...
					wcService.declare({
						id: "getCatalogEntryDetailsQI",
						actionId: "getCatalogEntryDetailsQI",
						url: getAbsoluteURL() + appendWcCommonRequestParameters("GetCatalogEntryDetailsByIDView"),
						formId: ""

						,successHandler: function(serviceResponse, ioArgs) {
							QuickInfoJS.setItemDetails(serviceResponse, ioArgs);
						}

						,failureHandler: function(serviceResponse, ioArgs) {
							console.debug("QuickInfoJS.selectItem: Unexpected error occurred during an xhrPost request.");
						}

					});
					wcService.invoke("getCatalogEntryDetailsQI", params);
				}
			}
		},
		
		/**
		* Handles the case when a swatch is selected. Set the border of the selected swatch.
		* @param {String} selectedAttributeName The name of the selected swatch attribute.
		* @param {String} selectedAttributeValue The value of the selected swatch attribute.
		* @param {String} swatchId id of the swatch element
		* @param {String} swatchGrp starting pattern of id of the swatch element group
		* 
		**/
		selectSwatch: function(selectedAttributeName, selectedAttributeValue, swatchId, swatchGrp) {
			if($("[id='quickInfoSwatch_" + selectedAttributeName + "_" + selectedAttributeValue + "']").hasClass("color_swatch_disabled")){
				return false;
			}
			// sets the store parameters and catalog details from the hidden fields
			this.setValues();
			// picks all the swatch names
			var swatchNames = $("#WC_QuickInfo_SwatchNames").val().split("_");
			// identifies the position of the current swatch
			var currentSwatchPos = -1;
			for(var i=0; i<swatchNames.length;i++){
				if(swatchNames[i] == selectedAttributeName){
					currentSwatchPos = i;
					break;
				}
			}
			var currentSwatchkey = "quickInfoSwatch_" + selectedAttributeName + "_" +selectedAttributeValue;
			var currentSwatchkeyLink = "WC_QuickInfo_Swatch_" + selectedAttributeName + "_" +selectedAttributeValue;
			var validSwatchArr = new Array();
			// iterates through each sku and its attributes to identify valid attribute combination
			for(idx in this.catEntryParams.skus){
				var validItem = false;
				var entitledItem = this.catEntryParams.skus[idx];
				for(attribute in entitledItem.attributes){
					
					if(selectedAttributeName == attribute && selectedAttributeValue == entitledItem.attributes[attribute] && entitledItem.buyable){
						validItem = true;
						break;
					}
				}
				if(validItem){
					for(attribute in entitledItem.attributes){
						var attributePos = -1;
						for(var i=0; i<swatchNames.length;i++){
							if(swatchNames[i] == attribute){
								attributePos = i;
								break;
							}
						}						
						if(attributePos > currentSwatchPos){
							// picks the valid swatch attributes for the current swatch selection
							validSwatchArr.push(attribute + "_" + entitledItem.attributes[attribute]);
						}
					}
				}
			}
			
			var swatchesDisabled = new Array();
			var selectedSwatches = new Array();
			for(idx in this.catEntryParams.skus){
				var entitledItem = this.catEntryParams.skus[idx];
				for(attribute in entitledItem.attributes){
					var attributePos = -1;
					for(var i=0; i<swatchNames.length;i++){
						if(swatchNames[i] == attribute){
							attributePos = i;
							break;
						}
					}											
					if(attributePos > currentSwatchPos){
						var swatchSelection = attribute + "_" + entitledItem.attributes[attribute];
						var swatchId = "quickInfoSwatch_" + swatchSelection;
						var swatchLinkId = "WC_QuickInfo_Swatch_" + swatchSelection;
						var validSwatchArrPos = -1;
						for(var i=0; i<validSwatchArr.length;i++){
							if(validSwatchArr[i] == swatchSelection){
								validSwatchArrPos = i;
								break;
							}
						}								
						var swatchesDisabledPos = -1;
						for(var i=0; i<swatchesDisabled.length;i++){
							if(swatchesDisabled[i] == swatchSelection){
								swatchesDisabledPos = i;
								break;
							}
						}								
						// enable valid swatches
						if(validSwatchArrPos > -1){
							if(!$("[id='" + swatchId + "']").hasClass("color_swatch_selected")){
								$("[id='" + swatchId + "']").attr("class", "color_swatch");
								$("[id='" + swatchId + "']").attr("src", $("[id='" + swatchId + "']").attr("src").replace("_disabled.png","_enabled.png"))
								$("[id='" + swatchLinkId + "']").attr("aria-disabled", "false");
							}
						} 
						// disable invalid swatches
						else if(swatchesDisabledPos == -1){
							swatchesDisabled.push(swatchSelection);
							if($("[id='" + swatchId + "']").hasClass("color_swatch_selected")){
								selectedSwatches.push(swatchId);
							}
							$("[id='" + swatchId + "']").attr("class", "color_swatch_disabled");
							$("[id='" + swatchId + "']").attr("src", $("[id='" + swatchId + "']").attr("src").replace("_enabled.png","_disabled.png"))
							$("[id='" + swatchLinkId + "']").attr("aria-disabled", "true");
						}
					}
					$("[id='WC_QuickInfo_Swatch_" + attribute + "_" + entitledItem.attributes[attribute] + "']").attr("aria-checked", "false");
				}
			}
			
			// if any of the disabled swatches were previously selected, change the selection to the first valid value
			for(idx in selectedSwatches){
				var selectedSwatch = selectedSwatches[idx];
				var idSelector = "img[id^='" + selectedSwatch.substring(0, selectedSwatch.lastIndexOf("_")) + "']";
				var swatchSelected = false;
				$(idSelector).each(function(index, node, arr){
					if(!swatchSelected && $(node).hasClass("color_swatch")){
						var values = node.id.split("_");
						QuickInfoJS.selectSwatch(values[1],values[2], "quickInfoSwatch_" + values[1] + "_" + values[2],"quickInfoSwatch_"+values[1]+"_");
						QuickInfoJS.selectItem(true);
						swatchSelected = true;
					}
				});
			}
			
			selector = "img[id^='"+swatchGrp+"']";
			
			$(selector).each(function(index, node, arr){
			    if(!$(node).hasClass("color_swatch_disabled")){
			    	$(node).addClass("color_swatch");
			    	if($(node).hasClass("color_swatch_selected")){
				    	$(node).removeClass("color_swatch_selected");
				    }
			    }
			});
			
			$("[id='" + currentSwatchkey + "']").attr("class", "color_swatch_selected");
			$("[id='quickinfo_swatch_selection_"+selectedAttributeName + "']").html(selectedAttributeValue)
			$("[id='" + currentSwatchkeyLink + "']").attr("aria-checked", "true");
			this.setSelectedAttribute(selectedAttributeName, selectedAttributeValue);
		},
		
		/**
		 * Sets the store specific values such as storeId, catalogId and langId in a Object and returns it.
		 * 
		 * @return {Object} params with store specific values
		 */
		setCommonParams: function(){
			var params = new Object();
			params.storeId		= WCParamJS.storeId;
			params.catalogId	= WCParamJS.catalogId;
			params.langId		= WCParamJS.langId;
			return params;
		},
		
		/** 
		 * Displays price of the catEntry selected with the JSON objrct returned from the server.
		 * 
		 * @param {object} serviceRepsonse The JSON response from the service.
		 * @param {object} ioArgs The arguments from the service call.
		 */
		setItemDetails: function(serviceResponse, ioArgs) {
			QuickInfoJS.itemDetailsArr[serviceResponse.catalogEntry.catalogEntryIdentifier.uniqueID] = serviceResponse.catalogEntry;
			QuickInfoJS.displayItemDetails(serviceResponse.catalogEntry);
		},
		
		displayItemDetails: function(catalogEntry) {
			if(null != this.catEntryParams){
				for(idx in this.catEntryParams.skus){
					if(null != this.catEntryParams.skus[idx] && (this.catEntryParams.skus[idx].id == catalogEntry.catalogEntryIdentifier.uniqueID)){
						var angleImageAreaList = $("div[id^='quickinfoAngleImagesArea']");
						var prodAngleImageAreaList = $("div[id^='quickinfoProductAngleImagesArea']");
						
						if(angleImageAreaList.length){
							var angleImageArea = angleImageAreaList[0];
						}
						if(this.catEntryParams.skus[idx].thumbnailAttachments != null && this.catEntryParams.skus[idx].thumbnailAttachments.length > 0){
							prodAngleImageAreaList.css("display", 'none');
                            
							var thumbnailAreaList = $("ul[id^='quickInfoAngleImagesAreaList']");
							if(thumbnailAreaList.length){
								var thumbnailArea = thumbnailAreaList[0];
								if(angleImageArea != null){
									$(angleImageArea).css("display", "block");
								}
								for(idx2 = 1; idx2 <= this.catEntryParams.skus[idx].thumbnailAttachments.length; idx2++){
									var angleThumbnail = document.createElement("li");						
									var angleThumbnailLink = document.createElement("a");
									var angleThumbnailImg = document.createElement("img");
									
									angleThumbnail.id = "quickInfoThumbnail" + idx2;
									
									angleThumbnailLink.href = "javaScript:QuickInfoJS.changeImage(" + idx2 + ",'" + this.catEntryParams.skus[idx].fullImageAttachments[idx2-1].path + "');";
									angleThumbnailLink.id = "WC_QuickInfo_Link_thumbnail_" + idx2;
									angleThumbnailLink.className = "tlignore";
									if(this.catEntryParams.skus[idx].thumbnailAttachments[idx2-1].shortDesc != 'undefined' && this.catEntryParams.skus[idx].thumbnailAttachments[idx2-1].shortDesc != null){
										angleThumbnailLink.title = this.catEntryParams.skus[idx].thumbnailAttachments[idx2-1].shortDesc;
									}
									
									angleThumbnailImg.src = this.catEntryParams.skus[idx].thumbnailAttachments[idx2-1].path;
									if(this.catEntryParams.skus[idx].thumbnailAttachments[idx2-1].shortDesc != 'undefined' && this.catEntryParams.skus[idx].thumbnailAttachments[idx2-1].shortDesc != null){
										angleThumbnailImg.alt = this.catEntryParams.skus[idx].thumbnailAttachments[idx2-1].shortDesc;
									}
									if(idx2 == 1){
										$(thumbnailArea).empty();							
									}						
									angleThumbnailLink.appendChild(angleThumbnailImg);
									angleThumbnail.appendChild(angleThumbnailLink);
									thumbnailArea.appendChild(angleThumbnail);
								}
							}
						} else {
							var prodDisplayClass = 'block';
							for (attribute in this.selectedAttributes){
								if(null != this.selectedAttributes[attribute] && '' != this.selectedAttributes[attribute]){
									prodDisplayClass = 'none';
								}
							}

							if(prodAngleImageAreaList != null){
								for(var i = 0; i < prodAngleImageAreaList.length; i++){			
									if(null != prodAngleImageAreaList[i]){
										$(prodAngleImageAreaList[i]).css("display", prodDisplayClass);
									}
								}
							}

							if (angleImageArea != null){
								$(angleImageArea).css("display", "none");
							}
						}
						if(null == this.selectedThumbnailIndex){
							this.selectedThumbnailIndex = 0;
						}
						this.selectedSkuIndex = idx;
						var imagePath = catalogEntry.description[0].thumbnail;
						if (null != imagePath && imagePath.length != 0){
							$("#quickInfoMainImage").attr("src", imagePath)
						}
						if ($("#ProductInfoImage_"+this.catEntryParams.id).length){
							document.getElementById("ProductInfoImage_"+this.catEntryParams.id).value = imagePath;
						}
					}
				}
			}
			
			if(this.updateItemImageOnly){	
				this.updateItemImageOnly = false;
				return;
			}
			
			$(".widget_quick_info_popup .main_header").first().html(catalogEntry.description[0].name);
			if ($("#ProductInfoName_"+this.catEntryParams.id).length){
				document.getElementById("ProductInfoName_"+this.catEntryParams.id).value = catalogEntry.description[0].name;
			}
			
			if(catalogEntry.listPriced && catalogEntry.listPrice > catalogEntry.offerPrice){
				if(null != $(".widget_quick_info_popup .old_price")[0]){
					$(".widget_quick_info_popup .old_price").first().html(catalogEntry.listPrice);
				} else {
					var oldPriceTag = "<span class='old_price'>" + catalogEntry.listPrice + "</span>";
					var priceTag = $(".widget_quick_info_popup .price")[0];
					$(oldPriceTag).before(priceTag);
				}
			} else if(null != $(".widget_quick_info_popup .old_price")[0]){
				$(".widget_quick_info_popup .old_price").remove();
			}
			$(".widget_quick_info_popup .price").first().html(catalogEntry.offerPrice);
			
			$(".widget_quick_info_popup .sku").first().html(Utils.getLocalizationMessage('SKU') + " " + catalogEntry.catalogEntryIdentifier.externalIdentifier.partNumber);

			if ($("#ProductInfoPrice_"+this.catEntryParams.id).length){
				document.getElementById("ProductInfoPrice_"+this.catEntryParams.id).value = catalogEntry.offerPrice;
			}
		},
		
		validate: function(){
			if(this.catEntryParams.type =='ProductBean' && 
					(null == this.catEntryParams.attributes || "undefined" == this.catEntryParams.attributes)) {
				MessageHelper.displayErrorMessage(Utils.getLocalizationMessage['ERR_RESOLVING_SKU']);
				return false;
			} else if(!isPositiveInteger(this.catEntryQuantity)){
				MessageHelper.displayErrorMessage(Utils.getLocalizationMessage['QUANTITY_INPUT_ERROR']);
				return false;
			}
			return true;
		},
		
		/**
		* add2ShopCart Adds displayed product to the shopping cart
		*
		*
		**/
		add2ShopCart: function(customParams){
			
			if (browseOnly){
				MessageHelper.displayErrorMessage(Utils.getLocalizationMessage['ERROR_ADD2CART_BROWSE_ONLY']); 
				return;
			}
			this.setValues();
			if(!this.validate()){
				return;
			}
			/* 
			 * params is null means, no product is waiting to be added to shopping cart.
			 * params will not be null if the call originated from merchandising association
			 */ 
			if(null == this.params){
				this.params = this.setCommonParams();
				this.params.orderId		= ".";
				// Remove calculations for performance
				// this.params.calculationUsage = "-1,-2,-5,-6,-7";
				this.params.inventoryValidation = "true";
				this.params.calculateOrder="0";
			}

			var productId = '';
			//Add the catalog entry to the cart.
			if(this.catEntryParams.type.toLowerCase() == 'itembean'
				|| this.catEntryParams.type.toLowerCase() == 'packagebean'
				|| this.catEntryParams.type.toLowerCase() == 'dynamickitbean'){
				updateParamObject(this.params,"catEntryId",this.catEntryParams.id,false,-1);
				updateParamObject(this.params,"quantity",this.catEntryQuantity,false,-1);
				productId = this.catEntryParams.id;
			} else {
				// Resolve ProductBean to an ItemBean based on the attributes in the main page
				var sku = this.resolveSKU();
				if(-1 == sku){
					MessageHelper.displayErrorMessage(Utils.getLocalizationMessage['ERR_RESOLVING_SKU']);
					return;
				} else {
					updateParamObject(this.params,"catEntryId",sku,false,-1);
					updateParamObject(this.params,"quantity",this.catEntryQuantity,false,-1);
				}
				productId = sku;
			}
			
			var shopCartService = "AddOrderItem";
			
			//Pass any other customParams set by other add on features
			if(customParams != null && customParams != 'undefined'){
				for(i in customParams){
					this.params[i] = customParams[i];
				}
				if(customParams['catalogEntryType'] == 'dynamicKit' ){
					shopCartService = "AddPreConfigurationToCart";
				}
			}
			if(this.params['catalogEntryType'] == 'dynamicKit' ){
				shopCartService = "AddPreConfigurationToCart";
			}
			
			shoppingActionsJS.saveAddedProductInfo(this.catEntryQuantity, this.catEntryParams.id, productId, this.selectedAttributes);

			this.close();
			
			//For Handling multiple clicks
			if(!submitRequest()){
				return;
			}   
			cursor_wait();		
			wcService.invoke(shopCartService, this.params);
		},
		
		/**
		 * This resolves the product SKUs to a single item by comparing the attributes selected by the user
		 * 
		 * @return {Integer} uniqueId, of the selected SKU.
		 * 					 -1, if no match found
		 */
		resolveSKU: function() {
			// if there is only one sku, no need to resolve.
			if(this.catEntryParams.skus.length == 1){
				return this.catEntryParams.skus[0].id;
			}
			for(idx=0;idx<this.catEntryParams.skus.length;idx++){
				var matches = 0;
				var attributeCount = 0;
				for(attribute in this.catEntryParams.skus[idx].attributes){
					attributeCount++;
					if(this.catEntryParams.attributes && this.catEntryParams.skus[idx].attributes[attribute] == this.catEntryParams.attributes[attribute]){
						matches++;
					} else {
						break;
					}
				}
				// if there are multiple skus for a product, there should be atleast one attribute for that product
				if(0 != matches && matches == attributeCount){
					return this.catEntryParams.skus[idx].id;
				}
			}
			return -1;
		},
		
		/** 
		 * Displays the Product Quick Info button.
		 * 
		 * @param {string} id The id of the div area to show.
		 */
		showQuickInfoButton: function(id){
            $("#" + id).css("visibility", "visible");
		},

		/** 
		 * Hides the Product Quick Info button.
		 * 
		 * @param {string} id The id of the div area to hide. 
		 */	
		hideQuickInfoButton: function(id){
            $("#" + id).css("visibility", "");
		},
		 
		/** 
		 * Overrides the hidePopupButton function above by also checking to see if the user clicks shift+tab.
		 * 
		 * @param {string} id The id of the div area to hide. 
		 * @param {event} event The keystroke event entered by the user. 
		 */	
		shiftTabHideQuickInfoButton: function(id, event){
			if ((event.shiftKey) && (event.keyCode === KeyCodes.TAB)){
				this.hideQuickInfoButton(id);
			} 
		},
		
		/**
		 * Close the quick info popup
		 */
		close: function(focusElement){
			$('#quickInfoPopup').WCDialog("close");
			if(focusElement !=null && focusElement !='undefined' && document.getElementById(focusElement)){
				document.getElementById(focusElement).focus();
			}
		},
		

		/**
		 * Sets the focus back to the product image after quick info is closed.
		 */
		setFocus: function(event){
			if(event.keyCode === KeyCodes.ESCAPE && $('#catEntryParamsForJS').length){
				var catEntryParams = $("#catEntryParamsForJS").val();
				var catEntryId = $.parseJSON(catEntryParams).id;
				if(document.getElementById('catalogEntry_img' + catEntryId)){
					document.getElementById('catalogEntry_img' + catEntryId).focus();
				}
			}
		},


		/**
		 * Selects first swatch element
		 */
		selectDefaultSwatch: function(){
			var swatchElement = $("a[id^='WC_QuickInfo_Swatch_']")[0];
			if(swatchElement){
				eval($(swatchElement).attr("href"));
			}
		},
		
		/**
		* replaceCartItem This function is used to replace an item in the shopping cart. This will be called from the shopping cart and checkout pages.
		*
		**/
		replaceCartItem : function(){
			this.setValues();
			if(!this.validate()){
				return;
			}

			var catalogEntryId = this.resolveSKU();
			if(-1 == catalogEntryId){
				MessageHelper.displayErrorMessage(Utils.getLocalizationMessage['ERR_RESOLVING_SKU']);
				return;
			}
			this.close();
			
			var addressId = "";
			var shipModeId = "";
			var physicalStoreId = "";
			var typeId = $("#shipmentTypeId");
			
			if($("#addressId_all").length && $("#shipModeId_all").length){
				//Single Shipment..get the common addressId and shipModeId..
				if(typeId.length === 0 || typeId.val() != "1"){
					addressId = $("#addressId_all").val();
				} else if($("#physicalStoreId").length){
					physicalStoreId = $("#physicalStoreId").val();
				}
				shipModeId = $("#shipModeId_all").val();
			} else if ($("#MS_ShipmentAddress_" + this.replaceOrderItemId).length && $("#MS_ShippingMode_" + this.replaceOrderItemId).length){
				//Multiple shipment..each orderItem will have its own addressId and shipModeId..
				addressId = $("#MS_ShipmentAddress_" + this.replaceOrderItemId).val();
				shipModeId = $("#MS_ShippingMode_" + this.replaceOrderItemId).val();
			}
					
			if(this.replaceOrderItemId != "" && categoryDisplayJS){
				//Else remove existing catEntryId and then add new one...
				shoppingActionsJS.replaceItemAjaxHelper(catalogEntryId,this.catEntryQuantity,this.replaceOrderItemId,addressId,shipModeId,physicalStoreId);
			} else {
				console.error("categoryDisplayJS not defined");
			}
		},
		
		/**
		 * select the attributes of an sku
		 */
		selectCurrentAttributes: function(){
			for(idx=0;idx<this.catEntryParams.skus.length;idx++){
				var selectedSKU = this.catEntryParams.skus[idx];
				if(selectedSKU.id == this.itemId){
					for(attribute in selectedSKU.attributes){
						var selectNode = $("select[alt='" + attribute + "']")[0];
						if(selectNode){
							selectNode.value = selectedSKU.attributes[attribute];
							this.setSelectedAttribute(attribute,selectNode.value);
						} else {
							var attrValue = selectedSKU.attributes[attribute];
							if ($("[id='quickInfoSwatch_" + attribute + "_" + attrValue + "']").length){													
								this.selectSwatch(attribute, attrValue, "quickInfoSwatch_" + attribute + "_" + attrValue, "quickInfoSwatch_" + attribute + "_");
							}
						}
					}
					
					this.notifyAttributeChange();
					this.selectItem(true);
				  	
					return;
				}
			}
			
		}
		
	}

}//-----------------------------------------------------------------
// Licensed Materials - Property of IBM
//
// WebSphere Commerce
//
// (C) Copyright IBM Corp. 2013, 2016 All Rights Reserved.
//
// US Government Users Restricted Rights - Use, duplication or
// disclosure restricted by GSA ADP Schedule Contract with
// IBM Corp.
//-----------------------------------------------------------------


if(typeof(SearchJS) == "undefined" || SearchJS == null || !SearchJS){

    SearchJS = {

        /**
         * This variable controls the timer handler before triggering the autoSuggest.  If the user types fast, intermittent requests will be cancelled.
         * The value is initialized to -1.
         */
        autoSuggestTimer: -1,

        /**
         * This variable controls the delay of the timer in milliseconds between the keystrokes before firing the search request.
         * The value is initialized to 400.
         */
        autoSuggestKeystrokeDelay : 400,

        /**
         * This variable indicates whether or not the user is hovering over the autoSuggest results popup display.
         * The value is initialized to false.
         */
        autoSuggestHover : false,

        /**
         * This variable stores the old search term used in the auto suggest search box
         * The value is initialized to empty string.
         */
        autoSuggestPreviousTerm : "",

        /**
         * This variable stores the URL of currently selected static autosuggest recommendation
         * The value is initialized to empty string.
         */
        autoSuggestURL : "",

        /**
         * This variable stores the index of the selected auto suggestion item when using up/down arrow keys.
         * The value is initialized to -1.
         */
        autoSelectOption : -1,

        /**
         * This variable stores the index offset of the first previous history term
         * The value is initialized to -1.
         */
        historyIndex : -1,

        /**
         * This variable indicates whether a the cached suggestions have been retrieved.
         * The value is initialized to false.
         */
        retrievedCachedSuggestions : false,

        /**
         * This variable sets the total number of static autosuggest recommendations used for each static category/grouping.
         * The value is initialized to 4.
         */
        TOTAL_SUGGESTED : 4,

        /**
         * This variable sets the total number of previous search history terms.
         * The value is initialized to 2.
         */
        TOTAL_HISTORY : 2,

        /**
         * This variable controls when to trigger the auto suggest box.  The number of characters greater than this threshold will trigger the auto suggest functionality.
         * The static/cached auto suggest will be performed if this threshold is exceeded.
         * The value is initialized to 1.
         */
        AUTOSUGGEST_THRESHOLD : 1,

        /**
         * This variable controls when to trigger the dynamic auto suggest.  The number of characters greater than this threshold will trigger the request for keyword search.
         * The static/cached auto suggest will be be displayed if the characters exceed the above config parameter, but exceeding this threshold will additionally perform the dynamic search to add to the results in the static/cached results.
         * This value should be greater or equal than the AUTOSUGGEST_THRESHOLD, as the dynamic autosuggest is secondary to the static/cached auto suggest.
         * The value is initialized to 1.
         */
        DYNAMIC_AUTOSUGGEST_THRESHOLD : 1,

        /**
         * This variable is an internal constant used in the element ID's generated in the autosuggest content.
         * The value is initialized to 1000.
         */
        CACHED_AUTOSUGGEST_OFFSET : 1000,

        /**
         * This variable is used to indicate whether or not the auto suggest selection has reached the end of the list.
         * The value is initialized to false.
         */
        END_OF_LIST : false,
        /**
          * The auto suggest container ID's
         */
        STATIC_CONTENT_SECTION_DIV: ["autoSuggestStatic_1", "autoSuggestStatic_2", "autoSuggestStatic_3"],


        /**
         * NLS message for header
        */
        staticContentHeaderHistory:"",

        /**
         * URL to retrieve auto suggest keywords
        */
        SearchAutoSuggestServletURL:"",

        /**
         * Timeout variable for department dropdown list
        */
        searchDepartmentHoverTimeout:"",
        /**
         * Timeout variable for suggestions dropdown list
        */
        searchSuggestionHoverTimeout:"",
        /**
         * Handle for on mousedown event.
         */
        mouseDownConnectHandle: null,

        searchDepartmentSelect: function (categoryId, lel) {
            $("#searchDepartmentLabel").html(lel.innerHTML);
            $('#search_categoryId').val() = categoryId;
            this.hideSearchDepartmentList();
            return false;
        },

        cancelEvent: function(e) {
            if (e.stopPropagation) {
                e.stopPropagation();
            }
            if (e.preventDefault) {
                e.preventDefault();
            }
            e.cancelBubble = true;
            e.cancel = true;
            e.returnValue = false;
        },

        searchDepartmentKeyPressed: function(event, pos, size, categoryId, item){
            if (event.keyCode === KeyCodes.RETURN) { // enter
                this.searchDepartmentSelect(categoryId, item);
                var scrElement = document.getElementById("mobileSearchDropdown");
                if (scrElement != null && scrElement.style.display == 'block'){
                    $("#MobileSimpleSearchForm_SearchTerm").focus();
                }else{
                    document.CatalogSearchForm.searchTerm.focus();
                }
            } else if (event.keyCode === KeyCodes.UP_ARROW) { // up arrow
                if (pos != 0) {
                    $('#searchDepartmentList_' + (pos - 1)).focus();
                    this.cancelEvent(event);
                }
            } else if (event.keyCode === KeyCodes.DOWN_ARROW) { // down arrow
                if (pos != size) {
                    $('#searchDepartmentList_' + (pos + 1)).focus();
                    this.cancelEvent(event);
                }
            } else if (event.keyCode === KeyCodes.ESCAPE) { // escape
                var scrElement = document.getElementById("mobileSearchDropdown");
                if (scrElement != null && scrElement.style.display == 'block'){
                    $("#MobileSimpleSearchForm_SearchTerm").focus();
                }else{
                    document.CatalogSearchForm.searchTerm.focus();
                }
                this.hideSearchDepartmentList();
            } else if (event.shiftKey && event.keyCode === KeyCodes.TAB) { // tab
                var scrElement = document.getElementById("mobileSearchDropdown");
                if (scrElement != null && scrElement.style.display == 'block'){
                    $("#MobileSimpleSearchForm_SearchTerm").focus();
                }else{
                    document.CatalogSearchForm.searchTerm.focus();
                }
                this.cancelEvent(event);
                this.hideSearchDepartmentList();
            } else if (event.keyCode === KeyCodes.TAB) { // tab
                $('#search_submit').focus();
                this.cancelEvent(event);
                this.hideSearchDepartmentList();
            }

            return false;
        },

        hideSearchDepartmentList: function () {
            $('#searchDepartmentList').css('display', 'none');
        },

	init:function(){
	     $(document.CatalogSearchForm.searchTerm).on("focus",$.proxy (SearchJS._onFocus, SearchJS));
	     $(document.CatalogSearchForm.searchTerm).on("keydown",$.proxy (SearchJS._onKeyDown, SearchJS));
	     $(document.CatalogSearchForm.searchTerm).on("keyup",$.proxy (SearchJS._onKeyUp, SearchJS));
	     $("#searchDropdown").on("keyup",$.proxy (SearchJS._onKeyTab, SearchJS));
	//   $("#"Mobilesearch_submit").on("click",$.proxy (SearchJS._MobileonClick, SearchJS));
	//   $("#"navSearchMobile").on("click",$.proxy (SearchJS._showMobileSearchComponent, SearchJS));
	//   $("#"search_submit").on("click",$.proxy (SearchJS._onClick, SearchJS));

	     //this.staticContentHeaderHistory = Utils.getLocalizationMessage("HISTORY");
        },

        showSearchComponent:function(){
            var srcElement = document.getElementById("searchDropdown");
            if(srcElement != null) {
                srcElement.style.display= 'block';
            }
          },

        hideSearchComponent:function(){
            var srcElement = document.getElementById("searchDropdown");
            if(srcElement != null) {
                srcElement.style.display= 'none';
            }
        },

        _showMobileSearchComponent:function(){
            var srcElement = document.getElementById("mobileSearchDropdown");
            if(srcElement != null) {
              if(srcElement.style.display == "block") {
                  DepartmentJS.close('mobileSearchDropdown');
                srcElement.style.display= 'none';
              }
              else
              {
                $(".subDeptDropdown ").each(function (i, node) {
                    DepartmentJS.close(node.id);
                });
                DepartmentJS.close("departmentsDropdown");
                srcElement.style.display='block';
              }
            }
          },

        setAutoSuggestURL:function(url){
            this.SearchAutoSuggestServletURL = getAbsoluteURL() + url;
        },

        _onFocus:function(evt){
            this.showSearchComponent();
            this.retrieveCachedSuggestions();
        },

        _MobileonFocus:function(evt){
            this.showSearchComponent();
            this.retrieveCachedSuggestions();
        },

        _MobileonBlur:function(evt){
            clearTimeout(this.searchSuggestionHoverTimeout);
            this.searchSuggestionHoverTimeout = setTimeout("SearchJS.showAutoSuggest(false)",100);
        },

        _onKeyPress:function(evt){
            return evt.keyCode !== KeyCodes.RETURN;
        },
        _onKeyDown:function(evt){
            if (evt.keyCode === KeyCodes.RETURN) {
                this._handleEnterKey();
                this.cancelEvent(evt);
            }
            else if (evt.keyCode === KeyCodes.TAB) {
                clearTimeout(this.searchSuggestionHoverTimeout);
                this.searchSuggestionHoverTimeout = setTimeout("SearchJS.showAutoSuggest(false)",200);
            }
        },
        _onKeyUp:function(evt){
            var srcElement = document.getElementById("searchDropdown");
            srcElement.style.display='block';
            this.doAutoSuggest(evt, this.SearchAutoSuggestServletURL, document.CatalogSearchForm.searchTerm.value);
        },
        _onKeyTab: function (evt) {
            if (evt.keyCode === KeyCodes.TAB) {
                $("#searchFilterButton").focus();
            }
        },
        _MobileonKeyUp:function(evt){
            var srcElement = document.getElementById("mobileSearchDropdown");
            srcElement.style.display='block';
            this.doAutoSuggest(evt, this.SearchAutoSuggestServletURL, $("#MobileSimpleSearchForm_SearchTerm").val());
        },

        _handleEnterKey:function() {
            document.CatalogSearchForm.searchTerm.value = trim(document.CatalogSearchForm.searchTerm.value);
            if(document.CatalogSearchForm.searchTerm.value.length > 0) {
                if(this.END_OF_LIST) {
                    this.gotoAdvancedSearch(byId("advancedSearch").href);
                }
                else if(this.autoSuggestURL !== "" &&  this.autoSuggestURL != (document.location.href + "#")) {
                    //When enter key is hit with one of the suggested keywords or results highlighted, then go to the URL specified for that result..
                    // go to suggested URL
                    document.location.href = appendWcCommonRequestParameters(this.autoSuggestURL);
                }
                else {
                    //Enter key is hit, when the focus was in search term input box.. Submit the form and get the results..
                    document.CatalogSearchForm.searchTerm.value = trim(document.CatalogSearchForm.searchTerm.value);
                    submitSpecifiedForm(document.CatalogSearchForm);
                }
            }

        },


        _onClick:function(evt){
            document.CatalogSearchForm.searchTerm.value = trim(document.CatalogSearchForm.searchTerm.value);
            if(document.CatalogSearchForm.searchTerm.value.length > 0) {
                if(typeof TealeafWCJS != "undefined"){
                    TealeafWCJS.processDOMEvent(evt);
                }
                submitSpecifiedForm(document.CatalogSearchForm);
            }
            return false;
        },

        _MobileonClick:function(evt){
            document.MobileCatalogSearchForm.searchTerm.value = trim(document.MobileCatalogSearchForm.searchTerm.value);
            if(document.MobileCatalogSearchForm.searchTerm.value.length > 0) {
                if(typeof TealeafWCJS != "undefined"){
                    TealeafWCJS.processDOMEvent(evt);
                }
                submitSpecifiedForm(document.MobileCatalogSearchForm);
            }
            return false;
        },

        doDynamicAutoSuggest:function(url, searchTerm, showHeader) {
            // if pending autosuggest triggered, cancel it.
            if(this.autoSuggestTimer != -1) {
                clearTimeout(this.autoSuggestTimer);
                this.autoSuggestTimer = -1;
            };

            // call the auto suggest
            this.autoSuggestTimer = setTimeout(function() {
                var newurl = url + "&term=" + encodeURIComponent(searchTerm) + "&showHeader=" + showHeader;
                $("#autoSuggestDynamic_Result_div").refreshWidget("updateUrl", newurl);
                console.debug("update autosuggest "+url);
                wcRenderContext.updateRenderContext("AutoSuggest_Context", {});
                this.autoSuggestTimer = -1;
            }, this.autoSuggestKeystrokeDelay);
        },

        gotoAdvancedSearch:function(url) {
            var searchTerm = $("#SimpleSearchForm_SearchTerm").val();
            document.location.href = appendWcCommonRequestParameters(url) + '&searchTerm=' + searchTerm;

        },

        showAutoSuggest:function(display) {
            var autoSuggest_Result_div = document.getElementById("autoSuggest_Result_div");
            var ie_version = Utils.get_IE_version();
            if (ie_version && ie_version < 7) {
                var autoSuggest_content_div = document.getElementById("autoSuggest_content_div");
                var autoSuggestDropDownIFrame = document.getElementById("autoSuggestDropDownIFrame");
            }

            if(autoSuggest_Result_div != null && typeof autoSuggest_Result_div != 'undefined') {
                if(display) {
                    autoSuggest_Result_div.style.display = "block";
                    if (ie_version && ie_version < 7) {
                        autoSuggestDropDownIFrame.style.height = autoSuggest_content_div.scrollHeight;
                        autoSuggestDropDownIFrame.style.display = "block";
                    }
                    this.registerMouseDown();
                }
                else {
                    if (ie_version && ie_version < 7) {
                        autoSuggestDropDownIFrame.style.display = "none";
                        autoSuggestDropDownIFrame.style.height = 0;
                    }
                    autoSuggest_Result_div.style.display = "none";
                    this.unregisterMouseDown();
                }
            }
            else {
                this.unregisterMouseDown();
            }
        },

        showAutoSuggestIfResults:function() {
            // if no results, hide the autosuggest box

            var scrElement = document.getElementById("mobileSearchDropdown");
            if(typeof(staticContent) != "undefined" && $("#" + this.STATIC_CONTENT_SECTION_DIV[0]).html() === "" && $("#autoSuggestHistory").html() === "" && document.getElementById("dynamicAutoSuggestTotalResults") == null) {
                this.showAutoSuggest(false);
            }
            else if(scrElement != null && scrElement.style.display == 'block')
            {
                    if($("#MobileSimpleSearchForm_SearchTerm").val().length <= this.AUTOSUGGEST_THRESHOLD)
                    {
                        this.showAutoSuggest(false);
                    }
                    else
                    {
                        this.showAutoSuggest(true);
                    }
            }
            else {
                    if(document.CatalogSearchForm.searchTerm.value.length <= this.AUTOSUGGEST_THRESHOLD)
                    {
                        this.showAutoSuggest(false);
                    }
                    else
                    {
                        this.showAutoSuggest(true);
                    }
            }
        },

        selectAutoSuggest:function(term) {
            var scrElement = document.getElementById("mobileSearchDropdown");
            if (scrElement != null && scrElement.style.display == 'block'){
                var searchBox = document.getElementById("MobileSimpleSearchForm_SearchTerm");
            }else{
                var searchBox = document.CatalogSearchForm.searchTerm;
            }

            searchBox.value = term;
            searchBox.focus();
            this.autoSuggestPreviousTerm = term;
            if(typeof TealeafWCJS != "undefined"){
                TealeafWCJS.createExplicitChangeEvent(searchBox);
            }
            submitSpecifiedForm(document.CatalogSearchForm);
        },

        highLightSelection:function(state, index) {
            var selection = document.getElementById("autoSelectOption_" + index);
            if(selection != null && typeof selection != 'undefined') {
                if(state) {
                    selection.className = "autoSuggestSelected";
                    var scrElement = document.getElementById("mobileSearchDropdown");
                    if (scrElement != null && scrElement.style.display == 'block'){
                        var searchBox = document.getElementById("MobileSimpleSearchForm_SearchTerm");
                    }else{
                        var searchBox = document.CatalogSearchForm.searchTerm;
                    }
                    $(searchBox).attr("aria-activedescendant", "suggestionItem_" + index);
                    var totalDynamicResults = document.getElementById("dynamicAutoSuggestTotalResults");
                    if((totalDynamicResults != null && typeof totalDynamicResults != 'undefined' && index < totalDynamicResults.value) || (index >= this.historyIndex)) {
                        searchBox.value = selection.title;
                        this.autoSuggestPreviousTerm = selection.title;
                    }
                    this.autoSuggestURL = selection.href;
                }
                else {
                    selection.className = "";
                }
                return true;
            }
            else {
                return false;
            }
        },

        enableAutoSelect:function(index) {
            this.highLightSelection(false, this.autoSelectOption);
            var item = document.getElementById('autoSelectOption_' + index);
            item.className = "autoSuggestSelected";
            this.autoSelectOption = index;
        },

        resetAutoSuggestKeyword:function() {
            var originalKeyedSearchTerm = document.getElementById("autoSuggestOriginalTerm");
            if(originalKeyedSearchTerm != null && typeof originalKeyedSearchTerm != 'undefined') {
                var scrElement = document.getElementById("mobileSearchDropdown");
                if (scrElement != null && scrElement.style.display == 'block')
                {
                    var searchBox = document.getElementById("MobileSimpleSearchForm_SearchTerm");
                }else{
                    var searchBox = document.CatalogSearchForm.searchTerm;
                }
                searchBox.value = originalKeyedSearchTerm.value;
                this.autoSuggestPreviousTerm = originalKeyedSearchTerm.value;
            }
        },


        clearAutoSuggestResults:function() {
            // clear the static search results.
            for (var i = 0; i < staticContent.length; i++) {
                $("#" + this.STATIC_CONTENT_SECTION_DIV[i]).html("");
            }
            this.autoSuggestPreviousTerm = "";
            this.autoSuggestURL = "";
            // clear the dynamic search results;
            $("#autoSuggestDynamic_Result_div").html("");
            this.showAutoSuggest(false);
        },

        doAutoSuggest:function(event, url, searchTerm) {
            searchTerm = searchTerm.trim();
            if(searchTerm.length <= this.AUTOSUGGEST_THRESHOLD ) {
                this.showAutoSuggest(false);
            }

            if (event.keyCode === KeyCodes.RETURN) {
                return;
            }

            if (event.keyCode === KeyCodes.TAB) {
                this.autoSuggestHover = true;
                return;
            }

            if (event.keyCode === KeyCodes.ESCAPE) {
                this.showAutoSuggest(false);
                return;
            }

            if (event.keyCode === KeyCodes.UP_ARROW) {
                var totalDynamicResults = document.getElementById("dynamicAutoSuggestTotalResults");
                if(this.END_OF_LIST) {
                    $("#autoSuggestAdvancedSearch").removeClass("autoSuggestSelected");
                    this.END_OF_LIST = false;
                    this.autoSelectOption--;
                    if(!this.highLightSelection(true, this.autoSelectOption)) {
                        if(this.autoSelectOption == this.CACHED_AUTOSUGGEST_OFFSET && totalDynamicResults != null && typeof totalDynamicResults != 'undefined') {
                            this.autoSelectOption = totalDynamicResults.value-1;
                            this.highLightSelection(true, this.autoSelectOption);
                        }
                    }
                }
                else if (this.highLightSelection(true, this.autoSelectOption-1)) {
                    this.highLightSelection(false, this.autoSelectOption);
                    if(this.autoSelectOption == this.historyIndex) {
                        this.resetAutoSuggestKeyword();
                    }
                    this.autoSelectOption--;
                }
                else if(this.autoSelectOption == this.CACHED_AUTOSUGGEST_OFFSET && totalDynamicResults != null && typeof totalDynamicResults != 'undefined') {
                    this.highLightSelection(false, this.CACHED_AUTOSUGGEST_OFFSET);
                    this.autoSelectOption = totalDynamicResults.value-1;
                    this.highLightSelection(true, this.autoSelectOption);
                }
                else {
                    // up arrow back to the very top
                    this.highLightSelection(false, this.autoSelectOption);
                    this.autoSelectOption = -1;
                    var originalKeyedSearchTerm = document.getElementById("autoSuggestOriginalTerm");
                    this.resetAutoSuggestKeyword();
                }
                return;
            }

            if (event.keyCode === KeyCodes.DOWN_ARROW) {
                if(this.highLightSelection(true, this.autoSelectOption+1)) {
                    this.highLightSelection(false, this.autoSelectOption);
                    this.autoSelectOption++;
                }
                else if(this.autoSelectOption < this.CACHED_AUTOSUGGEST_OFFSET && this.highLightSelection(true, this.CACHED_AUTOSUGGEST_OFFSET)) {
                    // down arrow into the cached autosuggest section
                    this.highLightSelection(false, this.autoSelectOption);
                    this.autoSelectOption = this.CACHED_AUTOSUGGEST_OFFSET;
                    this.resetAutoSuggestKeyword();
                }
                else if(!this.END_OF_LIST) {
                    $("#autoSuggestAdvancedSearch").addClass("autoSuggestSelected");
                    this.highLightSelection(false, this.autoSelectOption);
                    this.autoSelectOption++;
                    this.END_OF_LIST = true;
                    var scrElement = document.getElementById("mobileSearchDropdown");
                    if (scrElement != null && scrElement.style.display == 'block'){
                        var searchBox = document.getElementById("MobileSimpleSearchForm_SearchTerm");
                    }else{
                        var searchBox = document.CatalogSearchForm.searchTerm;
                    }
                    $(searchBox).attr("aria-activedescendant", "advancedSearch");
                }
                return;
            }

            if(searchTerm.length > this.AUTOSUGGEST_THRESHOLD && searchTerm == this.autoSuggestPreviousTerm) {
                return;
            }
            else {
                this.autoSuggestPreviousTerm = searchTerm;
            }

            if(searchTerm.length <= this.AUTOSUGGEST_THRESHOLD) {
                return;
            };

            // cancel the dynamic search if one is pending
            if(this.autoSuggestTimer != -1) {
                clearTimeout(this.autoSuggestTimer);
                this.autoSuggestTimer = -1;
            }

            if(searchTerm !== "") {
                this.autoSelectOption = -1;
                var hasResults = this.doStaticAutoSuggest(searchTerm);
                if(searchTerm.length > this.DYNAMIC_AUTOSUGGEST_THRESHOLD) {
                    var showHeader = true; // hasResults;
                    this.doDynamicAutoSuggest(url, searchTerm, showHeader);
                }
                else {
                    // clear the dynamic results
                    $("#autoSuggestDynamic_Result_div").html("");
                }
            }
            else {
                this.clearAutoSuggestResults();
            }
        },

        tokenizeForBidi:function(displayName, searchName, searchTerm, searchTermLower) {
            var tokens = displayName.split( " > " );
            var html = "";
            var str = "";
            if(tokens.length > 0) {
                html = html + "<div class='category_list'>";
                for(i = 0; i < tokens.length; i++) {
                    if(i!=0) {
                        // not the first token
                        html = html + "<span class='gt'>&nbsp; > &nbsp;</span>";
                    }
                    if(i == tokens.length - 1) {
                        // last token
                        var index = searchName.toLowerCase().indexOf(searchTermLower);
                        var subStringBefore = searchName.substr(0, index);
                        var subStringAfter =  searchName.substr(index + searchTerm.length);
                        var highLighted = "<span class='highlight'>" + searchTerm + "</span>";
                        str = subStringBefore + highLighted + subStringAfter;
                    }
                    else {
                        str = tokens[i];
                    }
                    html = html + str;
                }
                html = html + "</div>";
            }
            return html;
        },

        doStaticAutoSuggest:function(searchTerm) {
            var resultList = ["", "", "", "", "", ""];
            var emptyCell = 0;
            var searchTermLower = searchTerm.toLowerCase();
            var listCount = this.CACHED_AUTOSUGGEST_OFFSET;
            var divStart = "<div class='list_section'><div";
            var divEnd =   "</div></div>";

            for(var i = 0; i < staticContent.length; i++) {
                var count = 0;
                for(var j = 0; j < staticContent[i].length; j++) {
                    var searchName = staticContent[i][j][0];
                    var searchURL = staticContent[i][j][1];
                    var displayName = staticContent[i][j][2];
                    var index = searchName.toLowerCase().indexOf(searchTermLower);
                    if(index != -1) {

                        var htmlDisplayName = this.tokenizeForBidi(displayName, searchName, searchTerm, searchTermLower);

                        resultList[i] = resultList[i] + "<ul class='autoSuggestDivNestedList'><li id='suggestionItem_" + listCount + "' role='listitem' tabindex='-1'><a id='autoSelectOption_" + listCount + "' title='" + escapeXml(searchName, true) + "' onmouseout='this.className=\"\"; this.autoSuggestURL=\"\";' onclick='SearchJS.hideSearchComponent();' onmouseover='SearchJS.enableAutoSelect(" + listCount + "); this.autoSuggestURL=this.href;' href=\"" + searchURL + "\">" + htmlDisplayName + "</a></li></ul>";
                        count++;
                        listCount++;
                        if(count >= this.TOTAL_SUGGESTED) {
                            break;
                        }
                    }
                }
            }

            for (var i = 0; i < staticContent.length; i++) {
                $("#" + this.STATIC_CONTENT_SECTION_DIV[i]).html("");
                if(resultList[i] !== "") {
                    var heading =  "<ul class='autoSuggestDivNestedList'><li class='heading'><span>" + staticContentHeaders[i] + "</span></li></ul>";
                    $("#" + this.STATIC_CONTENT_SECTION_DIV[emptyCell]).html(heading + divStart + " role='list' title='" + staticContentHeaders[i] + "' aria-label='" + staticContentHeaders[i] + "'>" + resultList[i] + divEnd);
                    emptyCell++;
                }
            }

            var historyList = "";
            var searchHistorySection = document.getElementById("autoSuggestHistory");
            searchHistorySection.innerHTML = "";
            var historyArray = [];
            this.historyIndex = listCount;

            var searchHistoryCookie = getCookie("searchTermHistory");
            if(typeof(searchHistoryCookie) != 'undefined') {
                var termsArray = searchHistoryCookie.split("|");
                var count = 0;
                for(var i = termsArray.length - 1; i > 0; i--) {
                    var theTerm = termsArray[i];
                    var theLowerTerm = theTerm.toLowerCase();
                    if(theLowerTerm.match("^"+searchTermLower) == searchTermLower) {
                        var repeatedTerm = false;
                        for(var j = 0; j < historyArray.length; j++) {
                            if(historyArray[j] == theLowerTerm) {
                                repeatedTerm = true;
                                break;
                            }
                        }
                        if(!repeatedTerm) {
                            if(count >= this.TOTAL_HISTORY) {
                                break;
                            }
                            historyList = historyList + "<ul class='autoSuggestDivNestedList'><li id='suggestionItem_" + listCount + "' role='listitem' tabindex='-1'><a href='#' onmouseout='this.className=\"\"' onmouseover='SearchJS.enableAutoSelect(" + listCount + ");' onclick='SearchJS.selectAutoSuggest(this.title); return false;' title='" + theTerm + "' id='autoSelectOption_" + listCount+ "'><strong>" + searchTerm + "</strong>" + theTerm.substring(searchTerm.length, theTerm.length) + "</a></li></ul>";
                            historyArray.push(theLowerTerm);
                            count++;
                            listCount++;
                        }
                    }
                }
            }

            if (this.staticContentHeaderHistory === "") {
                this.staticContentHeaderHistory = Utils.getLocalizationMessage("HISTORY");
            }
            
            if(historyList !== "") {
                var heading =  "<ul class='autoSuggestDivNestedList'><li class='heading'><span>" + this.staticContentHeaderHistory + "</span></li></ul>"
                searchHistorySection.innerHTML = heading + divStart + " title='" + this.staticContentHeaderHistory + "'>" + historyList + divEnd;
                emptyCell++;
            }

            if(emptyCell > 0) {
                this.showAutoSuggest(true);
                return true;
            }

            return false;
        },

        retrieveCachedSuggestions:function() {
            if(!this.retrievedCachedSuggestions) {
                wcRenderContext.updateRenderContext("CachedSuggestions_Context", {});
            }
        },

        /**
         * Updates the searchTermHistory cookie value...
         */
        updateSearchTermHistoryCookie:function(updatedSearchTerm){
            var cookieKey = "searchTermHistory";
            var cookieValue = "|" + updatedSearchTerm;
            var searchTermHistoryCookie = getCookie(cookieKey);
            if(typeof(searchTermHistoryCookie) != 'undefined') {
                cookieValue = setCookie(cookieKey) + cookieValue;
            }
            setCookie(cookieKey, cookieValue, {path:'/', domain:cookieDomain});
        },

        updateSearchTermHistoryCookieAndRedirect:function(updatedSearchTerm, redirectURL){
            this.updateSearchTermHistoryCookie(updatedSearchTerm);
            if (navigator.userAgent.toLowerCase().indexOf('firefox') == -1) {document.location.href = appendWcCommonRequestParameters(redirectURL);}
        },

        isValidNumber:function(n) {
            return !isNaN(parseFloat(n)) && isFinite(n) && n >= 0;
        },

        /**
         * Validation method for advanced search form
         */
        validateForm: function(form) {
            form["minPrice"].value = trim(form["minPrice"].value);
            form["maxPrice"].value = trim(form["maxPrice"].value);

            var minValue = form["minPrice"].value;
            var maxValue = form["maxPrice"].value;

            var minIsValid = this.isValidNumber(minValue);
            var maxIsValid = this.isValidNumber(maxValue);

            if(minValue.length > 0 && !minIsValid) {
                MessageHelper.formErrorHandleClient(form["minPrice"].id, MessageHelper.messages["EDPPaymentMethods_AMOUNT_NAN"]);
                return false;
            }
            else if(maxValue.length > 0 && !maxIsValid) {
                MessageHelper.formErrorHandleClient(form["maxPrice"].id, MessageHelper.messages["EDPPaymentMethods_AMOUNT_NAN"]);
                return false;
            }
            else if (minValue.length > 0 && maxValue.length > 0 && parseFloat(minValue) > parseFloat(maxValue)) {
                MessageHelper.formErrorHandleClient(form["maxPrice"].id, MessageHelper.messages["ERROR_PRICE_RANGE"]);
                return false;
            }

            form["searchTerm"].value = trim(form["searchTerm"].value);
            form["filterTerm"].value = trim(form["filterTerm"].value);
            form["manufacturer"].value = trim(form["manufacturer"].value);

            var searchTerm = form["searchTerm"].value;
            var filterTerm = form["filterTerm"].value;
            var manufacturer = form["manufacturer"].value;

            if (searchTerm.length == 0 && filterTerm.length == 0 && manufacturer.length == 0) {
                MessageHelper.formErrorHandleClient(form["searchTerm"].id, MessageHelper.messages["ERROR_EMPTY_SEARCH_FIELDS"]);
                return false;
            }

            processAndSubmitForm(form);
        },

        registerMouseDown: function() {
            if (this.mouseDownConnectHandle == null) {
                this.mouseDownConnectHandle = $(document.documentElement).on("mousedown", $.proxy("handleMouseDown", this));
            }
        },

        unregisterMouseDown: function() {
            if (this.mouseDownConnectHandle != null) {
                $(document.documentElement).off("mousedown");
                this.mouseDownConnectHandle = null;
            }
        },

        handleMouseDown: function(evt) {
            var node = evt.target;
            if (node != document.documentElement) {
                var searchDropdown = document.getElementById("searchDropdown");
                var searchTerm = document.CatalogSearchForm.searchTerm;
                var close = true;
                while (node) {
                    if (node == searchDropdown || node == searchTerm) {
                        close = false;
                        break;
                    }
                    node = node.parentNode;
                }
                if (close) {
                    this.showAutoSuggest(false);
                }
            }
        },

        declareAutoSuggestRefreshArea: function() {
            // ============================================
            // div: autoSuggestDynamic_Result_div refresh area
            // Declares a new refresh controller for Auto Suggest

            // common render context
            wcRenderContext.declare("AutoSuggest_Context", ["autoSuggestDynamic_Result_div"], null);

            /**
             * Displays the keyword suggestions from the search index
             * This function is called when a render context changed event is detected.
             */
            var renderContextChangedHandler = function() {
                var renderContext = wcRenderContext.getRenderContextProperties("AutoSuggest_Context");
                $("#autoSuggestDynamic_Result_div").refreshWidget("refresh", renderContext);
            };

            /**
             * Display the results.
             */
            var postRefreshHandler = function() {
                  var response = document.getElementById('suggestedKeywordResults');
                  var productsResponse = document.getElementById('suggestedProductsResults');
                  if(response == null && productsResponse == null) {
                    // No response or an error page.   Clear the contents.
                    $("#autoSuggestDynamic_Result_div").html("");
                  }
                  SearchJS.showAutoSuggestIfResults();
            };

            // initialize widget
            $("#autoSuggestDynamic_Result_div").refreshWidget({renderContextChangedHandler: renderContextChangedHandler, postRefreshHandler: postRefreshHandler});
        },

        declareAutoSuggestCachedSuggestionRefreshArea: function() {
            // ============================================
            // div: autoSuggestCachedSuggestions_div refresh area
            // Declares a new refresh controller for Auto Suggest

            // common render context
            wcRenderContext.declare("CachedSuggestions_Context", ["autoSuggestCachedSuggestions_div"], null);

           /**
            * Retrieves the cached suggestions used in the autosuggest box.
            * This function is called when a render context changed event is detected.
            */
            var renderContextChangedHandler = function() {
                var renderContext = wcRenderContext.getRenderContextProperties("CachedSuggestions_Context");
                $("#autoSuggestCachedSuggestions_div").refreshWidget("refresh", renderContext);
            };

            /**
             * Updates the cached suggestions.
             */
            var postRefreshHandler = function() {
                var response = document.getElementById('cachedSuggestions');
                if(response == null) {
                    // No response or an error page.   Clear the contents.
                    $("#autoSuggestCachedSuggestions_div").html("");
                }
                else {
                    var scripts = response.getElementsByTagName("script");
                    var j = scripts.length;
                    for (var i = 0; i < j; i++){
                        var newScript = document.createElement('script');
                        newScript.type = "text/javascript";
                        newScript.text = scripts[i].text;
                        document.getElementById('autoSuggestCachedSuggestions_div').appendChild (newScript);
                    }
                    SearchJS.retrievedCachedSuggestions = true;
                    var scrElement = document.getElementById("mobileSearchDropdown");
                    if (scrElement != null && scrElement.style.display == 'block')
                    {
                        searchTerm = $("#MobileSimpleSearchForm_SearchTerm").val();
                    }
                        else
                    {
                    searchTerm = document.CatalogSearchForm.searchTerm.value;
                    }
                    if(searchTerm.length > SearchJS.AUTOSUGGEST_THRESHOLD) {
                        SearchJS.doStaticAutoSuggest(searchTerm);
                    }
                }
            };

            // initialize widget
            $("#autoSuggestCachedSuggestions_div").refreshWidget({renderContextChangedHandler: renderContextChangedHandler, postRefreshHandler: postRefreshHandler});
        }
    };
};

//-----------------------------------------------------------------
// Licensed Materials - Property of IBM
//
// WebSphere Commerce
//
// (C) Copyright IBM Corp. 2011, 2016 All Rights Reserved.
//
// US Government Users Restricted Rights - Use, duplication or
// disclosure restricted by GSA ADP Schedule Contract with
// IBM Corp.
//-----------------------------------------------------------------

function ShoppingListJS(storeParams, catEntryParams, shoppingListNames, jsObjectName) {

	this.storeParams = storeParams;

	this.catEntryParams = catEntryParams;

	this.catEntryParams.quantity = 1;

	this.shoppingListNames = shoppingListNames;

	this.addItemAfterCreate = false;

	this.jsObjectName = jsObjectName;

	this.dropDownVisible = false;

	this.dropDownInFocus = false;

	this.dropDownOpen = false;

	this.exceptionFlag = false;

	this.mouseOnArrow = false;

	this.pageName = "";

	this.itemId = -1;

	var eventName = "";

	/**
	 * Keep track of the wish list name that is to be deleted. This is needed only for the my account personal wish
	 * list management UI.
	 **/
	this.nameToDelete = "";

	/**
	 * Keep track of the orderItemId that is to be deleted from the shopping cart after successfully adding an item to the
	 * wish list. This is needed only for the shopping cart and checkout related UI that uses this button code.
	 **/
	this.orderItemId = "";

	/**
	 * Keep track of the current action being performed by this button widget. This action is needed when there are several
	 * same button widgets in the same page such as the shopping cart page UI. We need to know which button is actually doing
	 * actions so that we know when to display success dialogs. Otherwise, all buttons display success dialogs.
	 **/
	this.actionBeingPerformed = "";

	if(jsObjectName != 'shoppingListJS'){
		this.pageName = jsObjectName.replace('shoppingListJS', '');
		eventName = this.pageName + "_";
	}

	/**
	 * Setter for catEntryQuantity
	 *
	 * @param {Integer} catEntryQuantity
	 */
	this.setCatEntryQuantity = function(catEntryQuantity){
        	var catEntryQuantity = $.parseJSON(catEntryQuantity);
		// If the quantity is an object
        	if ($.isPlainObject(catEntryQuantity)) {
			var component = this.catEntryParams.components[catEntryQuantity.baseItemId];
			// component is a product and a new sku is available
			if(component.id != catEntryQuantity.baseItemId && catEntryQuantity.id !=0){
				component.id = catEntryQuantity.id;
			}
			component.quantity = catEntryQuantity.quantity;
		// If the quantity is a single value
		} else {
			this.catEntryParams.quantity = catEntryQuantity;
		}
	};

	/**
	 * Setter for catEntryAttributes
	 *
	 * @param {Integer} catEntryAttributes
	 */
	this.setCatEntryAttributes = function(catEntryAttributes){
        	this.catEntryParams.attributes = $.parseJSON(catEntryAttributes);
	};

	/**
	 * Setter for itemId
	 *
	 * @param {Integer} catEntryId
	 */
	this.setItemId = function(catEntryId){
		this.itemId = catEntryId;
	};

	/**
	 * Hides the dropdown with shopping list names if it exists
	 */
	this.hideDropDown = function() {
        	var dropDown = $('#' + this.pageName + 'shoppingListDropDown');
		if (dropDown) {
	            	$(dropDown).css('display', 'none');
	            	$("#" + this.pageName + "addToShoppingListBtn .drop").first().focus();
			this.dropDownVisible = false;
			this.dropDownInFocus = false;
			this.dropDownOpen = false;

            		var contentRightBorder = $(".widget_quick_info_popup .content_right_border").first();
			if (contentRightBorder != undefined) {
                		$(contentRightBorder).css('height', 'auto');
			}
		}
	};

	/**
	 * Shows the dropdown with shopping list names & a create a new shopping list link - if authenticated
	 * If not authenticated, redirects user to login page
	 */
	this.showDropDown = function() {
		if(this.dropDownOpen == false){
            var contentRightBorder = $(".widget_quick_info_popup .content_right_border").first();
            var ocontentRightBorderH = $(contentRightBorder).height();
            var dropDown = ('#' + this.pageName + 'shoppingListDropDown');
            $(dropDown).css('display', '');
			this.dropDownVisible = true;

            $("#" + this.pageName + "shoppingListDropDown.dropdown_list div").removeClass("focused");

            if ($("#quickInfoRefreshArea") && $("#QuickInfoshoppingListDropDown")) { // check if dropdown is shown in a QuickInfo popup
                var quickInfoRefreshAreaH = $("#quickInfoRefreshArea").height();
                var shoppingListDropDownH = $("QuickInfoshoppingListDropDown").height();
                var contentRightBorderH = $(contentRightBorder).height();
			}
			this.dropDownOpen = true;
		}
		else{
			this.hideDropDown();
		}
	};

	/**
	 * Show appropriate popups to create, update or delete Shopping List
	 *
	 * @param {String}
	 *            action type of popup to be shown (create, update or delete)
	 */
	this.showPopup = function(action){
		this.hideDropDown();
		this.clearPopupText();
		var popup = $("#" + this.pageName + action + "ShoppingListPopup").data("wc-WCDialog");
		var newListName = $("#" + this.pageName + "newListName");
		popup.option("close_on_primary_click", false);
		this.hideErrorMessage();
		this.hideEditErrorMessage();
		if (popup) {            
			closeAllDialogs(); //close other dialogs(quickinfo dialog, etc) before opening this.
			popup.close();//close all popups
			// Add a delay to showing the popup to give closeAllDialogs() a bit of time to do it's job
			setTimeout(function() {
				popup.open();
				if (action === 'create') {
					$(newListName).focus();
				} else if (action === 'edit') {
					$("#editListName").focus();
				}
			}, 250);
		}else {
			console.debug(action+"ShoppingListPopup"+" does not exist");
		}
	};

	/**
	 * Method to display message dialog on successful creation of shopping list.
	 *
	 */
	 this.showSuccessDialog = function(){
		var popup = $("#" + this.pageName + "shoppingListCreateSuccessPopup").data("wc-WCDialog");
		if (popup && this.actionBeingPerformed !== "") {
			$("#" + this.pageName + "successMessageAreaText").html(Utils.getLocalizationMessage('LIST_CREATED'));
			popup.open();
			this.actionBeingPerformed = "";
		}
	 };

	/**
	 * Method to display message dialog on successful creation of shopping list.
	 *
	 */
	 this.showMessageDialog = function(message){
		var popup = $("#" + this.pageName + "shoppingListCreateSuccessPopup").data("wc-WCDialog");

		if (popup) {
			$("#" + this.pageName + "successMessageAreaText").html(message);
			popup.open();
		}
	 };
	 
	/**
	 * Method to close/hide message dialog on successful creation of shopping list.
	 *
	 */
	this.hideMessageDialog = function(){
		var popup = $("#" + this.pageName + "shoppingListCreateSuccessPopup").data("wc-WCDialog");

		if (popup) {
			popup.close();
		}
	};

	/**
	 * Method to display error message pertaining to shopping list
	 * @param (string) msg The error/information message to be displayed
	 *
	 */
	this.showErrorMessage = function(msg){
		if(document.getElementById(this.pageName + "shoppingListErrorMessageArea") && document.getElementById(this.pageName + "shoppingListErrorMessageText")){
			document.getElementById(this.pageName + "shoppingListErrorMessageText").innerHTML = msg;
			document.getElementById(this.pageName + "shoppingListErrorMessageArea").style.display = "block";
		}
	};

	/**
	 * Method to hide error message display area
	 *
	 */
	this.hideErrorMessage = function(){
		if(document.getElementById(this.pageName + "shoppingListErrorMessageArea") && document.getElementById(this.pageName + "shoppingListErrorMessageText")){
			document.getElementById(this.pageName + "shoppingListErrorMessageText").innerHTML = "";
			document.getElementById(this.pageName + "shoppingListErrorMessageArea").style.display = "none";
		}
	};

	/**
	 * Method to display error message pertaining to change shopping list name
	 * @param (string) msg The error/information message to be displayed
	 *
	 */
	this.showEditErrorMessage = function(msg){
		if(document.getElementById("editShoppingListErrorMessageArea") && document.getElementById("editShoppingListErrorMessageText")){
			document.getElementById("editShoppingListErrorMessageText").innerHTML = msg;
			document.getElementById("editShoppingListErrorMessageArea").style.display = "block";
		}
	};

	/**
	 * Method to hide error message display area from the change shopping list name dialog
	 *
	 */
	this.hideEditErrorMessage = function(){
		if(document.getElementById("editShoppingListErrorMessageArea") && document.getElementById("editShoppingListErrorMessageText")){
			document.getElementById("editShoppingListErrorMessageText").innerHTML = "";
			document.getElementById("editShoppingListErrorMessageArea").style.display = "none";
		}
	};

	/**
	 * Method to create a new shopping list
	 *
	 */
	this.create = function(){
		// picks the new shopping list name and trims it
        var name = trim($("#" + this.pageName + "newListName").val());
        var maxlength = $("#" + this.pageName + "newListName").maxLength;
		var defaultName = Utils.getLocalizationMessage('DEFAULT_WISH_LIST_NAME');

		if (this.empty(name)) {
			// display error message saying list name is empty.
			this.showErrorMessage(Utils.getLocalizationMessage('ERR_NAME_EMPTY'));
		} else if(!MessageHelper.isValidUTF8length(name, maxlength)){
			// check for max length
			this.showErrorMessage(Utils.getLocalizationMessage('ERR_NAME_TOOLONG'));
		} else if(name == defaultName) {
			// show error message saying that DEFAULT cannot be used
			this.showErrorMessage(Utils.getLocalizationMessage('ERR_NAME_SHOPPING_LIST'));
		} else if(this.isDuplicate(name)){
			// show error message saying that a wish list with the same name already exists
			this.showErrorMessage(Utils.getLocalizationMessage('ERR_NAME_DUPLICATE'));
		} else if(!this.validateWishName(name)){
			// show error message saying that wish list name is invalid
			this.showErrorMessage(Utils.getLocalizationMessage('INVALID_NAME_SHOPPING_LIST'));
		} else {
			var params = this.setCommonParams();
			params.name = name;

			// For Handling multiple clicks.
			if(!submitRequest()){
				return;
			}
			cursor_wait();
			// calling the service to save the new list name
			wcService.invoke('ShoppingListServiceCreate',params);
			this.actionBeingPerformed = "create";
		}
	};

	/**
	 * Creates the default shopping list with name 'Wish List' and adds the displayed item to this list.
	 * If the default shopping list is already created, just adds the item to the existing list.
	 * Also, redirects the user to login page if not authenticated.
	 *
	 * @param {Integer} listId - id of the default shopping list if present, else -1 is passed
	 */
	this.createDefaultListAndAddItem = function(listId, orderItemId, focusElement){
		if (orderItemId && orderItemId != "") {
			this.orderItemId = orderItemId;
		}

		if("-1" == listId){
			var params = this.setCommonParams();
			params.name = Utils.getLocalizationMessage('DEFAULT_WISH_LIST_NAME');

			// For Handling multiple clicks.
			if(!submitRequest()){
				return;
			}
			cursor_wait();
			this.addItemAfterCreate = true;
			// calling the service to save the new list name
			wcService.invoke('ShoppingListServiceCreate',params);
		} else {
			if (orderItemId && orderItemId != "") {
				this.addToListAndDelete(listId, orderItemId, focusElement);
			} else {
				this.addToList(listId, focusElement);
			}
		}
	};

	/**
	 * add an item/product/bundle/package to a wish list
	 *
	 * @param {string}
	 *            listId id of the item/product/bundle/package be
	 *            added
	 */
	this.addToList = function(listId, focusElement){
		this.hideDropDown();

		var params = this.setCommonParams();
		params.giftListId = listId;

		var catEntryId = this.catEntryParams.id;
		//Add the parent product to the cart.
		if(this.catEntryParams.type.toLowerCase() == 'itembean'
			|| this.catEntryParams.type.toLowerCase() == 'packagebean'
			|| this.catEntryParams.type.toLowerCase() == 'preddynakitbean'
			|| this.catEntryParams.type.toLowerCase() == 'dynamickitbean'){
			updateParamObject(params,"catEntryId",this.catEntryParams.id,false,-1);
			updateParamObject(params,"quantity",this.catEntryParams.quantity,false,-1);
		} else if (this.catEntryParams.type.toLowerCase() == 'bundlebean') {
			// Add items in the bundle
			var resolved = true;
			for (baseItemId in this.catEntryParams.components) {
				if (this.catEntryParams.components[baseItemId].skus && this.catEntryParams.components[baseItemId].skus.length > 1) {
					// If component has multiple SKUs, meaning defining attributes
					var resolvedValue = this.catEntryParams.components[baseItemId].resolved;
					if (resolvedValue == null || resolvedValue == "undefined" || resolvedValue == false) {
						// If any component is unresolved (ie. attributes not selected), do not allow adding to the list
						resolved = false;
						break;
					}
				}
			}
			if (!resolved) {
				MessageHelper.displayErrorMessage(Utils.getLocalizationMessage('ERR_RESOLVING_SKU'));
				return;
			}
			else {
				for(baseItemId in this.catEntryParams.components){				
					updateParamObject(params,"catEntryId",this.catEntryParams.components[baseItemId].id,false,-1);
					updateParamObject(params,"quantity",this.catEntryParams.components[baseItemId].quantity,false,-1);
				}
			}
		} else {
			// Resolve ProductBean to an ItemBean based on the attributes in the main page
			var sku = this.itemId;
			if (sku == -1){
				sku = this.resolveSKU();
			}
			if(-1 == sku){
				MessageHelper.displayErrorMessage(Utils.getLocalizationMessage('ERR_RESOLVING_SKU'));
				return;
			} else {
				catEntryId = sku;
				updateParamObject(params,"catEntryId",sku,false,-1);
				updateParamObject(params,"quantity",this.catEntryParams.quantity,false,-1);
			}
		}
		if(this.jsObjectName != 'shoppingListJS'){
			QuickInfoJS.close();
		}

		// For Handling multiple clicks.
		if(!submitRequest()){
			return;
		}

		cursor_wait();
		ShoppingListDialogJS.setDialogParams(this.storeParams, {catEntryId:catEntryId, thumbnail: 'imgPath', focusElement: focusElement});
		wcService.invoke('ShoppingListServiceAddItem',params);

	};

	/**
	 * Checks if shopping list name already exists
	 *
	 * @param {String} listName, name of the shopping list to be created
	 * @return {Boolean} true, if a duplicate is present
	 * 					 false, if no duplicates present
	 */
	this.isDuplicate = function(listName) {
		var listName = this.escapeXml(listName, true);
		return (this.shoppingListNames[listName.toUpperCase()] == 1);
	};

	/**
	 * Updates the dom object representing the default shopping list with onclick function and also updates the shopping list
	 *
	 * @param {Integer} listId, default shopping list id
	 */
    	this.updateDefaultListId = function(listId){
		this.shoppingListNames[Utils.getLocalizationMessage('DEFAULT_WISH_LIST_NAME')] = 1;
    		if ($('#'+this.pageName+'addToShoppingList')) {
    			$('#'+this.pageName+'addToShoppingList').attr('href' ,'"javascript:" + this.jsObjectName + ".createDefaultListAndAddItem(" + listId + ");"');
		}
    	};

	/**
	 * Adds an entry in shopping list dropdown. Also updates the shopping list names with the new name.
	 *
	 * @param {Integer} listId, id of the new shopping list that got created
	 * @param {String} listName, name of the new shopping list that got created
	 */
	this.updateShoppingList = function(listId, listName, action){
		var listNameEsc = this.escapeXml(listName, false);
		this.shoppingListNames[listNameEsc.toUpperCase()] = 1;

		if (action && (action == 'edit' || action == 'delete')) {
			this.shoppingListNames[this.nameToDelete.toUpperCase()] = -1;
		}

        var dropdownWidgetNode = $('#' + this.pageName + 'ShoppingListDivider');
        if (dropdownWidgetNode) {
            var eventHandlerString = "javascript: this.className = 'created_list';";

            if (this.pageName.indexOf("OI") == -1) {
                $('#' + this.pageName + 'ShoppingListDivider').before('<div role="menuitem" id="' + this.pageName + 'ShoppingList_' + listId + '" class="created_list" onfocus="javascript:' + jsObjectName + '.focusList(\'' + listId +
                    '\'); "  onblur="' + eventHandlerString + '" onclick="javascript:' + jsObjectName + '.addToList(\'' + listId +
                    '\');"><a role="menuitem" id="' + this.pageName + 'ShoppingListLink_' + listId + '" href="javascript:' + jsObjectName + '.addToList(\'' + listId +
                    '\');" onfocus="javascript:' + jsObjectName + '.focusListLink(\'' + listId + '\');">' + listName + '</a></div>');
            } else {
                var oiId = this.pageName.replace("OI", "");
                $('#' + this.pageName + 'ShoppingListDivider').before('<div role="menuitem" id="' + this.pageName + 'ShoppingList_' + listId + '" class="created_list" onfocus="javascript:' + jsObjectName + '.focusList(\'' + listId +
                    '\'); "  onblur="' + eventHandlerString + '" onclick="javascript:' + jsObjectName + '.addToListAndDelete(\'' + listId +
                    '\',\'' + oiId + '\');"><a role="menuitem" id="' + this.pageName + 'ShoppingListLink_' + listId + '" href="javascript:' + jsObjectName + '.addToListAndDelete(\'' + listId +
                    '\',\'' + oiId + '\');" onfocus="javascript:' + jsObjectName + '.focusListLink(\'' + listId + '\');">' + listName + '</a></div>');
            }
        }
    };

	/**
	 * Clears the textbox in the popup
	 */
	this.clearPopupText = function(){
        $("#" + this.pageName + "newListName").val("");
	};

	/**
	 * Converts & < > " ' to xml accepted form
	 *
	 * @param {String} str, String to be converted
	 * @param {Boolean} fullConversion, if true converts & < > " ' chars
	 * 									if false converts only " ' chars
	 *
	 * @return {String} converted string
	 */
	this.escapeXml = function(str, fullConversion){
		if(fullConversion){
			str = str.replace(/&/gm, "&amp;").replace(/</gm, "&lt;").replace(/>/gm, "&gt;");
		}
		str = str.replace(/"/gm, "&#034;").replace(/'/gm, "&#039;");
		return str;
	};

	 /**
	  * Based on the selected attributes, resolve the SKU of the product.
	  *
	  * @return {Integer} uniqueId of the SKU
	  */
	 this.resolveSKU = function() {
		// if there is only one sku, no need to resolve.
		if(this.catEntryParams.skus.length == 1){
			return this.catEntryParams.skus[0].id;
		}
		for (idx = 0; idx < this.catEntryParams.skus.length; idx++) {
			var matches = 0;
			var attributeCount = 0;
			// iterate through each attribute
			for (attribute in this.catEntryParams.skus[idx].attributes) {
				attributeCount++;
				// check for matches
				if (this.catEntryParams.attributes
						&& this.catEntryParams.skus[idx].attributes[attribute] == this.catEntryParams.attributes[attribute]) {
					matches++;
				} else {
					break;
				}
			}
			// if all the attributes match, pick that SKU
			if (0 != matches && matches == attributeCount) {
				return this.catEntryParams.skus[idx].id;
			}
		}
		// no match found
		return -1;
	};

	/**
	 * Sets the store specific values such as storeId, catalogId and langId in a Object and returns it.
	 *
	 * @return {Object} params with store specific values
	 */
	this.setCommonParams = function(){
		var params = {};
		params.storeId		= this.storeParams.storeId;
		params.catalogId	= this.storeParams.catalogId;
		params.langId		= this.storeParams.langId;
		return params;
	};

	/**
	 * Checks if the string is null, undefined or empty
	 *
	 * @param {String} str, value to be checked
	 * @return {Boolean} true, if empty
	 * 					 false, if not empty
	 */
	this.empty = function(str) {
		return (str == null || str == undefined || str == "");
	};

	/**
	 * redirect users to the sign on page
	 */
	this.redirectToSignOn = function() {
		// 3 scenario's are possible
		/* 
		*	Scenario 1 - Current Page Loaded with HTTP
		*				 In this case, the page will be reloaded with HTTPS and globalLogIn panel is opened up.
		*				 GlobalLoginJS.updateGlobalLoginSignInContent does this work and uses WC_RedirectToPage_xxx cookie to
		*				 identify the page to display after logIn.
		*   Scenario 2 - Current page is loaded with HTTPS and signIn panel is already loaded.
		*				 In this case, before displayiong signIn panel, update the URL field value of the signIn panel form.
		*	Scenario 3 - Current page is laoded with HTTPS, but signIn panel is NOT yet loaded.
		*				 Ajax call is made to load the panel. Send reload URL as part of the ajax call, based on WC_RedirectToPage_xxx cookie value.
		*/
		var currentURL = document.location.href;
		var widgetId = 'Header_GlobalLogin'; // This widgetId is defined in Header_UI.jspf / GlobalLoginActions.js / UserTimeoutView.jsp
		setCookie("WC_RedirectToPage_"+WCParamJS.storeId, currentURL , {path:'/', domain:cookieDomain});			
		GlobalLoginJS.InitHTTPSecure(widgetId);
	};


	/**
	 * changes the style class to show which shopping list is currently focused
	 */
	this.focusList = function(listId){
		this.focusListByElementId(this.pageName + "ShoppingList_" +listId);
	};

	/**
	 * changes the style class to show which shopping list is currently focused
	 */
	this.focusListByElementId = function(elementId){
        if ($("#" + elementId).hasClass("focused")) {
			return;
		}
        $("#" + elementId.replace("ShoppingList", "ShoppingListLink")).focus();

	};

	/**
	 * changes the style class to show which shopping list is currently focused
	 */
	this.focusListLink = function(listId){
        $("#" + this.pageName + "shoppingListDropDown.dropdown_list div").removeClass("focused");
        $("#" + this.pageName + "ShoppingList_" + listId).addClass("focused");
	};

	this.updateShoppingListAndAddItem = function(serviceResponse){
		if(serviceResponse.listName == Utils.getLocalizationMessage('DEFAULT_WISH_LIST_NAME')){
			this.updateDefaultListId(serviceResponse.listId);
		} else {
			this.updateShoppingList(serviceResponse.listId, serviceResponse.listName, serviceResponse.action);
		}

		if(this.addItemAfterCreate){
			this.addItemAfterCreate = false;
			if (this.orderItemId != "") {
				this.addToListAndDelete(serviceResponse.listId, this.orderItemId);
			} else {
				this.addToList(serviceResponse.listId);
			}
		} else {
			if (serviceResponse.action == 'add') {
				this.showSuccessDialog();
			}
		}
	};

	this.navigateDropDown = function(event){
		var shoppingListObj = this;
		if (event.keyCode === KeyCodes.UP_ARROW) {
			Utils.stopEvent(event);

			var focusChanged = false;
			var dropdownList = $( "#" + shoppingListObj.pageName + "shoppingListDropDown.dropdown_list div.created_list" );
			dropdownList.each(function (index, element) {                				
				if (!focusChanged && ($(element).hasClass("focused"))) {
					if(0 == index){
						shoppingListObj.focusListByElementId($(dropdownList).get(dropdownList.length-1).id);
					} else {
						shoppingListObj.focusListByElementId($(dropdownList).get(index-1).id);
					}
					focusChanged = true;
				}
			});
		} else if (event.keyCode === KeyCodes.DOWN_ARROW) {
			Utils.stopEvent(event);

			var focusChanged = false;
			var dropdownList = $("#" + shoppingListObj.pageName + "shoppingListDropDown.dropdown_list div.created_list");
			dropdownList.each(function (index, element) {
				if (!focusChanged && ($(element).hasClass("focused"))) {
					if(dropdownList.length-1 == index){
						shoppingListObj.focusListByElementId($(dropdownList).get(0).id);
					} else {
						shoppingListObj.focusListByElementId($(dropdownList).get(index+1).id);
					}
					focusChanged = true;
				}
			});
		} else if (event.keyCode === KeyCodes.ESCAPE || event.keyCode === KeyCodes.TAB) {
			Utils.stopEvent(event);
			this.hideDropDown();
		}
	};

	this.hideIfNoFocus = function(){
		if(this.dropDownVisible && !this.dropDownInFocus && !this.mouseOnArrow){
			this.hideDropDown();
		}
	};

	this.hasFocus = function(event){
		$(document).on("contextmenu", function (event) {
			if (event.which == 1) {
				this.dropDownInFocus = true;
			} else {
				this.dropDownInFocus = false;
			}
		});
	};


	/**
	 * Method to update the name of an existing shopping list
	 *
	 */
	this.edit = function(){
		// picks the new shopping list name and trims it
                    var name = trim($("#editListName").val());
		var maxlength = name.maxLength;
		var defaultName = Utils.getLocalizationMessage('DEFAULT_WISH_LIST_NAME');

		if (this.empty(name)) {
			// display error message saying list name is empty.
			this.showEditErrorMessage(Utils.getLocalizationMessage('ERR_NAME_EMPTY'));
		} else if(!MessageHelper.isValidUTF8length(name, maxlength)){
			// check for max length
			this.showEditErrorMessage(Utils.getLocalizationMessage('ERR_NAME_TOOLONG'));
		} else if(name == defaultName) {
			// show error message saying that DEFAULT cannot be used
			this.showEditErrorMessage(Utils.getLocalizationMessage('ERR_NAME_SHOPPING_LIST'));
		} else if(this.isDuplicate(name)){
			// show error message saying that DEFAULT cannot be used
			this.showEditErrorMessage(Utils.getLocalizationMessage('ERR_NAME_DUPLICATE'));
		} else if(!this.validateWishName(name)){
			// show error message saying that
			this.showErrorMessage(Utils.getLocalizationMessage('INVALID_NAME_SHOPPING_LIST'));
		} else {
			var params = this.setCommonParams();
			params.name = name;

                        var dropdown = $('#multipleWishlistController_select');
			if((dropdown != null && dropdown != 'undefined') && dropdown.value != 0){
				// get wish list ID
                            params["giftListId"] = $("#multipleWishlistController_select").val();
                            this.nameToDelete = $('#multipleWishlistController_select options:dropdown.selectedIndex').text();
			}
                        $("#editShoppingListPopup").data("wc-WCDialog").close();
                        
                        // For Handling multiple clicks.
                        if (!submitRequest()) {
                            return;
                        }
                        cursor_wait();
                        // calling the service to save the new list name
                        wcService.invoke('ShoppingListServiceUpdate', params);
                    }
                };

	/**
	 * Method to delete an existing shopping list
	 *
	 */
	this.deleteList = function(){
		var params = this.setCommonParams();
                    var dropdown = $('#multipleWishlistController_select');
		if((dropdown != null && dropdown != 'undefined') && dropdown.value != 0){
			// get wish list ID
                        params["giftListId"] = $("#multipleWishlistController_select").val();
                        this.nameToDelete = $('#multipleWishlistController_select options:dropdown.selectedIndex').text();
		}
                    $("#deleteShoppingListPopup").data("wc-WCDialog").close();
                    
                    // For Handling multiple clicks.
                    if (!submitRequest()) {
                        return;
                    }
                    cursor_wait();
                    // calling the service to save the new list name
                    wcService.invoke('ShoppingListServiceDelete', params);
                };

	/**
	 * Method that knows how to hide or un-hide the links to delete and rename a wish list in the my account
	 * wish list select controller area.
	 *
	 */
	this.refreshLinkState = function() {
        var dropdown =$('#multipleWishlistController_select')[0];
		if (dropdown != null) {
			var wName = $('#multipleWishlistController_select')[0].options[dropdown.selectedIndex].text;
			var defaultName = Utils.getLocalizationMessage('DEFAULT_WISH_LIST_NAME');
			if (wName == defaultName) {
				//hide the delete and rename links, default wish list cannot be changed nor deleted
                        	$('#editDivider').css('display','none');
                        	$('#edit_popup_link').css('display','none');
                        	$('#deleteDivider').css('display','none');
                        	$('#delete_popup_link').css('display','none');
                        } else {
                        	$('#editDivider').css('display','block');
                        	$('#edit_popup_link').css('display','block');
                        	$('#deleteDivider').css('display','block');
                        	$('#delete_popup_link').css('display','block');
                        }
                    }
                };

	/**
	  * move an order item to the default wish list
	  * @param {string} listId id of the shopping list to add the item to
	  * @param {string} orderItemId the order item id of the item to be removed from shopping cart
	  */
	this.addToListAndDelete = function(listId, inOrderItemId, focusElement) {
		this.orderItemId = inOrderItemId;

                    wcTopic.publish("modelChanged/AnalyticsConversionEvent");

		this.hideDropDown();

		var params = this.setCommonParams();
		params.giftListId = listId;
		params["catEntryId_1"] = this.catEntryParams.id;
		params["quantity_1"] = 1;

		// For Handling multiple clicks.
		if(!submitRequest()){
			return;
		}
		cursor_wait();
		ShoppingListDialogJS.setDialogParams(this.storeParams, {catEntryId:this.catEntryParams.id, name:this.catEntryParams.name, image:this.catEntryParams.image, thumbnail: 'imgPath', focusElement: focusElement});
		wcService.invoke('ShoppingListServiceAddItemAndRemoveFromCart',params);
	};

	/**
	 * delete an order item from the shopping cart
	*/
	this.deleteItemFromCart = function() {
		if (this.orderItemId != "") {
			var test = this.orderItemId;
			this.orderItemId = "";
			if(test != ""){
				CheckoutHelperJS.deleteFromCart(test, true);
			}
		}
	};
	/**
	 * validate the wish name
	 */
	this.validateWishName = function(wishName) {
		var invalidChars = "~!@#$%^&*()+=[]{};:,<>?/|`"; // invalid chars
		invalidChars += "\t\'\"\\\/"; // escape sequences

		// look for presence of invalid characters.  if one is
		// found return false.  otherwise return true
		for (var i=0; i<wishName.length; i++) {
		  if (invalidChars.indexOf(wishName.substring(i, i+1)) >= 0) {
			return false;
		  }
		}
		return true;
	};
	/**
	 * Indicate a catEntry component has been resolved or unresolved (attributes selected or not selected)
	 */
	this.setResolved = function(baseItemId, value) {
		this.catEntryParams.components[baseItemId].resolved = value;
	};
	
                $(document.documentElement).on("mousedown", $.proxy("hideIfNoFocus", this));
	for (baseItemId in this.catEntryParams.components) {
		// For each catEntry component, subscribe to SKU resolution
                    wcTopic.subscribe('DefiningAttributes_Resolved_' + baseItemId, function (catEntryId, productId) {
			eval(jsObjectName + ".setResolved('" + productId + "', true)");
		});
                    wcTopic.subscribe('DefiningAttributes_Changed_' + baseItemId, function (catEntryId, productId) {
			if (catEntryId == 0) {
				// Some attribute has not been selected after SKU resolution
				eval(jsObjectName + ".setResolved('" + productId + "', false)");
			}
		});
	};
}

if(typeof(ShoppingListDialogJS) == "undefined" || ShoppingListDialogJS == null || !ShoppingListDialogJS) {

	ShoppingListDialogJS = {
		storeParams: null,
		dialogParams: null,

		setDialogParams: function(storeParams, dialogParams){
			this.storeParams = storeParams;
			this.dialogParams = dialogParams;
			if(this.dialogParams.image == null || this.dialogParams.image == ''){
				// when item image is not available, we need to fetch separately
				this.fetchAddedItem();
			} else {
				// when item is moved - the ones available in cart pages
				this.displayItemAddedWithoutFetching();
			}
		},

		fetchAddedItem: function(){
			var params = this.setCommonParams();
			params.productId = this.dialogParams.catEntryId;
			params.catalogEntryId = this.dialogParams.catEntryId;

			$.ajax({
				url: getAbsoluteURL() + "GetCatalogEntryDetailsByIDView",
				method:"post",
                		dataType: "json",
                		data: params,
				success: ShoppingListDialogJS.displayItemAddedDialog,
				error: function(jqXHR, textStatus, err) {
					console.debug("QuickInfoJS.selectItem: Unexpected error occurred during an xhrPost request.");
				}
			});
		},

		displayItemAddedDialog: function(serviceResponse) {
			var itemAddedPopup = $("#shoppingListItemAddedPopup");
			if(itemAddedPopup != null){
                var data = serviceResponse.catalogEntry.description[0];
                $("#shoppingListItemAddedImg").attr("src", data.thumbnail)
                                            .attr("alt", data.name);
				$("#shoppingListItemAddedName").html(data.name);
                $("#shoppingListItemAddedPopup").data("wc-WCDialog").open();
			} else {
				console.debug("shoppingListItemAddedPopup does not exist");
			}
		},

		/**
		 * This method can be used to display "Added to Wish List" popup in cart pages
		 * because cart has only items and no products, so no need to make another call to pick item image & name
		 */
		displayItemAddedWithoutFetching: function() {
                            if ($("#shoppingListItemAddedPopup").length) {
                                $("#shoppingListItemAddedImg").attr("src", this.dialogParams.image);
                                $("#shoppingListItemAddedImg").attr("alt", this.dialogParams.name);
                                $("#shoppingListItemAddedName").html(this.dialogParams.name);
                            } else {
                                console.debug("shoppingListItemAddedPopup does not exist");
                            }
                        },

		/**
		 * show popup
		 */
		showDialog: function(){
			var itemAddedPopup = $("#shoppingListItemAddedPopup");
			if(itemAddedPopup != null){
				itemAddedPopup.data("wc-WCDialog").open();
			} else {
				console.debug("shoppingListItemAddedPopup does not exist");
			}
		},

		setCommonParams: function(){
			var params = new Object();
			params.storeId		= this.storeParams.storeId;
			params.catalogId	= this.storeParams.catalogId;
			params.langId		= this.storeParams.langId;
			return params;
		},

		close: function(){
			$("#shoppingListItemAddedPopup").hide();
			if (this.dialogParams.focusElement && this.dialogParams.focusElement != "") {
				$("#" + this.dialogParams.focusElement).focus();
			}
		}
	}
	/*
	 * itemAddedReadyForDelete applies to items in cart - since cart has only items and no products,
	 * so no need to make another call to pick item image & name
	 */
	wcTopic.subscribe("ShoppingListItem_Added", ShoppingListDialogJS.showDialog);

}
//-----------------------------------------------------------------
// Licensed Materials - Property of IBM
//
// WebSphere Commerce
//
// (C) Copyright IBM Corp. 2012 All Rights Reserved.
//
// US Government Users Restricted Rights - Use, duplication or
// disclosure restricted by GSA ADP Schedule Contract with
// IBM Corp.
//-----------------------------------------------------------------

/** 
 * @fileOverview This javascript is used by the wish list pages to handle CRUD operations.
 * @version 1.0
 */


/**
/**
         * Declares a new render context for the Wishlist display,
         * and initializes it with the post URL to load. 
         */
        wcRenderContext.declare("WishlistDisplay_Context", ["WishlistDisplay_Widget"], {
            url: ""
        });
/**	
 * Declares a new render context for the Shared Wishlist display,
 * and initializes it with the post URL to load. 
 */
wcRenderContext.declare("SharedWishlistDisplay_Context", ["SharedWishlistDisplay_Widget"], {
            url: ""
        });
	
	
		
ShoppingListControllersJS = {

    
    declareWishlistDisplayWidgetRefreshController: function () {
        // ============================================
        // div: WishlistDisplay_Widget refresh area
        // Declares a new refresh controller for the Wishlist display
        var myWidgetObj = $("#WishlistDisplay_Widget");
       
        
        var myRCProperties = wcRenderContext.getRenderContextProperties("WishlistDisplay_Context");

        /** 
         * Displays the previous/next page of items on the Wishlist display page.
         * This function is called when a render context changed event is detected. 
         */
        var renderContextChangedHandler = function () {
            myWidgetObj.refreshWidget("refresh", myRCProperties);
        };

        /** 
         * Refreshs the wishlist display when an item is added to or deleted from the wishlist.
         * This function is called when a modelChanged event is detected. 
         */
        wcTopic.subscribe(["ShoppingListServiceCreate", "ShoppingListServiceUpdate", "ShoppingListServiceDelete", "ShoppingListServiceRemoveItem", "ShoppingListServiceAddItem"], function () {
            myWidgetObj.refreshWidget("refresh");
        });

        /** 
         * This function handles paging and browser back/forward functionalities upon a successful refresh.
         */
        var postRefreshHandler = function () {
            if (($("#multipleWishlistController_select") != null && $("#multipleWishlistController_select") != 'undefined')) {
                $("#multipleWishlistController_select").disabled = false;
            }
            cursor_clear();
        }

        // initialize widget with properties
        myWidgetObj.refreshWidget({
            renderContextChangedHandler: renderContextChangedHandler,
            postRefreshHandler: postRefreshHandler
        });
    },

    declareSharedWishlistDisplayRefreshController: function () {
        // ============================================
        // div: SharedWishlistDisplay_Widget refresh area
        // Declares a new refresh controller for the shared Wishlist display
        var myWidgetObj = $("#SharedWishlistDisplay_Widget");

        
        var myRCProperties = wcRenderContext.getRenderContextProperties("SharedWishlistDisplay_Context");

        /** 
         * Displays the previous/next page of items on the Shared Wishlist display page.
         * This function is called when a render context changed event is detected. 
         */
        var renderContextChangedHandler = function () {
            myWidgetObj.refreshWidget("refresh", myRCProperties);
        };

        /** 
         * This function handles paging and browser back/forward functionalities upon a successful refresh.
         */
        var postRefreshHandler = function () {
            cursor_clear();
        }

        // initialize widget with properties
        myWidgetObj.refreshWidget({
            renderContextChangedHandler: renderContextChangedHandler,
            postRefreshHandler: postRefreshHandler
        });
    },
    declareWishlistSelectWidgetRefreshController: function () {
        // ============================================
        // div: WishlistSelect_Widget refresh area
        // Declares a new refresh controller for the Wishlist select display
	
	/**
 * Declares a new render context for the multiple Wishlist select display
 */
 wcRenderContext.declare("WishlistSelect_Context", ["WishlistSelect_Widget"], "");
        var myWidgetObj = $("#WishlistSelect_Widget");

        /**
         * Declares a new render context for the multiple Wishlist select display
         */
       
        var myRCProperties = wcRenderContext.getRenderContextProperties("WishlistSelect_Context");


        /** 
         * Displays the previous/next page of items on the Wishlist display page.
         * This function is called when a render context changed event is detected. 
         */
        var renderContextChangedHandler = function () {
            myWidgetObj.refreshWidget("refresh", myRCProperties);
        };

        /** 
         * Refreshs the wishlist select drop down display when a new wish list is added or when a wish list is deleted.
         * This function is called when a modelChanged event is detected. 
         */
        wcTopic.subscribe(["ShoppingListServiceCreate", "ShoppingListServiceUpdate", "ShoppingListServiceDelete", "ShoppingListServiceAddItem"], function () {
            myWidgetObj.refreshWidget("refresh");
        });

        /** 
         * Hide the progress bar upon a successful refresh.
         */
        var postRefreshHandler = function () {
            cursor_clear();
            //ensure default wish list name is used if all lists are deleted.
            var dropdown = $('#multipleWishlistController_select');
            if (dropdown == null) {
                //if the drop down does not exist, that means there is no wish list
                MultipleWishLists.defaultListId = null;
                MultipleWishLists.addItemAfterCreate = null;
            } else if (dropdown.length > 0) {
                //ensure the name of the wish list is the same as the one selected in the drop down
                MultipleWishLists.defaultListId = $('#multipleWishlistController_select').val();
		
                shoppingListJS.refreshLinkState();
            }
        }

        // initialize widget with properties
        myWidgetObj.refreshWidget({
            renderContextChangedHandler: renderContextChangedHandler,
            postRefreshHandler: postRefreshHandler
        });

    }


};
//-----------------------------------------------------------------
// Licensed Materials - Property of IBM
//
// WebSphere Commerce
//
// (C) Copyright IBM Corp. 2011, 2015 All Rights Reserved.
//
// US Government Users Restricted Rights - Use, duplication or
// disclosure restricted by GSA ADP Schedule Contract with
// IBM Corp.
//-----------------------------------------------------------------

/** 
 * @fileOverview This javascript is used by the wish list pages to handle CRUD operations.
 * @version 1.0
 */

/**
 * This REST service allows customers to create a new shopping list
 * @constructor
 */
wcService.declare({
        id: "ShoppingListServiceCreate",
        actionId: "ShoppingListServiceCreate",
        url: getAbsoluteURL() + "AjaxRestWishListCreate",
        formId: ""

        /**
         * Hides all the messages and the progress bar.
         * @param (object) serviceResponse The service response object, which is the
         * JSON object returned by the service invocation.
         */
        ,
        successHandler: function (serviceResponse) {
            cursor_clear();
            closeAllDialogs(); //close the create popup

            wcTopic.publish("ShoppingList_Changed", {
                listId: serviceResponse.uniqueID,
                listName: serviceResponse.descriptionName,
                action: 'add'
            });




        }

        /**
         * display an error message.
         * @param (object) serviceResponse The service response object, which is the
         * JSON object returned by the service invocation.
         */
        ,
        failureHandler: function (serviceResponse) {
            if (serviceResponse.errorMessage) {
                MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
            } else {
                if (serviceResponse.errorMessageKey) {
                    MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
                }
            }
            cursor_clear();
        }
    }),

    /**
     * This REST service allows customers to update the name of a shopping list
     * @constructor
     */
    wcService.declare({
        id: "ShoppingListServiceUpdate",
        actionId: "ShoppingListServiceUpdate",
        url: getAbsoluteURL() + "AjaxRestWishListUpdate",
        formId: ""

        /**
         * Hides all the messages and the progress bar.
         * @param (object) serviceResponse The service response object, which is the
         * JSON object returned by the service invocation.
         */
        ,
        successHandler: function (serviceResponse) {
            cursor_clear();
            closeAllDialogs();
            shoppingListJS.showMessageDialog(Utils.getLocalizationMessage('LIST_EDITED'));

            wcTopic.publish("ShoppingList_Changed", {
                listId: serviceResponse.uniqueID,
                listName: serviceResponse.descriptionName,
                action: 'edit'
            });

        }

        /**
         * display an error message.
         * @param (object) serviceResponse The service response object, which is the
         * JSON object returned by the service invocation.
         */
        ,
        failureHandler: function (serviceResponse) {
            if (serviceResponse.errorMessage) {
                MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
            } else {
                if (serviceResponse.errorMessageKey) {
                    MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
                }
            }
            cursor_clear();
        }
    }),

    /**
     * This REST service allows customers to delete a selected shopping list
     * @constructor
     */
    wcService.declare({
        id: "ShoppingListServiceDelete",
        actionId: "ShoppingListServiceDelete",
        url: getAbsoluteURL() + "AjaxRestWishListDelete",
        formId: ""

        /**
         * Hides all the messages and the progress bar.
         * @param (object) serviceResponse The service response object, which is the
         * JSON object returned by the service invocation.
         */
        ,
        successHandler: function (serviceResponse) {
            cursor_clear();
            closeAllDialogs();
            shoppingListJS.showMessageDialog(Utils.getLocalizationMessage('LIST_DELETED'));

            wcTopic.publish("ShoppingList_Changed", {
                listId: serviceResponse.uniqueID,
                listName: '',
                action: 'delete'
            });

        }

        /**
         * display an error message.
         * @param (object) serviceResponse The service response object, which is the
         * JSON object returned by the service invocation.
         */
        ,
        failureHandler: function (serviceResponse) {
            if (serviceResponse.errorMessage) {
                MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
            } else {
                if (serviceResponse.errorMessageKey) {
                    MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
                }
            }
            cursor_clear();
        }
    }),

    /**
     * This REST service allows customers to add an item to a shopping list
     * @constructor
     */
    wcService.declare({
        id: "ShoppingListServiceAddItem",
        actionId: "ShoppingListServiceAddItem",
        url: getAbsoluteURL() + "AjaxRestWishListAddItem",
        formId: ""

        /**
         * Hides all the messages and the progress bar.
         * @param (object) serviceResponse The service response object, which is the
         * JSON object returned by the service invocation.
         */
        ,
        successHandler: function (serviceResponse) {
            cursor_clear();
            wcTopic.publish("ShoppingListItem_Added");
        }

        /**
         * display an error message.
         * @param (object) serviceResponse The service response object, which is the
         * JSON object returned by the service invocation.
         */
        ,
        failureHandler: function (serviceResponse) {
            if (serviceResponse.errorMessage) {
                MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
            } else {
                if (serviceResponse.errorMessageKey) {
                    MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
                }
            }
            cursor_clear();
        }
    }),

    /**
     * This REST service allows customers to remove an item from a shopping list
     * @constructor
     */
    wcService.declare({
        id: "ShoppingListServiceRemoveItem",
        actionId: "ShoppingListServiceRemoveItem",
        url: getAbsoluteURL() + "AjaxRestWishListRemoveItem",
        formId: ""

        /**
         * Hides all the messages and the progress bar.
         * @param (object) serviceResponse The service response object, which is the
         * JSON object returned by the service invocation.
         */
        ,
        successHandler: function (serviceResponse) {
            cursor_clear();
            MessageHelper.hideAndClearMessage();
            shoppingListJS.showMessageDialog(Utils.getLocalizationMessage('ITEM_REMOVED'));
        }

        /**
         * display an error message.
         * @param (object) serviceResponse The service response object, which is the
         * JSON object returned by the service invocation.
         */
        ,
        failureHandler: function (serviceResponse) {
            if (serviceResponse.errorMessage) {
                MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
            } else {
                if (serviceResponse.errorMessageKey) {
                    MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
                }
            }
            cursor_clear();
        }
    }),

    /**
     * This REST service allows customers to add an item to a shopping list and remove from the shopping cart
     * @constructor
     */
    wcService.declare({
        id: "ShoppingListServiceAddItemAndRemoveFromCart",
        actionId: "ShoppingListServiceAddItemAndRemoveFromCart",
        url: getAbsoluteURL() + "AjaxRestWishListAddItem",
        formId: ""

        /**
         * Hides all the messages and the progress bar.
         * @param (object) serviceResponse The service response object, which is the
         * JSON object returned by the service invocation.
         */
        ,
        successHandler: function (serviceResponse) {
            cursor_clear();
            wcTopic.publish("ShoppingListItem_Added");
        }

        /**
         * display an error message.
         * @param (object) serviceResponse The service response object, which is the
         * JSON object returned by the service invocation.
         */
        ,
        failureHandler: function (serviceResponse) {
            if (serviceResponse.errorMessage) {
                MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
            } else {
                if (serviceResponse.errorMessageKey) {
                    MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
                }
            }
            cursor_clear();
        }
    }),

    /**
     * This REST service allows customers to set a wish list as the default list
     * @constructor
     * 
     **/
    wcService.declare({
        id: "AjaxGiftListServiceChangeGiftListStatus",
        actionId: "AjaxGiftListServiceChangeGiftListStatus",
        url: getAbsoluteURL() + "AjaxRestWishListChangeState",
        formId: ""

        /**
         * Hides all the messages and the progress bar.
         * @param (object) serviceResponse The service response object, which is the
         * JSON object returned by the service invocation.
         */
        ,
        successHandler: function (serviceResponse) {
            cursor_clear();
            MessageHelper.hideAndClearMessage();

            //	MultipleWishLists.updateDefaultListName('multipleWishListButton',serviceResponse.descriptionName);		
            //	MultipleWishLists.updateDefaultListName('addToMultipleWishListLink',serviceResponse.descriptionName);
            MultipleWishLists.setDefaultListId(serviceResponse.uniqueID);
            MultipleWishLists.updateContextPostSwitch(serviceResponse.uniqueID);
        }

        /**
         * display an error message.
         * @param (object) serviceResponse The service response object, which is the
         * JSON object returned by the service invocation.
         */
        ,
        failureHandler: function (serviceResponse) {
            if (serviceResponse.errorMessage) {
                MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
            } else {
                if (serviceResponse.errorMessageKey) {
                    MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
                }
            }
            cursor_clear();
        }
    }),

    /**
     * This REST service sends the wish list to a specified email address.
     */
    wcService.declare({
        id: "AjaxGiftListAnnouncement",
        actionId: "AjaxGiftListAnnouncement",
        url: getAbsoluteURL() + "AjaxRESTWishListAnnounce",
        formId: ""

        /**
         * hides all the messages and the progress bar
         * @param (object) serviceResponse The service response object, which is the
         * JSON object returned by the service invocation
         */
        ,
        successHandler: function (serviceResponse) {
                cursor_clear();
                MessageHelper.hideAndClearMessage();
                shoppingListJS.showMessageDialog(Utils.getLocalizationMessage('WISHLIST_EMAIL_SENT'));
                $("#WishListEmailSucMsg_Div").css("display","block");
                //limit the recipient number of characters in To: email address of email success message to 25 characters 
                $("#recipientEmail_wishListDisplay").html(serviceResponse.recipient[0].substring(0, 25));
            }
            /**
             * display an error message
             * @param (object) serviceResponse The service response object, which is the
             * JSON object returned by the service invocation
             */
            ,
        failureHandler: function (serviceResponse) {

            if (serviceResponse.errorMessage) {
                MessageHelper.displayErrorMessage(serviceResponse.errorMessage);
            } else {
                if (serviceResponse.errorMessageKey) {
                    MessageHelper.displayErrorMessage(serviceResponse.errorMessageKey);
                }
            }
            cursor_clear();
        }

    })
//-----------------------------------------------------------------
// Licensed Materials - Property of IBM
//
// WebSphere Commerce
//
// (C) Copyright IBM Corp. 2013, 2016 All Rights Reserved.
//
// US Government Users Restricted Rights - Use, duplication or
// disclosure restricted by GSA ADP Schedule Contract with
// IBM Corp.
//-----------------------------------------------------------------

var toggleCollapsible = function(collapsible) {
	var content = collapsible.querySelector(".content");
	var expanded = $(collapsible).attr("aria-expanded");
	var mainESpotHome = document.getElementById("mainESpotHome");
	(content.id.match(/homeESpotDetails/)) ? ((mainESpotHome.className == "closed") ? mainESpotHome.className = "expand" : mainESpotHome.className = "closed") : 0;
	if (expanded == "true") {
		window.setTimeout(function() {
			$(collapsible).attr("aria-expanded", "false");
			$(content).css("transition", "max-height .2s");
		}, 0);
		window.setTimeout(function() {
			$(content).css("transition", null);
		}, 200);
		window.setTimeout(function() {
			$(content).css("display", "none");
		}, 300);
	} else if (expanded == "false") {
		$(collapsible).attr("aria-expanded", "true");
		$(content).css("transition", "max-height .2s");
		window.setTimeout(function() {
			$(content).css("transition", null);
		}, 200);
		window.setTimeout(function() {
			$(content).css("display", "block");
		}, 300);
	}
};

var updateGrid = function(i, grid) {
	var width = grid.clientWidth;
	var minColWidth = $(grid).attr("data-min-col-width");
	var minColCount = $(grid).attr("data-min-col-count");
	var colCount = Math.floor(width/minColWidth);
	if (colCount < minColCount) {
		colCount = minColCount;
	}
	var colWidth = Math.floor(100/colCount) + "%";
    $(".col", grid).css("width", colWidth);
};

var toggleExpandNav = function(id) {
	var icon = byId("icon_" + id);
	var section_list = byId("section_list_" + id);
	if(icon.className == "arrow") {
		icon.className = "arrow arrow_collapsed";
		$(section_list).attr("aria-expanded", "false");
		$(section_list).css("display", "none");
	} else {
		icon.className = "arrow";
		$(section_list).attr("aria-expanded", "true");
		$(section_list).css("display", "block");
	}
};

$(document).ready(function() {
    var updateCollapsibles = function(mediaQuery) {
        var expanded = mediaQuery ? !mediaQuery.matches : document.documentElement.clientWidth > 583;
        if (expanded == false){
            $(".collapsible").attr("aria-expanded", expanded.toString());
        }else {
            $(".collapsible:not(.collapsedOnInit)").attr("aria-expanded", expanded.toString());
        }
    };
    if (window.matchMedia) {
        var mediaQuery = window.matchMedia("(max-width: 600px)");
        updateCollapsibles(mediaQuery);
        mediaQuery.addListener(updateCollapsibles);
    }
    else {
        updateCollapsibles();

        $(window).on("resize", function(event) {
            updateCollapsibles();
        });
    }

    Utils.onOnce($(document), "click", "collapsible", ".collapsible .toggle", function(event) {
        toggleCollapsible($(event.target).parents(".collapsible")[0]);
        event.preventDefault();
    });
    Utils.onOnce($(document), "keydown", "collapsible", ".collapsible .toggle", function(event) {
        if (event.keyCode === KeyCodes.RETURN || event.keyCode === KeyCodes.SPACE) {
            toggleCollapsible($(event.target).parents(".collapsible")[0]);
            event.preventDefault();
        }
    });

    $(".grid").each(updateGrid);

    $(window).on("resize", function(event) {
        $(".grid").each(updateGrid);
    });
});


//-----------------------------------------------------------------
// Licensed Materials - Property of IBM
//
// WebSphere Commerce
//
// (C) Copyright IBM Corp. 2013, 2014 All Rights Reserved.
//
// US Government Users Restricted Rights - Use, duplication or
// disclosure restricted by GSA ADP Schedule Contract with
// IBM Corp.
//-----------------------------------------------------------------
/* global Utils, $, document, window, wc, setTimeout, cX, processAndSubmitForm, updateFormWithWcCommonRequestParameters, cursor_wait, cursor_clear */

// Declare functions/variables needed by the declareDeptDropdownRefreshArea function here
var updateDepartmentsMenu,
    activate,
    ajaxRefresh = "",

// We need this function to be global for Header_UI.jspf to call it
    setAjaxRefresh = function (refresh) {
        ajaxRefresh = refresh;
    };

$(document).ready(function () {
    var mouseDownRegistered = false,
        activeMenuNode = null,
        toggleControlNode = null,
        active = {},
        departmentMenuId = "departmentMenu_",
        registerMouseDown = function () {
            if (!mouseDownRegistered) {
                $(document.documentElement).on("mousedown.wc.header", handleMouseDown);
                mouseDownRegistered = true;
            }
        },
        unregisterMouseDown = function () {
            if (mouseDownRegistered) {
                $(document.documentElement).off("mousedown.wc.header");
                mouseDownRegistered = false;
            }
        },
        handleMouseDown = function (evt) {
            var node = evt.target;
            if (activeMenuNode !== null && node != document.documentElement) {
                var close = true;
                var parent = activeMenuNode.getAttribute("data-parent");
                while (node && node != document.documentElement) {
                    if (node == activeMenuNode || node == toggleControlNode || $(node).hasClass("dijitPopup") || parent == node.getAttribute("data-parent")) {
                        close = false;
                        break;
                    }
                    node = node.parentNode;
                }
                if (node === null) {
                    var children = $("div", activeMenuNode);
                    for (var i = 0; i < children.length; i++) {
                        var position = Utils.position(children[i]);
                        if (evt.clientX >= position.x && evt.clientX < position.x + position.w &&
                            evt.clientY >= position.y && evt.clientY < position.y + position.h) {
                            close = false;
                            break;
                        }
                    }
                }
                if (close) {
                    deactivate(activeMenuNode);
                }
            }
        },
        deactivate = function (target) {
            if (active[target.id]) {
                deactivate(active[target.id]);
            }
            $(target).removeClass("active");
            $("a[data-activate='" + target.id + "']").removeClass("selected");
            $("a[data-toggle='" + target.id + "']").removeClass("selected");
            var parent = target.getAttribute("data-parent");
            delete active[parent];
            if (target == activeMenuNode) {
                activeMenuNode = null;
                toggleControlNode = null;
                unregisterMouseDown();
            }
        },
        toggle = function (target) {
            if ($(target).hasClass("active")) {
                deactivate(target);
            } else {
                activate(target);
            }
        },
        setUpEventActions = function () {
            $(document).on("click", "a[data-activate]", function (e) {
                var target = this.getAttribute("data-activate");
                activate(document.getElementById(target));
                Utils.stopEvent(e);
            });
            $(document).on("click", "a[data-deactivate]", function (e) {
                var target = this.getAttribute("data-deactivate");
                deactivate(document.getElementById(target));
                Utils.stopEvent(e);
            });
            $(document).on("click", "a[data-toggle]", function (e) {
                var target = this.getAttribute("data-toggle");
                toggle(document.getElementById(target));
                Utils.stopEvent(e);
            });
            $(document).on("keydown", "a[data-toggle]", function (e) {
                var target;
                if (e.keyCode === 27) {
                    target = this.getAttribute("data-toggle");
                    deactivate(document.getElementById(target));
                    Utils.stopEvent(e);
                } else if (e.keyCode === 40) {
                    target = this.getAttribute("data-toggle");
                    var targetElem = document.getElementById(target);
                    activate(targetElem);
                    $('[class*="menuLink"]', targetElem)[0].focus();
                    Utils.stopEvent(e);
                }
            });

            var ie_version = Utils.get_IE_version();
            if (ie_version && ie_version < 10) {
                $("input[placeholder]").each(function (i, input) {
                    var placeholder = input.getAttribute("placeholder");
                    if (placeholder) {
                        var label = document.createElement("label");
                        label.className = "placeholder";
                        label.innerHTML = placeholder;
                        input.parentNode.insertBefore(label, input);
                        var updatePlaceholder = function () {
                            label.style.display = (input.value ? "none" : "block");
                        };
                        window.setTimeout(updatePlaceholder, 200);
                        $(input).on("blur focus keyup", updatePlaceholder);
                        $(label).click(function (e) {
                            input.focus();
                        });
                    }
                });
            }
        };

    activate = function (target) {
        var startsWith = (target.id.slice(0, departmentMenuId.length) == departmentMenuId);
        if (ajaxRefresh == "true" && startsWith) {
            setAjaxRefresh(""); // No more refresh till shopper leaves this page
            // Update the Context, so that widget gets refreshed..
            wcRenderContext.updateRenderContext("departmentSubMenuContext", {
                "targetId": target.id
            });
            if (typeof cX === 'function') {
                // For Coremetrics tagging to generate linkclick tags when clicking on navigation buttons
                setTimeout(function () {
                    cX("");
                }, 1000);
            }
            return;
        }

        var parent = target.getAttribute("data-parent");
        if (parent && active[parent]) {
            deactivate(active[parent]);
        }
        if (parent) {
            activate(document.getElementById(parent));
        }
        $(target).addClass("active");
        $("a[data-activate='" + target.id + "']").addClass("selected");
        var toggleControl = $("a[data-toggle='" + target.id + "']");
        toggleControl.addClass("selected");
        if (parent) {
            active[parent] = target;
            if (activeMenuNode === null) {
                activeMenuNode = target;
                toggleControlNode = toggleControl.length > 0 ? toggleControl[0] : null;
                registerMouseDown();
            }
        }
    };

    setUpEventActions();

    window.setTimeout(function () {
        var quickLinksBar = document.getElementById("quickLinksBar");
        var quickLinksButton = document.getElementById("quickLinksButton");
        var quickLinksMenu = document.getElementById("quickLinksMenu");
        var quickLinksMenuItems = $("> ul > li > a", quickLinksMenu);
        var signInOutQuickLink = document.getElementById("signInOutQuickLink");
        $("#quickLinksMenu > ul > li").each(function (i, li) {
            if (li.id != "facebookQuickLinkItem" && li.id != "globalLoginWidget") {
                li = li.cloneNode(true);
                $("[id]", li).each(function (j, node) {
                    node.id += "_alt";
                });
                quickLinksBar.insertBefore(li, quickLinksBar.firstChild);
            }
        });
        $("#quickLinksBar > li > a, #quickLinksBar > li > span").each(function (i, node) {
            if (node.id != "miniCartButton" && node.id != "barcodeScanButton" && node.id.indexOf("signOutQuickLink") === -1 && node.id != "contactQuickLink_alt") {
                var s = $.trim(node.innerHTML);
                var it = node.childNodes;
                //find the first non-blank text node (type=3)
                for (i = 0; i < it.length; i++) {
                    if (it[i].nodeType === 3 && $.trim(it[i].nodeValue) !== "") {
                        s = $.trim(it[i].nodeValue);
                        break;
                    }
                }
                var n = s.lastIndexOf(",");
                if (n === -1) {
                    n = s.lastIndexOf(" ");
                }
                if (n != -1) {
                    var sBr = s.substring(0, n + 1) + "<br/>" + s.substring(n + 1, s.length);
                    node.innerHTML = node.innerHTML.replace(s, sBr);
                }
            }
        });
        $(quickLinksButton).click(function (e) {
            var target = this.getAttribute("data-toggle");
            toggle(document.getElementById(target));
            Utils.stopEvent(e);
        });
        $(quickLinksButton).keydown(function (e) {
            var target;
            if (e.keyCode === 40) {
                target = this.getAttribute("data-toggle");
                activate(document.getElementById(target));
                quickLinksMenuItems[0].focus();
                Utils.stopEvent(e);
            } else if (e.keyCode === 9 || (e.keyCode === 9 && e.shiftKey)) {
                deactivate(quickLinksMenu);
            } else if (e.keyCode === 27) {
                target = this.getAttribute("data-toggle");
                deactivate(document.getElementById(target));
                Utils.stopEvent(e);
            }
        });
        $(quickLinksMenu).keydown(function (e) {
            if (e.keyCode === 27 || e.keyCode === 9 || (e.keyCode === 9 && e.shiftKey)) {
                deactivate(quickLinksMenu);
            } else if (e.keyCode === 27) {
                var target = this.getAttribute("data-toggle");
                deactivate(document.getElementById(target));
                Utils.stopEvent(e);
            }
        });
        quickLinksMenuItems.each(function (i, quickLinksMenuItem) {
            quickLinksMenuItem.setAttribute("role", "menuitem");
            quickLinksMenuItem.setAttribute("tabindex", "-1");
            $(quickLinksMenuItem).keydown(function (e) {
                switch (e.keyCode) {
                case 38:
                    quickLinksMenuItems[i === 0 ? quickLinksMenuItems.length - 1 : i - 1].focus();
                    Utils.stopEvent(e);
                    break;
                case 40:
                    quickLinksMenuItems[(i + 1) % quickLinksMenuItems.length].focus();
                    Utils.stopEvent(e);
                    break;
                }
            });
        });
        var searchFilterButton = document.getElementById("searchFilterButton");
        if (searchFilterButton) {
            $(searchFilterButton).keydown(function (e) {
                if (e.keyCode === 9 || (e.keyCode === 9 && e.shiftKey)) {
                    deactivate(document.getElementById(searchFilterButton.getAttribute("data-toggle")));
                }
            });
        }
        var searchForm = document.getElementById("SimpleSearchForm_SearchTerm");
        if (searchForm) {
            $(searchForm).click(function (e) {
                $('.selected:not(a[data-toggle="searchBar"])', document.getElementById("header")).each(function (i, selectedDataToggle) {
                    deactivate(document.getElementById(selectedDataToggle.getAttribute("data-toggle")));
                });
            });
        }
        var searchFilterMenu = document.getElementById("searchFilterMenu");
        if (searchFilterMenu) {
            $('[class*="menuLink"]', searchFilterMenu).each(function (i, searchFilterMenuItems) {
                $(searchFilterMenuItems).keydown(function (e) {
                    if (e.keyCode === 27) {
                        deactivate(searchFilterMenu);
                        Utils.stopEvent(e);
                    } else if (e.keyCode === 9 || (e.keyCode === 9 && e.shiftKey)) {
                        deactivate(searchFilterMenu);
                    } else if (e.keyCode === 38) {
                        searchFilterMenuItems[i === 0 ? searchFilterMenuItems.length - 1 : i - 1].focus();
                        Utils.stopEvent(e);
                    } else if (e.keyCode === 40) {
                        searchFilterMenuItems[(i + 1) % searchFilterMenuItems.length].focus();
                        Utils.stopEvent(e);
                    }
                });
            });
        }
    }, 100);

    var header = document.getElementById("header"),
        direction = Utils.getTextDirection(header),
        updateQuickLinksBar = function () {
            var logo = document.getElementById("logo");
            var quickLinksBar = document.getElementById("quickLinksBar");
            var availableWidth = (direction === "rtl" ? logo.offsetLeft - quickLinksBar.offsetLeft : (quickLinksBar.offsetLeft + quickLinksBar.offsetWidth) - (logo.offsetLeft + logo.offsetWidth));
            // BEGIN Facebook quick link workaround
            var facebookQuickLinkItem = document.getElementById("facebookQuickLinkItem");
            if (facebookQuickLinkItem && facebookQuickLinkItem.parentNode != quickLinksBar && availableWidth > 1024) {
                quickLinksBar.insertBefore(facebookQuickLinkItem, quickLinksBar.firstChild);
            } else if (facebookQuickLinkItem && facebookQuickLinkItem.parentNode == quickLinksBar && availableWidth <= 1024) {
                var quickLinksMenuList = $("#quickLinksMenu > ul")[0];
                quickLinksMenuList.append(facebookQuickLinkItem);
            }
            // END Facebook quick link workaround
            var quickLinksBarItems = $("#quickLinksBar > li");
            var quickLinksItem = quickLinksBarItems[quickLinksBarItems.length - 2];
            var miniCartItem = quickLinksBarItems[quickLinksBarItems.length - 1];
            availableWidth -= quickLinksItem.offsetWidth + miniCartItem.offsetWidth;
            for (var i = quickLinksBarItems.length - 3; i >= 0; i--) {
                availableWidth -= quickLinksBarItems[i].offsetWidth;
                $(quickLinksBarItems[i]).toggleClass("border-right", (availableWidth >= 0));
                $(quickLinksBarItems[i]).toggleClass("hidden", (availableWidth < 0));
            }

        };
    window.setTimeout(updateQuickLinksBar, 200);
    $(window).resize(updateQuickLinksBar);

    updateDepartmentsMenu = function () {
        var departmentsMenu = document.getElementById("departmentsMenu");
        var searchBar = document.getElementById("searchBar");
        var departmentButtons = $(".departmentButton");
        var departmentMenus = $(".departmentMenu");
        var departmentsMenuItems = $("#departmentsMenu > li");
        var allDepartmentsItem = departmentsMenuItems[departmentsMenuItems.length - 1];
        var availableWidth = null;
        if (searchBar) {
            availableWidth = (direction === "rtl" ? (departmentsMenu.offsetLeft + departmentsMenu.offsetWidth) - (searchBar.offsetLeft + searchBar.offsetWidth) : searchBar.offsetLeft - departmentsMenu.offsetLeft) - allDepartmentsItem.offsetWidth;
        } else {
            availableWidth = departmentsMenu.offsetWidth - allDepartmentsItem.offsetWidth;
        }
        for (var i = 0; i < departmentsMenuItems.length - 1; i++) {
            availableWidth -= departmentsMenuItems[i].offsetWidth;
            $(departmentsMenuItems[i]).toggleClass("hidden", (availableWidth < 0));
        }
        departmentButtons.each(function (i, departmentButton) {
            $(departmentButton).keydown(function (e) {
                if (e.keyCode === 9 || (e.keyCode === 9 && e.shiftKey)) {
                    deactivate(document.getElementById(departmentButton.getAttribute("data-toggle")));
                }
            });
        });
        departmentMenus.each(function (i, departmentMenu) {
            $(departmentMenu).click(function (e) {
                var target = this.getAttribute("data-toggle");
                if (target !== null) {
                    toggle(document.getElementById(target));
                    Utils.stopEvent(e);
                }
            });
            var departmentMenuItems = $('[class*="menuLink"]', departmentMenu);
            departmentMenuItems.each(function (j, departmentMenuItem) {
                $(departmentMenuItem).keydown(function (e) {
                    if (e.keyCode === 27) {
                        deactivate(document.getElementById(departmentMenu.getAttribute("id")));
                        Utils.stopEvent(e);
                    } else if (e.keyCode === 9 || (e.keyCode === 9 && e.shiftKey)) {
                        deactivate(document.getElementById(departmentMenu.getAttribute("id")));
                    } else if (e.keyCode === 38) {
                        departmentMenuItems[j === 0 ? departmentMenuItems.length - 1 : j - 1].focus();
                        Utils.stopEvent(e);
                    } else if (e.keyCode === 40) {
                        departmentMenuItems[(j + 1) % departmentMenuItems.length].focus();
                        Utils.stopEvent(e);
                    }
                });
            });
        });
    };
    window.setTimeout(updateDepartmentsMenu, 200);
    var ie_version = Utils.get_IE_version();
    if (!ie_version || ie_version > 8) {
        // Disabled in IE8 due to an IE8 bug causing the page to go partially black
        $(window).resize(updateDepartmentsMenu);
    }

    $("#searchFilterMenu > ul > li > a").click(function (e) {
        document.getElementById("searchFilterButton").innerHTML = this.innerHTML;
        document.getElementById("categoryId").value = this.getAttribute("data-value");
        deactivate(document.getElementById("searchFilterMenu"));
    });
    $("#searchBox > .submitButton").click(function (e) {
        var searchTerm = document.getElementById("SimpleSearchForm_SearchTerm");
        searchTerm.value = $.trim(searchTerm.value);
        var unquote = $.trim(searchTerm.value.replace(/'|"/g, ""));
        if (searchTerm.value && unquote !== "") {
            processAndSubmitForm(document.getElementById("searchBox"));
        }
    });
    var searchBox = document.getElementById("searchBox");
    if (searchBox) {
        $(searchBox).submit(function (e) {
            updateFormWithWcCommonRequestParameters(e.target);
            var searchTerm = document.getElementById("SimpleSearchForm_SearchTerm");
            var origTerm = searchTerm.value;
            var unquote = $.trim(searchTerm.value.replace(/'|"/g, ""));
            searchTerm.value = unquote;

            if (!searchTerm.value) {
                Utils.stopEvent(e);
                return false;
            }
            searchTerm.value = $.trim(origTerm);
        });
    }

});

function declareDeptDropdownRefreshArea(divId) {
    // ============================================
    // div: drop_down_${department.uniqueID} refresh area
    // Context and Controller to refresh department drop-down

    // common render context
    wcRenderContext.declare("departmentSubMenuContext", [divId], { targetId: "" });

    // render content changed handler
    var renderContextChangedHandler = function() {
        $("#"+divId).refreshWidget("refresh", wcRenderContext.getRenderContextProperties("departmentSubMenuContext"));
    };

    // post refresh handler
    var postRefreshHandler = function() {
        updateDepartmentsMenu(); // Browser may be re-sized. From server we return entire department list.. updateHeader to fit to the list within available size
        activate(document.getElementById(wcRenderContext.getRenderContextProperties("departmentSubMenuContext").targetId)); // We have all the data.. Activate the menu...
        cursor_clear();
    };

    // initialize widget
    $("#"+divId).refreshWidget({renderContextChangedHandler: renderContextChangedHandler, postRefreshHandler: postRefreshHandler});

}